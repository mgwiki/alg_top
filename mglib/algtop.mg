(* Parameter Eps_i "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter Eps_i : (set->prop)->set.
Axiom Eps_i_ax : forall P:set->prop, forall x:set, P x -> P (Eps_i P).
Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
(* Unicode /\ "2227" *)
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
(* Unicode \/ "2228" *)
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.
Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.
Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.
Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom In_ind : forall P:set->prop, (forall X:set, (forall x :e X, P x) -> P X) -> forall X:set, P X.
Binder+ exists , := ex; and.
Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
(* Unicode Union "22C3" *)
Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.
(* Unicode Power "1D4AB" *)
Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.
Axiom ReplEq : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} <-> exists x :e A, y = F x.
Definition TransSet : set->prop := fun U:set => forall x :e U, x c= U.
Definition Union_closed : set->prop := fun U:set => forall X:set, X :e U -> Union X :e U.
Definition Power_closed : set->prop := fun U:set => forall X:set, X :e U -> Power X :e U.
Definition Repl_closed : set->prop := fun U:set => forall X:set, X :e U -> forall F:set->set,
   (forall x:set, x :e X -> F x :e U) -> {F x|x :e X} :e U.
Definition ZF_closed : set->prop := fun U:set =>
   Union_closed U
/\ Power_closed U
/\ Repl_closed U.
Parameter UnivOf : set->set.
Axiom UnivOf_In : forall N:set, N :e UnivOf N.
Axiom UnivOf_TransSet : forall N:set, TransSet (UnivOf N).
Axiom UnivOf_ZF_closed : forall N:set, ZF_closed (UnivOf N).
Axiom UnivOf_Min : forall N U:set, N :e U
  -> TransSet U
  -> ZF_closed U
  -> UnivOf N c= U.

Theorem andI : forall (A B : prop), A -> B -> A /\ B.
exact (fun A B a b P H => H a b).
Qed.

Theorem orIL : forall (A B : prop), A -> A \/ B.
exact (fun A B a P H1 H2 => H1 a).
Qed.

Theorem orIR : forall (A B : prop), B -> A \/ B.
exact (fun A B b P H1 H2 => H2 b).
Qed.

Theorem iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
exact (fun A B => andI (A -> B) (B -> A)).
Qed.

Theorem pred_ext : forall P Q:set -> prop, (forall x, P x <-> Q x) -> P = Q.
let P Q. assume H1. apply func_ext set prop.
let x. apply prop_ext.
prove P x <-> Q x. exact H1 x.
Qed.

Definition nIn : set->set->prop :=
fun x X => ~In x X.
(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.

Theorem EmptyE : forall x:set, x /:e Empty.
let x. assume H.
apply EmptyAx.
witness x. exact H.
Qed.

Theorem PowerI : forall X Y:set, Y c= X -> Y :e Power X.
let X Y. apply PowerEq X Y. exact (fun _ H => H).
Qed.

Theorem Subq_Empty : forall X:set, Empty c= X.
exact (fun (X x : set) (H : x :e Empty) => EmptyE x H (x :e X)).
Qed.

Theorem Empty_In_Power : forall X:set, Empty :e Power X.
exact (fun X : set => PowerI X Empty (Subq_Empty X)).
Qed.


Theorem xm : forall P:prop, P \/ ~P.
let P:prop.
set p1 := fun x : set => x = Empty \/ P.
set p2 := fun x : set => x <> Empty \/ P.
claim L1:p1 Empty.
{ prove (Empty = Empty \/ P). apply orIL. exact (fun q H => H). }
claim L2: (Eps_i p1) = Empty \/ P.
{ exact (Eps_i_ax p1 Empty L1). }
claim L3:p2 (Power Empty).
{ prove ~(Power Empty = Empty) \/ P. apply orIL.
  assume H1: Power Empty = Empty.
  apply EmptyE Empty.
  prove Empty :e Empty.
  rewrite <- H1 at 2. apply Empty_In_Power.
}
claim L4: Eps_i p2 <> Empty \/ P.
{ exact (Eps_i_ax p2 (Power Empty) L3). }
apply L2.
- assume H1: Eps_i p1 = Empty.
  apply L4.
  + assume H2: Eps_i p2 <> Empty.
    prove P \/ ~ P.
    apply orIR.
    prove ~ P.
    assume H3 : P.
    claim L5:p1 = p2.
    { apply pred_ext. let x. apply iffI.
      - assume H4.
        prove (~(x = Empty) \/ P).
        apply orIR.
        prove P.
        exact H3.
      - assume H4.
        prove (x = Empty \/ P).
        apply orIR.
        prove P.
        exact H3.
    }
    apply H2. rewrite <- L5. exact H1.
  + assume H2:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H2.
- assume H1:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H1.
Qed.

Theorem FalseE : False -> forall p:prop, p.
exact (fun H => H).
Qed.

Theorem andEL : forall (A B : prop), A /\ B -> A.
exact (fun A B H => H A (fun a b => a)).
Qed.

Theorem andER : forall (A B : prop), A /\ B -> B.
exact (fun A B H => H B (fun a b => b)).
Qed.

Section PropN.
Variable P1 P2 P3:prop.

Theorem and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
exact (fun H1 H2 H3 => andI (P1 /\ P2) P3 (andI P1 P2 H1 H2) H3).
Qed.

Theorem and3E : P1 /\ P2 /\ P3 -> (forall p:prop, (P1 -> P2 -> P3 -> p) -> p).
exact (fun u p H => u p (fun u u3 => u p (fun u1 u2 => H u1 u2 u3))).
Qed.

Theorem or3I1 : P1 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIL P1 P2 u)).
Qed.

Theorem or3I2 : P2 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIR P1 P2 u)).
Qed.

Theorem or3I3 : P3 -> P1 \/ P2 \/ P3.
exact (orIR (P1 \/ P2) P3).
Qed.

Theorem or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
exact (fun u p H1 H2 H3 => u p (fun u => u p H1 H2) H3).
Qed.

Variable P4:prop.

Theorem and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
exact (fun H1 H2 H3 H4 => andI (P1 /\ P2 /\ P3) P4 (and3I H1 H2 H3) H4).
Qed.

Variable P5:prop.

Theorem and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
exact (fun H1 H2 H3 H4 H5 => andI (P1 /\ P2 /\ P3 /\ P4) P5 (and4I H1 H2 H3 H4) H5).
Qed.

Variable P6:prop.

Theorem and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
exact (fun H1 H2 H3 H4 H5 H6 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5) P6 (and5I H1 H2 H3 H4 H5) H6).
Qed.

Variable P7:prop.

Theorem and7I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
exact (fun H1 H2 H3 H4 H5 H6 H7 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6) P7 (and6I H1 H2 H3 H4 H5 H6) H7).
Qed.

End PropN.

Theorem not_or_and_demorgan : forall A B:prop, ~(A \/ B) -> ~A /\ ~B.
let A B.
assume u : ~(A \/ B).
apply andI.
- prove ~A. assume a:A. exact (u (orIL A B a)).
- prove ~B. assume b:B. exact (u (orIR A B b)).
Qed.

Theorem not_ex_all_demorgan_i : forall P:set->prop, (~exists x, P x) -> forall x, ~P x.
let P. assume H1. let x. assume H2. apply H1.
witness x.
exact H2.
Qed.

Theorem iffEL : forall A B:prop, (A <-> B) -> A -> B.
exact (fun A B => andEL (A -> B) (B -> A)).
Qed.

Theorem iffER : forall A B:prop, (A <-> B) -> B -> A.
exact (fun A B => andER (A -> B) (B -> A)).
Qed.

Theorem iff_refl : forall A:prop, A <-> A.
exact (fun A:prop => andI (A -> A) (A -> A) (fun H : A => H) (fun H : A => H)).
Qed.

Theorem iff_sym : forall A B:prop, (A <-> B) -> (B <-> A).
let A B.
assume H1: (A -> B) /\ (B -> A).
apply H1.
assume H2: A -> B.
assume H3: B -> A.
exact iffI B A H3 H2.
Qed.

Theorem iff_trans : forall A B C: prop, (A <-> B) -> (B <-> C) -> (A <-> C).
let A B C.
assume H1: A <-> B.
assume H2: B <-> C.
apply H1.
assume H3: A -> B.
assume H4: B -> A.
apply H2.
assume H5: B -> C.
assume H6: C -> B.
exact (iffI A C (fun H => H5 (H3 H)) (fun H => H4 (H6 H))).
Qed.

Theorem eq_i_tra : forall x y z, x = y -> y = z -> x = z.
let x y z. assume H1 H2. rewrite <- H2. exact H1.
Qed.

Theorem neq_i_sym: forall x y, x <> y -> y <> x.
let x y. assume H1 H2. apply H1. symmetry. exact H2.
Qed.

Theorem Eps_i_ex : forall P:set -> prop, (exists x, P x) -> P (Eps_i P).
let P. assume H1. apply H1.
let x. assume H2.
exact Eps_i_ax P x H2.
Qed.

Theorem prop_ext_2 : forall p q:prop, (p -> q) -> (q -> p) -> p = q.
let p q. assume H1 H2. apply prop_ext. apply iffI.
- exact H1.
- exact H2.
Qed.

Theorem Subq_ref : forall X:set, X c= X.
exact (fun (X x : set) (H : x :e X) => H).
Qed.

Theorem Subq_tra : forall X Y Z:set, X c= Y -> Y c= Z -> X c= Z.
exact (fun (X Y Z : set) (H1 : X c= Y) (H2 : Y c= Z) (x : set) (H : x :e X) => (H2 x (H1 x H))).
Qed.

Theorem Empty_Subq_eq : forall X:set, X c= Empty -> X = Empty.
let X.
assume H1: X c= Empty.
apply set_ext.
- exact H1.
- exact (Subq_Empty X).
Qed.

Theorem Empty_eq : forall X:set, (forall x, x /:e X) -> X = Empty.
let X.
assume H1: forall x, x /:e X.
apply Empty_Subq_eq.
let x.
assume H2: x :e X.
prove False.
exact (H1 x H2).
Qed.

Theorem UnionI : forall X x Y:set, x :e Y -> Y :e X -> x :e Union X.
let X x Y.
assume H1: x :e Y.
assume H2: Y :e X.
apply UnionEq X x.
assume _ H3. apply H3.
prove exists Y:set, x :e Y /\ Y :e X.
witness Y.
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem UnionE : forall X x:set, x :e Union X -> exists Y:set, x :e Y /\ Y :e X.
exact (fun X x : set => iffEL (x :e Union X) (exists Y:set, x :e Y /\ Y :e X) (UnionEq X x)).
Qed.

Theorem UnionE_impred : forall X x:set, x :e Union X -> forall p:prop, (forall Y:set, x :e Y -> Y :e X -> p) -> p.
let X x. assume H1.
let p. assume Hp.
apply UnionE X x H1.
let x. assume H2. apply H2.
exact Hp x.
Qed.

Theorem PowerE : forall X Y:set, Y :e Power X -> Y c= X.
let X Y. apply PowerEq X Y. exact (fun H _ => H).
Qed.

Theorem Self_In_Power : forall X:set, X :e Power X.
exact (fun X : set => PowerI X X (Subq_ref X)).
Qed.

Theorem dneg : forall P:prop, ~~P -> P.
let P. assume H1.
apply xm P.
- exact (fun H => H).
- assume H2: ~P.
  prove False.
  exact H1 H2.
Qed.

Theorem not_all_ex_demorgan_i : forall P:set->prop, ~(forall x, P x) -> exists x, ~P x.
let P.
assume u:~forall x, P x.
apply dneg.
assume v:~exists x, ~P x.
apply u. let x. apply dneg.
assume w:~P x. 
exact (not_ex_all_demorgan_i (fun x => ~P x) v x w).
Qed.

Theorem eq_or_nand : or = (fun (x y:prop) => ~(~x /\ ~y)).
apply func_ext prop (prop -> prop).
let x. apply func_ext prop prop.
let y. apply prop_ext_2.
- assume H1: x \/ y.
  assume H2: ~x /\ ~y.
  apply H2. assume H3 H4. exact (H1 False H3 H4).
- assume H1:~(~x /\ ~y).
  apply (xm x).
  + assume H2: x. apply orIL. exact H2.
  + assume H2: ~x. apply (xm y).
    * assume H3: y. apply orIR. exact H3.
    * assume H3: ~y. apply H1. exact (andI (~x) (~y) H2 H3).
Qed.

(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Definition exactly1of2 : prop->prop->prop := fun A B:prop =>
A /\ ~B \/ ~A /\ B.

Theorem exactly1of2_I1 : forall A B:prop, A -> ~B -> exactly1of2 A B.
let A B.
assume HA: A.
assume HB: ~B.
prove A /\ ~B \/ ~A /\ B.
apply orIL.
prove A /\ ~B.
exact (andI A (~B) HA HB).
Qed.

Theorem exactly1of2_I2 : forall A B:prop, ~A -> B -> exactly1of2 A B.
let A B.
assume HA: ~A.
assume HB: B.
prove A /\ ~B \/ ~A /\ B.
apply orIR.
prove ~A /\ B.
exact (andI (~A) B HA HB).
Qed.

Theorem exactly1of2_E : forall A B:prop, exactly1of2 A B ->
forall p:prop,
(A -> ~B -> p) ->
(~A -> B -> p) ->
p.
let A B.
assume H1: exactly1of2 A B.
let p.
assume H2 : A -> ~B -> p.
assume H3 : ~A -> B -> p.
apply (H1 p).
- exact (fun H4 : A /\ ~B => H4 p H2).
- exact (fun H4 : ~A /\ B => H4 p H3).
Qed.

Theorem exactly1of2_or : forall A B:prop, exactly1of2 A B -> A \/ B.
let A B.
assume H1: exactly1of2 A B.
apply (exactly1of2_E A B H1 (A \/ B)).
- exact (fun (HA : A) (_ : ~B) => orIL A B HA).
- exact (fun (_ : ~A) (HB : B) => orIR A B HB).
Qed.

Theorem ReplI : forall A:set, forall F:set->set, forall x:set, x :e A -> F x :e {F x|x :e A}.
let A F x. assume H1.
apply ReplEq A F (F x).
assume _ H2. apply H2.
prove exists x' :e A, F x = F x'.
witness x. apply andI.
- exact H1.
- exact (fun q H => H).
Qed.

Theorem ReplE : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> exists x :e A, y = F x.
let A F y. apply ReplEq A F y. exact (fun H _ => H).
Qed.

Theorem ReplE_impred : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> forall p:prop, (forall x:set, x :e A -> y = F x -> p) -> p.
let A F y. assume H1.
apply ReplE A F y H1.
let x. assume H2. apply H2.
assume H3 H4.
let p. assume Hp.
exact Hp x H3 H4.
Qed.

Theorem ReplE' : forall X, forall f:set -> set, forall p:set -> prop, (forall x :e X, p (f x)) -> forall y :e {f x|x :e X}, p y.
let X f p. assume H1. let y. assume Hy.
apply ReplE_impred X f y Hy.
let x. assume Hx: x :e X. assume Hx2: y = f x.
prove p y. rewrite Hx2. exact H1 x Hx.
Qed.

Theorem Repl_Empty : forall F:set -> set, {F x|x :e Empty} = Empty.
let F. apply (Empty_eq {F x|x :e Empty}).
let y.
assume H1: y :e {F x|x :e Empty}.
apply (ReplE_impred Empty F y H1).
let x.
assume H2: x :e Empty.
assume _.
exact (EmptyE x H2).
Qed.

Theorem ReplEq_ext_sub : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} c= {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
let y. assume Hy: y :e {F x|x :e X}.
apply ReplE_impred X F y Hy.
let x. assume Hx: x :e X.
assume H2: y = F x.
prove y :e {G x|x :e X}.
rewrite H2.
prove F x :e {G x|x :e X}.
rewrite H1 x Hx.
prove G x :e {G x|x :e X}.
apply ReplI. exact Hx.
Qed.

Theorem ReplEq_ext : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} = {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
apply set_ext.
- exact ReplEq_ext_sub X F G H1.
- apply ReplEq_ext_sub X G F.
  let x. assume Hx. symmetry. exact H1 x Hx.
Qed.

Theorem Repl_inv_eq : forall P:set -> prop, forall f g:set -> set,
    (forall x, P x -> g (f x) = x)
 -> forall X, (forall x :e X, P x) -> {g y|y :e {f x|x :e X}} = X.
let P f g. assume H1. let X. assume HX.
apply set_ext.
- let w. assume Hw: w :e {g y|y :e {f x|x :e X}}.
  apply ReplE_impred {f x|x :e X} g w Hw.
  let y. assume Hy: y :e {f x|x :e X}.
  assume Hwy: w = g y.
  apply ReplE_impred X f y Hy.
  let x. assume Hx: x :e X.
  assume Hyx: y = f x.
  prove w :e X. rewrite Hwy. rewrite Hyx.
  prove g (f x) :e X.
  rewrite H1 x (HX x Hx).
  exact Hx.
- let x. assume Hx: x :e X.
  rewrite <- H1 x (HX x Hx).
  prove g (f x) :e {g y|y :e {f x|x :e X}}.
  apply ReplI.
  prove f x :e {f x|x :e X}.
  apply ReplI. exact Hx.
Qed.

Theorem Repl_invol_eq : forall P:set -> prop, forall f:set -> set,
    (forall x, P x -> f (f x) = x)
 -> forall X, (forall x :e X, P x) -> {f y|y :e {f x|x :e X}} = X.
let P f. assume H1.
exact Repl_inv_eq P f f H1.
Qed.

(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Definition If_i : prop->set->set->set := (fun p x y => Eps_i (fun z:set => p /\ z = x \/ ~p /\ z = y)).
Notation IfThenElse If_i.

Theorem If_i_correct : forall p:prop, forall x y:set,
p /\ (if p then x else y) = x \/ ~p /\ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p.
  claim L1: p /\ x = x \/ ~p /\ x = y.
  {
    apply orIL. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) x L1).
- assume H1: ~p.
  claim L1: p /\ y = x \/ ~p /\ y = y.
  {
    apply orIR. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) y L1).
Qed.

Theorem If_i_0 : forall p:prop, forall x y:set,
~ p -> (if p then x else y) = y.
let p x y.
assume H1: ~p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (H1 (andEL p ((if p then x else y) = x) H2) ((if p then x else y) = y)).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andER (~p) ((if p then x else y) = y) H2).
Qed.

Theorem If_i_1 : forall p:prop, forall x y:set,
p -> (if p then x else y) = x.
let p x y.
assume H1: p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (andER p ((if p then x else y) = x) H2).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andEL (~p) ((if p then x else y) = y) H2 H1 ((if p then x else y) = x)).
Qed.

Theorem If_i_or : forall p:prop, forall x y:set, (if p then x else y) = x \/ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p. apply orIL. exact (If_i_1 p x y H1).
- assume H1: ~p. apply orIR. exact (If_i_0 p x y H1).
Qed.

(* Parameter UPair "80aea0a41bb8a47c7340fe8af33487887119c29240a470e920d3f6642b91990d" "74243828e4e6c9c0b467551f19c2ddaebf843f72e2437cc2dea41d079a31107f" *)
Definition UPair : set->set->set :=
fun y z => {if Empty :e X then y else z | X :e Power (Power Empty)}.
Notation SetEnum2 UPair.

Theorem UPairE :
forall x y z:set, x :e {y,z} -> x = y \/ x = z.
let x y z.
assume H1: x :e {y,z}.
apply (ReplE (Power (Power Empty)) (fun X => if Empty :e X then y else z) x H1).
let X.
assume H2: X :e Power (Power Empty) /\ x = if Empty :e X then y else z.
claim L1: x = if Empty :e X then y else z.
{ exact (andER (X :e Power (Power Empty)) (x = if Empty :e X then y else z) H2). }
apply (If_i_or (Empty :e X) y z).
- assume H3: (if Empty :e X then y else z) = y.
  apply orIL.
  prove x = y.
  rewrite <- H3. exact L1.
- assume H3: (if Empty :e X then y else z) = z.
  apply orIR.
  prove x = z.
  rewrite <- H3. exact L1.
Qed.

Theorem UPairI1 : forall y z:set, y :e {y,z}.
let y z.
prove y :e {y,z}.
rewrite <- (If_i_1 (Empty :e Power Empty) y z (Empty_In_Power Empty)) at 1.
prove (if Empty :e Power Empty then y else z) :e {y,z}.
prove (if Empty :e Power Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) (Power Empty)).
prove Power Empty :e Power (Power Empty).
exact (Self_In_Power (Power Empty)).
Qed.

Theorem UPairI2 : forall y z:set, z :e {y,z}.
let y z.
prove z :e {y,z}.
rewrite <- (If_i_0 (Empty :e Empty) y z (EmptyE Empty)) at 1.
prove (if Empty :e Empty then y else z) :e {y,z}.
prove (if Empty :e Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) Empty).
prove Empty :e Power (Power Empty).
exact (Empty_In_Power (Power Empty)).
Qed.

(* Parameter Sing "158bae29452f8cbf276df6f8db2be0a5d20290e15eca88ffe1e7b41d211d41d7" "bd01a809e97149be7e091bf7cbb44e0c2084c018911c24e159f585455d8e6bd0" *)
Definition Sing : set -> set := fun x => {x,x}.
Notation SetEnum1 Sing.

Theorem SingI : forall x:set, x :e {x}. 
exact (fun x : set => UPairI1 x x).
Qed.

Theorem SingE : forall x y:set, y :e {x} -> y = x. 
exact (fun x y H => UPairE y x x H (y = x) (fun H => H) (fun H => H)).
Qed.

(* Parameter binunion "0a445311c45f0eb3ba2217c35ecb47f122b2301b2b80124922fbf03a5c4d223e" "5e1ac4ac93257583d0e9e17d6d048ff7c0d6ccc1a69875b2a505a2d4da305784" *)
Definition binunion : set -> set -> set := fun X Y => Union {X,Y}.
(* Unicode :\/: "222a" *)
Infix :\/: 345 left := binunion.

Theorem binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
let X Y z.
assume H1: z :e X.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z X).
- prove z :e X. exact H1.
- prove X :e {X,Y}. exact (UPairI1 X Y).
Qed.

Theorem binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
let X Y z.
assume H1: z :e Y.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z Y).
- prove z :e Y. exact H1.
- prove Y :e {X,Y}. exact (UPairI2 X Y).
Qed.

Theorem binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.
let X Y z.
assume H1: z :e X :\/: Y.
prove z :e X \/ z :e Y.
apply (UnionE_impred {X,Y} z H1).
let Z.
assume H2: z :e Z.
assume H3: Z :e {X,Y}.
apply (UPairE Z X Y H3).
- assume H4: Z = X.
  apply orIL.
  prove z :e X.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
- assume H4: Z = Y.
  apply orIR.
  prove z :e Y.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
Qed.

Theorem binunionE' : forall X Y z, forall p:prop, (z :e X -> p) -> (z :e Y -> p) -> (z :e X :\/: Y -> p).
let X Y z p. assume H1 H2 Hz.
apply binunionE X Y z Hz.
- assume H3: z :e X. exact H1 H3.
- assume H3: z :e Y. exact H2 H3.
Qed.

Theorem binunion_asso:forall X Y Z:set, X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
let X Y Z. apply set_ext.
- let w. assume H1: w :e X :\/: (Y :\/: Z).
  prove w :e (X :\/: Y) :\/: Z.
  apply (binunionE X (Y :\/: Z) w H1).
  + assume H2: w :e X.
    apply binunionI1. apply binunionI1. exact H2.
  + assume H2: w :e Y :\/: Z.
    apply (binunionE Y Z w H2).
    * assume H3: w :e Y.
      apply binunionI1. apply binunionI2. exact H3.
    * assume H3: w :e Z.
      apply binunionI2. exact H3.
- let w. assume H1: w :e (X :\/: Y) :\/: Z.
  prove w :e X :\/: (Y :\/: Z).
  apply (binunionE (X :\/: Y) Z w H1).
  + assume H2: w :e X :\/: Y.
    apply (binunionE X Y w H2).
    * assume H3: w :e X.
      apply binunionI1. exact H3.
    * assume H3: w :e Y.
      apply binunionI2. apply binunionI1. exact H3.
  + assume H2: w :e Z.
    apply binunionI2. apply binunionI2. exact H2.
Qed.

Theorem binunion_com_Subq:forall X Y:set, X :\/: Y c= Y :\/: X.
let X Y w. assume H1: w :e X :\/: Y.
prove w :e Y :\/: X.
apply (binunionE X Y w H1).
- assume H2: w :e X. apply binunionI2. exact H2.
- assume H2: w :e Y. apply binunionI1. exact H2.
Qed.

Theorem binunion_com:forall X Y:set, X :\/: Y = Y :\/: X.
let X Y. apply set_ext.
- exact (binunion_com_Subq X Y).
- exact (binunion_com_Subq Y X).
Qed.

Theorem binunion_idl:forall X:set, Empty :\/: X = X.
let X. apply set_ext.
- let x. assume H1: x :e Empty :\/: X.
  apply (binunionE Empty X x H1).
  + assume H2: x :e Empty. prove False. exact (EmptyE x H2).
  + assume H2: x :e X. exact H2.
- let x. assume H2: x :e X. prove x :e Empty :\/: X. apply binunionI2. exact H2.
Qed.

Theorem binunion_idr:forall X:set, X :\/: Empty = X.
let X.
rewrite (binunion_com X Empty).
exact (binunion_idl X).
Qed.

Theorem binunion_Subq_1: forall X Y:set, X c= X :\/: Y.
exact binunionI1.
Qed.

Theorem binunion_Subq_2: forall X Y:set, Y c= X :\/: Y.
exact binunionI2.
Qed.

Theorem binunion_Subq_min: forall X Y Z:set, X c= Z -> Y c= Z -> X :\/: Y c= Z.
let X Y Z.
assume H1: X c= Z.
assume H2: Y c= Z.
let w.
assume H3: w :e X :\/: Y.
apply (binunionE X Y w H3).
- assume H4: w :e X. exact (H1 w H4).
- assume H4: w :e Y. exact (H2 w H4).
Qed.

Theorem Subq_binunion_eq:forall X Y, (X c= Y) = (X :\/: Y = Y).
let X Y. apply prop_ext_2.
- assume H1: X c= Y.
  prove X :\/: Y = Y.
  apply set_ext.
  + prove X :\/: Y c= Y. apply (binunion_Subq_min X Y Y).
    * prove X c= Y. exact H1.
    * prove Y c= Y. exact (Subq_ref Y).
  + prove Y c= X :\/: Y. exact (binunion_Subq_2 X Y).
- assume H1: X :\/: Y = Y.
  prove X c= Y.
  rewrite <- H1.
  prove X c= X :\/: Y.
  exact (binunion_Subq_1 X Y).
Qed.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.
(* Parameter famunion "d772b0f5d472e1ef525c5f8bd11cf6a4faed2e76d4eacfa455f4d65cc24ec792" "b3e3bf86a58af5d468d398d3acad61ccc50261f43c856a68f8594967a06ec07a" *)
Definition famunion:set->(set->set)->set
:= fun X F => Union {F x|x :e X}.
(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.

Theorem famunionI:forall X:set, forall F:(set->set), forall x y:set, x :e X -> y :e F x -> y :e \/_ x :e X, F x.
exact (fun X F x y H1 H2 => UnionI (Repl X F) y (F x) H2 (ReplI X F x H1)).
Qed.

Theorem famunionE:forall X:set, forall F:(set->set), forall y:set, y :e (\/_ x :e X, F x) -> exists x :e X, y :e F x.
let X F y.
assume H1: y :e (\/_ x :e X, F x).
prove exists x :e X, y :e F x.
apply (UnionE_impred {F x|x :e X} y H1).
let Y.
assume H2: y :e Y.
assume H3: Y :e {F x|x :e X}.
apply (ReplE_impred X F Y H3).
let x.
assume H4: x :e X.
assume H5: Y = F x.
witness x.
prove x :e X /\ y :e F x.
apply andI.
- exact H4.
- prove y :e F x.
  rewrite <- H5.
  exact H2.
Qed.

Theorem famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p:prop, (forall x, x :e X -> y :e F x -> p) -> p.
let X F y. assume Hy.
let p. assume Hp.
apply famunionE X F y Hy.
let x. assume H1. apply H1.
exact Hp x.
Qed.

Theorem famunion_Empty: forall F:set -> set, (\/_ x :e Empty, F x) = Empty.
let F. apply Empty_Subq_eq.
let y. assume Hy: y :e \/_ x :e Empty, F x.
apply famunionE_impred Empty F y Hy.
let x. assume Hx: x :e Empty. prove False. exact EmptyE x Hx.
Qed.

Theorem famunion_Subq: forall X, forall f g:set -> set, (forall x :e X, f x c= g x) -> famunion X f c= famunion X g.
let X f g. assume Hfg.
let y. assume Hy. apply famunionE_impred X f y Hy.
let x. assume Hx.
assume H1: y :e f x.
apply famunionI X g x y Hx.
prove y :e g x.
exact Hfg x Hx y H1.
Qed.

Theorem famunion_ext: forall X, forall f g:set -> set, (forall x :e X, f x = g x) -> famunion X f = famunion X g.
let X f g. assume Hfg.
apply set_ext.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
Qed.

Section SepSec.
Variable X:set.
Variable P:set->prop.
Let z : set := Eps_i (fun z => z :e X /\ P z).
Let F:set->set := fun x => if P x then x else z.
(* Parameter Sep "f7e63d81e8f98ac9bc7864e0b01f93952ef3b0cbf9777abab27bcbd743b6b079" "f336a4ec8d55185095e45a638507748bac5384e04e0c48d008e4f6a9653e9c44" *)
Definition Sep:set
:= if (exists z :e X, P z) then {F x|x :e X} else Empty.
End SepSec.
Notation Sep Sep.

Theorem SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
assume H1: x :e X.
assume H2: P x.
claim L1: exists z :e X, P z.
{
  witness x. apply andI.
  - exact H1.
  - exact H2.
}
prove x :e {x :e X|P x}.
prove x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
(*** Note:
 Making L2 a claim and then rewriting with it succeeds, but rewrite (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) fails.
 The reason is that when the proposition proved by (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) is
 extracted by the code, the F x will be beta reduced to be if P x then x else z. After this beta reduction, the left hand side of the
 equation does not match the right hand side of the claim x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
 This is an example of how one must be careful using the apply and rewrite tactics and must sometimes give these
 kinds of explicit annotations, i.e., proving a beta-eta-delta equivalent claim.
 ***)
claim L2: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
{
  exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1).
}
rewrite L2.
prove x :e {F x|x :e X}.
claim L3: F x = x.
{
  prove (if P x then x else z) = x.
  exact (If_i_1 (P x) x z H2).
}
rewrite <- L3.
prove F x :e {F x|x :e X}.
exact (ReplI X F x H1).
Qed.

Theorem SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
apply (xm (exists z :e X, P z)).
- assume H1: exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
  {
    exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty H1).
  }
  rewrite L1.
  prove x :e {F x|x :e X} -> x :e X /\ P x.
  assume H2: x :e {F x|x :e X}.
  apply (ReplE_impred X F x H2).
  let y.
  assume H3: y :e X.
  assume H4: x = F y.
  prove x :e X /\ P x.
  apply (xm (P y)).
  + assume H5: P y.
    claim L2: x = y.
    {
      rewrite <- (If_i_1 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove y :e X /\ P y.
    apply andI.
    * exact H3.
    * exact H5.
  + assume H5: ~P y.
    claim L2: x = z.
    {
      rewrite <- (If_i_0 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove z :e X /\ P z.
    exact (Eps_i_ex (fun z => z :e X /\ P z) H1).
- assume H1: ~exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = Empty.
  { exact (If_i_0 (exists z :e X, P z) {F x|x :e X} Empty H1). }
  rewrite L1.
  prove x :e Empty -> x :e X /\ P x.
  assume H2: x :e Empty.
  prove False.
  exact (EmptyE x H2).
Qed.

Theorem SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
exact (fun X P x H => SepE X P x H (x :e X) (fun H _ => H)).
Qed.

Theorem SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.
exact (fun X P x H => SepE X P x H (P x) (fun _ H => H)).
Qed.

Theorem Sep_Empty: forall P:set -> prop, {x :e Empty|P x} = Empty.
let P. apply Empty_eq.
let x. assume Hx.
exact EmptyE x (SepE1 Empty P x Hx).
Qed.

Theorem Sep_Subq : forall X:set, forall P:set->prop, {x :e X|P x} c= X.
exact SepE1.
Qed.

Theorem Sep_In_Power : forall X:set, forall P:set->prop, {x :e X|P x} :e Power X.
exact (fun X P => PowerI X (Sep X P) (Sep_Subq X P)).
Qed.

(* Parameter ReplSep "f627d20f1b21063483a5b96e4e2704bac09415a75fed6806a2587ce257f1f2fd" "ec807b205da3293041239ff9552e2912636525180ddecb3a2b285b91b53f70d8" *)
Definition ReplSep : set->(set->prop)->(set->set)->set := fun X P F => {F x|x :e {z :e X|P z}}.
Notation ReplSep ReplSep.

Theorem ReplSepI: forall X:set, forall P:set->prop, forall F:set->set, forall x:set, x :e X -> P x -> F x :e {F x|x :e X, P x}.
exact (fun X P F x u v => ReplI (Sep X P) F x (SepI X P x u v)).
Qed.

Theorem ReplSepE:forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> exists x:set, x :e X /\ P x /\ y = F x.
let X P F y.
assume H1: y :e {F x|x :e {z :e X|P z}}.
apply (ReplE {z :e X|P z} F y H1).
let x.
assume H2: x :e {z :e X|P z} /\ y = F x.
apply H2.
assume H3: x :e {z :e X|P z}.
assume H4: y = F x.
apply (SepE X P x H3).
assume H5: x :e X.
assume H6: P x.
witness x.
apply and3I.
- exact H5.
- exact H6.
- exact H4.
Qed.

Theorem ReplSepE_impred: forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> forall p:prop, (forall x :e X, P x -> y = F x -> p) -> p.
let X P F y.
assume H1: y :e {F x|x :e X, P x}.
let p.
assume H2: forall x :e X, P x -> y = F x -> p.
prove p.
apply ReplSepE X P F y H1.
let x. assume H3. apply H3. assume H3. apply H3.
exact H2 x.
Qed.

(* Parameter binintersect "8cf6b1f490ef8eb37db39c526ab9d7c756e98b0eb12143156198f1956deb5036" "b2abd2e5215c0170efe42d2fa0fb8a62cdafe2c8fbd0d37ca14e3497e54ba729" *)
Definition binintersect:set->set->set
:= fun X Y => {x :e X |x :e Y}.
(* Unicode :/\: "2229" *)
Infix :/\: 340 left := binintersect.

Theorem binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x :e Y) z H1 H2).
Qed.

Theorem binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
exact (fun X Y z H1 => SepE X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
exact (fun X Y z H1 => SepE1 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.
exact (fun X Y z H1 => SepE2 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersect_Subq_1:forall X Y:set, X :/\: Y c= X.
exact binintersectE1.
Qed.

Theorem binintersect_Subq_2:forall X Y:set, X :/\: Y c= Y.
exact binintersectE2.
Qed.

Theorem binintersect_Subq_eq_1 : forall X Y, X c= Y -> X :/\: Y = X.
let X Y.
assume H1: X c= Y.
apply set_ext.
- apply binintersect_Subq_1.
- let x. assume H2: x :e X.
  apply binintersectI.
  + exact H2.
  + apply H1. exact H2.
Qed.

Theorem binintersect_Subq_max:forall X Y Z:set, Z c= X -> Z c= Y -> Z c= X :/\: Y.
let X Y Z.
assume H1: Z c= X.
assume H2: Z c= Y.
let w.
assume H3: w :e Z.
apply (binintersectI X Y w).
- prove w :e X. exact (H1 w H3).
- prove w :e Y. exact (H2 w H3).
Qed.

Theorem binintersect_com_Subq: forall X Y:set, X :/\: Y c= Y :/\: X.
let X Y. apply (binintersect_Subq_max Y X (X :/\: Y)).
- prove X :/\: Y c= Y. apply binintersect_Subq_2.
- prove X :/\: Y c= X. apply binintersect_Subq_1.
Qed.

Theorem binintersect_com: forall X Y:set, X :/\: Y = Y :/\: X.
let X Y. apply set_ext.
- exact (binintersect_com_Subq X Y).
- exact (binintersect_com_Subq Y X).
Qed.

(* Parameter setminus "cc569397a7e47880ecd75c888fb7c5512aee4bcb1e7f6bd2c5f80cccd368c060" "c68e5a1f5f57bc5b6e12b423f8c24b51b48bcc32149a86fc2c30a969a15d8881" *)
Definition setminus:set->set->set
:= fun X Y => Sep X (fun x => x /:e Y).
(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.

Theorem setminusI:forall X Y z, (z :e X) -> (z /:e Y) -> z :e X :\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x /:e Y) z H1 H2).
Qed.

Theorem setminusE:forall X Y z, (z :e X :\: Y) -> z :e X /\ z /:e Y.
exact (fun X Y z H => SepE X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
exact (fun X Y z H => SepE1 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE2:forall X Y z, (z :e X :\: Y) -> z /:e Y.
exact (fun X Y z H => SepE2 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminus_Subq:forall X Y:set, X :\: Y c= X.
exact setminusE1.
Qed.

Theorem setminus_In_Power : forall A U, A :\: U :e Power A.
let A U. apply PowerI. apply setminus_Subq.
Qed.

Theorem binunion_remove1_eq: forall X, forall x :e X, X = (X :\: {x}) :\/: {x}.
let X x.
assume Hx: x :e X.
apply set_ext.
- let y. assume Hy: y :e X.
  prove y :e (X :\: {x}) :\/: {x}.
  apply xm (y :e {x}).
  + assume H1: y :e {x}.
    apply binunionI2. exact H1.
  + assume H1: y /:e {x}.
    apply binunionI1. apply setminusI.
    * exact Hy.
    * exact H1.
- let y. assume Hy: y :e (X :\: {x}) :\/: {x}.
  apply binunionE (X :\: {x}) {x} y Hy.
  + assume H1: y :e X :\: {x}.
    prove y :e X.
    exact setminusE1 X {x} y H1.
  + assume H1: y :e {x}.
    prove y :e X.
    rewrite SingE x y H1.
    prove x :e X.
    exact Hx.
Qed.

Theorem In_irref : forall x, x /:e x.
apply In_ind.
prove (forall X:set, (forall x:set, x :e X -> x /:e x) -> X /:e X).
let X.
assume IH: forall x : set, x :e X -> x /:e x.
assume H: X :e X.
exact IH X H H.
Qed.

Theorem In_no2cycle : forall x y, x :e y -> y :e x -> False.
apply In_ind.
let x.
assume IH: forall z, z :e x -> forall y, z :e y -> y :e z -> False.
let y.
assume H1: x :e y.
assume H2: y :e x.
exact IH y H2 x H2 H1.
Qed.

(* Parameter ordsucc "9db634daee7fc36315ddda5f5f694934869921e9c5f55e8b25c91c0a07c5cbec" "65d8837d7b0172ae830bed36c8407fcd41b7d875033d2284eb2df245b42295a6" *)
Definition ordsucc : set->set := fun x:set => x :\/: {x}.

Theorem ordsuccI1 : forall x:set, x c= ordsucc x.
let x.
exact (fun (y : set) (H1 : y :e x) => binunionI1 x {x} y H1).
Qed.

Theorem ordsuccI2 : forall x:set, x :e ordsucc x.
exact (fun x : set => binunionI2 x {x} x (SingI x)).
Qed.

Theorem ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
let x y.
assume H1: y :e x :\/: {x}.
apply (binunionE x {x} y H1).
- assume H2: y :e x. apply orIL. exact H2.
- assume H2: y :e {x}. apply orIR. exact (SingE x y H2).
Qed.

Notation Nat Empty ordsucc.

Theorem neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
let a. prove ~(0 = ordsucc a).
assume H1: 0 = ordsucc a.
claim L1: a :e ordsucc a -> False.
{ rewrite <- H1. exact (EmptyE a). }
exact (L1 (ordsuccI2 a)).
Qed.

Theorem neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
let a. exact neq_i_sym 0 (ordsucc a) (neq_0_ordsucc a).
Qed.

Theorem ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.
let a b.
assume H1: ordsucc a = ordsucc b.
claim L1: a :e ordsucc b.
{
  rewrite <- H1.
  exact (ordsuccI2 a).
}
apply (ordsuccE b a L1).
- assume H2: a :e b.
  claim L2: b :e ordsucc a.
  {
    rewrite H1.
    exact (ordsuccI2 b).
  }
  apply (ordsuccE a b L2).
  + assume H3: b :e a. prove False. exact (In_no2cycle a b H2 H3).
  + assume H3: b = a. symmetry. exact H3.
- assume H2: a = b. exact H2.
Qed.

Theorem In_0_1 : 0 :e 1.
exact (ordsuccI2 0).
Qed.

Theorem In_0_2 : 0 :e 2.
exact (ordsuccI1 1 0 In_0_1).
Qed.

Theorem In_1_2 : 1 :e 2.
exact (ordsuccI2 1).
Qed.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Theorem nat_0 : nat_p 0.
exact (fun p H _ => H).
Qed.

Theorem nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
exact (fun n H1 p H2 H3 => H3 n (H1 p H2 H3)).
Qed.

Theorem nat_1 : nat_p 1.
exact (nat_ordsucc 0 nat_0).
Qed.

Theorem nat_2 : nat_p 2.
exact (nat_ordsucc 1 nat_1).
Qed.

Theorem nat_0_in_ordsucc : forall n, nat_p n -> 0 :e ordsucc n.
let n.
assume H1.
apply H1 (fun n => 0 :e ordsucc n).
- prove 0 :e ordsucc 0.
  exact In_0_1.
- let n.
  assume IH: 0 :e ordsucc n.
  prove 0 :e ordsucc (ordsucc n).
  exact (ordsuccI1 (ordsucc n) 0 IH).
Qed.

Theorem nat_ordsucc_in_ordsucc : forall n, nat_p n -> forall m :e n, ordsucc m :e ordsucc n.
let n.
assume H1.
apply (H1 (fun n => forall m :e n, ordsucc m :e ordsucc n)).
- prove forall m :e 0, ordsucc m :e ordsucc 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume IH: forall m :e n, ordsucc m :e ordsucc n.
  prove forall m :e ordsucc n, ordsucc m :e ordsucc (ordsucc n).
  let m.
  assume H2: m :e ordsucc n.
  prove ordsucc m :e ordsucc (ordsucc n).
  apply (ordsuccE n m H2).
  + assume H3: m :e n.
    claim L1: ordsucc m :e ordsucc n.
    { exact (IH m H3). }
    exact (ordsuccI1 (ordsucc n) (ordsucc m) L1).
  + assume H3: m = n.
    rewrite H3.
    prove ordsucc n :e ordsucc (ordsucc n).
    exact (ordsuccI2 (ordsucc n)).
Qed.

Theorem nat_ind : forall p:set->prop, p 0 -> (forall n, nat_p n -> p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p.
assume H1: p 0.
assume H2: forall n, nat_p n -> p n -> p (ordsucc n).
claim L1: nat_p 0 /\ p 0.
{ exact (andI (nat_p 0) (p 0) nat_0 H1). }
claim L2: forall n, nat_p n /\ p n -> nat_p (ordsucc n) /\ p (ordsucc n).
{ let n.
  assume H3: nat_p n /\ p n.
  apply H3.
  assume H4: nat_p n.
  assume H5: p n.
  apply andI.
  - prove nat_p (ordsucc n).
    exact (nat_ordsucc n H4).
  - prove p (ordsucc n).
    exact (H2 n H4 H5).
}
let n.
assume H3.
claim L3: nat_p n /\ p n.
{ exact (H3 (fun n => nat_p n /\ p n) L1 L2). }
exact (andER (nat_p n) (p n) L3).
Qed.

Theorem nat_complete_ind : forall p:set->prop, (forall n, nat_p n -> (forall m :e n, p m) -> p n) -> forall n, nat_p n -> p n.
let p.
assume H1: forall n, nat_p n -> (forall m :e n, p m) -> p n.
claim L1: forall n:set, nat_p n -> forall m :e n, p m.
{ apply nat_ind.
  - prove forall m :e 0, p m.
    let m.
    assume Hm: m :e 0.
    prove False.
    exact (EmptyE m Hm).
  - let n.
    assume Hn: nat_p n.
    assume IHn: forall m :e n, p m.
    prove forall m :e ordsucc n, p m.
    let m.
    assume Hm: m :e ordsucc n.
    prove p m.
    apply (ordsuccE n m Hm).
    + assume H2: m :e n.
      exact (IHn m H2).
    + assume H2: m = n.
      prove p m.
      rewrite H2.
      prove p n.
      exact (H1 n Hn IHn).
}
prove forall n, nat_p n -> p n.
exact (fun n Hn => H1 n Hn (L1 n Hn)).
Qed.

Theorem nat_inv_impred : forall p:set->prop, p 0 -> (forall n, nat_p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p. assume H1 H2. exact nat_ind p H1 (fun n H _ => H2 n H).
Qed.

Theorem nat_inv : forall n, nat_p n -> n = 0 \/ exists x, nat_p x /\ n = ordsucc x.
apply nat_inv_impred.
- apply orIL. reflexivity.
- let n. assume Hn. apply orIR. witness n. apply andI.
  + exact Hn.
  + reflexivity.
Qed.

Theorem nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
apply nat_ind.
- prove forall m :e 0, nat_p m.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, nat_p m.
  prove forall m :e ordsucc n, nat_p m.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    exact (IHn m H1).
  + assume H1: m = n.
    rewrite H1.
    exact Hn.
Qed.

Theorem nat_trans : forall n, nat_p n -> forall m :e n, m c= n.
apply nat_ind.
- prove forall m :e 0, m c= 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, m c= n.
  prove forall m :e ordsucc n, m c= ordsucc n.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    prove m c= ordsucc n.
    apply (Subq_tra m n (ordsucc n)).
    * exact (IHn m H1).
    * exact (ordsuccI1 n).
  + assume H1: m = n.
    prove m c= ordsucc n.
    rewrite H1.
    prove n c= ordsucc n.
    exact (ordsuccI1 n).
Qed.

Theorem nat_ordsucc_trans : forall n, nat_p n -> forall m :e ordsucc n, m c= n.
let n.
assume Hn: nat_p n.
let m.
assume Hm: m :e ordsucc n.
let k.
assume Hk: k :e m.
prove k :e n.
apply (ordsuccE n m Hm).
- assume H1: m :e n.
  exact nat_trans n Hn m H1 k Hk.
- assume H1: m = n.
  rewrite <- H1.
  exact Hk.
Qed.

Definition surj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem form100_63_surjCantor: forall A:set, forall f:set -> set, ~surj A (Power A) f.
let A f. assume H. apply H.
assume H1: forall u :e A, f u :e Power A.
assume H2: forall w :e Power A, exists u :e A, f u = w.
set D := {x :e A|x /:e f x}.
claim L1: D :e Power A.
{ exact Sep_In_Power A (fun x => x /:e f x). }
apply H2 D L1.
let d. assume H. apply H.
assume Hd: d :e A.
assume HfdD: f d = D.
claim L2: d /:e D.
{ assume H3: d :e D.
  apply SepE2 A (fun x => x /:e f x) d H3.
  prove d :e f d.
  rewrite HfdD.
  prove d :e D.
  exact H3.
}
apply L2.
prove d :e D.
apply SepI.
- prove d :e A. exact Hd.
- prove d /:e f d. rewrite HfdD. exact L2.
Qed.

Definition inj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v).

Theorem form100_63_injCantor: forall A:set, forall f:set -> set, ~inj (Power A) A f.
let A f. assume H. apply H.
assume H1: forall X :e Power A, f X :e A.
assume H2: forall X Y :e Power A, f X = f Y -> X = Y.
set D := {f X | X :e Power A, f X /:e X}.
claim L1: D :e Power A.
{ apply PowerI.
  let n. assume H3: n :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f n H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: n = f X.
  prove n :e A. rewrite H5. apply H1. exact HX.
}
claim L2: f D /:e D.
{ assume H3: f D :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f (f D) H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: f D = f X.
  claim L2a: D = X.
  { exact H2 D L1 X HX H5. }
  apply H4. rewrite <- L2a. exact H3.
}
apply L2.
prove f D :e D.
apply ReplSepI.
- prove D :e Power A. exact L1.
- prove f D /:e D. exact L2.
Qed.

Theorem injI : forall X Y, forall f:set -> set, (forall x :e X, f x :e Y) -> (forall x z :e X, f x = f z -> x = z) -> inj X Y f.
let X Y f. assume H1 H2.
prove (forall x :e X, f x :e Y) /\ (forall x z :e X, f x = f z -> x = z).
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem inj_comp : forall X Y Z:set, forall f g:set->set, inj X Y f -> inj Y Z g -> inj X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf.
assume Hg.
apply Hf.
assume Hf1 Hf2.
apply Hg.
assume Hg1 Hg2.
apply injI.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
Qed.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem bijI : forall X Y, forall f:set -> set,
    (forall u :e X, f u :e Y)
 -> (forall u v :e X, f u = f v -> u = v)
 -> (forall w :e Y, exists u :e X, f u = w)
 -> bij X Y f.
let X Y f. assume Hf1 Hf2 Hf3.
prove (forall u :e X, f u :e Y)
   /\ (forall u v :e X, f u = f v -> u = v)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply and3I.
- exact Hf1.
- exact Hf2.
- exact Hf3.
Qed.

Theorem bijE : forall X Y, forall f:set -> set,
    bij X Y f
 -> forall p:prop,
      ((forall u :e X, f u :e Y)
    -> (forall u v :e X, f u = f v -> u = v)
    -> (forall w :e Y, exists u :e X, f u = w)
    -> p)
   -> p.
let X Y f. assume Hf. let p. assume Hp.
apply Hf. assume Hf. apply Hf.
assume Hf1 Hf2 Hf3.
exact Hp Hf1 Hf2 Hf3.
Qed.

Theorem bij_inj : forall X Y, forall f:set -> set, bij X Y f -> inj X Y f.
let X Y f. assume H1. apply H1. assume H1 _. exact H1.
Qed.

Theorem bij_id : forall X, bij X X (fun x => x).
let X.
prove (forall u :e X, u :e X) /\ (forall u v :e X, u = v -> u = v) /\ (forall w :e X, exists u :e X, u = w).
apply and3I.
- exact (fun u Hu => Hu).
- exact (fun u Hu v Hv H1 => H1).
- let w. assume Hw. witness w. apply andI.
  + exact Hw.
  + reflexivity.
Qed.

Theorem bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf. apply Hf. assume Hf12 Hf3. apply Hf12. assume Hf1 Hf2.
assume Hg. apply Hg. assume Hg12 Hg3. apply Hg12. assume Hg1 Hg2.
prove (forall u :e X, g (f u) :e Z)
  /\
  (forall u v :e X, g (f u) = g (f v) -> u = v)
  /\
  (forall w :e Z, exists u :e X, g (f u) = w).
apply and3I.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
- let w. assume Hw: w :e Z. apply Hg3 w Hw.
  let y. assume Hy12. apply Hy12.
  assume Hy1: y :e Y. assume Hy2: g y = w.
  apply Hf3 y Hy1.
  let u. assume Hu12. apply Hu12.
  assume Hu1: u :e X. assume Hu2: f u = y.
  prove exists u :e X, g (f u) = w.
  witness u.
  apply andI.
  + exact Hu1.
  + rewrite Hu2. exact Hy2.
Qed.

Theorem bij_surj : forall X Y, forall f:set -> set, bij X Y f -> surj X Y f.
let X Y f. assume H1. apply H1. assume H1. apply H1.
assume H1 _ H2.
prove (forall u :e X, f u :e Y)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply andI.
- exact H1.
- exact H2.
Qed.

Definition inv : set -> (set -> set) -> set -> set := fun X f => fun y:set => Eps_i (fun x => x :e X /\ f x = y).

Theorem surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
let X Y f. assume H1.
let y. assume Hy: y :e Y.
apply H1 y Hy.
let x.
assume H2.
exact Eps_i_ax (fun x => x :e X /\ f x = y) x H2.
Qed.

Theorem inj_linv : forall X, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.
let X f.
assume H1.
let x. assume Hx.
claim L1: inv X f (f x) :e X /\ f (inv X f (f x)) = f x.
{ apply Eps_i_ax (fun x' => x' :e X /\ f x' = f x) x.
  apply andI.
  - exact Hx.
  - reflexivity.
}
apply L1.
assume H2 H3.
exact H1 (inv X f (f x)) H2 x Hx H3.
Qed.

Theorem bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
let X Y f.
assume H1. apply H1.
assume H2. apply H2.
assume H3: forall u :e X, f u :e Y.
assume H4: forall u v :e X, f u = f v -> u = v.
assume H5: forall w :e Y, exists u :e X, f u = w.
set g : set->set := fun y => Eps_i (fun x => x :e X /\ f x = y).
claim L1: forall y :e Y, g y :e X /\ f (g y) = y.
{ exact surj_rinv X Y f H5. }
prove (forall u :e Y, g u :e X)
      /\
      (forall u v :e Y, g u = g v -> u = v)
      /\
      (forall w :e X, exists u :e Y, g u = w).
apply and3I.
- prove forall u :e Y, g u :e X.
  let u. assume Hu. apply L1 u Hu. assume H _. exact H.
- prove forall u v :e Y, g u = g v -> u = v.
  let u. assume Hu. let v. assume Hv H6.
  prove u = v.
  apply L1 u Hu.
  assume H7: g u :e X.
  assume H8: f (g u) = u.
  apply L1 v Hv.
  assume H9: g v :e X.
  assume H10: f (g v) = v.
  rewrite <- H8.
  rewrite <- H10.
  rewrite <- H6.
  reflexivity.
- prove forall w :e X, exists u :e Y, g u = w.
  let w. assume Hw.
  claim Lfw: f w :e Y.
  { exact H3 w Hw. }
  witness f w.
  apply andI.
  + exact Lfw.
  + exact inj_linv X f H4 w Hw.
Qed.

Definition atleastp : set -> set -> prop
 := fun X Y : set => exists f : set -> set, inj X Y f.

Theorem atleastp_tra: forall X Y Z, atleastp X Y -> atleastp Y Z -> atleastp X Z.
admit.
Qed.

Theorem Subq_atleastp : forall X Y, X c= Y -> atleastp X Y.
admit.
Qed.

Definition equip : set -> set -> prop
 := fun X Y : set => exists f : set -> set, bij X Y f.

Theorem equip_atleastp: forall X Y, equip X Y -> atleastp X Y.
admit.
Qed.

Theorem equip_ref : forall X, equip X X.
admit.
Qed.

Theorem equip_sym : forall X Y, equip X Y -> equip Y X.
admit.
Qed.

Theorem equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
admit.
Qed.

Theorem equip_0_Empty : forall X, equip X 0 -> X = 0.
admit.
Qed.

Theorem equip_adjoin_ordsucc : forall N X y, y /:e X -> equip N X -> equip (ordsucc N) (X :\/: {y}).
admit.
Qed.

Theorem equip_ordsucc_remove1: forall X N, forall x :e X, equip X (ordsucc N) -> equip (X :\: {x}) N.
admit.
Qed.

Section SchroederBernstein.

Theorem KnasterTarski_set: forall A, forall F:set->set,
    (forall U :e Power A, F U :e Power A)
 -> (forall U V :e Power A, U c= V -> F U c= F V)
 -> exists Y :e Power A, F Y = Y.
admit.
Qed.

Theorem image_In_Power : forall A B, forall f:set -> set, (forall x :e A, f x :e B) -> forall U :e Power A, {f x|x :e U} :e Power B.
admit.
Qed.

Theorem image_monotone : forall f:set -> set, forall U V, U c= V -> {f x|x :e U} c= {f x|x :e V}.
admit.
Qed.

Theorem setminus_antimonotone : forall A U V, U c= V -> A :\: V c= A :\: U.
admit.
Qed.

Theorem SchroederBernstein: forall A B, forall f g:set -> set, inj A B f -> inj B A g -> equip A B.
admit.
Qed.

Theorem atleastp_antisym_equip: forall A B, atleastp A B -> atleastp B A -> equip A B.
admit.
Qed.

End SchroederBernstein.

Section PigeonHole.

Theorem PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
admit.
Qed.

Theorem Pigeonhole_not_atleastp_ordsucc : forall n, nat_p n -> ~atleastp (ordsucc n) n.
admit.
Qed.

End PigeonHole.

Theorem Union_ordsucc_eq : forall n, nat_p n -> Union (ordsucc n) = n.
admit.
Qed.

Theorem cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
admit.
Qed.

Theorem cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
admit.
Qed.

Theorem neq_0_1 : 0 <> 1.
admit.
Qed.

Theorem neq_1_0 : 1 <> 0.
admit.
Qed.

Theorem neq_0_2 : 0 <> 2.
admit.
Qed.

Theorem neq_2_0 : 2 <> 0.
admit.
Qed.

Definition ordinal : set->prop := fun (alpha:set) => TransSet alpha /\ forall beta :e alpha, TransSet beta.

Theorem ordinal_TransSet : forall alpha:set, ordinal alpha -> TransSet alpha.
admit.
Qed.

Theorem ordinal_Empty : ordinal Empty.
admit.
Qed.

Theorem ordinal_Hered : forall alpha:set, ordinal alpha -> forall beta :e alpha, ordinal beta.
admit.
Qed.

Theorem TransSet_ordsucc : forall X:set, TransSet X -> TransSet (ordsucc X).
admit.
Qed.

Theorem ordinal_ordsucc : forall alpha:set, ordinal alpha -> ordinal (ordsucc alpha).
admit.
Qed.

Theorem nat_p_ordinal : forall n:set, nat_p n -> ordinal n.
admit.
Qed.

Theorem ordinal_1 : ordinal 1.
admit.
Qed.

Theorem ordinal_2 : ordinal 2.
admit.
Qed.

Theorem TransSet_ordsucc_In_Subq : forall X:set, TransSet X -> forall x :e X, ordsucc x c= X.
admit.
Qed.

Theorem ordinal_ordsucc_In_Subq : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta c= alpha.
admit.
Qed.

Theorem ordinal_trichotomy_or : forall alpha beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
admit.
Qed.    

Theorem ordinal_trichotomy_or_impred : forall alpha beta:set, ordinal alpha -> ordinal beta -> forall p:prop, (alpha :e beta -> p) -> (alpha = beta -> p) -> (beta :e alpha -> p) -> p.
admit.
Qed.

Theorem ordinal_In_Or_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_linear : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_ordsucc_In_eq : forall alpha beta, ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
admit.
Qed.

Theorem ordinal_lim_or_succ : forall alpha, ordinal alpha -> (forall beta :e alpha, ordsucc beta :e alpha) \/ (exists beta :e alpha, alpha = ordsucc beta).
admit.
Qed.

Theorem ordinal_ordsucc_In : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_famunion : forall X, forall F:set -> set, (forall x :e X, ordinal (F x)) -> ordinal (\/_ x :e X, F x).
admit.
Qed.

Theorem ordinal_binintersect : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).
admit.
Qed.

Theorem ordinal_binunion : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).
admit.
Qed.

Theorem ordinal_ind : forall p:set->prop, 
(forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha)
->
forall alpha, ordinal alpha -> p alpha.
admit.
Qed.

Theorem least_ordinal_ex : forall p:set -> prop, (exists alpha, ordinal alpha /\ p alpha) -> exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.
admit.
Qed.

Theorem equip_Sing_1 : forall x, equip {x} 1.
admit.
Qed.

Theorem TransSet_In_ordsucc_Subq : forall x y, TransSet y -> x :e ordsucc y -> x c= y.
admit.
Qed.

Theorem exandE_i : forall P Q:set -> prop, (exists x, P x /\ Q x) -> forall r:prop, (forall x, P x -> Q x -> r) -> r.
admit.
Qed.

Theorem exandE_ii : forall P Q:(set -> set) -> prop, (exists x:set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iii : forall P Q:(set -> set -> set) -> prop, (exists x:set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iiii : forall P Q:(set -> set -> set -> set) -> prop, (exists x:set -> set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Section Descr_ii.
Variable P : (set -> set) -> prop.
(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Definition Descr_ii : set -> set := fun x:set => Eps_i (fun y => forall h:set -> set, P h -> h x = y).
Hypothesis Pex: exists f:set -> set, P f.
Hypothesis Puniq: forall f g:set -> set, P f -> P g -> f = g.

Theorem Descr_ii_prop : P Descr_ii.
admit.
Qed.

End Descr_ii.
Section Descr_iii.
Variable P : (set -> set -> set) -> prop.
(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Definition Descr_iii : set -> set -> set := fun x y:set => Eps_i (fun z => forall h:set -> set -> set, P h -> h x y = z).
Hypothesis Pex: exists f:set -> set -> set, P f.
Hypothesis Puniq: forall f g:set -> set -> set, P f -> P g -> f = g.

Theorem Descr_iii_prop : P Descr_iii.
admit.
Qed.

End Descr_iii.
Section Descr_Vo1.
Variable P : Vo 1 -> prop.
(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Definition Descr_Vo1 : Vo 1 := fun x:set => forall h:set -> prop, P h -> h x.
Hypothesis Pex: exists f:Vo 1, P f.
Hypothesis Puniq: forall f g:Vo 1, P f -> P g -> f = g.

Theorem Descr_Vo1_prop : P Descr_Vo1.
admit.
Qed.

End Descr_Vo1.
Section If_ii.
Variable p:prop.
Variable f g:set -> set.
(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Definition If_ii : set -> set := fun x => if p then f x else g x.

Theorem If_ii_1 : p -> If_ii = f.
admit.
Qed.

Theorem If_ii_0 : ~p -> If_ii = g.
admit.
Qed.

End If_ii.
Section If_iii.
Variable p:prop.
Variable f g:set -> set -> set.
(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Definition If_iii : set -> set -> set := fun x y => if p then f x y else g x y.

Theorem If_iii_1 : p -> If_iii = f.
admit.
Qed.

Theorem If_iii_0 : ~p -> If_iii = g.
admit.
Qed.

End If_iii.
Section EpsilonRec_i.
Variable F:set -> (set -> set) -> set.
Definition In_rec_i_G : set -> set -> prop :=
fun X Y =>
forall R:set->set->prop,
(forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Definition In_rec_i : set -> set := fun X => Eps_i (In_rec_i_G X).

Theorem In_rec_i_G_c : forall X:set, forall f:set->set, (forall x :e X, In_rec_i_G x (f x)) -> In_rec_i_G X (F X f).
admit.
Qed.

Theorem In_rec_i_G_inv : forall X:set, forall Y:set, In_rec_i_G X Y -> exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_i_G_f : forall X:set, forall Y Z:set, In_rec_i_G X Y -> In_rec_i_G X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_i_G_In_rec_i : forall X:set, In_rec_i_G X (In_rec_i X).
admit.
Qed.

Theorem In_rec_i_G_In_rec_i_d : forall X:set, In_rec_i_G X (F X In_rec_i).
admit.
Qed.

Theorem In_rec_i_eq : forall X:set, In_rec_i X = F X In_rec_i.
admit.
Qed.

End EpsilonRec_i.
Section EpsilonRec_ii.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Definition In_rec_G_ii : set -> (set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set)->prop,
(forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Definition In_rec_ii : set -> (set -> set) := fun X => Descr_ii (In_rec_G_ii X).

Theorem In_rec_G_ii_c : forall X:set, forall f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) -> In_rec_G_ii X (F X f).
admit.
Qed.

Theorem In_rec_G_ii_inv : forall X:set, forall Y:(set -> set), In_rec_G_ii X Y -> exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_ii_f : forall X:set, forall Y Z:(set -> set), In_rec_G_ii X Y -> In_rec_G_ii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii : forall X:set, In_rec_G_ii X (In_rec_ii X).
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii_d : forall X:set, In_rec_G_ii X (F X In_rec_ii).
admit.
Qed.

Theorem In_rec_ii_eq : forall X:set, In_rec_ii X = F X In_rec_ii.
admit.
Qed.

End EpsilonRec_ii.
Section EpsilonRec_iii.
Variable F:set -> (set -> (set -> set -> set)) -> (set -> set -> set).
Definition In_rec_G_iii : set -> (set -> set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set -> set)->prop,
(forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Definition In_rec_iii : set -> (set -> set -> set) := fun X => Descr_iii (In_rec_G_iii X).

Theorem In_rec_G_iii_c : forall X:set, forall f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) -> In_rec_G_iii X (F X f).
admit.
Qed.

Theorem In_rec_G_iii_inv : forall X:set, forall Y:(set -> set -> set), In_rec_G_iii X Y -> exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_iii_f : forall X:set, forall Y Z:(set -> set -> set), In_rec_G_iii X Y -> In_rec_G_iii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii : forall X:set, In_rec_G_iii X (In_rec_iii X).
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii_d : forall X:set, In_rec_G_iii X (F X In_rec_iii).
admit.
Qed.

Theorem In_rec_iii_eq : forall X:set, In_rec_iii X = F X In_rec_iii.
admit.
Qed.

End EpsilonRec_iii.
Section NatRec.
Variable z:set.
Variable f:set->set->set.
Let F : set->(set->set)->set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.
Definition nat_primrec : set->set := In_rec_i F.

Theorem nat_primrec_r : forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.
admit.
Qed.

Theorem nat_primrec_0 : nat_primrec 0 = z.
admit.
Qed.

Theorem nat_primrec_S : forall n:set, nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).
admit.
Qed.

End NatRec.

Section NatAdd.

Definition add_nat : set->set->set := fun n m:set => nat_primrec n (fun _ r => ordsucc r) m.
Infix + 360 right := add_nat.

Theorem add_nat_0R : forall n:set, n + 0 = n.
admit.
Qed.

Theorem add_nat_SR : forall n m:set, nat_p m -> n + ordsucc m = ordsucc (n + m).
admit.
Qed.

Theorem add_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n + m).
admit.
Qed.

Theorem add_nat_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n+m)+k = n+(m+k).
admit.
Qed.

Theorem add_nat_0L : forall m:set, nat_p m -> 0+m = m.
admit.
Qed.

Theorem add_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n + m = ordsucc (n+m).
admit.
Qed.

Theorem add_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n + m = m + n.
admit.
Qed.

Theorem add_nat_In_R: forall m, nat_p m -> forall k :e m, forall n, nat_p n -> k + n :e m + n.
admit.
Qed.

Theorem add_nat_In_L: forall n, nat_p n -> forall m, nat_p m -> forall k :e m, n + k :e n + m.
admit.
Qed.

Theorem add_nat_Subq_R: forall k, nat_p k -> forall m, nat_p m -> k c= m -> forall n, nat_p n -> k + n c= m + n.
admit.
Qed.

Theorem add_nat_Subq_L: forall n, nat_p n -> forall k, nat_p k -> forall m, nat_p m -> k c= m -> n + k c= n + m.
admit.
Qed.

Theorem add_nat_Subq_R' : forall m, nat_p m -> forall n, nat_p n -> m c= m + n.
admit.
Qed.

Theorem nat_Subq_add_ex: forall n, nat_p n -> forall m, nat_p m -> n c= m -> exists k, nat_p k /\ m = k + n.
admit.
Qed.

Theorem add_nat_cancel_R : forall k, nat_p k -> forall m, nat_p m -> forall n, nat_p n -> k + n = m + n -> k = m.
admit.
Qed.

End NatAdd.

Section NatMul.

Infix + 360 right := add_nat.

Definition mul_nat : set->set->set := fun n m:set => nat_primrec 0 (fun _ r => n + r) m.
Infix * 355 right := mul_nat.

Theorem mul_nat_0R : forall n:set, n * 0 = 0.
admit.
Qed.

Theorem mul_nat_SR : forall n m, nat_p m -> n * ordsucc m = n + n * m.
admit.
Qed.

Theorem mul_nat_1R: forall n, n * 1 = n.
admit.
Qed.

Theorem mul_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n * m).
admit.
Qed.

Theorem mul_nat_0L : forall m:set, nat_p m -> 0 * m = 0.
admit.
Qed.

Theorem mul_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n * m = n * m + m.
admit.
Qed.

Theorem mul_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n * m = m * n.
admit.
Qed.

Theorem mul_add_nat_distrL : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> n * (m + k) = n * m + n * k.
admit.
Qed.

Theorem mul_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n*m)*k = n*(m*k).
admit.
Qed.

Theorem mul_nat_Subq_R : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> m * k c= n * k.
admit.
Qed.

Theorem mul_nat_Subq_L : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> k * m c= k * n.
admit.
Qed.

Theorem mul_nat_0_or_Subq: forall m, nat_p m -> forall n, nat_p n -> n = 0 \/ m c= m * n.
admit.
Qed.

(** If m times n = 0 for naturals m and n, then one must be 0. **)
Theorem mul_nat_0_inv : forall m, nat_p m -> forall n, nat_p n -> m * n = 0 -> m = 0 \/ n = 0.
admit.
Qed.

Theorem mul_nat_0m_1n_In: forall m, nat_p m -> forall n, nat_p n -> 0 :e m -> 1 :e n -> m :e m * n.
admit.
Qed.

Theorem nat_le1_cases: forall m, nat_p m -> m c= 1 -> m = 0 \/ m = 1.
admit.
Qed.

Definition Pi_nat : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_nat_0: forall f:set -> set, Pi_nat f 0 = 1.
admit.
Qed.

Theorem Pi_nat_S: forall f:set -> set, forall n, nat_p n -> Pi_nat f (ordsucc n) = Pi_nat f n * f n.
admit.
Qed.

Theorem Pi_nat_p: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, nat_p (f i))
  -> nat_p (Pi_nat f n).
admit.
Qed.

Theorem Pi_nat_0_inv: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> Pi_nat f n = 0
   -> (exists i :e n, f i = 0).
admit.
Qed.

Definition exp_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.

Infix ^ 342 right := exp_nat.

Theorem exp_nat_0 : forall n, n ^ 0 = 1.
admit.
Qed.

Theorem exp_nat_S : forall n m, nat_p m -> n ^ (ordsucc m) = n * n ^ m.
admit.
Qed.

Theorem exp_nat_p : forall n, nat_p n -> forall m, nat_p m -> nat_p (n ^ m).
admit.
Qed.

Theorem exp_nat_1 : forall n, n ^ 1 = n.
admit.
Qed.

End NatMul.

Section form100_52.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.
Infix ^ 342 right := exp_nat.

Theorem Subq_Sing0_1 : {0} c= 1.
admit.
Qed.

Theorem Subq_1_Sing0 : 1 c= {0}.
admit.
Qed.

Theorem eq_1_Sing0 : 1 = {0}.
admit.
Qed.

Theorem Power_0_Sing_0 : Power 0 = {0}.
admit.
Qed.

Theorem equip_finite_Power: forall n, nat_p n -> forall X,
  equip X n -> equip (Power X) (2 ^ n).
admit.
Qed.

End form100_52.

Theorem ZF_closed_E : forall U, ZF_closed U ->
 forall p:prop,
 (Union_closed U ->
  Power_closed U ->
  Repl_closed U -> p)
 -> p.
admit.
Qed.

Theorem ZF_Union_closed : forall U, ZF_closed U ->
  forall X :e U, Union X :e U.
admit.
Qed.

Theorem ZF_Power_closed : forall U, ZF_closed U ->
  forall X :e U, Power X :e U.
admit.
Qed.

Theorem ZF_Repl_closed : forall U, ZF_closed U ->
  forall X :e U, forall F:set->set, (forall x :e X, F x :e U) -> {F x|x:eX} :e U.
admit.
Qed.

Theorem ZF_UPair_closed : forall U, ZF_closed U ->
  forall x y :e U, {x,y} :e U.
admit.
Qed.

Theorem ZF_Sing_closed : forall U, ZF_closed U ->
  forall x :e U, {x} :e U.
admit.
Qed.

Theorem ZF_binunion_closed : forall U, ZF_closed U ->
  forall X Y :e U, (X :\/: Y) :e U.
admit.
Qed.

Theorem ZF_ordsucc_closed : forall U, ZF_closed U ->
  forall x :e U, ordsucc x :e U.
admit.
Qed.

Theorem nat_p_UnivOf_Empty : forall n:set, nat_p n -> n :e UnivOf Empty.
admit.
Qed.

(* Unicode omega "3c9" *)
(* Parameter omega "39cdf86d83c7136517f803d29d0c748ea45a274ccbf9b8488f9cda3e21f4b47c" "6fc30ac8f2153537e397b9ff2d9c981f80c151a73f96cf9d56ae2ee27dfd1eb2" *)
Definition omega : set := {n :e UnivOf Empty|nat_p n}.

Theorem omega_nat_p : forall n :e omega, nat_p n.
admit.
Qed.

Theorem nat_p_omega : forall n:set, nat_p n -> n :e omega.
admit.
Qed.

Theorem omega_ordsucc : forall n :e omega, ordsucc n :e omega.
admit.
Qed.

Theorem form100_22_v2: forall f:set -> set, ~inj (Power omega) omega f.
admit.
Qed.

Theorem form100_22_v3: forall g:set -> set, ~surj omega (Power omega) g.
admit.
Qed.

Theorem form100_22_v1: ~equip omega (Power omega).
admit.
Qed.

Theorem omega_TransSet : TransSet omega.
admit.
Qed.

Theorem omega_ordinal : ordinal omega.
admit.
Qed.

Theorem ordsucc_omega_ordinal: ordinal (ordsucc omega).
admit.
Qed.

Definition finite : set -> prop := fun X => exists n :e omega, equip X n.

Theorem nat_finite: forall n, nat_p n -> finite n.
admit.
Qed.

Theorem finite_ind : forall p:set -> prop,
    p Empty
 -> (forall X y, finite X -> y /:e X -> p X -> p (X :\/: {y}))
 -> forall X, finite X -> p X.
admit.
Qed.

Theorem finite_Empty: finite 0.
admit.
Qed.

Theorem Sing_finite: forall x, finite {x}.
admit.
Qed.

Theorem adjoin_finite: forall X y, finite X -> finite (X :\/: {y}).
admit.
Qed.

Theorem binunion_finite: forall X, finite X -> forall Y, finite Y -> finite (X :\/: Y).
admit.
Qed.

Theorem famunion_nat_finite : forall X:set -> set, forall n, nat_p n -> (forall i :e n, finite (X i)) -> finite (\/_ i :e n, X i).
admit.
Qed.

Theorem Subq_finite : forall X, finite X -> forall Y, Y c= X -> finite Y.
admit.
Qed.

Definition infinite : set -> prop := fun A => ~finite A.

Section InfinitePrimes.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Definition divides_nat : set -> set -> prop :=
  fun m n => m :e omega /\ n :e omega /\ exists k :e omega, m * k = n.

Theorem divides_nat_ref: forall n, nat_p n -> divides_nat n n.
admit.
Qed.

Theorem divides_nat_tra: forall k m n, divides_nat k m -> divides_nat m n -> divides_nat k n.
admit.
Qed.

Definition prime_nat : set -> prop :=
  fun n => n :e omega /\ 1 :e n /\ forall k :e omega, divides_nat k n -> k = 1 \/ k = n.

Theorem divides_nat_mulR: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mulL: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_nat_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> (forall i :e n, divides_nat (f i) (Pi_nat f n)).
admit.
Qed.

Definition composite_nat : set -> prop :=
  fun n => n :e omega /\ exists k m :e omega, 1 :e k /\ 1 :e m /\ k * m = n.

Theorem prime_nat_or_composite_nat: forall n :e omega, 1 :e n -> prime_nat n \/ composite_nat n.
admit.
Qed.

Theorem prime_nat_divisor_ex: forall n, nat_p n -> 1 :e n -> exists p, prime_nat p /\ divides_nat p n.
admit.
Qed.

Theorem nat_1In_not_divides_ordsucc: forall m n, 1 :e m -> divides_nat m n -> ~divides_nat m (ordsucc n).
admit.
Qed.

Definition primes : set := {n :e omega|prime_nat n}.

Theorem form100_11_infinite_primes: infinite primes.
admit.
Qed.

End InfinitePrimes.

Section InfiniteRamsey.

Infix + 360 right := add_nat.

Theorem atleastp_omega_infinite: forall X, atleastp omega X -> infinite X.
admit.
Qed.

Theorem infinite_remove1: forall X, infinite X -> forall y, infinite (X :\: {y}).
admit.
Qed.

Theorem infinite_Finite_Subq_ex: forall X, infinite X ->
  forall n, nat_p n -> exists Y c= X, equip Y n.
admit.
Qed.

Theorem infiniteRamsey_lem: forall X, forall f g f':set -> set,
    infinite X
 -> (forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z))
 -> (forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z)
 -> f' 0 = f X
 -> (forall m, nat_p m -> f' (ordsucc m) = f (f' m))
 -> (forall m, nat_p m -> f' m c= X /\ infinite (f' m))
 /\ (forall m m' :e omega, m c= m' -> f' m' c= f' m)
 /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
admit.
Qed.

Theorem infiniteRamsey: forall c, nat_p c -> forall n, nat_p n ->
  forall X, infinite X -> forall C:set -> set,
    (forall Y c= X, equip Y n -> C Y :e c)
 -> exists H c= X, exists i :e c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
admit.
Qed.

End InfiniteRamsey.

(*** Injection of set into itself that will correspond to x |-> (1,x) after pairing is defined. ***)
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).

Theorem Inj1_eq : forall X:set, Inj1 X = {0} :\/: {Inj1 x|x :e X}.
admit.
Qed.

Theorem Inj1I1 : forall X:set, 0 :e Inj1 X.
admit.
Qed.

Theorem Inj1I2 : forall X x:set, x :e X -> Inj1 x :e Inj1 X.
admit.
Qed.

Theorem Inj1E : forall X y:set, y :e Inj1 X -> y = 0 \/ exists x :e X, y = Inj1 x.
admit.
Qed.

Theorem Inj1NE1 : forall x:set, Inj1 x <> 0.
admit.
Qed.

Theorem Inj1NE2 : forall x:set, Inj1 x /:e {0}.
admit.
Qed.

(*** Injection of set into itself that will correspond to x |-> (0,x) after pairing is defined. ***)
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.

Theorem Inj0I : forall X x:set, x :e X -> Inj1 x :e Inj0 X.
admit.
Qed.

Theorem Inj0E : forall X y:set, y :e Inj0 X -> exists x:set, x :e X /\ y = Inj1 x.
admit.
Qed.

(*** Unj : Left inverse of Inj1 and Inj0 ***)
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).

Theorem Unj_eq : forall X:set, Unj X = {Unj x|x :e X :\: {0}}.
admit.
Qed.

Theorem Unj_Inj1_eq : forall X:set, Unj (Inj1 X) = X.
admit.
Qed.

Theorem Inj1_inj : forall X Y:set, Inj1 X = Inj1 Y -> X = Y.
admit.
Qed.

Theorem Unj_Inj0_eq : forall X:set, Unj (Inj0 X) = X.
admit.
Qed.

Theorem Inj0_inj : forall X Y:set, Inj0 X = Inj0 Y -> X = Y.
admit.
Qed.

Theorem Inj0_0 : Inj0 0 = 0.
admit.
Qed.

Theorem Inj0_Inj1_neq : forall X Y:set, Inj0 X <> Inj1 Y.
admit.
Qed.

(*** setsum ***)
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
(* Unicode :+: "002b" *)
Infix :+: 450 left := setsum.

Theorem Inj0_setsum : forall X Y x:set, x :e X -> Inj0 x :e X :+: Y.
admit.
Qed.

Theorem Inj1_setsum : forall X Y y:set, y :e Y -> Inj1 y :e X :+: Y.
admit.
Qed.

Theorem setsum_Inj_inv : forall X Y z:set, z :e X :+: Y -> (exists x :e X, z = Inj0 x) \/ (exists y :e Y, z = Inj1 y).
admit.
Qed.

Theorem Inj0_setsum_0L : forall X:set, 0 :+: X = Inj0 X.
admit.
Qed.

Theorem Inj1_setsum_1L : forall X:set, 1 :+: X = Inj1 X.
admit.
Qed.

Section pair_setsum.
Let pair := setsum.
Definition proj0 : set -> set := fun Z => {Unj z|z :e Z, exists x:set, Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z, exists y:set, Inj1 y = z}.

Theorem Inj0_pair_0_eq : Inj0 = pair 0.
admit.
Qed.

Theorem Inj1_pair_1_eq : Inj1 = pair 1.
admit.
Qed.

Theorem pairI0 : forall X Y x, x :e X -> pair 0 x :e pair X Y.
admit.
Qed.

Theorem pairI1 : forall X Y y, y :e Y -> pair 1 y :e pair X Y.
admit.
Qed.

Theorem pairE : forall X Y z, z :e pair X Y -> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
admit.
Qed.

Theorem pairE0 : forall X Y x, pair 0 x :e pair X Y -> x :e X.
admit.
Qed.

Theorem pairE1 : forall X Y y, pair 1 y :e pair X Y -> y :e Y.
admit.
Qed.

Theorem proj0I : forall w u:set, pair 0 u :e w -> u :e proj0 w.
admit.
Qed.

Theorem proj0E : forall w u:set, u :e proj0 w -> pair 0 u :e w.
admit.
Qed.

Theorem proj1I : forall w u:set, pair 1 u :e w -> u :e proj1 w.
admit.
Qed.

Theorem proj1E : forall w u:set, u :e proj1 w -> pair 1 u :e w.
admit.
Qed.

Theorem proj0_pair_eq : forall X Y:set, proj0 (pair X Y) = X.
admit.
Qed.

Theorem proj1_pair_eq : forall X Y:set, proj1 (pair X Y) = Y.
admit.
Qed.

Opaque add_nat mul_nat omega ordsucc setminus binintersect ReplSep Sep famunion binunion Sing UPair exactly1of2 If_i If_ii If_iii Descr_Vo1 Descr_iii Descr_ii inv In_rec_i In_rec_ii In_rec_iii.

(*** Sigma X Y = {(x,y) | x in X, y in Y x} ***)
Definition Sigma : set -> (set -> set) -> set :=
fun X Y => \/_ x :e X, {pair x y|y :e Y x}.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

Theorem Sigma_eta_proj0_proj1 : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem proj0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj0 z :e X.
admit.
Qed.

Theorem proj1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem pair_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, pair x y :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem pair_Sigma_E1 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> y :e Y x.
admit.
Qed.

Theorem Sigma_E : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) -> exists x :e X, exists y :e Y x, z = pair x y.
admit.
Qed.

Definition setprod : set->set->set := fun X Y:set => Sigma_ x :e X, Y.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(*** lam X F = {(x,y) | x :e X, y :e F x} = \/_{x :e X} {(x,y) | y :e (F x)} = Sigma X F ***)
Let lam : set -> (set -> set) -> set := Sigma.
(***  ap f x = {proj1 z | z :e f,  exists y, z = pair x y}} ***)
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f, exists y:set, z = pair x y}.
Notation SetImplicitOp ap.
Notation SetLam Sigma.

Theorem lamI : forall X:set, forall F:set->set, forall x :e X, forall y :e F x, pair x y :e fun x :e X => F x.
admit.
Qed.

Theorem lamE : forall X:set, forall F:set->set, forall z:set, z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = pair x y.
admit.
Qed.

Theorem apI : forall f x y, pair x y :e f -> y :e f x.
admit.
Qed.

Theorem apE : forall f x y, y :e f x -> pair x y :e f.
admit.
Qed.

Theorem beta : forall X:set, forall F:set -> set, forall x:set, x :e X -> (fun x :e X => F x) x = F x.
admit.
Qed.

Theorem proj0_ap_0 : forall u, proj0 u = u 0.
admit.
Qed.

Theorem proj1_ap_1 : forall u, proj1 u = u 1.
admit.
Qed.

Theorem pair_ap_0 : forall x y:set, (pair x y) 0 = x.
admit.
Qed.

Theorem pair_ap_1 : forall x y:set, (pair x y) 1 = y.
admit.
Qed.

Theorem ap0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 0) :e X.
admit.
Qed.

Theorem ap1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 1) :e (Y (z 0)).
admit.
Qed.

Definition pair_p:set->prop
:= fun u:set => pair (u 0) (u 1) = u.

Theorem pair_p_I : forall x y, pair_p (pair x y).
admit.
Qed.

Theorem Subq_2_UPair01 : 2 c= {0,1}.
admit.
Qed.

Theorem tuple_pair : forall x y:set, pair x y = (x,y).
admit.
Qed.

Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

Theorem PiI : forall X:set, forall Y:set->set, forall f:set,
    (forall u :e f, pair_p u /\ u 0 :e X) -> (forall x :e X, f x :e Y x) -> f :e Pi_ x :e X, Y x.
admit.
Qed.

Theorem lam_Pi : forall X:set, forall Y:set -> set, forall F:set -> set,
 (forall x :e X, F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X, Y x).
admit.
Qed.

Theorem ap_Pi : forall X:set, forall Y:set -> set, forall f:set, forall x:set, f :e (Pi_ x :e X, Y x) -> x :e X -> f x :e Y x.
admit.
Qed.

Definition setexp : set->set->set := fun X Y:set => Pi_ y :e Y, X.
(* Superscript :^: *)
Infix :^: 430 left := setexp.

Theorem pair_tuple_fun : pair = (fun x y => (x,y)).
admit.
Qed.

Section Tuples.
Variable x0 x1: set.

Theorem tuple_2_0_eq: (x0,x1) 0 = x0.
admit.
Qed.

Theorem tuple_2_1_eq: (x0,x1) 1 = x1.
admit.
Qed.

End Tuples.

Theorem ReplEq_setprod_ext : forall X Y, forall F G:set -> set -> set, (forall x :e X, forall y :e Y, F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.
admit.
Qed.

Theorem lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.
admit.
Qed.

Theorem tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.
admit.
Qed.

End pair_setsum.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.
(* Superscript :^: *)
Infix :^: 430 left := setexp.
(* Parameter DescrR_i_io_1 "1f005fdad5c6f98763a15a5e5539088f5d43b7d1be866b0b204fda1ce9ed9248" "1d3fd4a14ef05bd43f5c147d7966cf05fd2fed808eea94f56380454b9a6044b2" *)
Definition DescrR_i_io_1 : (set->(set->prop)->prop) -> set := fun R => Eps_i (fun x => (exists y:set -> prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)).
(* Parameter DescrR_i_io_2 "28d8599686476258c12dcc5fc5f5974335febd7d5259e1a8e5918b7f9b91ca03" "768eb2ad186988375e6055394e36e90c81323954b8a44eb08816fb7a84db2272" *)
Definition DescrR_i_io_2 : (set->(set->prop)->prop) -> set->prop := fun R => Descr_Vo1 (fun y => R (DescrR_i_io_1 R) y).

Theorem DescrR_i_io_12 : forall R:set->(set->prop)->prop, (exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) -> R (DescrR_i_io_1 R) (DescrR_i_io_2 R).
admit.
Qed.

(** Conway describes this way of formalizing in ZF in an appendix to Part Zero of his book,
    but rejects formalization in favor of "Mathematician's Liberation."
 **)
Definition PNoEq_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => forall beta :e alpha, p beta <-> q beta.

Theorem PNoEq_ref_ : forall alpha, forall p:set -> prop, PNoEq_ alpha p p.
admit.
Qed.

Theorem PNoEq_sym_ : forall alpha, forall p q:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q p.
admit.
Qed.

Theorem PNoEq_tra_ : forall alpha, forall p q r:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q r -> PNoEq_ alpha p r.
admit.
Qed.

Theorem PNoEq_antimon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoEq_ alpha p q -> PNoEq_ beta p q.
admit.
Qed.

Definition PNoLt_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.

Theorem PNoLt_E_ : forall alpha, forall p q:set -> prop, PNoLt_ alpha p q ->
  forall R:prop, (forall beta, beta :e alpha -> PNoEq_ beta p q -> ~p beta -> q beta -> R) -> R.
admit.
Qed.

Theorem PNoLt_irref_ : forall alpha, forall p:set -> prop, ~PNoLt_ alpha p p.
admit.
Qed.

Theorem PNoLt_mon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoLt_ beta p q -> PNoLt_ alpha p q.
admit.
Qed.

Theorem PNoLt_trichotomy_or_ : forall p q:set -> prop, forall alpha, ordinal alpha
  -> PNoLt_ alpha p q \/ PNoEq_ alpha p q \/ PNoLt_ alpha q p.
admit.
Qed.

(* Parameter PNoLt "2336eb45d48549dd8a6a128edc17a8761fd9043c180691483bcf16e1acc9f00a" "8f57a05ce4764eff8bc94b278352b6755f1a46566cd7220a5488a4a595a47189" *)
Definition PNoLt : set -> (set -> prop) -> set -> (set -> prop) -> prop
 := fun alpha p beta q =>
        PNoLt_ (alpha :/\: beta) p q
     \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
     \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.

Theorem PNoLtI1 : forall alpha beta, forall p q:set -> prop,
  PNoLt_ (alpha :/\: beta) p q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI2 : forall alpha beta, forall p q:set -> prop,
  alpha :e beta -> PNoEq_ alpha p q -> q alpha -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI3 : forall alpha beta, forall p q:set -> prop,
  beta :e alpha -> PNoEq_ beta p q -> ~p beta -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtE : forall alpha beta, forall p q:set -> prop,
  PNoLt alpha p beta q ->
  forall R:prop,
      (PNoLt_ (alpha :/\: beta) p q -> R)
   -> (alpha :e beta -> PNoEq_ alpha p q -> q alpha -> R)
   -> (beta :e alpha -> PNoEq_ beta p q -> ~p beta -> R)
   -> R.
admit.
Qed.

Theorem PNoLt_irref : forall alpha, forall p:set -> prop, ~PNoLt alpha p alpha p.
admit.
Qed.

Theorem PNoLt_trichotomy_or : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q \/ PNoLt beta q alpha p.
admit.
Qed.

Theorem PNoLtEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoEq_ beta q r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoEqLt_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLt alpha q beta r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Definition PNoLe : set -> (set -> prop) -> set -> (set -> prop) -> prop
   := fun alpha p beta q => PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.

Theorem PNoLeI1 : forall alpha beta, forall p q:set -> prop,
   PNoLt alpha p beta q -> PNoLe alpha p beta q.
admit.
Qed.

Theorem PNoLeI2 : forall alpha, forall p q:set -> prop,
   PNoEq_ alpha p q -> PNoLe alpha p alpha q.
admit.
Qed.

Theorem PNoLe_ref : forall alpha, forall p:set -> prop, PNoLe alpha p alpha p.
admit.
Qed.

Theorem PNoLe_antisym : forall alpha beta, ordinal alpha -> ordinal beta ->
 forall p q:set -> prop,
 PNoLe alpha p beta q -> PNoLe beta q alpha p -> alpha = beta /\ PNoEq_ alpha p q.
admit.
Qed.

Theorem PNoLtLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLe beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoLeLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoEqLe_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLe alpha q beta r -> PNoLe alpha p beta r.
admit.
Qed.

Theorem PNoLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLe beta q gamma r -> PNoLe alpha p gamma r.
admit.
Qed.

Definition PNo_downc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun L alpha p => exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.
Definition PNo_upc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun R alpha p => exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.

Theorem PNoLe_downc : forall L:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_downc L alpha p -> PNoLe beta q alpha p -> PNo_downc L beta q.
admit.
Qed.

Theorem PNo_downc_ref : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, L alpha p -> PNo_downc L alpha p.
admit.
Qed.

Theorem PNo_upc_ref : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, R alpha p -> PNo_upc R alpha p.
admit.
Qed.

Theorem PNoLe_upc : forall R:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_upc R alpha p -> PNoLe alpha p beta q -> PNo_upc R beta q.
admit.
Qed.

Definition PNoLt_pwise : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> prop
  := fun L R => forall gamma, ordinal gamma -> forall p:set -> prop, L gamma p -> forall delta, ordinal delta -> forall q:set -> prop, R delta q -> PNoLt gamma p delta q.

Theorem PNoLt_pwise_downc_upc : forall L R:set -> (set -> prop) -> prop,
    PNoLt_pwise L R -> PNoLt_pwise (PNo_downc L) (PNo_upc R).
admit.
Qed.

Definition PNo_rel_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_downc L beta q -> PNoLt beta q alpha p.
Definition PNo_rel_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_upc R beta q -> PNoLt alpha p beta q.
Definition PNo_rel_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_upperbd L alpha p /\ PNo_rel_strict_lowerbd R alpha p.

Theorem PNoEq_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNo_rel_strict_upperbd_antimon : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_lowerbd_antimon : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_imv_antimon : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Definition PNo_rel_strict_uniq_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_imv L R alpha p /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.
Definition PNo_rel_strict_split_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p =>
         PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha)
      /\ PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Theorem PNo_extend0_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_extend1_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_rel_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha ->
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
admit.
Qed.

Definition PNo_lenbdd : set -> (set -> (set -> prop) -> prop) -> prop
  := fun alpha L => forall beta, forall p:set -> prop, L beta p -> beta :e alpha.

Theorem PNo_lenbdd_strict_imv_extend0 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_extend1 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_split : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_split_imv L R alpha p.
admit.
Qed.

Theorem PNo_rel_imv_bdd_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_rel_strict_split_imv L R beta p.
admit.
Qed.

Definition PNo_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, L beta q -> PNoLt beta q alpha p.
Definition PNo_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, R beta q -> PNoLt alpha p beta q.
Definition PNo_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.

Theorem PNoEq_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_upperbd L alpha p -> PNo_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNoEq_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_lowerbd R alpha p -> PNo_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNoEq_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_imv L R alpha p -> PNo_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_strict_upperbd_imp_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNo_strict_lowerbd_imp_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNo_strict_imv_imp_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Theorem PNo_rel_split_imv_imp_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> forall p:set -> prop,
       PNo_rel_strict_split_imv L R alpha p
    -> PNo_strict_imv L R alpha p.
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_strict_imv L R beta p.
admit.
Qed.

Definition PNo_least_rep : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => ordinal beta
       /\ PNo_strict_imv L R beta p
       /\ forall gamma :e beta,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.
Definition PNo_least_rep2 : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => PNo_least_rep L R beta p /\ forall x, x /:e beta -> ~p x.

Theorem PNo_strict_imv_pred_eq : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha -> forall p q:set -> prop,
     PNo_least_rep L R alpha p
  -> PNo_strict_imv L R alpha q
  -> forall beta :e alpha, p beta <-> q beta.
admit.
Qed.

Theorem PNo_lenbdd_least_rep2_exuniq2 : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta,
        (exists p:set -> prop, PNo_least_rep2 L R beta p)
     /\ (forall p q:set -> prop, PNo_least_rep2 L R beta p -> PNo_least_rep2 L R beta q -> p = q).
admit.
Qed.

(* Parameter PNo_bd "1b39e85278dd9e820e7b6258957386ac55934d784aa3702c57a28ec807453b01" "ed76e76de9b58e621daa601cca73b4159a437ba0e73114924cb92ec8044f2aa2" *)
Definition PNo_bd : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set
 := fun L R => DescrR_i_io_1 (PNo_least_rep2 L R).
(* Parameter PNo_pred "be07c39b18a3aa93f066f4c064fee3941ec27cfd07a4728b6209135c77ce5704" "b2d51dcfccb9527e9551b0d0c47d891c9031a1d4ee87bba5a9ae5215025d107a" *)
Definition PNo_pred : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> prop
 := fun L R => DescrR_i_io_2 (PNo_least_rep2 L R).

Theorem PNo_bd_pred_lem : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep2 L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_pred : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_In : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_bd L R :e ordsucc alpha.
admit.
Qed.

Opaque Sigma Pi ap PNo_pred PNo_bd PNoLt DescrR_i_io_1 DescrR_i_io_2.

Section TaggedSets.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem not_TransSet_Sing1 : ~TransSet {1}.
admit.
Qed.

Theorem not_ordinal_Sing1 : ~ordinal {1}.
admit.
Qed.

Theorem tagged_not_ordinal : forall y, ~ordinal (y ').
admit.
Qed.

Theorem tagged_notin_ordinal : forall alpha y, ordinal alpha -> (y ') /:e alpha.
admit.
Qed.

Theorem tagged_eqE_Subq : forall alpha beta, ordinal alpha -> alpha ' = beta ' -> alpha c= beta.
admit.
Qed.

Theorem tagged_eqE_eq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha ' = beta ' -> alpha = beta.
admit.
Qed.

Theorem tagged_ReplE : forall alpha beta, ordinal alpha -> ordinal beta -> beta ' :e {gamma '|gamma :e alpha} -> beta :e alpha.
admit.
Qed.

Theorem ordinal_notin_tagged_Repl : forall alpha Y, ordinal alpha -> alpha /:e {y '|y :e Y}.
admit.
Qed.

Definition SNoElts_ : set -> set := fun alpha => alpha :\/: {beta '|beta :e alpha}.

Theorem SNoElts_mon : forall alpha beta, alpha c= beta -> SNoElts_ alpha c= SNoElts_ beta.
admit.
Qed.

Definition SNo_ : set -> set -> prop := fun alpha x =>
    x c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).
Definition PSNo : set -> (set -> prop) -> set :=
  fun alpha p => {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.

Theorem PNoEq_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha (fun beta => beta :e PSNo alpha p) p.
admit.
Qed.

Theorem SNo_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNo_ alpha (PSNo alpha p).
admit.
Qed.

Theorem SNo_PSNo_eta_ : forall alpha x, ordinal alpha -> SNo_ alpha x -> x = PSNo alpha (fun beta => beta :e x).
admit.
Qed.

(* Parameter SNo "87d7604c7ea9a2ae0537066afb358a94e6ac0cd80ba277e6b064422035a620cf" "11faa7a742daf8e4f9aaf08e90b175467e22d0e6ad3ed089af1be90cfc17314b" *)
Definition SNo : set -> prop := fun x => exists alpha, ordinal alpha /\ SNo_ alpha x.

Theorem SNo_SNo : forall alpha, ordinal alpha -> forall z, SNo_ alpha z -> SNo z.
admit.
Qed.

(* Parameter SNoLev "bf1decfd8f4025a2271f2a64d1290eae65933d0f2f0f04b89520449195f1aeb8" "293b77d05dab711767d698fb4484aab2a884304256765be0733e6bd5348119e8" *)
Definition SNoLev : set -> set := fun x => Eps_i (fun alpha => ordinal alpha /\ SNo_ alpha x).

Theorem SNoLev_uniq_Subq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha c= beta.
admit.
Qed.

Theorem SNoLev_uniq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha = beta.
admit.
Qed.

Theorem SNoLev_prop : forall x, SNo x -> ordinal (SNoLev x) /\ SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNoLev_ordinal : forall x, SNo x -> ordinal (SNoLev x).
admit.
Qed.

Theorem SNoLev_ : forall x, SNo x -> SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNo_PSNo_eta : forall x, SNo x -> x = PSNo (SNoLev x) (fun beta => beta :e x).
admit.
Qed.

Theorem SNoLev_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNoLev (PSNo alpha p) = alpha.
admit.
Qed.

Theorem SNo_Subq : forall x y, SNo x -> SNo y -> SNoLev x c= SNoLev y -> (forall alpha :e SNoLev x, alpha :e x <-> alpha :e y) -> x c= y.
admit.
Qed.

Definition SNoEq_ : set -> set -> set -> prop
 := fun alpha x y => PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).

Theorem SNoEq_I : forall alpha x y, (forall beta :e alpha, beta :e x <-> beta :e y) -> SNoEq_ alpha x y.
admit.
Qed.

Theorem SNo_eq : forall x y, SNo x -> SNo y -> SNoLev x = SNoLev y -> SNoEq_ (SNoLev x) x y -> x = y.
admit.
Qed.

End TaggedSets.
Definition SNoLt : set -> set -> prop :=
  fun x y => PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
Infix < 490 := SNoLt.
Definition SNoLe : set -> set -> prop :=
  fun x y => PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoLtLe : forall x y, x < y -> x <= y.
admit.
Qed.

Theorem SNoLeE : forall x y, SNo x -> SNo y -> x <= y -> x < y \/ x = y.
admit.
Qed.

Theorem SNoEq_sym_ : forall alpha x y, SNoEq_ alpha x y -> SNoEq_ alpha y x.
admit.
Qed.

Theorem SNoEq_tra_ : forall alpha x y z, SNoEq_ alpha x y -> SNoEq_ alpha y z -> SNoEq_ alpha x z.
admit.
Qed.

Theorem SNoLtE : forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z, SNo z -> SNoLev z :e SNoLev x :/\: SNoLev y -> SNoEq_ (SNoLev z) z x -> SNoEq_ (SNoLev z) z y -> x < z -> z < y -> SNoLev z /:e x -> SNoLev z :e y -> p)
 -> (SNoLev x :e SNoLev y -> SNoEq_ (SNoLev x) x y -> SNoLev x :e y -> p)
 -> (SNoLev y :e SNoLev x -> SNoEq_ (SNoLev y) x y -> SNoLev y /:e x -> p)
 -> p.
admit.
Qed.

(** The analogous thm to PNoLtI1 can be recovered by SNoLt_tra (transitivity) and SNoLtI2 and SNoLtI3. **)
Theorem SNoLtI2 : forall x y,
     SNoLev x :e SNoLev y
  -> SNoEq_ (SNoLev x) x y
  -> SNoLev x :e y
  -> x < y.
admit.
Qed.

Theorem SNoLtI3 : forall x y,
     SNoLev y :e SNoLev x
  -> SNoEq_ (SNoLev y) x y
  -> SNoLev y /:e x
  -> x < y.
admit.
Qed.

Theorem SNoLt_irref : forall x, ~SNoLt x x.
admit.
Qed.

Theorem SNoLt_trichotomy_or : forall x y, SNo x -> SNo y -> x < y \/ x = y \/ y < x.
admit.
Qed.

Theorem SNoLt_trichotomy_or_impred : forall x y, SNo x -> SNo y ->
  forall p:prop,
      (x < y -> p)
   -> (x = y -> p)
   -> (y < x -> p)
   -> p.
admit.
Qed.

Theorem SNoLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_ref : forall x, SNoLe x x.
admit.
Qed.

Theorem SNoLe_antisym : forall x y, SNo x -> SNo y -> x <= y -> y <= x -> x = y.
admit.
Qed.

Theorem SNoLtLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y <= z -> x < z.
admit.
Qed.

Theorem SNoLeLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y <= z -> x <= z.
admit.
Qed.

Theorem SNoLtLe_or : forall x y, SNo x -> SNo y -> x < y \/ y <= x.
admit.
Qed.

Theorem SNoLt_PSNo_PNoLt : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PSNo alpha p < PSNo beta q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLt_SNoLt_PSNo : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q -> PSNo alpha p < PSNo beta q.
admit.
Qed.

Definition SNoCut : set -> set -> set :=
  fun L R => PSNo (PNo_bd (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)) (PNo_pred (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)).
Definition SNoCutP : set -> set -> prop :=
 fun L R =>
      (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).

Theorem SNoCutP_SNoCut : forall L R, SNoCutP L R
 -> SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z).
admit.
Qed.

Theorem SNoCutP_SNoCut_impred : forall L R, SNoCutP L R
 -> forall p:prop,
      (SNo (SNoCut L R)
    -> SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
    -> (forall x :e L, x < SNoCut L R)
    -> (forall y :e R, SNoCut L R < y)
    -> (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z)
    -> p)
   -> p.
admit.
Qed.

Theorem SNoCutP_L_0: forall L, (forall x :e L, SNo x) -> SNoCutP L 0.
admit.
Qed.

Theorem SNoCutP_0_0: SNoCutP 0 0.
admit.
Qed.

Definition SNoS_ : set -> set := fun alpha => {x :e Power (SNoElts_ alpha)|exists beta :e alpha, SNo_ beta x}.

Theorem SNoS_E : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, exists beta :e alpha, SNo_ beta x.
admit.
Qed.

Section TaggedSets2.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem SNoS_I : forall alpha, ordinal alpha -> forall x, forall beta :e alpha, SNo_ beta x -> x :e SNoS_ alpha.
admit.
Qed.

Theorem SNoS_I2 : forall x y, SNo x -> SNo y -> SNoLev x :e SNoLev y -> x :e SNoS_ (SNoLev y).
admit.
Qed.  

Theorem SNoS_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> SNoS_ alpha c= SNoS_ beta.
admit.
Qed.

Theorem SNoLev_uniq2 : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNoLev x = alpha.
admit.
Qed.

Theorem SNoS_E2 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha,
 forall p:prop,
     (SNoLev x :e alpha -> ordinal (SNoLev x) -> SNo x -> SNo_ (SNoLev x) x -> p)
  -> p.
admit.
Qed.

Theorem SNoS_In_neq : forall w, SNo w -> forall x :e SNoS_ (SNoLev w), x <> w.
admit.
Qed.

Theorem SNoS_SNoLev : forall z, SNo z -> z :e SNoS_ (ordsucc (SNoLev z)).
admit.
Qed.

Definition SNoL : set -> set := fun z => {x :e SNoS_ (SNoLev z) | x < z}.
Definition SNoR : set -> set := fun z => {y :e SNoS_ (SNoLev z) | z < y}.

Theorem SNoCutP_SNoL_SNoR: forall z, SNo z -> SNoCutP (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoL_E : forall x, SNo x -> forall w :e SNoL x,
  forall p:prop,
       (SNo w -> SNoLev w :e SNoLev x -> w < x -> p)
    -> p.
admit.
Qed.

Theorem SNoR_E : forall x, SNo x -> forall z :e SNoR x,
  forall p:prop,
       (SNo z -> SNoLev z :e SNoLev x -> x < z -> p)
    -> p.
admit.
Qed.

Theorem SNoL_SNoS_ : forall z, SNoL z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoR_SNoS_ : forall z, SNoR z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoL_SNoS : forall x, SNo x -> forall w :e SNoL x, w :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoR_SNoS : forall x, SNo x -> forall z :e SNoR x, z :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoL_I : forall z, SNo z -> forall x, SNo x -> SNoLev x :e SNoLev z -> x < z -> x :e SNoL z.
admit.
Qed.

Theorem SNoR_I : forall z, SNo z -> forall y, SNo y -> SNoLev y :e SNoLev z -> z < y -> y :e SNoR z.
admit.
Qed.

Theorem SNo_eta : forall z, SNo z -> z = SNoCut (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoCutP_SNo_SNoCut : forall L R, SNoCutP L R -> SNo (SNoCut L R).
admit.
Qed.

Theorem SNoCutP_SNoCut_L : forall L R, SNoCutP L R -> forall x :e L, x < SNoCut L R.
admit.
Qed.

Theorem SNoCutP_SNoCut_R : forall L R, SNoCutP L R -> forall y :e R, SNoCut L R < y.
admit.
Qed.

Theorem SNoCutP_SNoCut_fst : forall L R, SNoCutP L R ->
 forall z, SNo z
   -> (forall x :e L, x < z)
   -> (forall y :e R, z < y)
   -> SNoLev (SNoCut L R) c= SNoLev z
   /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.
admit.
Qed.

Theorem SNoCut_Le : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 <= SNoCut L2 R2.
admit.
Qed.

Theorem SNoCut_ext : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R1, SNoCut L2 R2 < z)
  -> (forall w :e L2, w < SNoCut L1 R1)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 = SNoCut L2 R2.
admit.
Qed.

Theorem SNoLt_SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y ->
 forall p:prop,
    (x = y -> p)
 -> (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> (forall z :e SNoR y, z :e SNoL x -> p)
 -> (x :e SNoR y -> p)
 -> (y :e SNoL x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_SNoCutP_ex: forall L R, SNoCutP L R -> forall w :e SNoL (SNoCut L R), exists w' :e L, w <= w'.
admit.
Qed.

Theorem SNoR_SNoCutP_ex: forall L R, SNoCutP L R -> forall z :e SNoR (SNoCut L R), exists z' :e R, z' <= z.
admit.
Qed.

Theorem ordinal_SNo_ : forall alpha, ordinal alpha -> SNo_ alpha alpha.
admit.
Qed.

Theorem ordinal_SNo : forall alpha, ordinal alpha -> SNo alpha.
admit.
Qed.

Theorem ordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev alpha = alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> z < alpha.
admit.
Qed.

Theorem ordinal_SNoL : forall alpha, ordinal alpha -> SNoL alpha = SNoS_ alpha.
admit.
Qed.

Theorem ordinal_SNoR : forall alpha, ordinal alpha -> SNoR alpha = Empty.
admit.
Qed.

Theorem nat_p_SNo: forall n, nat_p n -> SNo n.
admit.
Qed.

Theorem omega_SNo: forall n :e omega, SNo n.
admit.
Qed.

Theorem omega_SNoS_omega : omega c= SNoS_ omega.
admit.
Qed.

Theorem ordinal_In_SNoLt : forall alpha, ordinal alpha -> forall beta :e alpha, beta < alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> z <= alpha.
admit.
Qed.

Theorem ordinal_Subq_SNoLe : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> alpha <= beta.
admit.
Qed.

Theorem ordinal_SNoLt_In : forall alpha beta, ordinal alpha -> ordinal beta -> alpha < beta -> alpha :e beta.
admit.
Qed.

Theorem omega_nonneg : forall m :e omega, 0 <= m.
admit.
Qed.

Theorem SNo_0 : SNo 0.
admit.
Qed.

Theorem SNo_1 : SNo 1.
admit.
Qed.

Theorem SNo_2 : SNo 2.
admit.
Qed.

Theorem SNoLev_0 : SNoLev 0 = 0.
admit.
Qed.

Theorem SNoCut_0_0: SNoCut 0 0 = 0.
admit.
Qed.

Theorem SNoL_0 : SNoL 0 = 0.
admit.
Qed.

Theorem SNoR_0 : SNoR 0 = 0.
admit.
Qed.

Theorem SNoL_1 : SNoL 1 = 1.
admit.
Qed.

Theorem SNoR_1 : SNoR 1 = 0.
admit.
Qed.

Theorem SNo_max_SNoLev : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> SNoLev x = x.
admit.
Qed.

Theorem SNo_max_ordinal : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> ordinal x.
admit.
Qed.

Theorem pos_low_eq_one : forall x, SNo x -> 0 < x -> SNoLev x c= 1 -> x = 1.
admit.
Qed.

Definition SNo_extend0 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x /\ delta <> SNoLev x).
Definition SNo_extend1 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x \/ delta = SNoLev x).

Theorem SNo_extend0_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNo : forall x, SNo x -> SNo (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo : forall x, SNo x -> SNo (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNoLev : forall x, SNo x -> SNoLev (SNo_extend0 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_SNoLev : forall x, SNo x -> SNoLev (SNo_extend1 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend0_nIn : forall x, SNo x -> SNoLev x /:e SNo_extend0 x.
admit.
Qed.

Theorem SNo_extend1_In : forall x, SNo x -> SNoLev x :e SNo_extend1 x.
admit.
Qed.

Theorem SNo_extend0_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend0 x) x.
admit.
Qed.

Theorem SNo_extend1_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend1 x) x.
admit.
Qed.

Theorem SNoLev_0_eq_0 : forall x, SNo x -> SNoLev x = 0 -> x = 0.
admit.
Qed.

(** eps_ n is the Surreal Number 1/2^n, without needing to define division or exponents first **)
Definition eps_ : set -> set := fun n => {0} :\/: {(ordsucc m) ' | m :e n}.

Theorem eps_ordinal_In_eq_0 : forall n alpha, ordinal alpha -> alpha :e eps_ n -> alpha = 0.
admit.
Qed.

Theorem eps_0_1 : eps_ 0 = 1.
admit.
Qed.

Theorem SNo__eps_ : forall n :e omega, SNo_ (ordsucc n) (eps_ n).
admit.
Qed.

Theorem SNo_eps_ : forall n :e omega, SNo (eps_ n).
admit.
Qed.

Theorem SNo_eps_1 : SNo (eps_ 1).
admit.
Qed.

Theorem SNoLev_eps_ : forall n :e omega, SNoLev (eps_ n) = ordsucc n.
admit.
Qed.

Theorem SNo_eps_SNoS_omega : forall n :e omega, eps_ n :e SNoS_ omega.
admit.
Qed.

Theorem SNo_eps_decr : forall n :e omega, forall m :e n, eps_ n < eps_ m.
admit.
Qed.

Theorem SNo_eps_pos : forall n :e omega, 0 < eps_ n.
admit.
Qed.

Theorem SNo_pos_eps_Lt : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> eps_ n < x.
admit.
Qed.

Theorem SNo_pos_eps_Le : forall n, nat_p n -> forall x :e SNoS_ (ordsucc (ordsucc n)), 0 < x -> eps_ n <= x.
admit.
Qed.

Theorem eps_SNo_eq : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> SNoEq_ (SNoLev x) (eps_ n) x -> exists m :e n, x = eps_ m.
admit.
Qed.

Theorem eps_SNoCutP : forall n :e omega, SNoCutP {0} {eps_ m|m :e n}.
admit.
Qed.

Theorem eps_SNoCut : forall n :e omega, eps_ n = SNoCut {0} {eps_ m|m :e n}.
admit.
Qed.

End TaggedSets2.

Theorem SNo_etaE : forall z, SNo z ->
  forall p:prop,
     (forall L R, SNoCutP L R
       -> (forall x :e L, SNoLev x :e SNoLev z)
       -> (forall y :e R, SNoLev y :e SNoLev z)
       -> z = SNoCut L R
       -> p)
   -> p.
admit.
Qed.

(*** surreal induction ***)
Theorem SNo_ind : forall P:set -> prop,
  (forall L R, SNoCutP L R
   -> (forall x :e L, P x)
   -> (forall y :e R, P y)
   -> P (SNoCut L R))
 -> forall z, SNo z -> P z.
admit.
Qed.

(*** surreal recursion ***)
Section SurrealRecI.
Variable F:set -> (set -> set) -> set.
Let default : set := Eps_i (fun _ => True).
Let G : set -> (set -> set -> set) -> set -> set
  := fun alpha g =>
       If_ii
          (ordinal alpha)
          (fun z:set => if z :e SNoS_ (ordsucc alpha) then
                           F z (fun w => g (SNoLev w) w)
                        else
                           default)
          (fun z:set => default).
(* Parameter SNo_rec_i "352082c509ab97c1757375f37a2ac62ed806c7b39944c98161720a584364bfaf" "be45dfaed6c479503a967f3834400c4fd18a8a567c8887787251ed89579f7be3" *)
Definition SNo_rec_i : set -> set
 := fun z => In_rec_ii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> set, (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_i_eq : forall z, SNo z -> SNo_rec_i z = F z SNo_rec_i.
admit.
Qed.

End SurrealRecI.
Section SurrealRecII.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Let default : (set -> set) := Descr_ii (fun _ => True).
Let G : set -> (set -> set -> (set -> set)) -> set -> (set -> set)
  := fun alpha g =>
       If_iii
          (ordinal alpha)
          (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha))
                              (F z (fun w => g (SNoLev w) w))
                              default)
          (fun z:set => default).
(* Parameter SNo_rec_ii "030b1b3db48f720b8db18b1192717cad8f204fff5fff81201b9a2414f5036417" "e148e62186e718374accb69cda703e3440725cca8832aed55c0b32731f7401ab" *)
Definition SNo_rec_ii : set -> (set -> set)
 := fun z => In_rec_iii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> (set -> set), (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_ii_eq : forall z, SNo z -> SNo_rec_ii z = F z SNo_rec_ii.
admit.
Qed.

End SurrealRecII.
Section SurrealRec2.
Variable F:set -> set -> (set -> set -> set) -> set.
Let G:set -> (set -> set -> set) -> set -> (set -> set) -> set
  := fun w f z g => F w z (fun x y => if x = w then g y else f x y).
Let H:set -> (set -> set -> set) -> set -> set
  := fun w f z => if SNo z then SNo_rec_i (G w f) z else Empty.
(* Parameter SNo_rec2 "9c6267051fa817eed39b404ea37e7913b3571fe071763da2ebc1baa56b4b77f5" "7d10ab58310ebefb7f8bf63883310aa10fc2535f53bb48db513a868bc02ec028" *)
Definition SNo_rec2 : set -> set -> set
  := SNo_rec_ii H.
Hypothesis Fr: forall w, SNo w -> forall z, SNo z ->
   forall g h:set -> set -> set,
        (forall x :e SNoS_ (SNoLev w), forall y, SNo y -> g x y = h x y)
     -> (forall y :e SNoS_ (SNoLev z), g w y = h w y)
     -> F w z g = F w z h.

Theorem SNo_rec2_G_prop : forall w, SNo w -> forall f k:set -> set -> set,
    (forall x :e SNoS_ (SNoLev w), f x = k x)
 -> forall z, SNo z ->
    forall g h:set -> set, (forall u :e SNoS_ (SNoLev z), g u = h u)
 -> G w f z g = G w k z h.
admit.
Qed.

Theorem SNo_rec2_eq_1 : forall w, SNo w -> forall f:set -> set -> set,
  forall z, SNo z ->
   SNo_rec_i (G w f) z = G w f z (SNo_rec_i (G w f)).
admit.
Qed.

Theorem SNo_rec2_eq : forall w, SNo w -> forall z, SNo z ->
   SNo_rec2 w z = F w z SNo_rec2.
admit.
Qed.

End SurrealRec2.

Theorem SNo_ordinal_ind : forall P:set -> prop,
  (forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNo_ordinal_ind2 : forall P:set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y)
  ->
  (forall x y, SNo x -> SNo y -> P x y).
admit.
Qed.

Theorem SNo_ordinal_ind3 : forall P:set -> set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall gamma, ordinal gamma ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z)
  ->
  (forall x y z, SNo x -> SNo y -> SNo z -> P x y z).
admit.
Qed.

Theorem SNoLev_ind : forall P:set -> prop,
  (forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNoLev_ind2 : forall P:set -> set -> prop,
  (forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y)
-> forall x y, SNo x -> SNo y -> P x y.
admit.
Qed.

Theorem SNoLev_ind3 : forall P:set -> set -> set -> prop,
  (forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z)
 -> forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
admit.
Qed.

Theorem SNo_omega : SNo omega.
admit.
Qed.

Theorem SNoLt_0_1 : 0 < 1.
admit.
Qed.

Theorem SNoLt_0_2 : 0 < 2.
admit.
Qed.

Theorem SNoLt_1_2 : 1 < 2.
admit.
Qed.

Theorem restr_SNo_ : forall x, SNo x -> forall alpha :e SNoLev x, SNo_ alpha (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNo : forall x, SNo x -> forall alpha :e SNoLev x, SNo (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNoLev : forall x, SNo x -> forall alpha :e SNoLev x, SNoLev (x :/\: SNoElts_ alpha) = alpha.
admit.
Qed.

Theorem restr_SNoEq : forall x, SNo x -> forall alpha :e SNoLev x, SNoEq_ alpha (x :/\: SNoElts_ alpha) x.
admit.
Qed.

Theorem SNo_extend0_restr_eq : forall x, SNo x -> x = SNo_extend0 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_restr_eq : forall x, SNo x -> x = SNo_extend1 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Opaque eps_ SNo_rec2 SNo_rec_ii SNo_rec_i SNoLev SNo.

Section SurrealMinus.
(* Parameter minus_SNo "6d39c64862ac40c95c6f5e4ed5f02bb019279bfb0cda8c9bbe0e1b813b1e876c" "268a6c1da15b8fe97d37be85147bc7767b27098cdae193faac127195e8824808" *)
Definition minus_SNo : set -> set
  := SNo_rec_i (fun x m => SNoCut {m z|z :e SNoR x} {m w|w :e SNoL x}).
Prefix - 358 := minus_SNo.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem minus_SNo_eq : forall x, SNo x -> - x = SNoCut {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_prop1 : forall x, SNo x -> SNo (- x) /\ (forall u :e SNoL x, - x < - u) /\ (forall u :e SNoR x, - u < - x) /\ SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem SNo_minus_SNo : forall x, SNo x -> SNo (- x).
admit.
Qed.

Theorem minus_SNo_Lt_contra : forall x y, SNo x -> SNo y -> x < y -> - y < - x.
admit.
Qed.

Theorem minus_SNo_Le_contra : forall x y, SNo x -> SNo y -> x <= y -> - y <= - x.
admit.
Qed.

Theorem minus_SNo_SNoCutP : forall x, SNo x -> SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_SNoCutP_gen : forall L R, SNoCutP L R -> SNoCutP {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lev_lem1 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_Lev_lem2 : forall x, SNo x -> SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_invol : forall x, SNo x -> - - x = x.
admit.
Qed.

Theorem minus_SNo_Lev : forall x, SNo x -> SNoLev (- x) = SNoLev x.
admit.
Qed.

Theorem minus_SNo_SNo_ : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNo_ alpha (- x).
admit.
Qed.

Theorem minus_SNo_SNoS_ : forall alpha, ordinal alpha -> forall x, x :e SNoS_ alpha -> - x :e SNoS_ alpha.
admit.
Qed.

Theorem minus_SNoCut_eq_lem : forall v, SNo v -> forall L R, SNoCutP L R -> v = SNoCut L R -> - v = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNoCut_eq : forall L R, SNoCutP L R -> - SNoCut L R = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lt_contra1 : forall x y, SNo x -> SNo y -> -x < y -> - y < x.
admit.
Qed.

Theorem minus_SNo_Lt_contra2 : forall x y, SNo x -> SNo y -> x < -y -> y < - x.
admit.
Qed.

Theorem mordinal_SNoLev_min_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> - alpha <= z.
admit.
Qed.

Theorem minus_SNo_SNoS_omega : forall x :e SNoS_ omega, - x :e SNoS_ omega.
admit.
Qed.

Theorem SNoL_minus_SNoR: forall x, SNo x -> SNoL (- x) = {- w|w :e SNoR x}.
admit.
Qed.

End SurrealMinus.
Opaque minus_SNo.
Section SurrealAdd.
Prefix - 358 := minus_SNo.
(* Parameter add_SNo "29b9b279a7a5b776b777d842e678a4acaf3b85b17a0223605e4cc68025e9b2a7" "127d043261bd13d57aaeb99e7d2c02cae2bd0698c0d689b03e69f1ac89b3c2c6" *)
Definition add_SNo : set -> set -> set
  := SNo_rec2 (fun x y a => SNoCut ({a w y|w :e SNoL x} :\/: {a x w|w :e SNoL y}) ({a z y|z :e SNoR x} :\/: {a x z|z :e SNoR y})).
Infix + 360 right := add_SNo.

Theorem add_SNo_eq : forall x, SNo x -> forall y, SNo y ->
    x + y = SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_prop1 : forall x y, SNo x -> SNo y ->
    SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem SNo_add_SNo : forall x y, SNo x -> SNo y -> SNo (x + y).
admit.
Qed.

Theorem SNo_add_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + z).
admit.
Qed.

Theorem SNo_add_SNo_3c : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + - z).
admit.
Qed.

Theorem SNo_add_SNo_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> SNo (x + y + z + w).
admit.
Qed.

Theorem add_SNo_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x < z -> x + y < z + y.
admit.
Qed.

Theorem add_SNo_Le1 : forall x y z, SNo x -> SNo y -> SNo z -> x <= z -> x + y <= z + y.
admit.
Qed.

Theorem add_SNo_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> y < z -> x + y < x + z.
admit.
Qed.

Theorem add_SNo_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> y <= z -> x + y <= x + z.
admit.
Qed.

Theorem add_SNo_Lt3a : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y <= w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3b : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Le3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y <= w -> x + y <= z + w.
admit.
Qed.

Theorem add_SNo_SNoCutP : forall x y, SNo x -> SNo y -> SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_com : forall x y, SNo x -> SNo y -> x + y = y + x.
admit.
Qed.

Theorem add_SNo_0L : forall x, SNo x -> 0 + x = x.
admit.
Qed.

Theorem add_SNo_0R : forall x, SNo x -> x + 0 = x.
admit.
Qed.

Theorem add_SNo_minus_SNo_linv : forall x, SNo x -> -x+x = 0.
admit.
Qed.

Theorem add_SNo_minus_SNo_rinv : forall x, SNo x -> x + -x = 0.
admit.
Qed.

Theorem add_SNo_ordinal_SNoCutP : forall alpha, ordinal alpha -> forall beta, ordinal beta -> SNoCutP ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_eq : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + beta = SNoCut ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_ordinal : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordinal (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordsucc alpha + beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + ordsucc beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_InL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e alpha, gamma + beta :e alpha + beta.
admit.
Qed.

Theorem add_SNo_ordinal_InR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e beta, alpha + gamma :e alpha + beta.
admit.
Qed.

Theorem add_nat_add_SNo : forall n m :e omega, add_nat n m = n + m.
admit.
Qed.

Theorem add_SNo_In_omega : forall n m :e omega, n + m :e omega.
admit.
Qed.

Theorem add_SNo_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x + y), (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).
admit.
Qed.

Theorem add_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x + y), (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).
admit.
Qed.

Theorem add_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z -> x + (y + z) = (x + y) + z.
admit.
Qed.

Theorem add_SNo_minus_R2 : forall x y, SNo x -> SNo y -> (x + y) + - y = x.
admit.
Qed.

Theorem add_SNo_minus_R2' : forall x y, SNo x -> SNo y -> (x + - y) + y = x.
admit.
Qed.

Theorem add_SNo_minus_L2 : forall x y, SNo x -> SNo y -> - x + (x + y) = y.
admit.
Qed.

Theorem add_SNo_minus_L2' : forall x y, SNo x -> SNo y -> x + (- x + y) = y.
admit.
Qed.

Theorem add_SNo_cancel_L : forall x y z, SNo x -> SNo y -> SNo z -> x + y = x + z -> y = z.
admit.
Qed.

Theorem add_SNo_cancel_R : forall x y z, SNo x -> SNo y -> SNo z -> x + y = z + y -> x = z.
admit.
Qed.

Theorem minus_SNo_0 : - 0 = 0.
admit.
Qed.

Theorem minus_add_SNo_distr : forall x y, SNo x -> SNo y -> -(x+y) = (-x) + (-y).
admit.
Qed.

Theorem minus_add_SNo_distr_3 : forall x y z, SNo x -> SNo y -> SNo z -> -(x + y + z) = -x + - y + -z.
admit.
Qed.

Theorem add_SNo_Lev_bd : forall x y, SNo x -> SNo y -> SNoLev (x + y) c= SNoLev x + SNoLev y.
admit.
Qed.

Theorem add_SNo_SNoS_omega : forall x y :e SNoS_ omega, x + y :e SNoS_ omega.
admit.
Qed.

Theorem add_SNo_Lt1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < z + y -> x < z.
admit.
Qed.

Theorem add_SNo_Lt2_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < x + z -> y < z.
admit.
Qed.

Theorem add_SNo_Le1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y <= z + y -> x <= z.
admit.
Qed.

Theorem add_SNo_assoc_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> x + y + z + w = (x + y + z) + w.
admit.
Qed.

Theorem add_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x + y + z = y + x + z.
admit.
Qed.

Theorem add_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) + z = (x + z) + y.
admit.
Qed.

Theorem add_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x + y) + (z + w) = (x + z) + (y + w).
admit.
Qed.

Theorem add_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x + y + z = z + x + y.
admit.
Qed.

Theorem add_SNo_rotate_4_1 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w ->
  x + y + z + w = w + x + y + z.
admit.
Qed.

Theorem add_SNo_rotate_5_1 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = v + x + y + z + w.
admit.
Qed.

Theorem add_SNo_rotate_5_2 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = w + v + x + y + z.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop2 : forall x y, SNo x -> SNo y -> x + - x + y = y.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + z) + (- z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop5 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + - z) + (z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x + - y < z -> x < z + y.
admit.
Qed.

Theorem add_SNo_minus_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> z < x + - y -> z + y < x.
admit.
Qed.

Theorem add_SNo_minus_Lt1b : forall x y z, SNo x -> SNo y -> SNo z -> x < z + y -> x + - y < z.
admit.
Qed.

Theorem add_SNo_minus_Lt2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y < x -> z < x + - y.
admit.
Qed.

Theorem add_SNo_minus_Lt1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y < w + z -> x + y + - z < w.
admit.
Qed.

Theorem add_SNo_minus_Lt2b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> w + z < x + y -> w < x + y + - z.
admit.
Qed.

Theorem add_SNo_minus_Lt_lem : forall x y z u v w, SNo x -> SNo y -> SNo z -> SNo u -> SNo v -> SNo w ->
  x + y + w < u + v + z ->
  x + y + - z < u + v + - w.
admit.
Qed.

Theorem add_SNo_minus_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> z <= x + - y -> z + y <= x.
admit.
Qed.

Theorem add_SNo_minus_Le2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y <= x -> z <= x + - y.
admit.
Qed.

Theorem add_SNo_Lt_subprop2 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
  -> x + u < z + v
  -> y + v < w + u
  -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt_subprop3a : forall x y z w u a, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a
  -> x + z < w + a
  -> y + a < u
  -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3b : forall x y w u v a, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a
  -> x + a < w + v
  -> y < a + u
  -> x + y < w + u + v.
admit.
Qed.

Theorem add_SNo_Lt_subprop3c : forall x y z w u a b c, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a -> SNo b -> SNo c
 -> x + a < b + c
 -> y + c < u
 -> b + z < w + a
 -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3d : forall x y w u v a b c, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a -> SNo b -> SNo c
 -> x + a < b + v
 -> y < c + u
 -> b + c < w + a
 -> x + y < w + u + v.
admit.
Qed.

Theorem ordinal_ordsucc_SNo_eq : forall alpha, ordinal alpha -> ordsucc alpha = 1 + alpha.
admit.
Qed.

Theorem add_SNo_3a_2b: forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u
 -> (x + y + z) + (w + u) = (u + y + z) + (w + x).
admit.
Qed.

Theorem add_SNo_1_ordsucc : forall n :e omega, n + 1 = ordsucc n.
admit.
Qed.

Theorem add_SNo_eps_Lt : forall x, SNo x -> forall n :e omega, x < x + eps_ n.
admit.
Qed.

Theorem add_SNo_eps_Lt' : forall x y, SNo x -> SNo y -> forall n :e omega, x < y -> x < y + eps_ n.
admit.
Qed.

Theorem SNoLt_minus_pos : forall x y, SNo x -> SNo y -> x < y -> 0 < y + - x.
admit.
Qed.

Theorem add_SNo_omega_In_cases: forall m, forall n :e omega, forall k, nat_p k -> m :e n + k -> m :e n \/ m + - n :e k.
admit.
Qed.

Theorem add_SNo_Lt4 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v -> x < w -> y < u -> z < v -> x + y + z < w + u + v.
admit.
Qed.

Theorem add_SNo_3_3_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  x + y < z + w -> x + y + u < z + w + u.
admit.
Qed.

Theorem add_SNo_3_2_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  y + x < z + w -> x + u + y < z + w + u.
admit.
Qed.

Theorem add_SNo_minus_Lt12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v < w + u + z
 -> x + y + - z < w + u + - v.
admit.
Qed.

Theorem add_SNo_minus_Le1b : forall x y z, SNo x -> SNo y -> SNo z -> x <= z + y -> x + - y <= z.
admit.
Qed.

Theorem add_SNo_minus_Le1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y <= w + z -> x + y + - z <= w.
admit.
Qed.

Theorem add_SNo_minus_Le12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v <= w + u + z
 -> x + y + - z <= w + u + - v.
admit.
Qed.

End SurrealAdd.

Opaque add_SNo.

Section SurrealAbs.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
(* Parameter abs_SNo "9f9389c36823b2e0124a7fe367eb786d080772b5171a5d059b10c47361cef0ef" "34f6dccfd6f62ca020248cdfbd473fcb15d8d9c5c55d1ec7c5ab6284006ff40f" *)
Definition abs_SNo : set -> set := fun x => if 0 <= x then x else - x.

Theorem nonneg_abs_SNo : forall x, 0 <= x -> abs_SNo x = x.
admit.
Qed.

Theorem not_nonneg_abs_SNo : forall x, ~(0 <= x) -> abs_SNo x = - x.
admit.
Qed.

Theorem pos_abs_SNo : forall x, 0 < x -> abs_SNo x = x.
admit.
Qed.

Theorem neg_abs_SNo : forall x, SNo x -> x < 0 -> abs_SNo x = - x.
admit.
Qed.

Theorem SNo_abs_SNo : forall x, SNo x -> SNo (abs_SNo x).
admit.
Qed.

Theorem abs_SNo_minus: forall x, SNo x -> abs_SNo (- x) = abs_SNo x.
admit.
Qed.

Theorem abs_SNo_dist_swap: forall x y, SNo x -> SNo y -> abs_SNo (x + - y) = abs_SNo (y + - x).
admit.
Qed.

End SurrealAbs.

Opaque abs_SNo.

Section SurrealMul.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
(* Parameter mul_SNo "f56bf39b8eea93d7f63da529dedb477ae1ab1255c645c47d8915623f364f2d6b" "48d05483e628cb37379dd5d279684d471d85c642fe63533c3ad520b84b18df9d" *)
Definition mul_SNo : set -> set -> set
  := SNo_rec2
      (fun x y m =>
        SNoCut ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoL y})).

Infix * 355 right := mul_SNo.

Theorem mul_SNo_eq : forall x, SNo x -> forall y, SNo y ->
   x * y
      = SNoCut ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y})
               ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}).
admit.
Qed.

Theorem mul_SNo_eq_2 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R,
         (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_prop_1 : forall x, SNo x -> forall y, SNo y ->
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
admit.
Qed.

Theorem SNo_mul_SNo : forall x y, SNo x -> SNo y -> SNo (x * y).
admit.
Qed.

Theorem SNo_mul_SNo_lem : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v -> SNo (u * y + x * v + - (u * v)).
admit.
Qed.

Theorem SNo_mul_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x * y * z).
admit.
Qed.

Theorem mul_SNo_eq_3 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R, SNoCutP L R
       -> (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_Lt : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
admit.
Qed.

Theorem mul_SNo_Le : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 (exists v :e SNoL x, exists w :e SNoL y, u + v * w <= v * y + x * w)
 \/
 (exists v :e SNoR x, exists w :e SNoR y, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
admit.
Qed.  

Theorem mul_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 (exists v :e SNoL x, exists w :e SNoR y, v * y + x * w <= u + v * w)
 \/
 (exists v :e SNoR x, exists w :e SNoL y, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoR_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
admit.
Qed.

(** This could be useful for proving L c= L', L = L', R c= R' or R = R'
    when corresponding conditions hold. **)
Theorem mul_SNo_Subq_lem : forall x y X Y Z W,
  forall U U',
      (forall u, u :e U ->
         (forall q:prop,
                (forall w0 :e X, forall w1 :e Y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e Z, forall z1 :e W, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
   -> (forall w0 :e X, forall w1 :e Y, w0 * y + x * w1 + - w0 * w1 :e U')
   -> (forall w0 :e Z, forall w1 :e W, w0 * y + x * w1 + - w0 * w1 :e U')
   -> U c= U'.
admit.
Qed.

(** Part of Conway Chapter 2 Theorem 7 **)
Theorem mul_SNo_zeroR : forall x, SNo x -> x * 0 = 0.
admit.
Qed.

Theorem mul_SNo_oneR : forall x, SNo x -> x * 1 = x.
admit.
Qed.

Theorem mul_SNo_com : forall x y, SNo x -> SNo y -> x * y = y * x.
admit.
Qed.

Theorem mul_SNo_minus_distrL : forall x y, SNo x -> SNo y -> (- x) * y = - x * y.
admit.
Qed.

Theorem mul_SNo_minus_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

Theorem mul_SNo_distrR : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) * z = x * z + y * z.
admit.
Qed.

Theorem mul_SNo_distrL : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y + z) = x * y + x * z.
admit.
Qed.

Section mul_SNo_assoc_lems.
Variable M:set -> set -> set.
Infix * 355 right := M.
Hypothesis SNo_M : forall x y, SNo x -> SNo y -> SNo (x * y).
Hypothesis DL: forall x y z, SNo x -> SNo y -> SNo z -> x * (y + z) = x * y + x * z.
Hypothesis DR: forall x y z, SNo x -> SNo y -> SNo z -> (x + y) * z = x * z + y * z.
Hypothesis IL: forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
Hypothesis IR: forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
Hypothesis M_Lt: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
Hypothesis M_Le: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.

Theorem mul_SNo_assoc_lem1 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall L,
    (forall u :e L,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e L, u < (x * y) * z.
admit.
Qed.

Theorem mul_SNo_assoc_lem2 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall R,
    (forall u :e R,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e R, (x * y) * z < u.
admit.
Qed.

End mul_SNo_assoc_lems.

Theorem mul_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y * z) = (x * y) * z.
admit.
Qed.

Theorem mul_nat_mul_SNo : forall n m :e omega, mul_nat n m = n * m.
admit.
Qed.

Theorem mul_SNo_In_omega : forall n m :e omega, n * m :e omega.
admit.
Qed.

Theorem mul_SNo_zeroL : forall x, SNo x -> 0 * x = 0.
admit.
Qed.

Theorem mul_SNo_oneL : forall x, SNo x -> 1 * x = x.
admit.
Qed.

Theorem mul_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x * y * z = z * x * y.
admit.
Qed.

Theorem pos_mul_SNo_Lt : forall x y z, SNo x -> 0 < x -> SNo y -> SNo z -> y < z -> x * y < x * z.
admit.
Qed.

Theorem nonneg_mul_SNo_Le : forall x y z, SNo x -> 0 <= x -> SNo y -> SNo z -> y <= z -> x * y <= x * z.
admit.
Qed.

Theorem neg_mul_SNo_Lt : forall x y z, SNo x -> x < 0 -> SNo y -> SNo z -> z < y -> x * y < x * z.
admit.
Qed.

Theorem pos_mul_SNo_Lt' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < z -> x < y -> x * z < y * z.
admit.
Qed.

Theorem mul_SNo_Lt1_pos_Lt : forall x y, SNo x -> SNo y -> x < 1 -> 0 < y -> x * y < y.
admit.
Qed.

Theorem nonneg_mul_SNo_Le' : forall x y z, SNo x -> SNo y -> SNo z -> 0 <= z -> x <= y -> x * z <= y * z.
admit.
Qed.

Theorem mul_SNo_Le1_nonneg_Le : forall x y, SNo x -> SNo y -> x <= 1 -> 0 <= y -> x * y <= y.
admit.
Qed.

Theorem pos_mul_SNo_Lt2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 < x -> 0 < y -> x < z -> y < w -> x * y < z * w.
admit.
Qed.

Theorem nonneg_mul_SNo_Le2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 <= x -> 0 <= y -> x <= z -> y <= w -> x * y <= z * w.
admit.
Qed.

Theorem mul_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_pos_neg: forall x y, SNo x -> SNo y -> 0 < x -> y < 0 -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_neg: forall x y, SNo x -> SNo y -> x < 0 -> y < 0 -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_nonneg_nonneg: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> 0 <= x * y.
admit.
Qed.

Theorem mul_SNo_nonpos_pos: forall x y, SNo x -> SNo y -> x <= 0 -> 0 < y -> x * y <= 0.
admit.
Qed.

Theorem mul_SNo_nonpos_neg: forall x y, SNo x -> SNo y -> x <= 0 -> y < 0 -> 0 <= x * y.
admit.
Qed.

Theorem nonpos_mul_SNo_Le : forall x y z, SNo x -> x <= 0 -> SNo y -> SNo z -> z <= y -> x * y <= x * z.
admit.
Qed.

Theorem SNo_zero_or_sqr_pos : forall x, SNo x -> x = 0 \/ 0 < x * x.
admit.
Qed.

Theorem SNo_pos_sqr_uniq: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_nonneg_sqr_uniq: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_foil: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y) * (z + w) = x * z + x * w + y * z + y * w.
admit.
Qed.

Theorem mul_SNo_minus_minus: forall x y, SNo x -> SNo y -> (- x) * (- y) = x * y.
admit.
Qed.

Theorem mul_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x * y * z = y * x * z.
admit.
Qed.

Theorem mul_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x * y) * z = (x * z) * y.
admit.
Qed.

Theorem mul_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x * y) * (z * w) = (x * z) * (y * w).
admit.
Qed.

Theorem SNo_foil_mm: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + - y) * (z + - w) = x * z + - x * w + - y * z + y * w.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem mul_SNoCutP_lem : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> SNoCutP ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
            ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ x * y
  = SNoCut ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
           ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNoCut_abs : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
 (exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w)
 \/
 (exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ly, u + v * w <= v * y + x * w -> p)
     -> (forall v :e Rx, forall w :e Ry, u + v * w <= v * y + x * w -> p)
     -> p.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
 (exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w)
 \/
 (exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ry, v * y + x * w <= u + v * w -> p)
     -> (forall v :e Rx, forall w :e Ly, v * y + x * w <= u + v * w -> p)
     -> p.
admit.
Qed.

Theorem nonpos_nonneg_0 : forall m n :e omega, m = - n -> m = 0 /\ n = 0.
admit.
Qed.

Theorem mul_minus_SNo_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

End SurrealMul.

Opaque mul_SNo.

Section Int.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Definition int : set := omega :\/: {- n|n :e omega}.

Theorem int_SNo_cases : forall p:set -> prop,
    (forall n :e omega, p n)
 -> (forall n :e omega, p (- n))
 -> forall x :e int, p x.
admit.
Qed.

Theorem int_3_cases: forall n :e int, forall p:prop,
    (forall m :e omega, n = - ordsucc m -> p)
 -> (n = 0 -> p)
 -> (forall m :e omega, n = ordsucc m -> p)
 -> p.
admit.
Qed.

Theorem int_SNo : forall x :e int, SNo x.
admit.
Qed.

Theorem Subq_omega_int : omega c= int.
admit.
Qed.

Theorem int_minus_SNo_omega : forall n :e omega, - n :e int.
admit.
Qed.

Theorem int_add_SNo_lem: forall n :e omega, forall m, nat_p m -> - n + m :e int.
admit.
Qed.

Theorem int_add_SNo: forall x y :e int, x + y :e int.
admit.
Qed.

Theorem int_minus_SNo: forall x :e int, - x :e int.
admit.
Qed.

Theorem int_mul_SNo: forall x y :e int, x * y :e int.
admit.
Qed.

Theorem nonneg_int_nat_p: forall n :e int, 0 <= n -> nat_p n.
admit.
Qed.

End Int.

Section BezoutAndGCD.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem quotient_remainder_nat: forall n :e omega :\: {0}, forall m, nat_p m -> exists q :e omega, exists r :e n, m = q * n + r.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem mul_SNo_nonpos_nonneg: forall x y, SNo x -> SNo y -> x <= 0 -> 0 <= y -> x * y <= 0.
admit.
Qed.

Theorem ordinal_0_In_ordsucc: forall alpha, ordinal alpha -> 0 :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_ordsucc_pos: forall alpha, ordinal alpha -> 0 < ordsucc alpha.
admit.
Qed.

Theorem quotient_remainder_int: forall n :e omega :\: {0}, forall m :e int, exists q :e int, exists r :e n, m = q * n + r.
admit.
Qed.

Definition divides_int : set -> set -> prop := fun m n => m :e int /\ n :e int /\ exists k :e int, m * k = n.

Theorem divides_int_ref: forall n :e int, divides_int n n.
admit.
Qed.

Theorem divides_int_0: forall n :e int, divides_int n 0.
admit.
Qed.

Theorem divides_int_add_SNo: forall m n k, divides_int m n -> divides_int m k -> divides_int m (n + k).
admit.
Qed.

Theorem divides_int_mul_SNo: forall m n m' n', divides_int m m' -> divides_int n n' -> divides_int (m * n) (m' * n').
admit.
Qed.

Theorem divides_nat_divides_int: forall m n, divides_nat m n -> divides_int m n.
admit.
Qed.

Theorem divides_int_divides_nat: forall m n :e omega, divides_int m n -> divides_nat m n.
admit.
Qed.

Theorem divides_int_minus_SNo: forall m n, divides_int m n -> divides_int m (- n).
admit.
Qed.

Theorem divides_int_mul_SNo_L: forall m n, forall k :e int, divides_int m n -> divides_int m (n * k).
admit.
Qed.

Theorem divides_int_mul_SNo_R: forall m n, forall k :e int, divides_int m n -> divides_int m (k * n).
admit.
Qed.

Theorem divides_int_1: forall n :e int, divides_int 1 n.
admit.
Qed.

Theorem divides_int_pos_Le: forall m n, divides_int m n -> 0 < n -> m <= n.
admit.
Qed.

Definition gcd_reln : set -> set -> set -> prop := fun m n d => divides_int d m /\ divides_int d n /\ forall d', divides_int d' m -> divides_int d' n -> d' <= d.

Theorem gcd_reln_uniq: forall a b c d, gcd_reln a b c -> gcd_reln a b d -> c = d.
admit.
Qed.

Definition int_lin_comb : set -> set -> set -> prop := fun a b c => a :e int /\ b :e int /\ c :e int /\ exists m n :e int, m * a + n * b = c.

Theorem int_lin_comb_I: forall a b c :e int, (exists m n :e int, m * a + n * b = c) -> int_lin_comb a b c.
admit.
Qed.

Theorem int_lin_comb_E: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (a :e int -> b :e int -> c :e int -> forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem int_lin_comb_E1: forall a b c, int_lin_comb a b c -> a :e int.
admit.
Qed.

Theorem int_lin_comb_E2: forall a b c, int_lin_comb a b c -> b :e int.
admit.
Qed.

Theorem int_lin_comb_E3: forall a b c, int_lin_comb a b c -> c :e int.
admit.
Qed.

Theorem int_lin_comb_E4: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem least_pos_int_lin_comb_ex: forall a b :e int, ~(a = 0 /\ b = 0) -> exists c, int_lin_comb a b c /\ 0 < c /\ forall c', int_lin_comb a b c' -> 0 < c' -> c <= c'.
admit.
Qed.

Theorem int_lin_comb_sym: forall a b d,
     int_lin_comb a b d
  -> int_lin_comb b a d.
admit.
Qed.
  
Theorem least_pos_int_lin_comb_divides_int: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> divides_int d a.
admit.
Qed.

Theorem least_pos_int_lin_comb_gcd: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> gcd_reln a b d.
admit.
Qed.

Theorem BezoutThm: forall a b :e int, ~(a = 0 /\ b = 0) ->
  forall d, gcd_reln a b d <-> int_lin_comb a b d /\ 0 < d /\ forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
admit.
Qed.

Theorem gcd_id: forall m :e omega :\: {0}, gcd_reln m m m.
admit.
Qed.

Theorem gcd_0: forall m :e omega :\: {0}, gcd_reln 0 m m.
admit.
Qed.

Theorem gcd_sym: forall m n d, gcd_reln m n d -> gcd_reln n m d.
admit.
Qed.

Theorem gcd_minus: forall m n d, gcd_reln m n d -> gcd_reln m (- n) d.
admit.
Qed.

Theorem euclidean_algorithm_prop_1: forall m n d, n :e int -> gcd_reln m (n + - m) d -> gcd_reln m n d.
admit.
Qed.

Theorem euclidean_algorithm:
     (forall m :e omega :\: {0}, gcd_reln m m m)
  /\ (forall m :e omega :\: {0}, gcd_reln 0 m m)
  /\ (forall m :e omega :\: {0}, gcd_reln m 0 m)
  /\ (forall m n :e omega, m < n
          -> forall d, gcd_reln m (n + - m) d
                    -> gcd_reln m n d)
  /\ (forall m n :e omega, n < m
          -> forall d, gcd_reln n m d
                    -> gcd_reln m n d)
  /\ (forall m :e omega, forall n :e int, n < 0
          -> forall d, gcd_reln m (- n) d
                    -> gcd_reln m n d)
  /\ (forall m n :e int, m < 0
          -> forall d, gcd_reln (- m) n d
                    -> gcd_reln m n d).
admit.
Qed.

Theorem Euclid_lemma: forall p, prime_nat p -> forall a b :e int, divides_int p (a * b) -> divides_int p a \/ divides_int p b.
admit.
Qed.

End BezoutAndGCD.

Section PrimeFactorization.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem prime_not_divides_int_1: forall p, prime_nat p -> ~divides_int p 1.
admit.
Qed.

Definition Pi_SNo : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_SNo_0: forall f:set -> set, Pi_SNo f 0 = 1.
admit.
Qed.

Theorem Pi_SNo_S: forall f:set -> set, forall n, nat_p n -> Pi_SNo f (ordsucc n) = Pi_SNo f n * f n.
admit.
Qed.

Theorem Pi_SNo_In_omega: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e omega)
  -> Pi_SNo f n :e omega.
admit.
Qed.

Theorem Pi_SNo_In_int: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e int)
  -> Pi_SNo f n :e int.
admit.
Qed.

Theorem divides_int_prime_nat_eq: forall p q, prime_nat p -> prime_nat q -> divides_int p q -> p = q.
admit.
Qed.

Theorem Euclid_lemma_Pi_SNo: forall f:set->set,
  forall p, prime_nat p ->
  forall n, nat_p n ->
      (forall i :e n, f i :e int)
   -> divides_int p (Pi_SNo f n)
   -> exists i :e n, divides_int p (f i).
admit.
Qed.

Theorem divides_nat_mul_SNo_R: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mul_SNo_L: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_SNo_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, f i :e omega)
   -> (forall i :e n, divides_nat (f i) (Pi_SNo f n)).
admit.
Qed.

Definition nonincrfinseq : (set -> prop) -> set -> (set -> set) -> prop := fun A n f => forall i :e n, A (f i) /\ forall j :e i, f i <= f j.

Theorem Pi_SNo_eq: forall f g:set->set,
  forall m, nat_p m
   -> (forall i :e m, f i = g i)
   -> Pi_SNo f m = Pi_SNo g m.
admit.
Qed.

Theorem prime_factorization_ex_uniq: forall n, nat_p n -> 0 :e n ->
  exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
         -> k' = k /\ forall i :e k, f' i = f i.
admit.
Qed.

End PrimeFactorization.

Section SurrealExp.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Definition exp_SNo_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.
Infix ^ 342 right := exp_SNo_nat.

Theorem exp_SNo_nat_0 : forall x, SNo x -> x ^ 0 = 1.
admit.
Qed.

Theorem exp_SNo_nat_S : forall x, SNo x -> forall n, nat_p n -> x ^ (ordsucc n) = x * x ^ n.
admit.
Qed.

Theorem exp_SNo_nat_1: forall x, SNo x -> x ^ 1 = x.
admit.
Qed.

Theorem SNo_exp_SNo_nat : forall x, SNo x -> forall n, nat_p n -> SNo (x ^ n).
admit.
Qed.

Theorem nat_exp_SNo_nat : forall x, nat_p x -> forall n, nat_p n -> nat_p (x ^ n).
admit.
Qed.

Theorem eps_ordsucc_half_add : forall n, nat_p n -> eps_ (ordsucc n) + eps_ (ordsucc n) = eps_ n.
admit.
Qed.

Theorem eps_1_half_eq1 : eps_ 1 + eps_ 1 = 1.
admit.
Qed.

Theorem eps_1_half_eq2 : 2 * eps_ 1 = 1.
admit.
Qed.

Theorem double_eps_1 : forall x y z, SNo x -> SNo y -> SNo z -> x + x = y + z -> x = eps_ 1 * (y + z).
admit.
Qed.

Theorem exp_SNo_1_bd: forall x, SNo x -> 1 <= x -> forall n, nat_p n -> 1 <= x ^ n.
admit.
Qed.

Theorem exp_SNo_2_bd: forall n, nat_p n -> n < 2 ^ n.
admit.
Qed.

Theorem mul_SNo_eps_power_2: forall n, nat_p n -> eps_ n * 2 ^ n = 1.
admit.
Qed.

Theorem eps_bd_1 : forall n :e omega, eps_ n <= 1.
admit.
Qed.

Theorem mul_SNo_eps_power_2': forall n, nat_p n -> 2 ^ n * eps_ n = 1.
admit.
Qed.

Theorem exp_SNo_nat_mul_add : forall x, SNo x -> forall m, nat_p m -> forall n, nat_p n -> x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_mul_add' : forall x, SNo x -> forall m n :e omega, x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_pos : forall x, SNo x -> 0 < x -> forall n, nat_p n -> 0 < x ^ n.
admit.
Qed.

Theorem mul_SNo_eps_eps_add_SNo: forall m n :e omega, eps_ m * eps_ n = eps_ (m + n).
admit.
Qed.

Theorem SNoS_omega_Lev_equip : forall n, nat_p n -> equip {x :e SNoS_ omega|SNoLev x = n} (2 ^ n).
admit.
Qed.

Theorem SNoS_finite : forall n :e omega, finite (SNoS_ n).
admit.
Qed.

Theorem SNoS_omega_SNoL_finite : forall x :e SNoS_ omega, finite (SNoL x).
admit.
Qed.

Theorem SNoS_omega_SNoR_finite : forall x :e SNoS_ omega, finite (SNoR x).
admit.
Qed.

End SurrealExp.

Opaque exp_SNo_nat.

Section SNoMaxMin.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Definition SNo_max_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> y <= x.
Definition SNo_min_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> x <= y.

Theorem minus_SNo_max_min : forall X y, (forall x :e X, SNo x) -> SNo_max_of X y -> SNo_min_of {- x|x :e X} (- y).
admit.
Qed.

Theorem minus_SNo_max_min' : forall X y, (forall x :e X, SNo x) -> SNo_max_of {- x|x :e X} y -> SNo_min_of X (- y).
admit.
Qed.

Theorem minus_SNo_min_max : forall X y, (forall x :e X, SNo x) -> SNo_min_of X y -> SNo_max_of {- x|x :e X} (- y).
admit.
Qed.

Theorem double_SNo_max_1 : forall x y, SNo x -> SNo_max_of (SNoL x) y -> forall z, SNo z -> x < z -> y + z < x + x -> exists w :e SNoR z, y + w = x + x.
admit.
Qed.

Theorem double_SNo_min_1 : forall x y, SNo x -> SNo_min_of (SNoR x) y -> forall z, SNo z -> z < x -> x + x < y + z -> exists w :e SNoL z, y + w = x + x.
admit.
Qed.

Theorem finite_max_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_max_of X x.
admit.
Qed.

Theorem finite_min_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_min_of X x.
admit.
Qed.

Theorem SNoS_omega_SNoL_max_exists : forall x :e SNoS_ omega, SNoL x = 0 \/ exists y, SNo_max_of (SNoL x) y.
admit.
Qed.

Theorem SNoS_omega_SNoR_min_exists : forall x :e SNoS_ omega, SNoR x = 0 \/ exists y, SNo_min_of (SNoR x) y.
admit.
Qed.

End SNoMaxMin.

Section DiadicRationals.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.

Theorem nonneg_diadic_rational_p_SNoS_omega: forall k :e omega, forall n, nat_p n -> eps_ k * n :e SNoS_ omega.
admit.
Qed.

Definition diadic_rational_p : set -> prop := fun x => exists k :e omega, exists m :e int, x = eps_ k * m.

Theorem diadic_rational_p_SNoS_omega: forall x, diadic_rational_p x -> x :e SNoS_ omega.
admit.
Qed.

Theorem int_diadic_rational_p : forall m :e int, diadic_rational_p m.
admit.
Qed.

Theorem omega_diadic_rational_p : forall m :e omega, diadic_rational_p m.
admit.
Qed.

Theorem eps_diadic_rational_p : forall k :e omega, diadic_rational_p (eps_ k).
admit.
Qed.

Theorem minus_SNo_diadic_rational_p : forall x, diadic_rational_p x -> diadic_rational_p (- x).
admit.
Qed.

Theorem mul_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x * y).
admit.
Qed.

Theorem add_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x + y).
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p_lem: forall n, nat_p n -> forall x, SNo x -> SNoLev x = n -> diadic_rational_p x.
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p: forall x :e SNoS_ omega, diadic_rational_p x.
admit.
Qed.

Theorem mul_SNo_SNoS_omega : forall x y :e SNoS_ omega, x * y :e SNoS_ omega.
admit.
Qed.

End DiadicRationals.

Opaque int.

Section SurrealDiv.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_pos : set -> set := fun x => {w :e SNoL x|0 < w}.

Theorem SNo_recip_pos_pos: forall x xi, SNo x -> SNo xi -> 0 < x -> x * xi = 1 -> 0 < xi.
admit.
Qed.

Theorem SNo_recip_lem1: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Theorem SNo_recip_lem2: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem3: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem4: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Definition SNo_recipauxset : set -> set -> set -> (set -> set) -> set := fun Y x X g => \/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X}.

Theorem SNo_recipauxset_I: forall Y x X, forall g:set -> set,
 forall y :e Y, forall x' :e X, (1 + (x' + - x) * y) * g x' :e SNo_recipauxset Y x X g.
admit.
Qed.

Theorem SNo_recipauxset_E : forall Y x X, forall g:set -> set, forall z :e SNo_recipauxset Y x X g, forall p:prop, (forall y :e Y, forall x' :e X, z = (1 + (x' + - x) * y) * g x' -> p) -> p.
admit.
Qed.

Theorem SNo_recipauxset_ext: forall Y x X, forall g h:set -> set, (forall x' :e X, g x' = h x') -> SNo_recipauxset Y x X g = SNo_recipauxset Y x X h.
admit.
Qed.

Definition SNo_recipaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)).

Theorem SNo_recipaux_0: forall x, forall g:set -> set, SNo_recipaux x g 0 = ({0},0).
admit.
Qed.

Theorem SNo_recipaux_S: forall x, forall g:set -> set, forall n, nat_p n ->
   SNo_recipaux x g (ordsucc n)
 = (SNo_recipaux x g n 0 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoR x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoL_pos x) g,
    SNo_recipaux x g n 1 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoL_pos x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoR x) g).
admit.
Qed.

Theorem SNo_recipaux_lem1: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> forall k, nat_p k ->
         (forall y :e SNo_recipaux x g k 0, SNo y /\ x * y < 1)
      /\ (forall y :e SNo_recipaux x g k 1, SNo y /\ 1 < x * y).
admit.
Qed.

Theorem SNo_recipaux_lem2: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> SNoCutP (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
admit.
Qed.

Theorem SNo_recipaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_recipaux x g k = SNo_recipaux x h k.
admit.
Qed.

Section recip_SNo_pos.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
Definition recip_SNo_pos : set -> set := SNo_rec_i G.

Theorem recip_SNo_pos_eq: forall x, SNo x -> recip_SNo_pos x = G x recip_SNo_pos.
admit.
Qed.

Theorem recip_SNo_pos_prop1: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x) /\ x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem SNo_recip_SNo_pos: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x).
admit.
Qed.

Theorem recip_SNo_pos_invR: forall x, SNo x -> 0 < x -> x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem recip_SNo_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_pos_invol: forall x, SNo x -> 0 < x -> recip_SNo_pos (recip_SNo_pos x) = x.
admit.
Qed.

Theorem recip_SNo_pos_eps_: forall n, nat_p n -> recip_SNo_pos (eps_ n) = 2 ^ n.
admit.
Qed.

Theorem recip_SNo_pos_pow_2: forall n, nat_p n -> recip_SNo_pos (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_pos_2: recip_SNo_pos 2 = eps_ 1.
admit.
Qed.

End recip_SNo_pos.
Definition recip_SNo : set -> set := fun x => if 0 < x then recip_SNo_pos x else if x < 0 then - recip_SNo_pos (- x) else 0.

Theorem recip_SNo_poscase: forall x, 0 < x -> recip_SNo x = recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_negcase: forall x, SNo x -> x < 0 -> recip_SNo x = - recip_SNo_pos (- x).
admit.
Qed.

Theorem recip_SNo_0: recip_SNo 0 = 0.
admit.
Qed.

Theorem SNo_recip_SNo: forall x, SNo x -> SNo (recip_SNo x).
admit.
Qed.

Theorem recip_SNo_invR: forall x, SNo x -> x <> 0 -> x * recip_SNo x = 1.
admit.
Qed.

Theorem recip_SNo_invL: forall x, SNo x -> x <> 0 -> recip_SNo x * x = 1.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel_L: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem recip_SNo_pow_2 : forall n, nat_p n -> recip_SNo (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_of_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo x.
admit.
Qed.

Definition div_SNo : set -> set -> set := fun x y => x * recip_SNo y.

Infix :/: 353 := div_SNo.

Theorem SNo_div_SNo: forall x y, SNo x -> SNo y -> SNo (x :/: y).
admit.
Qed.

Theorem div_SNo_0_num: forall x, SNo x -> 0 :/: x = 0.
admit.
Qed.

Theorem div_SNo_0_denum: forall x, SNo x -> x :/: 0 = 0.
admit.
Qed.

Theorem mul_div_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x :/: y) * y = x.
admit.
Qed.

Theorem mul_div_SNo_invR: forall x y, SNo x -> SNo y -> y <> 0 -> y * (x :/: y) = x.
admit.
Qed.

Theorem mul_div_SNo_R: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) * z = (x * z) :/: y.
admit.
Qed.

Theorem mul_div_SNo_L: forall x y z, SNo x -> SNo y -> SNo z -> z * (x :/: y) = (z * x) :/: y.
admit.
Qed.

Theorem div_mul_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x * y) :/: y = x.
admit.
Qed.

Theorem div_div_SNo: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) :/: z = x :/: (y * z).
admit.
Qed.

Theorem mul_div_SNo_both: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x :/: y) * (z :/: w) = (x * z) :/: (y * w).
admit.
Qed.

Theorem recip_SNo_pos_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem div_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x :/: y.
admit.
Qed.

Theorem div_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x :/: y < 0.
admit.
Qed.

Theorem div_SNo_pos_LtL : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x < z * y -> x :/: y < z.
admit.
Qed.

Theorem div_SNo_pos_LtR : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z * y < x -> z < x :/: y.
admit.
Qed.

Theorem div_SNo_pos_LtL' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x :/: y < z -> x < z * y.
admit.
Qed.

Theorem div_SNo_pos_LtR' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z < x :/: y -> z * y < x.
admit.
Qed.

Theorem mul_div_SNo_nonzero_eq: forall x y z, SNo x -> SNo y -> SNo z -> y <> 0 -> x = y * z -> x :/: y = z.
admit.
Qed.

End SurrealDiv.

Opaque recip_SNo_pos recip_SNo.

Section Reals.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoS_omega_drat_intvl : forall x :e SNoS_ omega,
  forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_above : forall x :e SNoS_ (ordsucc omega), x < omega -> exists N :e omega, x < N.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_below : forall x :e SNoS_ (ordsucc omega), - omega < x -> exists N :e omega, - N < x.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_drat_intvl : forall x :e SNoS_ (ordsucc omega),
    - omega < x -> x < omega
 -> forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Definition real : set := {x :e SNoS_ (ordsucc omega)| x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)}.

Theorem real_I : forall x :e SNoS_ (ordsucc omega),
    x <> omega
 -> x <> - omega
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> x :e real.
admit.
Qed.

Theorem real_E : forall x :e real,
 forall p:prop,
      (SNo x
    -> SNoLev x :e ordsucc omega
    -> x :e SNoS_ (ordsucc omega)
    -> - omega < x
    -> x < omega
    -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
    -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
    -> p)
   -> p.
admit.
Qed.

Theorem real_SNo : forall x :e real, SNo x.
admit.
Qed.

Theorem real_SNoS_omega_prop : forall x :e real, forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
admit.
Qed.

Theorem SNoS_omega_real : SNoS_ omega c= real.
admit.
Qed.

Theorem real_0 : 0 :e real.
admit.
Qed.

Theorem real_1 : 1 :e real.
admit.
Qed.

Theorem SNoLev_In_real_SNoS_omega : forall x :e real, forall w, SNo w -> SNoLev w :e SNoLev x -> w :e SNoS_ omega.
admit.
Qed.

Theorem real_SNoCut_SNoS_omega: forall L R c= SNoS_ omega, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem real_SNoCut: forall L R c= real, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem minus_SNo_prereal_1 : forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - - x) < eps_ k) -> q = - x).
admit.
Qed.

Theorem minus_SNo_prereal_2 : forall x, SNo x ->
    (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < - x /\ - x < q + eps_ k).
admit.
Qed.

Theorem SNo_prereal_incr_lower_pos: forall x, SNo x -> 0 < x
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> forall k :e omega,
     forall p:prop,
         (forall q :e SNoS_ omega, 0 < q -> q < x -> x < q + eps_ k -> p)
      -> p.
admit.
Qed.

Theorem real_minus_SNo : forall x :e real, - x :e real.
admit.
Qed.

Theorem SNo_prereal_incr_lower_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists f :e SNoS_ omega :^: omega,
       forall n :e omega, f n < x /\ x < f n + eps_ n
                       /\ forall i :e n, f i < f n.
admit.
Qed.

Theorem SNo_prereal_decr_upper_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists g :e SNoS_ omega :^: omega,
       forall n :e omega, g n + - eps_ n < x /\ x < g n
                       /\ forall i :e n, g n < g i.
admit.
Qed.

Theorem SNoCutP_SNoCut_lim : forall lambda, ordinal lambda
 -> (forall alpha :e lambda, ordsucc alpha :e lambda)
 -> forall L R c= SNoS_ lambda, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc lambda.
admit.
Qed.

Theorem SNoCutP_SNoCut_omega : forall L R c= SNoS_ omega, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc omega.
admit.
Qed.

Theorem SNo_approx_real_lem:
  forall f g :e SNoS_ omega :^: omega,
     (forall n m :e omega, f n < g m)
  -> forall p:prop,
         (SNoCutP {f n|n :e omega} {g n|n :e omega}
       -> SNo (SNoCut {f n|n :e omega} {g n|n :e omega})
       -> SNoLev (SNoCut {f n|n :e omega} {g n|n :e omega}) :e ordsucc omega
       -> SNoCut {f n|n :e omega} {g n|n :e omega} :e SNoS_ (ordsucc omega)
       -> (forall n :e omega, f n < SNoCut {f n|n :e omega} {g n|n :e omega})
       -> (forall n :e omega, SNoCut {f n|n :e omega} {g n|n :e omega} < g n)
       -> p)
      -> p.
admit.
Qed.

Theorem SNo_approx_real: forall x, SNo x ->
 forall f g :e SNoS_ omega :^: omega,
     (forall n :e omega, f n < x)
  -> (forall n :e omega, x < f n + eps_ n)
  -> (forall n :e omega, forall i :e n, f i < f n)
  -> (forall n :e omega, x < g n)
  -> (forall n :e omega, forall i :e n, g n < g i)
  -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
  -> x :e real.
admit.
Qed.

Theorem SNo_approx_real_rep : forall x :e real,
 forall p:prop,
     (forall f g :e SNoS_ omega :^: omega,
           (forall n :e omega, f n < x)
        -> (forall n :e omega, x < f n + eps_ n)
        -> (forall n :e omega, forall i :e n, f i < f n)
        -> (forall n :e omega, g n + - eps_ n < x)
        -> (forall n :e omega, x < g n)
        -> (forall n :e omega, forall i :e n, g n < g i)
        -> SNoCutP {f n|n :e omega} {g n|n :e omega}
        -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
        -> p)
  -> p.
admit.
Qed.

Theorem real_add_SNo : forall x y :e real, x + y :e real.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_eps_pos : forall x :e SNoS_ (ordsucc omega), 0 < x -> x < omega -> exists N :e omega, eps_ N * x < 1.
admit.
Qed.

Theorem real_mul_SNo_pos : forall x y :e real, 0 < x -> 0 < y -> x * y :e real.
admit.
Qed.

Theorem real_mul_SNo : forall x y :e real, x * y :e real.
admit.
Qed.

Theorem nonneg_real_nat_interval: forall x :e real, 0 <= x -> exists n :e omega, n <= x /\ x < ordsucc n.
admit.
Qed.

Theorem pos_real_left_approx_double: forall x :e real, 0 < x
 -> x <> 2 -> (forall m :e omega, x <> eps_ m)
 -> exists w :e SNoL_pos x, x < 2 * w.
admit.
Qed.

Theorem real_recip_SNo_lem1: forall x, SNo x -> x :e real -> 0 < x ->
    recip_SNo_pos x :e real
 /\ forall k, nat_p k ->
         (SNo_recipaux x recip_SNo_pos k 0 c= real)
      /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
admit.
Qed.

Theorem real_recip_SNo_pos: forall x :e real, 0 < x -> recip_SNo_pos x :e real.
admit.
Qed.

Theorem real_recip_SNo: forall x :e real, recip_SNo x :e real.
admit.
Qed.

Theorem real_div_SNo: forall x y :e real, x :/: y :e real.
admit.
Qed.

End Reals.

Opaque real.

Section even_odd.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem nat_le2_cases: forall m, nat_p m -> m c= 2 -> m = 0 \/ m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2_lem: forall m, nat_p m -> forall n, nat_p n -> m * n = 2 -> m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2: prime_nat 2.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem not_eq_2m_2n1: forall m n :e int, 2 * m <> 2 * n + 1.
admit.
Qed.

End even_odd.

Section form100_22b.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem atleastp_SNoS_ordsucc_omega_Power_omega: atleastp (SNoS_ (ordsucc omega)) (Power omega).
admit.
Qed.

Theorem Repl_finite: forall f:set -> set, forall X, finite X -> finite {f x|x :e X}.
admit.
Qed.

Theorem infinite_bigger: forall X c= omega, infinite X -> forall m :e omega, exists n :e X, m :e n.
admit.
Qed.

Theorem equip_real_Power_omega: equip real (Power omega).
admit.
Qed.

Theorem form100_22_real_uncountable_atleastp: ~atleastp real omega.
admit.
Qed.

Theorem form100_22_real_uncountable_equip: ~equip real omega.
admit.
Qed.

Theorem form100_22_real_uncountable: atleastp omega real /\ ~equip real omega.
admit.
Qed.

End form100_22b.

Section rational.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Definition rational : set := {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}.

End rational.

Section form100_3.

(** The Denumerability of the Rational Numbers **)

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.

Theorem Subq_int_SNoS_omega: int c= SNoS_ omega.
admit.
Qed.

Theorem Subq_SNoS_omega_rational: SNoS_ omega c= rational.
admit.
Qed.

Theorem Subq_rational_real: rational c= real.
admit.
Qed.

Theorem rational_minus_SNo: forall q :e rational, - q :e rational.
admit.
Qed.

Definition nat_pair : set -> set -> set := fun m n => 2 ^ m * (2 * n + 1).

Theorem nat_pair_In_omega: forall m n :e omega, nat_pair m n :e omega.
admit.
Qed.

Theorem nat_pair_0: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> m = m'.
admit.
Qed.

Theorem nat_pair_1: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> n = n'.
admit.
Qed.

Theorem form100_3: equip omega rational.
admit.
Qed.

End form100_3.

Section SurrealSqrt.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_nonneg : set -> set := fun x => {w :e SNoL x|0 <= w}.

Theorem SNoL_nonneg_0: SNoL_nonneg 0 = 0.
admit.
Qed.

Theorem SNoL_nonneg_1: SNoL_nonneg 1 = 1.
admit.
Qed.

Definition SNo_sqrtauxset : set -> set -> set -> set := fun Y Z x => \/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.

Theorem SNo_sqrtauxset_I : forall Y Z x,
 forall y :e Y, forall z :e Z, 0 < y + z -> (x + y * z) :/: (y + z) :e SNo_sqrtauxset Y Z x.
admit.
Qed.

Theorem SNo_sqrtauxset_E : forall Y Z x,
 forall u :e SNo_sqrtauxset Y Z x, forall p:prop,
     (forall y :e Y, forall z :e Z, 0 < y + z -> u = (x + y * z) :/: (y + z) -> p)
  -> p.
admit.
Qed.

Theorem SNo_sqrtauxset_0: forall Z x, SNo_sqrtauxset 0 Z x = 0.
admit.
Qed.

Theorem SNo_sqrtauxset_0': forall Y x, SNo_sqrtauxset Y 0 x = 0.
admit.
Qed.

Definition SNo_sqrtaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)).

Theorem SNo_sqrtaux_0: forall x, forall g:set -> set, SNo_sqrtaux x g 0 = ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x}).
admit.
Qed.

Theorem SNo_sqrtaux_S: forall x, forall g:set -> set, forall n, nat_p n
 -> SNo_sqrtaux x g (ordsucc n)
  = (SNo_sqrtaux x g n 0
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 1) x,
     SNo_sqrtaux x g n 1
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 0) x
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 1) (SNo_sqrtaux x g n 1) x).
admit.
Qed.

Theorem SNo_sqrtaux_mon_lem: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1.
admit.
Qed.

Theorem SNo_sqrtaux_mon: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n -> m c= n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g n 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g n 1.
admit.
Qed.

Theorem SNo_sqrtaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_sqrtaux x g k = SNo_sqrtaux x h k.
admit.
Qed.

Section sqrt_SNo_nonneg.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_sqrtaux x g k 0) (\/_ k :e omega, SNo_sqrtaux x g k 1).
Definition sqrt_SNo_nonneg : set -> set := SNo_rec_i G.

Theorem sqrt_SNo_nonneg_eq: forall x, SNo x -> sqrt_SNo_nonneg x = G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1a: forall x, SNo x -> 0 <= x ->
    (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
 -> forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1b: forall x, SNo x -> 0 <= x
 -> (forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y))
 -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1c: forall x, SNo x -> 0 <= x ->
    SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
 -> (forall z :e (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1), forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p)
 -> 0 <= G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1d: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg < x
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1e: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> x < G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x) /\ 0 <= sqrt_SNo_nonneg x /\ sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

End sqrt_SNo_nonneg.

Theorem SNo_sqrtaux_0_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
      (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
   /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem SNo_sqrtaux_0_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x.
admit.
Qed.

Theorem SNo_sqrtaux_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y.
admit.
Qed.

Theorem SNo_sqrt_SNo_SNoCutP: forall x, SNo x -> 0 <= x ->
  SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0)
          (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem SNo_sqrt_SNo_nonneg: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x).
admit.
Qed.

Theorem sqrt_SNo_nonneg_nonneg: forall x, SNo x -> 0 <= x -> 0 <= sqrt_SNo_nonneg x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_sqr: forall x, SNo x -> 0 <= x -> sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0 : sqrt_SNo_nonneg 0 = 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_1 : sqrt_SNo_nonneg 1 = 1.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0inL0: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> 0 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Lnonempty: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) <> 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Rnonempty: forall x, SNo x -> 0 <= x -> 1 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1) <> 0.
admit.
Qed.

Theorem SNo_sqrtauxset_real: forall Y Z x, Y c= real -> Z c= real -> x :e real -> SNo_sqrtauxset Y Z x c= real.
admit.
Qed.

Theorem SNo_sqrtauxset_real_nonneg: forall Y Z x, Y c= {w :e real|0 <= w} -> Z c= {z :e real|0 <= z} -> x :e real -> 0 <= x -> SNo_sqrtauxset Y Z x c= {w :e real|0 <= w}.
admit.
Qed.

Theorem sqrt_SNo_nonneg_SNoS_omega: forall x :e SNoS_ omega, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

Theorem sqrt_SNo_nonneg_real: forall x :e real, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

End SurrealSqrt.
Opaque sqrt_SNo_nonneg.

Section form100_1.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem divides_int_div_SNo_int: forall m n, divides_int m n -> n :/: m :e int.
admit.
Qed.

(** If m times m = 2 times n times n for naturals m and n, then n = 0. **)
Theorem form100_1_lem1 : forall m, nat_p m -> forall n, nat_p n -> m * m = 2 * n * n -> n = 0.
admit.
Qed.

(** There are no nonzero naturals m and n such that m times m = 2 times n times n. **)
Theorem form100_1_lem2 : forall m :e omega, forall n :e omega :\: 1, m * m <> 2 * n * n.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem sqrt_2_irrational: sqrt_SNo_nonneg 2 :e real :\: rational.
admit.
Qed.

End form100_1.

Section Topology.

(** from 12 Topological Spaces: definition of topology on X **)
(** LATEX VERSION: A topology on a set X is a collection T of subsets of X such that  and X are in T, arbitrary unions of subcollections of T lie in T, and finite intersections of elements of T lie in T. **)
(** SUSPICIOUS DEFINITION: This is a left-associated conjunction; later proofs must destruct it as ((((A /\ B) /\ C) /\ D) /\ E). **)
(** REVIEWED: Matches the LATEX VERSION; keep left-assoc and use helper extraction lemmas. **)
Definition topology_on : set -> set -> prop := fun X T =>
  T c= Power X
/\ Empty :e T
/\ X :e T
/\ (forall UFam :e Power T, Union UFam :e T)
/\ (forall U :e T, forall V :e T, U :/\: V :e T).

(** Helper: extract T c= Power X from topology_on **)
Theorem topology_sub_Power : forall X T:set,
  topology_on X T -> T c= Power X.
admit.
Qed.

(** from 12: definition of open sets in a topology **)
(** LATEX VERSION: If X has topology T, a subset U of X is open exactly when U is an element of T. **)
(** SUSPICIOUS DEFINITION: `open_in X T U` bundles the hypothesis `topology_on X T`; this is convenient but means open cannot be stated independently of already knowing T is a topology. **)
(** REVIEWED: Keep bundled form; use `open_in_topology` and `open_in_elem` to unpack. **)
Definition open_in : set -> set -> set -> prop := fun X T U =>
  topology_on X T /\ U :e T.

(** Helper: extract topology_on from open_in **)
Theorem open_in_topology : forall X T U:set,
  open_in X T U -> topology_on X T.
admit.
Qed.

(** Helper: extract membership from open_in **)
Theorem open_in_elem : forall X T U:set,
  open_in X T U -> U :e T.
admit.
Qed.

(** Helper: introduction rule for open_in **)
Theorem open_inI : forall X T U:set,
  topology_on X T -> U :e T -> open_in X T U.
admit.
Qed.

(** helper: if a predicate has a unique witness then Eps_i returns it **)
Theorem Eps_i_unique : forall P:set->prop, forall x:set,
  P x ->
  (forall y:set, P y -> y = x) ->
  Eps_i P = x.
admit.
Qed.

(** Helper: Open set is a subset of X **)
Theorem open_in_subset : forall X T U:set,
  open_in X T U -> U c= X.
admit.
Qed.

(** Helper: Elements of topology are subsets of X **)
Theorem topology_elem_subset : forall X T U:set,
  topology_on X T -> U :e T -> U c= X.
admit.
Qed.

(** Helper: Empty is in every topology **)
Theorem topology_has_empty : forall X T:set,
  topology_on X T -> Empty :e T.
admit.
Qed.

(** Helper: X is in every topology on X **)
Theorem topology_has_X : forall X T:set,
  topology_on X T -> X :e T.
admit.
Qed.

(** Helper: topology is a family of subsets **)
Theorem topology_subset_axiom : forall X T:set,
  topology_on X T -> T c= Power X.
admit.
Qed.

(** Helper: Union of family in topology stays in topology **)
Theorem topology_union_closed : forall X T UFam:set,
  topology_on X T -> UFam c= T -> Union UFam :e T.
admit.
Qed.

(** Helper: Union axiom using Power membership **)
Theorem topology_union_closed_pow : forall X T UFam:set,
  topology_on X T -> UFam :e Power T -> Union UFam :e T.
admit.
Qed.

(** Helper: union axiom extracted **)
Theorem topology_union_axiom : forall X T:set,
  topology_on X T ->
  forall UFam :e Power T, Union UFam :e T.
admit.
Qed.

(** Helper: Binary intersection in topology stays in topology **)
Theorem topology_binintersect_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :/\: V :e T.
admit.
Qed.

(** Helper: intersection axiom extracted **)
Theorem topology_binintersect_axiom : forall X T:set,
  topology_on X T ->
  forall U :e T, forall V :e T, U :/\: V :e T.
admit.
Qed.

(** Helper: Empty set is open in any topology **)
Theorem Empty_is_open : forall X T:set,
  topology_on X T -> open_in X T Empty.
admit.
Qed.

(** Helper: X is open in its own topology **)
Theorem X_is_open : forall X T:set,
  topology_on X T -> open_in X T X.
admit.
Qed.

(** Helper: Union of open sets is open **)
Theorem union_open : forall X T UFam:set,
  topology_on X T ->
  (forall U :e UFam, open_in X T U) ->
  open_in X T (Union UFam).
admit.
Qed.

(** Helper: Binary intersection of open sets is open **)
Theorem binintersect_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :/\: V).
admit.
Qed.

(** from 12: closed set as complement of open set **)
(** LATEX VERSION: A set C is closed in X (with topology T) if there exists an open set UT whose complement in X equals C. **)
(** SUSPICIOUS DEFINITION: This is packaged with an explicit subset condition `C c= X` and an existential complement witness; later closure lemmas must unpack that witness carefully. **)
(** REVIEWED: Matches the LATEX VERSION; subset condition is redundant but harmless and used by `closed_in_subset`. **)
Definition closed_in : set -> set -> set -> prop := fun X T C =>
  topology_on X T /\ (C c= X /\ exists U :e T, C = X :\: U).

(** Helper: extract topology_on from closed_in **)
Theorem closed_in_topology : forall X T C:set,
  closed_in X T C -> topology_on X T.
admit.
Qed.

(** Helper: extract the complement-witness package from closed_in **)
Theorem closed_in_package : forall X T C:set,
  closed_in X T C -> C c= X /\ exists U :e T, C = X :\: U.
admit.
Qed.

(** Helper: introduction rule for closed_in **)
Theorem closed_inI : forall X T C:set,
  topology_on X T ->
  C c= X ->
  (exists U :e T, C = X :\: U) ->
  closed_in X T C.
admit.
Qed.

(** Helper: pairing belongs to setprod via Sigma encoding **)
Theorem tuple_2_setprod_by_pair_Sigma : forall X Y:set, forall x y:set,
  x :e X -> y :e Y -> (x,y) :e setprod X Y.
admit.
Qed.

(** Helper: extract existence of open complement witness from closed_in **)
Theorem closed_in_exists_open_complement : forall X T C:set,
  closed_in X T C -> exists U :e T, C = X :\: U.
admit.
Qed.

(** Helper: Closed set is a subset of X **)
Theorem closed_in_subset : forall X T C:set,
  closed_in X T C -> C c= X.
admit.
Qed.

(** from 12: complement of open set is closed **)
(** LATEX VERSION: If U is open in topology T on X, then X\\U is closed in that topology. **)
Theorem closed_of_open_complement : forall X T U:set, topology_on X T -> U :e T -> closed_in X T (X :\: U).
admit.
Qed.

(** Helper: X is closed in any topology **)
Theorem X_is_closed : forall X T:set,
  topology_on X T -> closed_in X T X.
admit.
Qed.

(** Helper: Empty is closed in any topology **)
Theorem Empty_is_closed : forall X T:set,
  topology_on X T -> closed_in X T Empty.
let X T.
assume HTx: topology_on X T.
prove closed_in X T Empty.
apply (closed_inI X T Empty).
- exact HTx.
- exact (Subq_Empty X).
- witness X.
  apply andI.
  * exact (topology_has_X X T HTx).
  * prove Empty = X :\: X.
    apply set_ext.
    { exact (Subq_Empty (X :\: X)). }
    { let x. assume Hx: x :e X :\: X.
      claim HxX: x :e X.
      { exact (setminusE1 X X x Hx). }
      claim HxnotX: x /:e X.
      { exact (setminusE2 X X x Hx). }
      apply FalseE.
      exact (HxnotX HxX).
    }
Qed.




(** Helper: intersection of two closed sets is closed **)
(** LATEX VERSION: Complements turn finite intersections of closed sets into finite unions of open sets. **)
Theorem closed_binintersect : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :/\: D).
admit.
Qed.

(** Helper: union of two closed sets is closed **)
(** LATEX VERSION: Complements turn finite unions of closed sets into finite intersections of open sets. **)
Theorem closed_binunion : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :\/: D).
admit.
Qed.

(** Helper: Complement of closed set is open **)
Theorem open_of_closed_complement : forall X T C:set,
  closed_in X T C -> open_in X T (X :\: C).
admit.
Qed.

(** Helper: binary union is union of a pair **)
Theorem binunion_eq_Union_pair : forall X Y:set, X :\/: Y = Union {X,Y}.
admit.
Qed.

(** Helper: binary union of members of a topology is in the topology **)
(** LATEX VERSION: Since U  V is the union of the pair {U,V}, any topology is closed under binary unions. **)
Theorem topology_binunion_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
admit.
Qed.

(** Helper: binary union of open sets is open **)
(** LATEX VERSION: The union of two open sets is open. **)
Theorem binunion_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :\/: V).
admit.
Qed.

(** from 12: "finer than" / "coarser than" topologies **)
(** LATEX VERSION: Given topologies T and T' on X, T' is finer than T if T'  T; T is coarser than T'; the topologies are comparable if one contains the other. **)
 (** REVIEWED: These are plain set inclusions on families of subsets; any topology_on assumptions must be carried separately. **)
Definition finer_than : set -> set -> prop := fun T' T => T c= T'.

(** LATEX VERSION: Coarser is the reverse inclusion: T' is coarser than T when T'  T. **)
 (** REVIEWED: Matches the LATEX VERSION, with the same caveat about carrying topology_on separately. **)
Definition coarser_than : set -> set -> prop := fun T' T => T' c= T.


(** from 12 Example 2: discrete topology **)
(** LATEX VERSION: Example 2 defines the discrete topology on X as the collection of all subsets of X. **)
 (** REVIEWED: discrete_topology X = Power X as intended. **)
Definition discrete_topology : set -> set := fun X => Power X.

(** from 12: indiscrete/trivial topology **)
(** LATEX VERSION: The indiscrete (trivial) topology on X consists only of X and . **)
 (** REVIEWED: indiscrete_topology X = {Empty, X} as intended. **)
Definition indiscrete_topology : set -> set := fun X => {Empty, X}.

(** from 12 Example 3: finite complement topology **)
(** LATEX VERSION: Example 3 defines T_f = { U  X | X\\U is finite or U =  }, the finite complement topology. **)
 (** REVIEWED: Uses the standard finite complement predicate, with the explicit U=Empty disjunct. **)
Definition finite_complement_topology : set -> set :=
  fun X => {U :e Power X | finite (X :\: U) \/ U = Empty}.

(** helper: countable set: admits an injection into omega (at most countable) **)
(** LATEX VERSION: A set is countable if it admits an injection into  (at most countable). **)
(** NOTE: `atleastp X omega` is used here in the sense there exists an injection from X into omega (cardinality at most omega). **)
(** SUSPICIOUS DEFINITION: This is at most countable (injects into omega), not countably infinite (equip omega). Later statements must use the intended meaning consistently. **)
(** REVIEWED: Matches the LATEX VERSION; keep at most countable meaning. **)
Definition countable : set -> prop := fun X => atleastp X omega.

(** LATEX VERSION: Every finite set is countable. **)
Theorem finite_countable : forall X:set, finite X -> countable X.
admit.
Qed.

(** Helper: Empty is countable **)
Theorem countable_Empty : countable Empty.
admit.
Qed.

(** Helper: Subset of countable set is countable **)
Theorem Subq_countable : forall X Y:set, countable Y -> X c= Y -> countable X.
admit.
Qed.

(** Helper: intersection of a countable set with any set is countable **)
(** LATEX VERSION: Any subset of a countable set is countable; in particular XY is countable if X is countable. **)
Theorem binintersect_countable_left : forall X Y:set,
  countable X -> countable (X :/\: Y).
admit.
Qed.

(** Helper: set difference of a countable set is countable **)
(** LATEX VERSION: X\\A is countable if X is countable. **)
Theorem setminus_countable : forall X A:set,
  countable X -> countable (X :\: A).
admit.
Qed.

(** Helper: Union of two countable sets is countable **)
(** NOTE: This requires some form of choice or construction **)
Theorem binunion_countable : forall X Y:set, countable X -> countable Y -> countable (X :\/: Y).
admit.
Qed.

(** Helper: dependent sum of countables is countable **)
(** LATEX VERSION: A countable union of countable sets is countable, encoded as a dependent sum with nat-pairing. **)
Theorem Sigma_countable : forall X:set, countable X ->
  forall Y:set->set, (forall x:set, x :e X -> countable (Y x)) ->
  countable (Sigma_ x :e X, Y x).
admit.
Qed.

(** Helper: product of two countable sets is countable **)
(** LATEX VERSION: If X and Y are countable then XY is countable via nat-pairing of injections. **)
Theorem setprod_countable : forall X Y:set, countable X -> countable Y -> countable (X :*: Y).
admit.
Qed.

(** Helper: Union of a family preserves Power set membership **)
Theorem Union_Power : forall X Fam:set,
  Fam c= Power X -> Union Fam c= X.
admit.
Qed.

(** Helper: Binary intersection of Power set members is in Power set **)
Theorem binintersect_Power : forall X U V:set,
  U :e Power X -> V :e Power X -> U :/\: V :e Power X.
admit.
Qed.

(** Helper: intersection with Empty on the left **)
Theorem binintersect_Empty_left : forall A:set,
  Empty :/\: A = Empty.
admit.
Qed.

(** Helper: intersection with Empty on the right **)
Theorem binintersect_Empty_right : forall A:set,
  A :/\: Empty = Empty.
admit.
Qed.

(** Helper: Setminus with subset is in Power set **)
Theorem setminus_Power : forall X U:set,
  U :e Power X -> X :\: U :e Power X.
admit.
Qed.

(** from 12 Example 4: countable complement topology **)
(** LATEX VERSION: Example 4 defines T_c = { U  X | X\\U is countable or U =  }, the countable complement topology. **)
 (** REVIEWED: Uses the development's countable predicate (at most countable) for X\\U, matching the LATEX VERSION intent. **)
Definition countable_complement_topology : set -> set :=
  fun X => {U :e Power X | countable (X :\: U) \/ U = Empty}.

(** from 12 Example 4: countable complement topology is a topology **)
(** LATEX VERSION: The countable complement collection T_c on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_c. **)
Theorem countable_complement_topology_on : forall X, topology_on X (countable_complement_topology X).
admit.
Qed.

(** from 12: discrete topology is a topology **)
(** LATEX VERSION: The discrete topology on any set X satisfies the axioms of a topology. **)
Theorem discrete_topology_on : forall X, topology_on X (discrete_topology X).
admit.
Qed.

(** from 12: indiscrete topology is a topology **)
(** LATEX VERSION: The trivial/indiscrete topology {, X} on any set X satisfies the topology axioms. **)
Theorem indiscrete_topology_on : forall X, topology_on X (indiscrete_topology X).
admit.
Qed.

(** from 12 Example 3: finite complement topology is a topology **)
(** LATEX VERSION: The finite complement collection T_f on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_f. **)
Theorem finite_complement_topology_on : forall X, topology_on X (finite_complement_topology X).
admit.
Qed.

(** from 12: finer_than reflexive **)
(** LATEX VERSION: Any topology is finer than itself. **)
Theorem finer_than_refl : forall T:set, finer_than T T.
admit.
Qed.

(** from 12: finer_than transitive **)
(** LATEX VERSION: Finer-than is transitive: if T'' finer than T' and T' finer than T, then T'' finer than T. **)
Theorem finer_than_trans : forall A B C:set, finer_than B A -> finer_than C B -> finer_than C A.
admit.
Qed.

(** from 12: equivalence of finer/coarser phrasing **)
(** LATEX VERSION: Saying T' is finer than T is equivalent to saying T is coarser than T'. **)
Theorem finer_coarser_dual : forall T T':set, finer_than T' T -> coarser_than T T'.
admit.
Qed.

(** from 12: comparability of topologies **)
(** LATEX VERSION: Two topologies are comparable if one contains the other. **)
(** SUSPICIOUS DEFINITION: This is defined for arbitrary families `T1,T2`; it does not assert either is a topology on any `X` unless added separately. **)
(** REVIEWED: Matches the LATEX VERSION; when needed, add `topology_on X T1` and `topology_on X T2` separately. **)
Definition comparable_topologies : set -> set -> prop := fun T1 T2 =>
  finer_than T1 T2 \/ finer_than T2 T1.

(** from 12: equality of topologies **)
(** LATEX VERSION: Topology equality on X means both are topologies on X and have identical collections of opens. **)
(** SUSPICIOUS DEFINITION: This is literal set equality `T1 = T2` bundled with `topology_on` assumptions; statements using this should not confuse it with extensional same open sets without equality, but in this development sets are extensional anyway. **)
(** REVIEWED: Uses literal set equality `T1 = T2` (extensional in this development). **)
Definition topology_eq : set -> set -> set -> prop := fun X T1 T2 =>
  topology_on X T1 /\ topology_on X T2 /\ T1 = T2.

(** from 12: symmetry of topology equality **)
(** LATEX VERSION: Equality of topologies is symmetric. **)
Theorem topology_eq_sym : forall X T1 T2:set, topology_eq X T1 T2 -> topology_eq X T2 T1.
admit.
Qed.

(** from 12: transitivity of topology equality **)
(** LATEX VERSION: Equality of topologies is transitive. **)
Theorem topology_eq_trans : forall X T1 T2 T3:set, topology_eq X T1 T2 -> topology_eq X T2 T3 -> topology_eq X T1 T3.
admit.
Qed.

(** from 12: reflexivity of topology equality **)
(** LATEX VERSION: Any topology equals itself (with the requisite topology_on hypotheses). **)
Theorem topology_eq_refl : forall X T:set, topology_on X T -> topology_eq X T T.
admit.
Qed.

(** from 12: strict fineness/coarseness **)
(** LATEX VERSION: T' is strictly finer than T if T'T and not conversely; strictly coarser is the dual. **)
(** SUSPICIOUS DEFINITION: This is stated for arbitrary sets of subsets; it does not require `T` or `T'` to satisfy `topology_on` unless added separately. **)
(** REVIEWED: Matches the LATEX VERSION; topology hypotheses are carried separately when required. **)
Definition strictly_finer_than : set -> set -> prop := fun T' T => finer_than T' T /\ ~finer_than T T'.

 (** REVIEWED: Dual notion using coarser_than, with strictness expressed as negated reverse inclusion. **)
Definition strictly_coarser_than : set -> set -> prop := fun T' T => coarser_than T' T /\ ~coarser_than T T'.

(** from 12 examples: auxiliary aliases **)
(** LATEX VERSION: Alternate notation: discrete topology and trivial (indiscrete) topology. **)
 (** REVIEWED: Aliases to keep later statements close to the LATEX naming. **)
Definition discrete_topology_alt : set -> set := discrete_topology.
Definition trivial_topology : set -> set := indiscrete_topology.

(** from 12: finer_than between topologies on same X **)
(** LATEX VERSION: A notion of T' finer than T together with both being topologies on X. **)
(** SUSPICIOUS DEFINITION: This bundles `topology_on` hypotheses; in proofs it is easy to accidentally use only the inclusion `finer_than T' T` without carrying those hypotheses along. **)
(** REVIEWED: Bundling is intentional; destruct the conjunction to keep `topology_on` assumptions in scope. **)
Definition finer_than_topology : set -> set -> set -> prop := fun X T' T =>
  topology_on X T' /\ topology_on X T /\ finer_than T' T.

(** from 12: finer/coarser equivalence **)
(** LATEX VERSION: Finer-than and coarser-than are logically equivalent statements with reversed arguments. **)
Theorem finer_than_def : forall T T':set, finer_than T' T <-> coarser_than T T'.
admit.
Qed.

(** from 12: discrete topology is the finest **)
(** LATEX VERSION: The discrete topology on X is finer than any other topology on X. **)
Theorem discrete_topology_finest : forall X T:set,
  topology_on X T -> finer_than (discrete_topology X) T.
admit.
Qed.

(** from 12: indiscrete topology is the coarsest **)
(** LATEX VERSION: The indiscrete topology on X is coarser than any other topology on X. **)
Theorem indiscrete_topology_coarsest : forall X T:set,
  topology_on X T -> coarser_than (indiscrete_topology X) T.
admit.
Qed.

(** from 12: every subset is open in discrete topology **)
(** LATEX VERSION: In the discrete topology on X, every subset UX is open. **)
Theorem discrete_open_all : forall X U:set, U c= X -> U :e discrete_topology X.
admit.
Qed.

(** from 12: opens in indiscrete topology are Empty or X **)
(** LATEX VERSION: In the indiscrete topology, the only open sets are  and X. **)
Theorem indiscrete_open_iff : forall X U:set,
  U :e indiscrete_topology X <-> (U = Empty \/ U = X).
admit.
Qed.

(** from 12 Example 3: finite complement openness criterion **)
(** LATEX VERSION: In the finite complement topology, an open set U satisfies that X\\U is finite or U=. **)
Theorem finite_complement_topology_open_criterion : forall X U:set,
  open_in X (finite_complement_topology X) U ->
  finite (X :\: U) \/ U = Empty.
admit.
Qed.

(** from 12 Example 3: Empty is open in finite complement topology **)
(** LATEX VERSION:  is an open set in the finite complement topology. **)
Theorem finite_complement_topology_contains_empty : forall X:set,
  Empty :e finite_complement_topology X.
admit.
Qed.

(** from 12 Example 3: X is open in finite complement topology **)
(** LATEX VERSION: X itself is open in the finite complement topology. **)
Theorem finite_complement_topology_contains_full : forall X:set,
  X :e finite_complement_topology X.
admit.
Qed.

(** from 12 Example 4: openness via countable complement **) 
(** LATEX VERSION: In the countable complement topology, an open set U has X\\U countable or U=. **)
Theorem countable_complement_topology_open_iff : forall X U:set,
  open_in X (countable_complement_topology X) U ->
  countable (X :\: U) \/ U = Empty.
admit.
Qed.

(** from 12 Example 4: Empty is open in countable complement topology **)
(** LATEX VERSION:  is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_empty : forall X:set,
  Empty :e countable_complement_topology X.
admit.
Qed.

(** from 12 Example 4: X is open in countable complement topology **) 
(** LATEX VERSION: X is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_full : forall X:set,
  X :e countable_complement_topology X.
admit.
Qed.

(** from 12 Example comparison: countable vs finite complement **)
(** LATEX VERSION: The countable complement topology is finer than the finite complement topology. **)
Theorem countable_complement_finer_than_finite_complement : forall X:set,
  finer_than (countable_complement_topology X) (finite_complement_topology X).
admit.
Qed.

(** from 12 examples: finite complement coarser than discrete **)
(** LATEX VERSION: The finite complement topology is coarser than the discrete topology. **)
Theorem finite_complement_coarser_than_discrete : forall X:set,
  coarser_than (finite_complement_topology X) (discrete_topology X).
admit.
Qed.

(** from 12 examples: indiscrete coarser than countable complement **) 
(** LATEX VERSION: The indiscrete topology is coarser than the countable complement topology. **)
Theorem indiscrete_coarser_than_countable_complement : forall X:set,
  coarser_than (indiscrete_topology X) (countable_complement_topology X).
admit.
Qed.

(** from 12: fineness via set inclusion of topologies **)
(** LATEX VERSION: A restatement of fineness between topologies on X as inclusion of their open sets. **)
 (** REVIEWED: This is just an alias of finer_than_topology. **)
Definition finer_than_topology_by_inclusion : set -> set -> set -> prop := finer_than_topology.

(** from 12: fineness via inclusion characterization **)
(** LATEX VERSION: The earlier fineness notion between topologies on X is equivalent to plain inclusion of their open sets. **)
Theorem finer_than_topology_by_inclusion_eq : forall X T' T:set,
  finer_than_topology X T' T <-> finer_than_topology_by_inclusion X T' T.
admit.
Qed.

(** from 12 axiom: arbitrary unions of opens are open **)
(** LATEX VERSION: In any topology, the union of any subfamily of open sets is open. **)
Theorem lemma_union_of_topology_family_open : forall X T UFam:set,
  topology_on X T ->
  UFam :e Power T ->
  Union UFam :e T.
admit.
Qed.

(** from 12 axiom: finite intersections of opens are open **)
(** LATEX VERSION: In any topology, the intersection of two open sets is open (and hence any finite intersection). **)
Theorem lemma_intersection_two_open : forall X T U V:set,
  topology_on X T ->
  U :e T -> V :e T ->
  U :/\: V :e T.
admit.
Qed.

(** from 12: alternative naming for topological space **)
(** LATEX VERSION: Using notation topological_space X T for topology_on X T and open_set_family/open_set for opens. **)
(** NOTE: `open_set` is defined as an alias of `open_in` to avoid duplicate bookkeeping. **)
 (** REVIEWED: This is only naming; no semantic change. **)
Definition topological_space : set -> set -> prop := topology_on.

(** from 12: alternative naming for topology family **)
(** LATEX VERSION: We write T for the family of open sets, and call it the open_set_family. **)
 (** REVIEWED: open_set_family ignores X and returns T. **)
Definition open_set_family : set -> set -> set := fun _ T => T.

(** from 12: alternative naming for open sets **)
(** LATEX VERSION: A subset U of X is open iff U is in the topology T; we name this predicate open_set. **)
 (** REVIEWED: Alias to open_in, so it bundles topology_on as open_in does. **)
Definition open_set : set -> set -> set -> prop := open_in.

(** from 13 Definition: basis for a topology **) 
(** LATEX VERSION: A basis on X is a collection BP(X) such that every xX lies in some bB and intersections around a point refine to another basis element. **)
(** SUSPICIOUS DEFINITION: This is a left-associated conjunction; proofs must destruct it as (A /\ B) /\ C, not A /\ (B /\ C). **)
(** REVIEWED: Matches the LATEX VERSION; keep left-assoc and use the existing basis_on helper extractors. **)
Definition basis_on : set -> set -> prop := fun X B =>
  B c= Power X
  /\ (forall x :e X, exists b :e B, x :e b)
  /\ (forall b1 :e B, forall b2 :e B, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).

(** Helper: extract B c= Power X from basis_on **)
Theorem basis_on_sub_Power : forall X B:set,
  basis_on X B -> B c= Power X.
admit.
Qed.

(** Helper: extract cover property from basis_on **)
Theorem basis_on_cover : forall X B:set,
  basis_on X B -> forall x :e X, exists b :e B, x :e b.
admit.
Qed.

(** Helper: extract refinement property from basis_on **)
Theorem basis_on_refine : forall X B:set,
  basis_on X B ->
  forall b1 :e B, forall b2 :e B, forall x:set,
    x :e b1 -> x :e b2 ->
    exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
admit.
Qed.

(** from 13 Definition: topology generated by a basis **)
(** LATEX VERSION: The topology generated by basis B on X consists of all UX such that every xU lies in some bB with bU. **)
(** SUSPICIOUS DEFINITION: Membership is encoded by a local basis refinement condition; later set ext proofs often need to rewrite this definition and then destruct nested existentials carefully. **)
(** REVIEWED: Matches the LATEX VERSION; local refinement is the intended definition of generated topology. **)
Definition generated_topology : set -> set -> set := fun X B =>
  {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.

(** helper: unfold membership in generated topology **)
(** LATEX VERSION: If U is open in the topology generated by B and xU, then some bB contains x and is contained in U. **)
Theorem generated_topology_local_refine : forall X B U x:set,
  U :e generated_topology X B ->
  x :e U ->
  exists b :e B, x :e b /\ b c= U.
admit.
Qed.

(** Helper: Any declared generator element is open in the generated topology **)
(** LATEX VERSION: If U is one of the designated generators and U  X, then U is open in the generated topology. **)
Theorem generated_topology_contains_elem : forall X B U:set,
  U :e Power X ->
  U :e B ->
  U :e generated_topology X B.
admit.
Qed.

(** Helper: Basis elements are subsets of X **)
Theorem basis_elem_subset : forall X B b:set,
  basis_on X B -> b :e B -> b c= X.
admit.
Qed.

(** Helper: Basis elements are in generated topology **)
Theorem basis_in_generated : forall X B b:set,
  basis_on X B -> b :e B -> b :e generated_topology X B.
admit.
Qed.

(** Helper: Elements of generated topology are subsets of X **)
Theorem generated_topology_subset : forall X B U:set,
  U :e generated_topology X B -> U c= X.
admit.
Qed.

(** from 13: generated family is a topology **) 
(** LATEX VERSION: The collection generated by a basis indeed satisfies the topology axioms. **)
Theorem lemma_topology_from_basis : forall X B:set,
  basis_on X B ->
  topology_on X (generated_topology X B).
admit.
Qed.

(** from 13: basis elements belong to generated topology **) 
(** LATEX VERSION: Every basis element bB is itself open in the topology generated by B. **)
Theorem generated_topology_contains_basis : forall X B:set,
  basis_on X B -> forall b:set, b :e B -> b :e generated_topology X B.
admit.
Qed.

(** Helper: generated topology is contained in any topology that contains the generators **)
(** LATEX VERSION: If T is a topology on X and every generator bB is in T, then every set generated from B is in T. **)
(** NOTE: This does not require B to satisfy the basis axioms; it is a general generated topology is minimal direction. **)
Theorem generated_topology_finer_weak : forall X B T:set,
  topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
admit.
Qed.

(** from 13: shorthand for basis generating topology **) 
(** LATEX VERSION: basis_generates X B T abbreviates B is a basis on X and the generated topology equals T. **)
Definition basis_generates : set -> set -> set -> prop := fun X B T =>
  basis_on X B /\ generated_topology X B = T.

(** from 13: shorthand that a family refines all opens **) 
(** LATEX VERSION: basis_refines X B T means T is a topology on X and every x in any UT lies in some bB with bU. **)
Definition basis_refines : set -> set -> set -> prop := fun X B T =>
  topology_on X T /\ (forall U :e T, forall x :e U, exists b :e B, x :e b /\ b c= U).

(** from 13: generated topology characterization **) 
(** LATEX VERSION: Characterization of generated_topology as the comprehension of subsets UX with the basis neighborhood property. **)
Theorem lemma_generated_topology_characterization : forall X B:set,
  basis_on X B ->
  generated_topology X B
  = {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.
admit.
Qed.

(** from 13 Lemma 13.1: open sets are unions of basis elements **) 
(** LATEX VERSION: Lemma 13.1: For a basis B on X, every open set is a union of elements of B. **)
Theorem open_sets_as_unions_of_basis : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    exists Fam :e Power B, Union Fam = U.
admit.
Qed.

(** from 13 Lemma 13.1 converse direction **) 
(** LATEX VERSION: Conversely, any union of basis elements is open in the topology generated by the basis. **)
Theorem basis_generates_open_sets : forall X B:set,
  basis_on X B ->
  forall U:set, (exists Fam :e Power B, Union Fam = U) ->
    open_in X (generated_topology X B) U.
admit.
Qed.

(** from 13 Lemma 13.1 corollary **) 
(** LATEX VERSION: Corollary: For U open in topology generated by B, U equals the union of all basis elements contained in U. **)
Theorem open_as_union_of_basis_elements : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    U = Union {b :e B|b c= U}.
admit.
Qed.

(** from 13 Lemma 13.2: extracting a basis from an open refinement condition **) 
(** LATEX VERSION: Lemma 13.2: If every open set of topology T on X is locally contained in some element of CT, then C is a basis and generates T. **)
Theorem basis_refines_topology : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists Cx :e C, x :e Cx /\ Cx c= U) ->
  basis_on X C /\ generated_topology X C = T.
admit.
Qed.

(** from 13 Lemma 13.2 (alias): open refinement family yields a basis **) 
(** LATEX VERSION: Rephrasing Lemma 13.2: a subcollection C of opens that locally refines every open is a basis generating T. **)
Theorem lemma13_2_basis_from_open_subcollection : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists c :e C, x :e c /\ c c= U) ->
  basis_on X C /\ generated_topology X C = T.
admit.
Qed.

(** from 13: criterion for fineness via bases **) 
(** LATEX VERSION: Lemma 13.3 ( direction): If every basis element of B around x contains a basis element of B at x, then the topology from B is finer than that from B. **)
Theorem finer_via_basis : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  (forall x :e X, forall b:set, b :e B -> x :e b ->
      exists b' :e B', x :e b' /\ b' c= b) ->
  finer_than (generated_topology X B') (generated_topology X B).
admit.
Qed.

(** from 13 Lemma 13.3: basis inclusion criterion for fineness **) 
(** LATEX VERSION: Lemma 13.3: T(B) finer than T(B) iff each basis element of B has for every xb some bB with xbb. **)
Theorem basis_finer_equiv_condition : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  ((forall x :e X, forall b :e B, x :e b -> exists b' :e B', x :e b' /\ b' c= b) <->
  finer_than (generated_topology X B') (generated_topology X B)).
admit.
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is minimal containing basis **) 
(** LATEX VERSION: If T is a topology on X containing every basis element of B, then T is finer than the topology generated by B. **)
Theorem generated_topology_finer : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
admit.
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is smallest with given basis **) 
(** LATEX VERSION: Restates previous direction: the topology generated by B is the smallest topology containing B. **)
Theorem topology_generated_by_basis_is_smallest : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
admit.
Qed.

(** from 13 Lemma 13.4: generated topology equals unions of basis elements **) 
(** LATEX VERSION: Lemma 13.4: The topology generated by B consists exactly of unions of subfamilies of B. **)
Theorem union_of_basis_equals_open :
  forall X B:set, basis_on X B ->
  generated_topology X B = {Union Fam | Fam :e Power B}.
admit.
Qed.

(** from 13 Example 3: singleton basis **) 
(** LATEX VERSION: Example 3: the collection of all one-point subsets of X forms a basis. **)
(** FIXED: Use `{x}` directly rather than `{x,x}`. **)
Definition singleton_basis : set -> set := fun X => {{x}|x :e X}.

(** from 13 Example 3: singleton collection forms a basis **) 
(** LATEX VERSION: The collection of singletons on X satisfies the two basis axioms. **)
Theorem singleton_basis_is_basis : forall X:set, basis_on X (singleton_basis X).
admit.
Qed.

(** from 13 Example 3: topology generated by singletons is discrete **) 
(** LATEX VERSION: The topology generated by the singleton basis is the discrete topology on X. **)
Theorem generated_topology_singletons_discrete : forall X:set,
  generated_topology X (singleton_basis X) = discrete_topology X.
admit.
Qed.

(** Misleading "OrderedPair" definition eliminated. Cartesian products use setprod (defined at line 2717). Individual ordered pairs use tuple notation (x,y). **)

(** from 13: the real line as ambient set for the standard and related topologies **)
(** LATEX VERSION: We consider the real line R and define standard, lower limit, and K-topologies on it. **)
(** ambient real line **)
Definition R : set := real.

(** rational numbers as subset of reals **)
(** LATEX VERSION: The rationals  as a subset of . **)
(** FIXED: Now uses proper rational definition from line 6202. rational = {x :e real | exists m :e int, exists n :e omega\\{0}, x = m/n}. **)
Definition Q : set := rational.

(** from 13: the usual order on the real line **)
(** LATEX VERSION: We use the standard relations < and  on the real line. **)
(** ordering relation on the reals **)
Definition Rlt : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ a < b.

(** helper: non-strict order on the reals by negating strict order **)
(** LATEX VERSION: Write a  b for not(b < a) in the ambient strict order on . **)
(** SUSPICIOUS DEFINITION: This defines `a <= b` as `~(b < a)`, not as `a=b \/ a<b`; later uses rely on the trichotomy properties of `<` on reals. **)
(** REVIEWED: Classical `<=` is defined via `<`; later lemmas bridge this to the expected order properties. **)
Definition Rle : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ ~(Rlt b a).

(** helper introduction rule for Rle **)
Theorem RleI : forall a b:set, a :e R -> b :e R -> ~(Rlt b a) -> Rle a b.
admit.
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_left : forall a b:set, Rle a b -> a :e R.
admit.
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_right : forall a b:set, Rle a b -> b :e R.
admit.
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_nlt : forall a b:set, Rle a b -> ~(Rlt b a).
admit.
Qed.

(** helper: strictness from non-equality **)
(** LATEX VERSION: If a<=b and a<>b then a<b. **)
Theorem Rle_neq_implies_Rlt : forall a b:set, Rle a b -> ~(a = b) -> Rlt a b.
admit.
Qed.

(** helper: nonneg implies neg is nonpos **)
(** LATEX VERSION: If t is real and not(t<0), then -t <= 0. **)
Theorem Rle_minus_nonneg : forall t:set,
  t :e R -> ~(Rlt t 0) -> Rle (minus_SNo t) 0.
admit.
Qed.

(** from 13 Example 4: helper introduction rule for Rlt **)
(** LATEX VERSION: We use the usual convention a<b implies a and b are reals and a<b. **)
Theorem RltI : forall a b:set, a :e R -> b :e R -> a < b -> Rlt a b.
admit.
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_left : forall a b:set, Rlt a b -> a :e R.
admit.
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_right : forall a b:set, Rlt a b -> b :e R.
admit.
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_lt : forall a b:set, Rlt a b -> a < b.
admit.
Qed.

(** helper: transitivity of Rlt **)
(** LATEX VERSION: If a<b and b<c then a<c. **)
Theorem Rlt_tra : forall a b c:set, Rlt a b -> Rlt b c -> Rlt a c.
admit.
Qed.

(** from 13 Example 4: Rlt is irreflexive **)
(** LATEX VERSION: We use that a<a is impossible. **)
Theorem not_Rlt_refl : forall a:set, a :e R -> ~(Rlt a a).
admit.
Qed.

(** helper: asymmetry of Rlt **)
(** LATEX VERSION: If a<b then not(b<a). **)
Theorem not_Rlt_sym : forall a b:set, Rlt a b -> ~(Rlt b a).
admit.
Qed.

(** helper: if a<b then 0 < (b-a) in Rlt form **)
(** LATEX VERSION: If a<b in R then b-a is positive. **)
Theorem Rlt_0_diff_of_lt : forall a b:set,
  Rlt a b -> Rlt 0 (add_SNo b (minus_SNo a)).
admit.
Qed.

(** helper: strict order implies non-strict order **)
Theorem Rlt_implies_Rle : forall a b:set, Rlt a b -> Rle a b.
admit.
Qed.

(** helper: reflexivity of Rle **)
(** LATEX VERSION: a  a. **)
Theorem Rle_refl : forall a:set, a :e R -> Rle a a.
admit.
Qed.

(** helper: antisymmetry for Rle, via SNo trichotomy on reals **)
Theorem R_eq_of_not_Rlt : forall a b:set,
  a :e R -> b :e R -> ~(Rlt a b) -> ~(Rlt b a) -> a = b.
admit.
Qed.

(** helper: antisymmetry of Rle **)
(** LATEX VERSION: If a  b and b  a then a = b. **)
Theorem Rle_antisym : forall a b:set, Rle a b -> Rle b a -> a = b.
admit.
Qed.

(** helper: convert non-strict real order to SNo order **)
Theorem SNoLe_of_Rle : forall a b:set, Rle a b -> a <= b.
admit.
Qed.

(** helper for 13 Example 4: 0 < 1 in Rlt form **)
(** LATEX VERSION: We use 0<1 in the usual order on R. **)
Theorem Rlt_0_1 : Rlt 0 1.
admit.
Qed.

(** from 13 Example 4: -1 is less than 0 in  **)
(** LATEX VERSION: We use that -1 < 0. **)
Theorem minus_1_lt_0 : minus_SNo 1 < 0.
admit.
Qed.

(** from 13 Example 4: circular vs rectangular region bases **)
(** LATEX VERSION: Example 4: circular regions and axis-parallel rectangular regions in  both form bases generating the same topology. **)
(** FIXED: EuclidPlane is now correctly RR (Cartesian product), since `setprod` is the -encoding used throughout for XY. **)
Definition EuclidPlane : set := setprod R R.
(** from 13 Examples 1-2: coordinates on the plane **)
(** LATEX VERSION: A point in the plane is described by its x and y coordinates. **)
(** Coordinate selectors for points in EuclidPlane. **)
Definition R2_xcoord : set -> set := fun p => p 0.

(** from 13 Examples 1-2: coordinates on the plane **)
(** LATEX VERSION: A point in the plane is described by its x and y coordinates. **)
Definition R2_ycoord : set -> set := fun p => p 1.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_xcoord_in_R : forall p:set, p :e EuclidPlane -> R2_xcoord p :e R.
admit.
Qed.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_ycoord_in_R : forall p:set, p :e EuclidPlane -> R2_ycoord p :e R.
admit.
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_xcoord_tuple : forall x y:set, R2_xcoord (x,y) = x.
admit.
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_ycoord_tuple : forall x y:set, R2_ycoord (x,y) = y.
admit.
Qed.

(** helper: equality of ordered pairs is coordinatewise **)
(** LATEX VERSION: If (x1,y1) = (x2,y2) then x1=x2 and y1=y2. **)
Theorem tuple_eq_coords : forall x1 y1 x2 y2:set,
  (x1,y1) = (x2,y2) -> x1 = x2 /\ y1 = y2.
admit.
Qed.

(** helper: equality of ordered pairs from coordinate equalities **)
(** LATEX VERSION: If x1=x2 and y1=y2 then (x1,y1)=(x2,y2). **)
Theorem tuple_coords_eq : forall x1 y1 x2 y2:set,
  x1 = x2 -> y1 = y2 -> (x1,y1) = (x2,y2).
admit.
Qed.

(** helper: equality of ordered pairs from coordinate equalities **)
(** LATEX VERSION: If x1=x2 and y1=y2 then (x1,y1)=(x2,y2). **)
Theorem coords_eq_tuple : forall x1 y1 x2 y2:set,
  x1 = x2 -> y1 = y2 -> (x1,y1) = (x2,y2).
admit.
Qed.

(** helper: eta law for points in EuclidPlane **)
(** LATEX VERSION: Every point p in RR is equal to the ordered pair of its coordinates. **)
Theorem EuclidPlane_eta : forall p:set, p :e EuclidPlane -> (R2_xcoord p, R2_ycoord p) = p.
admit.
Qed.

(** from 13 Example 4: equality of points in RR is coordinatewise **)
(** LATEX VERSION: If (x1,y1) = (x2,y2) then x1=x2 and y1=y2. **)
Theorem tuple_eq_coords_R2 : forall x1 y1 x2 y2:set,
  (x1,y1) = (x2,y2) -> x1 = x2 /\ y1 = y2.
admit.
Qed.

(** from 13 Examples 1-2: circular and rectangular regions in the plane **)
(** LATEX VERSION: Circular regions are interiors of circles in the plane; they are described using a distance function d(p,c) < r. **)
(** Euclidean distance in : sqrt((x1-x2)^2 + (y1-y2)^2), implemented using pre-topology surreal and real operations. **)
Definition distance_R2 : set -> set -> set := fun p c =>
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))).

(** from 13 Example 4: distance is real-valued **)
(** LATEX VERSION: For points p,c in RR, the distance d(p,c) is a real number. **)
Theorem distance_R2_in_R : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c :e R.
admit.
Qed.

(** from 13 Example 4: distance is nonnegative **)
(** LATEX VERSION: The distance function takes nonnegative values. **)
Theorem distance_R2_nonneg : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> 0 <= distance_R2 p c.
admit.
Qed.

(** from 13 Example 4: squared distance formula **)
(** LATEX VERSION: d(p,c) squared equals (xp-xc) squared plus (yp-yc) squared. **)
Theorem distance_R2_sqr : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane ->
  mul_SNo (distance_R2 p c) (distance_R2 p c)
  = add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))).
admit.
Qed.

(** helper: the square of abs equals the square of the original **)
(** LATEX VERSION: For real numbers, abs(x) squared equals x squared. **)
Theorem abs_SNo_sqr_eq : forall x:set,
  SNo x ->
  mul_SNo (abs_SNo x) (abs_SNo x) = mul_SNo x x.
admit.
Qed.

(** helper: adding a nonnegative term preserves order on the right **)
(** LATEX VERSION: If y is nonnegative then x <= x + y. **)
Theorem SNoLe_add_nonneg_right : forall x y:set,
  SNo x -> SNo y -> 0 <= y -> x <= add_SNo x y.
admit.
Qed.

(** helper: a square is nonnegative **)
(** LATEX VERSION: For real numbers, x squared is nonnegative. **)
Theorem SNo_sqr_nonneg : forall x:set,
  SNo x ->
  0 <= mul_SNo x x.
admit.
Qed.

(** Helper: first squared coordinate difference bounded by squared distance **)
(** LATEX VERSION: If d(p,c) is the Euclidean distance then (xp-xc) squared is at most d(p,c) squared. **)
Theorem dx2_le_distance_R2_sqr : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
         (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
  <= mul_SNo (distance_R2 p c) (distance_R2 p c).
admit.
Qed.

(** Helper: second squared coordinate difference bounded by squared distance **)
(** LATEX VERSION: If d(p,c) is the Euclidean distance then (yp-yc) squared is at most d(p,c) squared. **)
Theorem dy2_le_distance_R2_sqr : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
         (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
  <= mul_SNo (distance_R2 p c) (distance_R2 p c).
admit.
Qed.

(** Helper: absolute x coordinate difference squared bounded by squared distance **)
(** LATEX VERSION: The square of abs(xp-xc) is at most d(p,c) squared. **)
Theorem abs_dx2_le_distance_R2_sqr : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  mul_SNo
    (abs_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
    (abs_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
  <= mul_SNo (distance_R2 p c) (distance_R2 p c).
admit.
Qed.

(** Helper: absolute y coordinate difference squared bounded by squared distance **)
(** LATEX VERSION: The square of abs(yp-yc) is at most d(p,c) squared. **)
Theorem abs_dy2_le_distance_R2_sqr : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  mul_SNo
    (abs_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))
    (abs_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))
  <= mul_SNo (distance_R2 p c) (distance_R2 p c).
admit.
Qed.

(** Helper: absolute value is nonnegative **)
(** LATEX VERSION: For real numbers, abs(x) is always nonnegative. **)
Theorem abs_SNo_nonneg : forall x:set,
  SNo x ->
  0 <= abs_SNo x.
admit.
Qed.

(** Helper: strict inequality implies strict inequality of squares for nonnegative numbers **)
(** LATEX VERSION: If 0<=x<y then x squared is less than y squared. **)
Theorem SNo_sqr_lt_of_lt_nonneg : forall x y:set,
  SNo x ->
  SNo y ->
  0 <= x ->
  x < y ->
  mul_SNo x x < mul_SNo y y.
admit.
Qed.

(** Helper: coordinate absolute difference bounded by distance **)
(** LATEX VERSION: In Euclidean plane, abs(xp-xc) is at most d(p,c). **)
Theorem abs_dx_le_distance_R2 : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  abs_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))) <= distance_R2 p c.
admit.
Qed.

(** Helper: coordinate absolute difference bounded by distance **)
(** LATEX VERSION: In Euclidean plane, abs(yp-yc) is at most d(p,c). **)
Theorem abs_dy_le_distance_R2 : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  abs_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))) <= distance_R2 p c.
admit.
Qed.

(** Helper: from abs(t)<r and r>0 infer t<r **)
(** LATEX VERSION: If abs(t) < r and r is positive then t < r. **)
Theorem abs_SNoLt_imp_lt : forall t r:set,
  SNo t ->
  SNo r ->
  0 < r ->
  abs_SNo t < r ->
  t < r.
admit.
Qed.

(** Helper: from abs(t)<r and r>0 infer -t<r **)
(** LATEX VERSION: If abs(t) < r and r is positive then -t < r. **)
Theorem abs_SNoLt_imp_neg_lt : forall t r:set,
  SNo t ->
  SNo r ->
  0 < r ->
  abs_SNo t < r ->
  minus_SNo t < r.
admit.
Qed.

(** helper: propagate strict lower bound through an abs-difference bound **)
(** If a < x-r and abs(x-y) < r with r>0, then a < y. **)
Theorem SNoLt_of_abs_diff_and_margin : forall a x y r:set,
  SNo a ->
  SNo x ->
  SNo y ->
  SNo r ->
  0 < r ->
  a < add_SNo x (minus_SNo r) ->
  abs_SNo (add_SNo x (minus_SNo y)) < r ->
  a < y.
admit.
Qed.

(** Helper: distance bound gives x coordinate abs bound **)
(** LATEX VERSION: If d(p,x) < r then abs(xp-xx) < r. **)
Theorem abs_xcoord_lt_of_distance_lt : forall p x r:set,
  p :e EuclidPlane ->
  x :e EuclidPlane ->
  r :e R ->
  Rlt (distance_R2 p x) r ->
  abs_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord x))) < r.
admit.
Qed.

(** Helper: distance bound gives y coordinate abs bound **)
(** LATEX VERSION: If d(p,x) < r then abs(yp-yx) < r. **)
Theorem abs_ycoord_lt_of_distance_lt : forall p x r:set,
  p :e EuclidPlane ->
  x :e EuclidPlane ->
  r :e R ->
  Rlt (distance_R2 p x) r ->
  abs_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord x))) < r.
admit.
Qed.

(** from 13 Example 4: distance from a point to itself is 0 **)
(** LATEX VERSION: d(p,p) = 0. **)
Theorem distance_R2_refl_0 : forall p:set, p :e EuclidPlane -> distance_R2 p p = 0.
admit.
Qed.

(** from 13 Example 4: symmetry of Euclidean distance in R^2 **)
(** LATEX VERSION: The distance function satisfies d(p,c)=d(c,p). **)
Theorem distance_R2_sym : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c = distance_R2 c p.
admit.
Qed.

(** helper: nonnegative and nonzero implies positive **)
Theorem SNo_nonneg_ne0_pos : forall x:set,
  SNo x -> 0 <= x -> x <> 0 -> 0 < x.
admit.
Qed.

(** helper: strict inequality is preserved by squaring for nonnegative numbers **)
Theorem SNoLt_sqr_nonneg : forall x y:set,
  SNo x -> SNo y -> 0 <= x -> 0 <= y -> x < y ->
  mul_SNo x x < mul_SNo y y.
admit.
Qed.

(** helper: for nonnegative numbers, an inequality on squares implies an inequality **)
Theorem SNo_nonneg_sqr_Le_imp_Le : forall x y:set,
  SNo x -> SNo y -> 0 <= x -> 0 <= y ->
  mul_SNo x x <= mul_SNo y y -> x <= y.
admit.
Qed.

(** helper: two-variable Cauchy-Schwarz inequality in squared form **)
Theorem CauchySchwarz2_sq : forall a b c d:set,
  SNo a -> SNo b -> SNo c -> SNo d ->
  mul_SNo (add_SNo (mul_SNo a c) (mul_SNo b d))
         (add_SNo (mul_SNo a c) (mul_SNo b d))
  <= mul_SNo (add_SNo (mul_SNo a a) (mul_SNo b b))
            (add_SNo (mul_SNo c c) (mul_SNo d d)).
admit.
Qed.

(** helper: triangle inequality for distance_R2 in Rle form **)
(** LATEX VERSION: For points x,y,z in R^2, d(x,z) <= d(x,y) + d(y,z). **)
(** SUSPICIOUS THEOREM: This requires Minkowski style inequalities; it is not proved in this development yet. **)
(** helper: squared Minkowski inequality for distance_R2 **)
Theorem distance_R2_triangle_sqr_Le : forall x y z:set,
  x :e EuclidPlane -> y :e EuclidPlane -> z :e EuclidPlane ->
  mul_SNo (distance_R2 x z) (distance_R2 x z)
  <= mul_SNo (add_SNo (distance_R2 x y) (distance_R2 y z))
            (add_SNo (distance_R2 x y) (distance_R2 y z)).
admit.
Qed.
Theorem distance_R2_triangle_Rle : forall x y z:set,
  x :e EuclidPlane -> y :e EuclidPlane -> z :e EuclidPlane ->
  Rle (distance_R2 x z) (add_SNo (distance_R2 x y) (distance_R2 y z)).
admit.
Qed.

(** helper: distance_R2 = 0 implies equality of points **)
(** LATEX VERSION: In , d(p,c)=0 implies p=c. **)
Theorem distance_R2_eq0 : forall p c:set,
  p :e EuclidPlane -> c :e EuclidPlane ->
  distance_R2 p c = 0 -> p = c.
admit.
Qed.

(** helper: distance_R2 is never negative **)
(** LATEX VERSION: d(p,c) is not < 0. **)
Theorem distance_R2_not_Rlt_0 : forall p c:set,
  p :e EuclidPlane -> c :e EuclidPlane -> ~(Rlt (distance_R2 p c) 0).
admit.
Qed.

(** from 13 Example 4: circular region basis elements in EuclidPlane **)
(** LATEX VERSION: Circular regions: sets of the form {p in R^2 | d(p,c) < r} with c in R^2 and 0<r. **)
Definition circular_regions : set :=
  {U :e Power EuclidPlane |
     exists c:set, exists r:set,
       c :e EuclidPlane /\ Rlt 0 r /\
       U = {p :e EuclidPlane|Rlt (distance_R2 p c) r}}.

(** helper for 13 Example 4: introduce a circular region from center and radius **)
(** LATEX VERSION: If cR^2 and 0<r then {pR^2|d(p,c)<r} is a circular region. **)
Theorem circular_regionI : forall c r:set,
  c :e EuclidPlane ->
  Rlt 0 r ->
  {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e circular_regions.
admit.
Qed.

(** from 13 Example 4: rectangular region basis elements in EuclidPlane **)
(** LATEX VERSION: Rectangular regions: axis-parallel rectangles (a,b)x(c,d) in R^2 described by inequalities on coordinates. **)
Definition rectangular_regions : set :=
  {U :e Power EuclidPlane |
     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
       U = {p :e EuclidPlane|
              exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}}.

(** helper for 13 Example 4: introduce a rectangular region from endpoints **)
(** LATEX VERSION: If a<b and c<d then {(x,y)R^2|a<x<b and c<y<d} is a rectangular region. **)
Theorem rectangular_regionI : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  Rlt a b -> Rlt c d ->
  {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e rectangular_regions.
admit.
Qed.

(** Helper: for any positive real d, some eps_N is smaller than d **)
Theorem exists_eps_lt_pos_Euclid : forall d:set, d :e R -> Rlt 0 d -> exists N :e omega, eps_ N < d.
admit.
Qed.

(** Helper: choose a single eps below two positive reals **)
(** LATEX VERSION: Given two positive real numbers, there is a positive eps radius smaller than both. **)
Theorem exists_eps_lt_two_pos_Euclid : forall a b:set,
  a :e R -> b :e R ->
  Rlt 0 a -> Rlt 0 b ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\ Rlt r3 a /\ Rlt r3 b.
admit.
Qed.

(** Helper: choose a single eps below four positive reals **)
(** LATEX VERSION: Given finitely many positive reals, there is a positive eps radius smaller than all of them. **)
Theorem exists_eps_lt_four_pos_Euclid : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  Rlt 0 a -> Rlt 0 b -> Rlt 0 c -> Rlt 0 d ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\ Rlt r3 a /\ Rlt r3 b /\ Rlt r3 c /\ Rlt r3 d.
admit.
Qed.

(** Helper: if a <= b and b < c then a < c **)
Theorem Rle_Rlt_tra_Euclid : forall a b c:set, Rle a b -> Rlt b c -> Rlt a c.
admit.
Qed.

(** helper for 13 Example 4: two-ball refinement around a point **)
(** LATEX VERSION: If x lies in two open balls B(c1,r1) and B(c2,r2), then there is a smaller ball B(x,r3) contained in their intersection. **)
(** SUSPICIOUS THEOREM: The intended proof needs a triangle inequality for distance_R2 and monotonicity style estimates for sqrt and squares; those are not yet available here, so this lemma is currently admitted. **)
(** NOTE: An automated proof attempt at this admit timed out. **)
Theorem ball_refine_two_balls :
  forall x c1 c2 r1 r2:set,
    x :e EuclidPlane ->
    c1 :e EuclidPlane ->
    c2 :e EuclidPlane ->
    Rlt 0 r1 ->
    Rlt 0 r2 ->
    Rlt (distance_R2 x c1) r1 ->
    Rlt (distance_R2 x c2) r2 ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set,
        p :e EuclidPlane ->
        Rlt (distance_R2 p x) r3 ->
        Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2).
admit.
Qed.

(** helper for 13 Example 4: from two-sided bounds to an abs bound **)
(** LATEX VERSION: If y-r < x < y+r and r>0 then |x-y| < r. **)
Theorem abs_diff_lt_of_between : forall x y r:set,
  x :e R ->
  y :e R ->
  r :e R ->
  Rlt 0 r ->
  Rlt (add_SNo y (minus_SNo r)) x ->
  Rlt x (add_SNo y r) ->
  abs_SNo (add_SNo x (minus_SNo y)) < r.
admit.
Qed.

(** helper for 13 Example 4: distance bounded by sum of coordinate absolute differences **)
(** LATEX VERSION: In R2, d(p,c) is at most |xp-xc| plus |yp-yc|. **)
Theorem distance_R2_le_absdx_plus_absdy : forall p c:set,
  p :e EuclidPlane ->
  c :e EuclidPlane ->
  distance_R2 p c
  <= add_SNo (abs_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
            (abs_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))).
admit.
Qed.

(** helper for 13 Example 4: rectangle inside a ball around a center **)
(** LATEX VERSION: Every point x in a ball B(c,r0) has a rectangular neighborhood contained in B(c,r0). **)
Theorem rectangle_inside_ball :
  forall x c r0:set,
    x :e EuclidPlane ->
    c :e EuclidPlane ->
    Rlt 0 r0 ->
    Rlt (distance_R2 x c) r0 ->
    exists r :e rectangular_regions,
      x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
admit.
Qed.

(** helper for 13 Example 4: ball inside a rectangle around a point **)
(** LATEX VERSION: Every point x in a rectangle has a circular neighborhood contained in it. **)
(** NOTE: This lemma is proved below using abs bounds from distance_R2 and epsilon selection below finitely many positive margins. **)
Theorem ball_inside_rectangle :
  forall b x:set,
    b :e rectangular_regions ->
    x :e EuclidPlane ->
    x :e b ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b).
admit.
Qed.

(** from 13 Example 4: circular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of circular regions is a basis for a topology on R^2. **)
Theorem circular_regions_basis_plane : basis_on EuclidPlane circular_regions.
admit.
Qed.

(** from 13 Example 4: rectangular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of axis-parallel open rectangles is a basis for a topology on R^2. **)
Theorem rectangular_regions_basis_plane : basis_on EuclidPlane rectangular_regions.
admit.
Qed.

(** from 13 Example 4: circular and rectangular bases generate the same topology **)
(** LATEX VERSION: The topology generated by circular regions equals the topology generated by rectangular regions in R^2. **)
(** LATEX VERSION: This is shown by local refinement in both directions: each circular neighborhood contains a rectangular one, and each rectangular neighborhood contains a circular one. **)

(** from 13 Example 4: rectangular neighborhoods inside circular neighborhoods **)
(** LATEX VERSION: For any point x in a circular region, there is an open rectangle containing x and contained in that circular region. **)
Theorem rectangular_refines_circular_plane :
  forall b :e circular_regions, forall x:set,
    x :e b -> exists r :e rectangular_regions, x :e r /\ r c= b.
admit.
Qed.

(** from 13 Example 4: circular neighborhoods inside rectangular neighborhoods **)
(** LATEX VERSION: For any point x in an open rectangle, there is a circular region containing x and contained in that rectangle. **)
Theorem circular_refines_rectangular_plane :
  forall b :e rectangular_regions, forall x:set,
    x :e b -> exists u :e circular_regions, x :e u /\ u c= b.
admit.
Qed.
Theorem circular_rectangular_same_topology_plane :
  generated_topology EuclidPlane circular_regions = generated_topology EuclidPlane rectangular_regions.
admit.
Qed.

(** from 13: refinement of basis yields finer topology **) 
(** LATEX VERSION: If B refines every open set of the topology generated by B, then T(B) is finer than T(B). **)
Theorem lemma_finer_if_basis_refines : forall X B B':set,
  basis_on X B -> basis_refines X B' (generated_topology X B) ->
  finer_than (generated_topology X B') (generated_topology X B).
admit.
Qed.

(** from 13 Definition: subbasis and its generated topology **) 
(** LATEX VERSION: A subbasis S for a topology on X is a collection of subsets of X whose union equals X. **)
(** SUSPICIOUS DEFINITION: The condition is `Union S = X`; in later uses it is easy to accidentally only show `Union S c= X`, which is weaker. **)
(** REVIEWED: Keep the equality form; it matches the LATEX VERSION and avoids silently weakening later lemmas. **)
Definition subbasis_on : set -> set -> prop := fun X S =>
  S c= Power X /\ Union S = X.

(** from 13: finite intersections of subbasis elements **)
(** LATEX VERSION: intersection_of_family collects common points of all sets in a family; finite_subcollections picks finite families; finite_intersections_of X S takes intersections of finite subfamilies of S. **)
(** FIXED: Now takes ambient set X as first parameter. Empty family correctly gives X; nonempty Fam gives the usual intersection inside X. **)
(** SUSPICIOUS DEFINITION: `intersection_of_family X Fam` does not require `Fam c= Power X`; it relies on the ambient restriction `x :e X` to force the intersection to lie in X. **)
(** REVIEWED: Matches the intended set theoretic intersection inside X; separate hypotheses on Fam are carried where needed. **)
Definition intersection_of_family : set -> set -> set :=
  fun X Fam => {x :e X|forall U:set, U :e Fam -> x :e U}.

(** from 13: finite subcollections of a family **)
(** LATEX VERSION: finite_subcollections S is the collection of finite subfamilies F of S. **)
Definition finite_subcollections : set -> set :=
  fun S => {F :e Power S|finite F}.

(** helper: introduction and eliminations for intersection_of_family **)
Theorem intersection_of_familyI : forall X Fam x:set,
  x :e X ->
  (forall U:set, U :e Fam -> x :e U) ->
  x :e intersection_of_family X Fam.
admit.
Qed.
Theorem intersection_of_familyE1 : forall X Fam x:set,
  x :e intersection_of_family X Fam -> x :e X.
admit.
Qed.
Theorem intersection_of_familyE2 : forall X Fam x:set,
  x :e intersection_of_family X Fam ->
  forall U:set, U :e Fam -> x :e U.
admit.
Qed.

(** from 13: finite intersections generated by a family **)
(** LATEX VERSION: For a family S of subsets of X, the finite intersections of S are the sets of the form F where F ranges over finite subcollections of S (interpreting the empty intersection as X). **)
(** FIXED: Now takes X to pass to intersection_of_family. **)
Definition finite_intersections_of : set -> set -> set := fun X S =>
  {intersection_of_family X F|F :e finite_subcollections S}.

(** from 13: basis obtained from a subbasis by finite intersections **)
(** LATEX VERSION: basis_of_subbasis X S is the set of nonempty finite intersections of elements of S. **)
(** FIXED: Now properly uses X parameter. Empty intersection gives X; the filter keeps only nonempty intersections. **)
(** SUSPICIOUS DEFINITION: `basis_of_subbasis` removes `Empty`; this matches the usual convention but means `X` appears only via the empty intersection and only when `X <> Empty`. **)
(** REVIEWED: This matches the standard nonempty finite intersections basis construction; the empty intersection case is handled separately via X_in_basis_of_subbasis when needed. **)
Definition basis_of_subbasis : set -> set -> set := fun X S =>
  {b :e finite_intersections_of X S | b <> Empty}.

(** Helper: Finite intersection of a family is in the basis_of_subbasis **)
Theorem finite_intersection_in_basis : forall X S F:set,
  F :e finite_subcollections S ->
  intersection_of_family X F <> Empty ->
  intersection_of_family X F :e basis_of_subbasis X S.
admit.
Qed.

(** Helper: empty family intersection equals X **)
Theorem intersection_of_family_empty_eq : forall X:set,
  intersection_of_family X Empty = X.
admit.
Qed.

(** Helper: singleton family intersection equals the set when it is a subset of X **)
Theorem intersection_of_family_singleton_eq : forall X s:set,
  s c= X ->
  intersection_of_family X {s} = s.
admit.
Qed.

(** Helper: Elements of subbasis are in the generated basis **)
Theorem subbasis_elem_in_basis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s <> Empty ->
  s :e basis_of_subbasis X S.
admit.
Qed.

(** Helper: X itself (empty intersection) is in the basis when nonempty **)
Theorem X_in_basis_of_subbasis : forall X S:set,
  X <> Empty ->
  X :e basis_of_subbasis X S.
admit.
Qed.

(** Helper: Finite intersection of topology elements is in the topology **)
Theorem intersection_of_family_adjoin : forall X F U:set,
  intersection_of_family X (F :\/: {U}) = (intersection_of_family X F) :/\: U.
admit.
Qed.
Theorem finite_intersection_in_topology : forall X T F:set,
  topology_on X T ->
  F :e Power T ->
  finite F ->
  intersection_of_family X F :e T.
admit.
Qed.

(** from 13: topology generated by a subbasis **) 
(** LATEX VERSION: generated_topology_from_subbasis X S is the topology generated by the basis arising from S. **)
Definition generated_topology_from_subbasis : set -> set -> set :=
  fun X S => generated_topology X (basis_of_subbasis X S).

(** from 13: finite intersections of a subbasis form a basis **) 
(** LATEX VERSION: The set of nonempty finite intersections of subbasis elements forms a basis. **)
Theorem finite_intersections_basis_of_subbasis : forall X S:set,
  subbasis_on X S -> basis_on X (basis_of_subbasis X S).
admit.
Qed.

(** from 13: topology generated by a subbasis is a topology **) 
(** LATEX VERSION: The topology generated from a subbasis S on X satisfies the topology axioms. **)
Theorem topology_from_subbasis_is_topology : forall X S:set,
  subbasis_on X S -> topology_on X (generated_topology_from_subbasis X S).
admit.
Qed.

(** from 13: generated topology from subbasis is minimal among topologies containing S **) 
(** LATEX VERSION: Among all topologies containing a subbasis S, the generated one is the smallest/finer-than criterion. **)
Theorem topology_generated_by_basis_is_minimal : forall X S T:set,
  subbasis_on X S -> topology_on X T -> S c= T ->
  finer_than T (generated_topology_from_subbasis X S).
admit.
Qed.

(** from 13 Exercise 1: local openness implies set is open **)
(** LATEX VERSION: Exercise 1: If every xA lies in some open UA, then A is open. **)
Theorem ex13_1_local_open_subset : forall X T A:set,
  topology_on X T ->
  (forall x :e A, exists U :e T, x :e U /\ U c= A) ->
  open_in X T A.
admit.
Qed.

(** from 13 Exercise 2: comparison of nine topologies on {a,b,c} **) 
(** LATEX VERSION: Exercise 2 constructs nine topologies on {a,b,c} and compares which are topologies and their fineness relations. **)
Definition a_elt : set := Empty.
Definition b_elt : set := {Empty}.
Definition c_elt : set := {{Empty}}.
(** FIXED: Use binunion to create proper 3-element set {a,b,c}; old UPair a_elt (UPair b_elt c_elt) gave {a,{b,c}}, new UPair a_elt b_elt :\/: {c_elt} gives {a,b,c}. **)
Definition abc_set : set := UPair a_elt b_elt :\/: {c_elt}.

(** from 13 Exercise 2: topology on three element set **)
(** LATEX VERSION: One of the nine candidate families is the indiscrete topology {Empty, X}. **)
Definition top_abc_1 : set := UPair Empty abc_set.
(** from 13 Exercise 2: topology on three element set **)
(** LATEX VERSION: One of the nine candidate families is the discrete topology Power(X). **)
Definition top_abc_2 : set := Power abc_set.
(** FIXED: Nested `UPair` does not create a 3- or 4-element family; use unions with singletons. **)
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {a}, {a,b,c}}. **)
Definition top_abc_3 : set := UPair Empty {a_elt} :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {b}, {a,b,c}}. **)
Definition top_abc_4 : set := UPair Empty {b_elt} :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {c}, {a,b,c}}. **)
Definition top_abc_5 : set := UPair Empty {c_elt} :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {a,b}, {a,b,c}}. **)
Definition top_abc_6 : set := UPair Empty (UPair a_elt b_elt) :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {a,c}, {a,b,c}}. **)
Definition top_abc_7 : set := UPair Empty (UPair a_elt c_elt) :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {b,c}, {a,b,c}}. **)
Definition top_abc_8 : set := UPair Empty (UPair b_elt c_elt) :\/: {abc_set}.
  (** from 13 Exercise 2: topology on three element set **)
  (** LATEX VERSION: One of the nine candidate families of open sets on {a,b,c} is {Empty, {a}, {a,b}, {a,b,c}}. **)
Definition top_abc_9 : set := (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) :\/: {abc_set}.

(** Helper: topology of the form {Empty, A, X} **)
Theorem topology_three_sets : forall X A:set,
  A c= X ->
  topology_on X (UPair Empty A :\/: {X}).
admit.
Qed.

(** Helper: topology of the form {Empty, A, B, X} with A c= B c= X **)
Theorem topology_chain_four_sets : forall X A B:set,
  A c= B ->
  B c= X ->
  topology_on X ((UPair Empty A :\/: {B}) :\/: {X}).
admit.
Qed.
Theorem ex13_2_compare_nine_topologies :
  topology_on abc_set top_abc_1 /\ topology_on abc_set top_abc_2 /\
  topology_on abc_set top_abc_3 /\ topology_on abc_set top_abc_4 /\
  topology_on abc_set top_abc_5 /\ topology_on abc_set top_abc_6 /\
  topology_on abc_set top_abc_7 /\ topology_on abc_set top_abc_8 /\
  topology_on abc_set top_abc_9 /\
  exists finer_pairs:set,
    finer_pairs =
      {p :e Power (Power (Power abc_set))|
         exists T1 T2:set, p = setprod T1 T2 /\
           (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
            T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
            T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
           (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
            T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
           T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
           T1 c= T2}.
admit.
Qed.

(** from 13 Exercise 2: some basic fineness relations between the nine examples **)
(** LATEX VERSION: Exercise 2 asks to compare the nine topologies by inclusion (finer/coarser). **)
Theorem top_abc_3_finer_than_top_abc_1 : finer_than top_abc_3 top_abc_1.
admit.
Qed.
Theorem top_abc_2_finer_than_top_abc_3 : finer_than top_abc_2 top_abc_3.
admit.
Qed.
Theorem top_abc_9_finer_than_top_abc_3 : finer_than top_abc_9 top_abc_3.
admit.
Qed.
Theorem top_abc_9_finer_than_top_abc_6 : finer_than top_abc_9 top_abc_6.
admit.
Qed.

(** helper for 13 exercises: intersection of a family of topologies **)
(** LATEX VERSION: Intersection_Fam X Fam denotes the intersection (common opens) of all topologies in Fam. **)
(** FIXED: `Intersection_Fam X Fam` is the collection of common open sets, as subsets of the given ambient set `X`; for `Fam = Empty`, `Intersection_Fam X Fam = Power X`. **)
(** SUSPICIOUS DEFINITION: This does not assert that members of `Fam` are topologies on `X`; that must be carried as a separate hypothesis when needed. **)
(** REVIEWED: This is the intended common open sets operator; hypotheses about each member being a topology are carried separately in later theorems. **)
Definition Intersection_Fam : set -> set -> set :=
  fun X Fam => {U :e Power X|forall T:set, T :e Fam -> U :e T}.

(** helper: empty family gives discrete topology **)
Theorem Intersection_Fam_empty_eq : forall X Fam:set,
  ~(exists T:set, T :e Fam) ->
  Intersection_Fam X Fam = Power X.
admit.
Qed.

(** helper: intersection of a family stays within X (updated for new signature) **)
Theorem intersection_of_family_sub_X : forall X Fam:set,
  intersection_of_family X Fam c= X.
admit.
Qed.

(** helper: empty set is in intersection family when all members contain Empty **)
Theorem intersection_of_family_empty : forall Fam:set,
  (forall T:set, T :e Fam -> Empty :e T) ->
  forall X:set, Empty :e Intersection_Fam X Fam.
admit.
Qed.

(** from 12 Exercises Item 3: countable complement topology and Tinfty **) 
(** LATEX VERSION: Show that the collection Tc from Example 4 of 12 is a topology on X. Is the collection Tinfty = {U | X-U is infinite or empty or all of X} a topology on X. **)
Definition infinite_complement_family : set -> set :=
  fun X => {U :e Power X | infinite (X :\: U) \/ U = Empty \/ U = X}.

(** LATEX VERSION: Exercise 3: The countable-complement topology Tc on X is a topology. **)
Theorem ex13_3a_Tc_topology : forall X:set, topology_on X (countable_complement_topology X).
admit.
Qed.

(** helper: nonempty open sets in T_c have countable complement **) 
Theorem ex13_3a_countable_complement_open : forall X:set, forall U :e countable_complement_topology X,
  U <> Empty -> countable (X :\: U).
admit.
Qed.

(** helper: unions of Tc open families remain Tc-open **) 
Theorem ex13_3a_union_helper : forall X:set, forall UFam :e Power (countable_complement_topology X),
  Union UFam :e countable_complement_topology X.
admit.
Qed.

(** helper: removing a finite subset from an infinite set leaves an infinite set **)
(** LATEX VERSION: If X is infinite and F is finite, then X\\F is infinite. **)
Theorem infinite_setminus_finite : forall X F:set,
  infinite X -> finite F -> infinite (X :\: F).
admit.
Qed.

(** helper: infinite sets are nonempty **)
(** LATEX VERSION: (set theory) An infinite set cannot be empty. **)
Theorem infinite_nonempty : forall X:set, infinite X -> exists x:set, x :e X.
admit.
Qed.

(** helper: unordered pairs are finite **)
(** LATEX VERSION: (set theory) A two-element set {a,b} is finite. **)
Theorem finite_UPair : forall a b:set, finite (UPair a b).
admit.
Qed.

(** helper: removing two points from an infinite set leaves an infinite set **)
(** LATEX VERSION: (set theory) If X is infinite then X\\{a,b} is infinite. **)
Theorem infinite_remove2 : forall X a b:set, infinite X -> infinite (X :\: UPair a b).
admit.
Qed.

(** helper: infinite sets contain two distinct elements **)
(** LATEX VERSION: (set theory) If X is infinite then there exist a,b in X with a  b. **)
Theorem infinite_two_distinct : forall X:set,
  infinite X -> exists a b:set, a :e X /\ b :e X /\ ~(a = b).
admit.
Qed.

(** helper: infinite minus finite is nonempty **)
(** LATEX VERSION: (set theory) If X is infinite and F is finite then X\\F is nonempty. **)
Theorem infinite_setminus_finite_nonempty : forall X F:set,
  infinite X -> finite F -> exists x:set, x :e X :\: F.
admit.
Qed.

(** helper: removing one point from an infinite set leaves an infinite set (proved in topology section) **)
(** LATEX VERSION: (set theory) If X is infinite then X\\{y} is infinite. **)
Theorem infinite_remove1_top : forall X y:set, infinite X -> infinite (X :\: {y}).
admit.
Qed.

(** LATEX VERSION: Exercise 3: For infinite X, Tinfty is not a topology (union-closure fails). **)
Theorem ex13_3b_Tinfty_not_topology : forall X:set,
  infinite X ->
  ~topology_on X (infinite_complement_family X).
admit.
Qed.

(** helper: structured witness outline for Tinfty failure, for infinite ambient sets **) 
Theorem ex13_3b_witness_outline : forall X:set,
  infinite X -> exists U V:set, U :e infinite_complement_family X /\ V :e infinite_complement_family X.
admit.
Qed.

(** from 13 Exercise 4(a): intersection of topologies **)
(** LATEX VERSION: Exercise 4(a): The intersection of a nonempty family of topologies on X is a topology. **)
Theorem ex13_4a_intersection_topology : forall X Fam:set,
  (exists T:set, T :e Fam) ->
  (forall T :e Fam, topology_on X T) ->
  topology_on X (Intersection_Fam X Fam).
admit.
Qed.

(** from 13 Exercise 4(b): smallest/largest topology containing a family **) 
(** LATEX VERSION: Exercise 4(b): There exist smallest and largest topologies containing a given family of topologies on X. **)
Theorem ex13_4b_smallest_largest : forall X Fam:set,
  (forall T :e Fam, topology_on X T) ->
  exists Tmin, topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T') /\
  exists Tmax, topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax).
admit.
Qed.

(** from 13 Exercise 4(c): specific smallest/largest topology on {a,b,c} **) 
(** LATEX VERSION: Exercise 4(c): Determine the smallest and largest topologies on {a,b,c} containing given families (continuation of Exercise 4). **)
Theorem ex13_4c_specific_topologies :
  exists Tsmall Tall:set, topology_on abc_set Tsmall /\ topology_on abc_set Tall.
admit.
Qed.

(** from 13 Exercise 5: topology generated by a basis is intersection of topologies containing it **) 
(** LATEX VERSION: Exercise 5: The topology generated by a basis A equals the intersection of all topologies on X containing A. **)
Theorem ex13_5_basis_intersection : forall X A:set,
  basis_on X A ->
  generated_topology X A =
    Intersection_Fam X {T :e Power (Power X)|topology_on X T /\ A c= T}.
admit.
Qed.

(** from 13 Exercise 6: incomparability of two real line topologies **)
(** LATEX VERSION: Exercise 6: Compare the standard, lower limit, and K-topologies on ; standard vs lower-limit and standard vs K are incomparable. **)
(** FIXED: Now uses proper rational definition (same as Q); rational = {x :e real | exists m :e int, exists n :e omega\\{0}, x = m/n} from line 6202. **)
(** NOTE: `rational_numbers` is an alias of `Q`. **)
Definition rational_numbers : set := Q.

(** from 13: rationals are reals **)
(** LATEX VERSION: Q is a subset of R. **)
Theorem rational_numbers_Subq_R : rational_numbers c= R.
admit.
Qed.

(** from 13: elements of Q are in R **)
(** LATEX VERSION: If q is rational then q is real. **)
Theorem rational_numbers_in_R : forall q :e rational_numbers, q :e R.
admit.
Qed.

(** from 13: open intervals in  **)
(** LATEX VERSION: For a<b in , the open interval (a,b) is {x | a<x and x<b}. **)
Definition open_interval : set -> set -> set := fun a b => {x :e R|Rlt a x /\ Rlt x b}.
(** SUSPICIOUS DEFINITION: The endpoints `a,b` are not required to be in `R` explicitly; membership uses `Rlt` so ill-typed endpoints make the interval behave like `Empty`. **)
(** REVIEWED: This matches the LATEX version via `Rlt`; endpoints are effectively constrained when the interval is nonempty. **)

(** helper: membership in open_interval implies left endpoint is real **)
(** LATEX VERSION: If x(a,b), then a is a real number (since a<x in ). **)
Theorem open_interval_left_in_R : forall a b x:set, x :e open_interval a b -> a :e R.
admit.
Qed.

(** helper: membership in open_interval implies right endpoint is real **)
(** LATEX VERSION: If x(a,b), then b is a real number (since x<b in ). **)
Theorem open_interval_right_in_R : forall a b x:set, x :e open_interval a b -> b :e R.
admit.
Qed.
(** from 13 Exercise 6: lower limit basis element **)
(** LATEX VERSION: Lower limit topology uses half open intervals [a,b). **)
Definition halfopen_interval_left : set -> set -> set := fun a b => {x :e R|~(Rlt x a) /\ Rlt x b}.

(** from 13 Exercise 7: upper limit basis element **)
(** LATEX VERSION: Upper limit topology uses half open intervals (a,b]. **)
Definition halfopen_interval_right : set -> set -> set := fun a b => {x :e R|Rlt a x /\ ~(Rlt b x)}.
(** SUSPICIOUS DEFINITION: These half-open intervals use `~(Rlt x a)` and `~(Rlt b x)` as non-strict bounds; later proofs rely on the linearity of `<` on `R` to relate this to equality. **)
(** REVIEWED: This is the intended encoding using strict order and classical negation; order lemmas later connect this to the usual weak inequalities. **)

(** from 13 Exercise 7: upper limit interval is a subset of R **)
(** LATEX VERSION: (a,b] is a subset of R. **)
Theorem halfopen_interval_right_Subq_R : forall a b:set, halfopen_interval_right a b c= R.
admit.
Qed.

(** from 13 Exercise 7: right endpoint belongs to (a,b] when a<b **)
(** LATEX VERSION: If a<b then b is in (a,b]. **)
Theorem halfopen_interval_right_rightmem : forall a b:set, Rlt a b -> b :e halfopen_interval_right a b.
admit.
Qed.

(** from 13 Exercise 6: open interval is a subset of  **)
(** LATEX VERSION: (a,b) is a subset of . **)
Theorem open_interval_Subq_R : forall a b:set, open_interval a b c= R.
admit.
Qed.

(** from 13: every real lies in some standard open interval **)
(** LATEX VERSION: For any x in R, x is contained in (x-1,x+1). **)
Theorem real_in_open_interval_minus1_plus1 : forall x:set,
  x :e R ->
  x :e open_interval (add_SNo x (minus_SNo 1)) (add_SNo x 1).
admit.
Qed.

(** from 13 Exercise 6: half open interval is a subset of  **)
(** LATEX VERSION: [a,b) is a subset of . **)
Theorem halfopen_interval_left_Subq_R : forall a b:set, halfopen_interval_left a b c= R.
admit.
Qed.

(** from 13 Exercise 6: left endpoint belongs to [a,b) when a<b **)
(** LATEX VERSION: If a<b then a[a,b). **)
Theorem halfopen_interval_left_leftmem : forall a b:set, Rlt a b -> a :e halfopen_interval_left a b.
admit.
Qed.

(** helper: if a <= x then [x,b) c= [a,b) **)
(** LATEX VERSION: If ax<b then [x,b)  [a,b). **)
Theorem halfopen_interval_left_leftmonotone : forall a x b:set,
  a :e R -> x :e R -> b :e R ->
  Rle a x ->
  halfopen_interval_left x b c= halfopen_interval_left a b.
admit.
Qed.

  (** from 13 Definition: standard topology basis on R **)
  (** LATEX VERSION: If B is the collection of all open intervals (a,b) in R, the topology generated by B is the standard topology on R. **)
Definition R_standard_basis : set :=
  \/_ a :e R, {open_interval a b|b :e R}.

  (** from 13 Definition: standard topology on R **)
  (** LATEX VERSION: The topology generated by the open-interval basis is called the standard topology on R. **)
Definition R_standard_topology : set :=
  generated_topology R R_standard_basis.
(** SUSPICIOUS DEFINITION: This basis includes all `open_interval a b` with `a,b :e R` without requiring `Rlt a b`; empty intervals are allowed as basis elements, which is harmless but can complicate refinement arguments. **)
(** REVIEWED: Allowing empty basis elements is harmless for generated_topology; refinement proofs should explicitly use `Rlt a b` when nonempty intervals are needed. **)

(** Helper: unfold the definition of the standard topology on R. **)
Theorem R_standard_topology_def_eq : R_standard_topology = generated_topology R R_standard_basis.
admit.
Qed.

(** from 13: standard open intervals form a basis on R **)
(** LATEX VERSION: The collection of open intervals (a,b) is a basis for the standard topology on R. **)
Theorem R_standard_basis_is_basis_local : basis_on R R_standard_basis.
admit.
Qed.

(** helper: any open interval is open in the standard topology **)
(** LATEX VERSION: Every interval (a,b) is open in the standard topology on . **)
Theorem open_interval_in_R_standard_topology : forall a b:set,
  Rlt a b -> open_interval a b :e R_standard_topology.
admit.
Qed.

(** from 13: the standard topology on R is a topology **)
(** LATEX VERSION: The topology generated by the standard basis satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology_local : topology_on R R_standard_topology.
admit.
Qed.

(** helper: open set in R_standard_topology contains a basic open interval **)
(** LATEX VERSION: If U is open and xU, then some open interval (a,b) satisfies x(a,b)U. **)
Theorem R_standard_open_refine_interval : forall U x:set,
  U :e R_standard_topology ->
  x :e U ->
  exists a b:set,
    a :e R /\ b :e R /\
    x :e open_interval a b /\
    open_interval a b c= U /\
    Rlt a x /\ Rlt x b.
admit.
Qed.

  (** from 13 Definition: lower limit topology basis on R **)
  (** LATEX VERSION: If B' is the collection of all half-open intervals [a,b) in R with a<b, the topology generated by B' is the lower limit topology on R. **)
Definition R_lower_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_left a b|b :e R}.

  (** from 13 Definition: lower limit topology on R **)
  (** LATEX VERSION: When R is given the lower limit topology, it is denoted R_l. **)
Definition R_lower_limit_topology : set :=
  generated_topology R R_lower_limit_basis.

  (** from 13: the described families are bases **)
  (** LATEX VERSION: It is easy to see the half-open interval family is a basis; intersections are basis elements or empty. **)
  (** helper: the lower limit basis is a basis on R **)
Theorem R_lower_limit_basis_is_basis_local : basis_on R R_lower_limit_basis.
admit.
Qed.

(** from 13: the lower limit topology on R is a topology **)
(** LATEX VERSION: The topology generated by the lower limit basis satisfies the topology axioms. **)
Theorem R_lower_limit_topology_is_topology : topology_on R R_lower_limit_topology.
admit.
Qed.

(** Helper: half-open intervals [a,b) are open in the lower limit topology **)
(** LATEX VERSION: Every basic lower-limit interval [a,b) is open in the topology generated by the lower-limit basis. **)
Theorem halfopen_interval_left_in_R_lower_limit_topology : forall a b:set,
  a :e R -> b :e R ->
  halfopen_interval_left a b :e R_lower_limit_topology.
admit.
Qed.

(** Helper: open intervals (a,b) are open in the lower limit topology **)
(** LATEX VERSION: Every standard open interval (a,b) is a union of half open intervals [x,b) with x in (a,b), hence is open in R_ell. **)
Theorem open_interval_in_R_lower_limit_topology : forall a b:set,
  a :e R -> b :e R ->
  open_interval a b :e R_lower_limit_topology.
admit.
Qed.

(** Helper: the lower limit topology is finer than the standard topology **)
(** LATEX VERSION: Every standard open interval (a,b) is open in R_ell, hence R_ell is finer than the standard topology. **)
Theorem R_lower_limit_finer_than_R_standard : finer_than R_lower_limit_topology R_standard_topology.
admit.
Qed.

(** from 13 Exercise 7: basis for the upper limit topology on R **)
(** LATEX VERSION: The upper limit topology on R is generated by half open intervals (a,b]. **)
Definition R_upper_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_right a b|b :e R}.

(** helper: the upper limit basis is a basis on R **)
Theorem R_upper_limit_basis_is_basis_local : basis_on R R_upper_limit_basis.
admit.
Qed.

(** from 13 Exercise 7: upper limit topology on R **)
(** LATEX VERSION: The upper limit topology is the topology generated by that basis. **)
Definition R_upper_limit_topology : set :=
  generated_topology R R_upper_limit_basis.

(** helper: the upper limit topology on R is a topology **)
Theorem R_upper_limit_topology_is_topology_local : topology_on R R_upper_limit_topology.
admit.
Qed.

(** from 13 Definition: K subset of R via reciprocals **)
(** LATEX VERSION: Let K be the set of all numbers of the form 1/n, for n in Z_+. **)
(** FIXED: Now uses proper reciprocal from line 5762; recip_SNo computes 1/x for surreal numbers (including naturals), so for n, recip_SNo n computes 1/n. **)
Definition inv_nat : set -> set := recip_SNo.

(** helper: 1/n is real for n in omega **)
Theorem inv_nat_real : forall n:set, n :e omega -> inv_nat n :e R.
admit.
Qed.

(** from 13 Exercise 6: the set K={1/n | n in omega and n not 0} used in the K-topology **)
(** LATEX VERSION: Let K={1/n : n in N} as a subset of R (excluding n=0). **)
Definition K_set : set := {inv_nat n|n :e omega :\: {0}}.

(** helper: 0 is not in K_set **)
Theorem zero_not_in_K_set : 0 /:e K_set.
admit.
Qed.

(** helper: 1 is in K_set **)
Theorem one_in_K_set : 1 :e K_set.
admit.
Qed.

(** helper: if x is not in K_set then x is not 1 **)
Theorem not_in_K_set_implies_neq1 : forall x:set, ~(x :e K_set) -> x <> 1.
admit.
Qed.

(** helper: if an interval has empty intersection with K_set then no inv_nat lies in it **)
Theorem inv_nat_not_in_open_interval_of_empty_cap_K_set :
  forall a b:set,
    open_interval a b :/\: K_set = Empty ->
    forall n:set, n :e omega :\: {0} -> ~(inv_nat n :e open_interval a b).
admit.
Qed.

(** helper: K_set is a subset of R **)
Theorem K_set_Subq_R : K_set c= R.
admit.
Qed.

(** helper: elements of K_set are positive reals **)
Theorem inv_nat_pos : forall n:set, n :e omega :\: {0} -> Rlt 0 (inv_nat n).
admit.
Qed.

  (** from 13 Definition: K-topology basis family on R **)
  (** LATEX VERSION: Let K be {1/n | n in Z_+}; let B'' be all open intervals (a,b) and all sets (a,b)-K. **)
Definition R_K_basis : set :=
  \/_ a :e R, {open_interval a b :\: K_set|b :e R}.

  (** from 13 Definition: K-topology on R **)
  (** LATEX VERSION: The topology generated by B'' is called the K-topology on R, denoted R_K. **)
Definition R_K_topology : set :=
  generated_topology R (R_standard_basis :\/: R_K_basis).

  (** from 13: the described families are bases **)
  (** LATEX VERSION: It is easy to see the three collections are bases; intersections are basis elements or empty. **)
  (** helper: the K topology basis is a basis on R **)
Theorem R_standard_plus_K_basis_is_basis_local : basis_on R (R_standard_basis :\/: R_K_basis).
admit.
Qed.

(** helper: the K topology on R is a topology **)
Theorem R_K_topology_is_topology_local : topology_on R R_K_topology.
admit.
Qed.

(** helper: K_set meets any lower limit neighborhood of 0 **)
(** LATEX VERSION: In the lower limit topology, every basic neighborhood [a,b) of 0 contains some element of K={1/n}. **)
Theorem K_set_meets_lower_limit_neighborhood_0 :
  forall a b:set,
    a :e R -> b :e R ->
    ~(Rlt 0 a) ->
    Rlt 0 b ->
    exists y:set, y :e halfopen_interval_left a b /\ y :e K_set.
admit.
Qed.

(** LATEX VERSION: Exercise 6: The lower-limit topology and the K-topology on  are incomparable. **)
Theorem ex13_6_Rl_RK_not_comparable :
  ~finer_than R_lower_limit_topology R_K_topology /\
  ~finer_than R_K_topology R_lower_limit_topology.
admit.
Qed.

(** from 13 Exercise 7: containment relations among five  topologies **) 
(** LATEX VERSION: Exercise 7 lists several standard  topologies and records which contain which (upper limit finer than standard, etc.). **)
Definition R_finite_complement_topology : set := finite_complement_topology R.
Definition R_ray_topology : set :=
  {U :e Power R|U = Empty \/ U = R \/ (exists a :e R, U = {x :e R|Rlt x a})}.

(** from 13 Exercise 7: open rays are open in the standard topology **)
(** LATEX VERSION: The ray (a,) is open in the standard topology on . **)
Theorem open_ray_in_R_standard_topology : forall a:set, a :e R -> {x :e R|Rlt a x} :e R_standard_topology.
admit.
Qed.

(** from 13: left open ray is open in the standard topology on R **)
(** LATEX VERSION: The ray (-infty,b) is open in the standard topology on R. **)
Theorem open_left_ray_in_R_standard_topology : forall b:set, b :e R -> {x :e R|Rlt x b} :e R_standard_topology.
admit.
Qed.

(** from 13: unions of standard open sets are standard open **)
(** LATEX VERSION: Arbitrary unions of open sets are open; in particular, unions of two open sets are open. **)
Theorem binunion_in_R_standard_topology : forall U V:set,
  U :e R_standard_topology ->
  V :e R_standard_topology ->
  U :\/: V :e R_standard_topology.
admit.
Qed.

(** from 13: complement of a point in R equals union of two open rays **)
(** LATEX VERSION: R minus {a} is (-infty,a) union (a,infty). **)
Theorem R_minus_singleton_eq_rays_union : forall a:set, a :e R ->
  R :\: {a,a} = {x :e R|Rlt x a} :\/: {x :e R|Rlt a x}.
admit.
Qed.

(** from 13: complement of a point is open in the standard topology on R **)
(** LATEX VERSION: Since (-infty,a) and (a,infty) are open, their union R minus {a} is open. **)
Theorem R_minus_singleton_in_R_standard_topology : forall a:set, a :e R -> R :\: {a,a} :e R_standard_topology.
admit.
Qed.

(** from 13: complement of a union is intersection of complements **)
(** LATEX VERSION: X minus (A union B) equals (X minus A) intersect (X minus B). **)
Theorem setminus_binunion_eq_binintersect : forall X A B:set,
  X :\: (A :\/: B) = (X :\: A) :/\: (X :\: B).
admit.
Qed.

(** from 13: complement of an intersection is union of complements **)
(** LATEX VERSION: X minus (A intersect B) equals (X minus A) union (X minus B). **)
Theorem setminus_binintersect_eq_binunion : forall X A B:set,
  X :\: (A :/\: B) = (X :\: A) :\/: (X :\: B).
admit.
Qed.

(** from 13: double complement inside X **)
(** LATEX VERSION: If U is a subset of X then X minus (X minus U) equals U. **)
Theorem setminus_setminus_eq : forall X U:set,
  U c= X ->
  X :\: (X :\: U) = U.
admit.
Qed.

(** from 12: finite intersections of closed sets are closed **)
(** LATEX VERSION: Finite intersections of closed sets are closed because their complements are finite unions of open sets. **)
Theorem binintersect_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :/\: D).
admit.
Qed.

(** from 12: finite unions of closed sets are closed **)
(** LATEX VERSION: Finite unions of closed sets are closed because their complements are finite intersections of open sets. **)
Theorem binunion_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :\/: D).
admit.
Qed.

(** from 13: complements of finite sets are open in the standard topology on R **)
(** LATEX VERSION: In the standard topology, the complement of a finite set is open. **)
Theorem Sing_eq_UPair : forall x:set, {x} = {x,x}.
admit.
Qed.
Theorem finite_complement_open_in_R_standard_topology : forall F:set,
  finite F ->
  F c= R ->
  R :\: F :e R_standard_topology.
admit.
Qed.

(** LATEX VERSION: Containment statements among the five  topologies in Exercise 7. **)
Theorem ex13_7_R_topology_containments :
  finer_than R_upper_limit_topology R_standard_topology /\
  finer_than R_K_topology R_standard_topology /\
  finer_than R_standard_topology R_finite_complement_topology /\
  finer_than R_standard_topology R_ray_topology.
admit.
Qed.

(** from 13 Exercise 8(a): rational open intervals generate standard topology on  **) 
(** LATEX VERSION: Exercise 8(a): Basis of rational open intervals generates the standard topology on . **)
Definition rational_open_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {open_interval q1 q2|q2 :e rational_numbers}.

(** from 13 Exercise 8(a): rational open intervals are standard open intervals **)
(** LATEX VERSION: Any rational open interval (q1,q2) is a standard basis element since q1,q2 are real. **)
Theorem rational_open_intervals_basis_Subq_R_standard_basis :
  rational_open_intervals_basis c= R_standard_basis.
admit.
Qed.

(** from 13 Exercise 8(a): density of rationals in reals (in order sense) **)
(** LATEX VERSION: Between any two real numbers a<b there exists a rational q with a<q<b. **)
Theorem rational_dense_between_reals : forall a b:set,
  a :e R -> b :e R -> Rlt a b ->
  exists q :e rational_numbers, Rlt a q /\ Rlt q b.
admit.
Qed.

(** from 13 Exercise 8(a): rational endpoints around a point in a real open interval **)
(** LATEX VERSION: If x is in (a,b) then there are rationals q1,q2 with q1<x<q2 and (q1,q2) contained in (a,b). **)
Theorem rational_interval_refines_real_interval : forall a b x:set,
  a :e R -> b :e R -> x :e R ->
  x :e open_interval a b ->
  exists q1 :e rational_numbers, exists q2 :e rational_numbers,
    x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
admit.
Qed.
Theorem ex13_8a_rational_intervals_basis_standard :
  basis_on R rational_open_intervals_basis /\
  generated_topology R rational_open_intervals_basis = R_standard_topology.
admit.
Qed.

(** from 13 Exercise 8(b): half-open rational intervals generate a different topology **) 
(** LATEX VERSION: Exercise 8(b): Half-open rational intervals form a basis whose generated topology differs from the lower limit topology. **)
Definition rational_halfopen_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {halfopen_interval_left q1 q2|q2 :e rational_numbers}.

(** LATEX VERSION: The half-open rational basis generates a topology distinct from the lower limit topology. **)
Theorem ex13_8b_halfopen_rational_basis_topology :
  basis_on R rational_halfopen_intervals_basis /\
  generated_topology R rational_halfopen_intervals_basis <> R_lower_limit_topology.
admit.
Qed.

(** from 14 Definition: basis for the order topology **) 
(** LATEX VERSION: For a simply ordered set X, the order-topology basis consists of all open intervals/rays; here represented abstractly. **)
(** FIXED: For dictionary order on R, a and b are ordered pairs (a1,a2) and (b1,b2), not cartesian products setprod a1 a2 and setprod b1 b2. **)
(** SUSPICIOUS DEFINITION: `order_rel` is implemented as a case split over a small list of carrier sets used later; this is not a general interface for simply ordered sets and may force later axioms. **)
(** SUSPICIOUS DEFINITION: `order_rel X a b` does not include the hypotheses `a :e X` and `b :e X`; most theorems therefore carry carrier membership assumptions separately. **)
(** REVIEWED: This case split is intentional for this development. Order-topology theorems should assume `simply_ordered_set X` and carry `a:e X` and `b:e X` explicitly, since `order_rel` alone does not bundle carrier membership. **)
Definition order_rel : set -> set -> set -> prop := fun X a b =>
  (X = R /\ Rlt a b)
  \/
  (X = rational_numbers /\ Rlt a b)
  \/
  (X = omega /\ a :e b)
  \/
  (X = omega :\: {0} /\ a :e b)
  \/
  (X = setprod 2 omega /\
   exists i m j n:set,
     (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
      a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))
  \/
  (X = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
  \/
  (ordinal X /\ X <> R /\ X <> rational_numbers /\ X <> setprod 2 omega /\ X <> setprod R R /\ a :e b).

(** from 14: simply ordered sets (scope of order topology) **)
(** LATEX VERSION: A simply ordered set is a set X equipped with a strict order relation < satisfying the order axioms. **)
(** NOTE: In this development, the order relation is hard-wired as `order_rel X` on a fixed list of carrier sets. **)
Definition simply_ordered_set : set -> prop := fun X =>
  X = R
  \/ X = rational_numbers
  \/ X = omega
  \/ X = omega :\: {0}
  \/ X = setprod 2 omega
  \/ X = setprod R R
  \/ ordinal X.

(** helper: R is a simply ordered set **)
Theorem simply_ordered_set_R : simply_ordered_set R.
admit.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,0) < (1,0) **)
Theorem order_rel_setprod_2_omega_00_10 :
  order_rel (setprod 2 omega) (0,0) (1,0).
admit.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,0) < (1,n) for any n **)
Theorem order_rel_setprod_2_omega_00_1n : forall n:set,
  n :e omega -> order_rel (setprod 2 omega) (0,0) (1,n).
admit.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,k) < (1,n) for any k,n **)
Theorem order_rel_setprod_2_omega_0k_1n : forall k n:set,
  k :e omega -> n :e omega -> order_rel (setprod 2 omega) (0,k) (1,n).
admit.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,k) < (0,ordsucc k) for any k **)
Theorem order_rel_setprod_2_omega_0k_0succk : forall k:set,
  k :e omega -> order_rel (setprod 2 omega) (0,k) (0, ordsucc k).
admit.
Qed.

(** helper: eps_ 1 is not an element of the ordinal 2 **)
(** LATEX VERSION: 1/2 is neither 0 nor 1. **)
Theorem eps_1_not_in_2 : eps_ 1 /:e 2.
admit.
Qed.

(** helper: setprod R R is not setprod 2 omega **)
Theorem setprod_R_R_neq_setprod_2_omega : setprod R R <> setprod 2 omega.
admit.
Qed.

(** helper: tagging notation y' **)
(** LATEX VERSION: Notation helper: we sometimes tag points by adjoining a marker; this is used in constructed examples and does not correspond to a named TeX definition. **)
(** helper: reintroduce tagging notation y' as SetAdjoin y {1} in the topology section **)
Definition tag_topology : set -> set := fun y => SetAdjoin y {1}.
Postfix ' 100 := tag_topology.

(** helper: singleton {1} is not a surreal number **)
Theorem Sing1_not_SNo : ~SNo {1}.
admit.
Qed.

(** Helper: Inj1 0 equals 1 **)
Theorem Inj1_0_eq_1 : Inj1 0 = 1.
admit.
Qed.

(** Helper: tuple (0,1) equals {1} **)
Theorem tuple_0_1_eq_Sing1 : (0,1) = {1}.
admit.
Qed.

(** helper: setprod R R is not R **)
Theorem setprod_R_R_neq_R : setprod R R <> R.
admit.
Qed.

(** helper: setprod R R is not rational_numbers **)
Theorem setprod_R_R_neq_rational_numbers : setprod R R <> rational_numbers.
admit.
Qed.

(** helper: R is not countable, hence R is not omega, omega\\{0}, or Q **)
(** LATEX VERSION: Uses uncountability of reals to separate R from  and . **)
Theorem R_neq_omega : R <> omega.
admit.
Qed.
Theorem R_neq_omega_nonzero : R <> (omega :\: {0}).
admit.
Qed.
Theorem R_neq_rational_numbers : R <> rational_numbers.
admit.
Qed.

(** helper: R is not setprod 2 omega **)
(** LATEX VERSION:  is uncountable, but 2 is countable. **)
Theorem R_neq_setprod_2_omega : R <> setprod 2 omega.
admit.
Qed.

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (first disjunct in the definition). **)
Theorem Rlt_implies_order_rel_R : forall a b:set, Rlt a b -> order_rel R a b.
admit.
Qed.

(** Helper: order_rel on  implies strict order on  **)
(** LATEX VERSION: If order_rel(,a,b) then a<b in  (all other disjuncts contradict known inequalities of carrier sets). **)
Theorem order_rel_R_implies_Rlt : forall a b:set, order_rel R a b -> Rlt a b.
admit.
Qed.

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (second disjunct in the definition). **)
Theorem Rlt_implies_order_rel_Q : forall a b:set, Rlt a b -> order_rel rational_numbers a b.
admit.
Qed.

(** Helper: membership order on  implies order_rel on  **)
(** LATEX VERSION: For , the strict order is membership: if ab then order_rel(,a,b). **)
Theorem mem_implies_order_rel_omega : forall a b:set, a :e b -> order_rel omega a b.
admit.
Qed.

(** Helper: for , order_rel implies membership **)
(** LATEX VERSION: On  (as a von Neumann ordinal), the strict order is membership: a<b iff ab. **)
Theorem order_rel_omega_implies_mem : forall a b:set,
  order_rel omega a b -> a :e b.
admit.
Qed.

(** helper: for \\{0}, order_rel implies membership **)
Theorem order_rel_omega_nonzero_implies_mem : forall a b:set,
  order_rel (omega :\: {0}) a b -> a :e b.
admit.
Qed.

(** Helper: membership order on \\{0} implies order_rel on \\{0} **)
(** LATEX VERSION: For \\{0}, we still use membership as the strict order. **)
Theorem mem_implies_order_rel_omega_nonzero : forall a b:set, a :e b -> order_rel (omega :\: {0}) a b.
admit.
Qed.

(** helper: omega without 0 differs from omega **)
Theorem omega_nonzero_neq_omega : (omega :\: {0}) <> omega.
admit.
Qed.

(** helper: introduce dictionary order on {0,1}xomega **)
Theorem order_rel_setprod_2_omega_intro : forall i m j n:set,
  i :e 2 ->
  m :e omega ->
  j :e 2 ->
  n :e omega ->
  (i :e j \/ (i = j /\ m :e n)) ->
  order_rel (setprod 2 omega) (i,m) (j,n).
admit.
Qed.

(** helper: trichotomy for order_rel on simply ordered sets **)
Theorem order_rel_trichotomy_or_impred : forall X a b:set,
  simply_ordered_set X ->
  a :e X ->
  b :e X ->
  forall p:prop,
    (order_rel X a b -> p) ->
    (a = b -> p) ->
    (order_rel X b a -> p) ->
    p.
admit.
Qed.

(** helper: transitivity for order_rel on simply ordered sets **)
Theorem order_rel_trans : forall X a b c:set,
  simply_ordered_set X ->
  a :e X ->
  b :e X ->
  c :e X ->
  order_rel X a b ->
  order_rel X b c ->
  order_rel X a c.
admit.
Qed.

(** helper: order_rel is irreflexive (by case analysis on its definition) **)
Theorem order_rel_irref : forall X x:set, ~(order_rel X x x).
admit.
Qed.

(** from 16 Definition: order topology basis **)
(** LATEX VERSION: The order topology is generated by basic open intervals (a,b) together with open rays (a0,b) and (a,b0) at endpoints. **)
Definition order_topology_basis : set -> set := fun X =>
  (({I :e Power X | exists a :e X, exists b :e X,
          I = {x :e X | order_rel X a x /\ order_rel X x b}}
    :\/:
    {I :e Power X | exists b :e X, I = {x :e X | order_rel X x b}}
    :\/:
    {I :e Power X | exists a :e X, I = {x :e X | order_rel X a x}})
   :\/:
   {X}).
(** NOTE: This `order_topology_basis` includes both open intervals and open rays for all X; the TeX-definition basis is given separately as `order_topology_basis_tex`. **)

(** helper: cases for membership in the order topology basis **)
(** LATEX VERSION: Basis elements are open intervals, open rays, or the whole space. **)
Theorem order_topology_basis_cases : forall X I:set,
  I :e order_topology_basis X ->
  (exists a :e X, exists b :e X, I = {x :e X | order_rel X a x /\ order_rel X x b})
  \/
  (exists b :e X, I = {x :e X | order_rel X x b})
  \/
  (exists a :e X, I = {x :e X | order_rel X a x})
  \/
  I = X.
admit.
Qed.

(** helper: intersection of two open intervals refines to an open interval basis element **)
Theorem order_topology_interval_refine : forall X a1 b1x a2 b2x b1 b2 x:set,
  simply_ordered_set X ->
  a1 :e X ->
  b1x :e X ->
  a2 :e X ->
  b2x :e X ->
  b1 = {x0 :e X | order_rel X a1 x0 /\ order_rel X x0 b1x} ->
  b2 = {x0 :e X | order_rel X a2 x0 /\ order_rel X x0 b2x} ->
  x :e b1 ->
  x :e b2 ->
  exists b3 :e (order_topology_basis X), x :e b3 /\ b3 c= b1 :/\: b2.
admit.
Qed.

(** from 14 The Order Topology: least and largest elements **)
(** LATEX VERSION: a0 is the smallest element of X if every xX satisfies not(x<a0); b0 is the largest if not(b0<x) for all xX. **)
Definition is_least_element : set -> set -> prop := fun X a0 =>
  a0 :e X /\ forall x:set, x :e X -> ~(order_rel X x a0).

Definition is_largest_element : set -> set -> prop := fun X b0 =>
  b0 :e X /\ forall x:set, x :e X -> ~(order_rel X b0 x).

(** from 14 Definition: order topology basis (TeX version) **)
(** LATEX VERSION: Assuming X has more than one element, a basis consists of (1) open intervals (a,b); (2) [a0,b) if a0 is the smallest element; (3) (a,b0] if b0 is the largest element. **)
Definition order_topology_basis_tex : set -> set := fun X =>
  ({I :e Power X | exists a :e X, exists b :e X, order_rel X a b /\ I = {x :e X | order_rel X a x /\ order_rel X x b}}
   :\/:
   {I :e Power X | exists a0 b:set, is_least_element X a0 /\ b :e X /\ order_rel X a0 b /\
     I = {x :e X | (x = a0 \/ order_rel X a0 x) /\ order_rel X x b}}
   :\/:
   {I :e Power X | exists b0 a:set, is_largest_element X b0 /\ a :e X /\ order_rel X a b0 /\
     I = {x :e X | order_rel X a x /\ (x = b0 \/ order_rel X x b0)}}).

(** from 14 Definition: order topology on a simply ordered set **)
(** LATEX VERSION: The order topology on X is the topology generated by the order-topology basis on X. **)
Definition order_topology : set -> set := fun X => generated_topology X (order_topology_basis X).

(** Helper: order topology basis satisfies basis axioms **)
Theorem order_topology_basis_is_basis : forall X:set,
  simply_ordered_set X ->
  basis_on X (order_topology_basis X).
admit.
Qed.

(** from 14: order topology is a topology **) 
(** LATEX VERSION: The order topology satisfies the topology axioms. **)
Theorem order_topology_is_topology : forall X:set,
  simply_ordered_set X ->
  topology_on X (order_topology X).
admit.
Qed.

(** from 16: open rays as building blocks in the order topology **) 
(** LATEX VERSION: The sets (a,) and (-,a) are open rays used to build the order topology; they form part of a subbasis. **)
Definition open_ray_upper : set -> set -> set := fun X a => {x :e X | order_rel X a x}.

(** from 16: open rays as building blocks in the order topology **) 
(** LATEX VERSION: The sets (a,) and (-,a) are open rays used to build the order topology; they form part of a subbasis. **)
Definition open_ray_lower : set -> set -> set := fun X a => {x :e X | order_rel X x a}.

(** from 16: open rays form a subbasis for the order topology **) 
(** LATEX VERSION: The order topology is generated by the subbasis of all open rays, together with X itself. **)
Definition open_rays_subbasis : set -> set := fun X =>
  (({I :e Power X | exists a :e X, I = open_ray_upper X a}
    :\/:
    {I :e Power X | exists b :e X, I = open_ray_lower X b})
   :\/:
   {X}).

(** Helper: open rays subbasis is a subset of Power X **)
Theorem open_rays_subbasis_sub_Power : forall X:set,
  open_rays_subbasis X c= Power X.
admit.
Qed.

(** Helper: open rays subbasis covers X and lies in Power X **)
Theorem open_rays_subbasis_is_subbasis : forall X:set,
  subbasis_on X (open_rays_subbasis X).
admit.
Qed.

(** Helper: an upper ray is a basis element for the order topology **)
Theorem open_ray_upper_in_order_topology_basis : forall X a:set,
  a :e X -> open_ray_upper X a :e order_topology_basis X.
admit.
Qed.

(** Helper: a lower ray is a basis element for the order topology **)
Theorem open_ray_lower_in_order_topology_basis : forall X b:set,
  b :e X -> open_ray_lower X b :e order_topology_basis X.
admit.
Qed.

(** helper: order_topology_basis covers  via successor lower rays **)
(** LATEX VERSION: For , every point lies in some basic open ray of the order topology. **)
Theorem order_topology_basis_covers_omega : forall x:set,
  x :e omega -> exists b :e (order_topology_basis omega), x :e b.
admit.
Qed.

(** helper: the lower ray below 1 in  is exactly {0} **)
(** LATEX VERSION: In , the initial segment below 1 is the singleton {0}. **)
Theorem open_ray_lower_omega_1_eq_Sing0 :
  open_ray_lower omega 1 = {0}.
admit.
Qed.

(** helper: every singleton {x} with x is a basis element of the  order topology basis **)
(** LATEX VERSION: In the order topology on , each point is isolated: {x} is a basic open set. **)
Theorem singleton_in_order_topology_basis_omega : forall x:set,
  x :e omega -> {x} :e order_topology_basis omega.
admit.
Qed.

(** helper: the order-topology basis on  satisfies the basis axioms **)
(** LATEX VERSION: For  with the usual order, the order-topology basis is a basis. **)
Theorem order_topology_basis_omega_is_basis :
  basis_on omega (order_topology_basis omega).
admit.
Qed.

(** helper: the order topology on  is a topology **)
(** LATEX VERSION: The order topology generated by the order basis is a topology. **)
Theorem order_topology_omega_is_topology :
  topology_on omega (order_topology omega).
admit.
Qed.

(** Helper: open rays subbasis elements are open in the order topology **)
Theorem open_rays_subbasis_sub_order_topology : forall X:set,
  simply_ordered_set X ->
  open_rays_subbasis X c= order_topology X.
admit.
Qed.

(** Helper: any subbasis element is open in the generated topology from the subbasis **)
Theorem subbasis_elem_open_in_generated_from_subbasis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s :e generated_topology_from_subbasis X S.
admit.
Qed.

(** Helper: upper ray belongs to open_rays_subbasis **)
Theorem open_ray_upper_in_open_rays_subbasis : forall X a:set,
  a :e X ->
  open_ray_upper X a :e open_rays_subbasis X.
admit.
Qed.

(** Helper: lower ray belongs to open_rays_subbasis **)
Theorem open_ray_lower_in_open_rays_subbasis : forall X b:set,
  b :e X ->
  open_ray_lower X b :e open_rays_subbasis X.
admit.
Qed.

(** Helper: open interval equals intersection of open rays **)
Theorem open_interval_eq_rays_intersection : forall X a b:set,
  {x :e X | order_rel X a x /\ order_rel X x b}
  =
  (open_ray_upper X a) :/\: (open_ray_lower X b).
admit.
Qed.

(** Helper: order topology basis elements are open in the topology generated by open rays **)
Theorem order_topology_basis_sub_generated_from_open_rays : forall X:set,
  order_topology_basis X c= generated_topology_from_subbasis X (open_rays_subbasis X).
admit.
Qed.
Theorem open_rays_subbasis_for_order_topology : forall X:set,
  simply_ordered_set X ->
  generated_topology_from_subbasis X (open_rays_subbasis X) = order_topology X.
admit.
Qed.

(** from 14 Example 1: standard basis is a basis on  **)
(** LATEX VERSION: The standard open-interval basis on  satisfies the basis axioms. **)
Theorem R_standard_basis_is_basis : basis_on R R_standard_basis.
admit.
Qed.

(** from 14 Example 1: standard topology is a topology **)
(** LATEX VERSION: The standard topology on  satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology : topology_on R R_standard_topology.
admit.
Qed.

(** from 14 Example 1: standard topology on  is the order topology **)
(** LATEX VERSION: Example 1: The standard topology on  equals its order topology. **)
(** NOTE: The earlier axiom equating bases was too strong; we only need equality of the generated topologies. **)
(** Helper: any standard open interval is an order-topology basis element on . **)
Theorem open_interval_in_order_topology_basis_R : forall a b:set,
  a :e R -> b :e R -> open_interval a b :e order_topology_basis R.
admit.
Qed.

(** Helper: refine order-topology basis elements by standard open intervals on . **)
Theorem order_topology_basis_R_refines_standard_basis :
  forall b :e order_topology_basis R, forall x:set,
    x :e b ->
    exists I :e R_standard_basis, x :e I /\ I c= b.
admit.
Qed.
Theorem standard_topology_is_order_topology : order_topology R = R_standard_topology.
admit.
Qed.

(** Helper: order topology on  is a topology, via equality with the standard topology. **)
Theorem order_topology_R_is_topology : topology_on R (order_topology R).
admit.
Qed.

(** Helper: the order-topology basis on  satisfies the basis axioms. **)
(** LATEX VERSION: The order topology on  is generated by open intervals and open rays, and these form a basis. **)
Theorem order_topology_basis_R_is_basis : basis_on R (order_topology_basis R).
admit.
Qed.

(** Helper: open rays subbasis elements are open in the order topology on . **)
Theorem open_rays_subbasis_sub_order_topology_R : open_rays_subbasis R c= order_topology R.
admit.
Qed.

(** Helper: on , the order topology is generated by the open rays subbasis. **)
Theorem open_rays_subbasis_for_order_topology_R :
  generated_topology_from_subbasis R (open_rays_subbasis R) = order_topology R.
admit.
Qed.

(** from 14 Example 2: dictionary order topology on  **) 
(** LATEX VERSION: Example 2 defines the dictionary order topology on  via the order topology construction. **)
(** NOTE: We define the dictionary order topology via the open-rays subbasis. This is equivalent to the order-topology construction for the lexicographic order, but avoids dependence on the currently-admitted global order-topology basis axiom. **)
Definition R2_dictionary_order_topology : set :=
  generated_topology_from_subbasis (setprod R R) (open_rays_subbasis (setprod R R)).
Theorem dictionary_order_topology_is_topology :
  topology_on (setprod R R) R2_dictionary_order_topology.
admit.
Qed.

(** from 14 Example 2: rectangle subbasis yields product-style topology **) 
(** LATEX VERSION: Rectangle-type sets give a basis generating the dictionary order topology on . **)
(** NOTE: Current witness uses the canonical basis from the open-rays subbasis via `basis_of_subbasis`; rectangle characterization is not yet formalized. **)
Theorem rectangles_basis_for_R2 :
  exists B:set, basis_on (setprod R R) B /\ generated_topology (setprod R R) B = R2_dictionary_order_topology.
admit.
Qed.

(** from 14 Example 3: order topology on  is discrete **)
(** LATEX VERSION: Example 3: The order topology on the positive integers is the discrete topology. **)
Definition Zplus : set := omega :\: {0}.

(** Helper: 0 is not in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem zero_not_in_Zplus : 0 /:e Zplus.
admit.
Qed.

(** Helper: 1 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem one_in_Zplus : 1 :e Zplus.
admit.
Qed.

(** Helper: 2 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem two_in_Zplus : 2 :e Zplus.
admit.
Qed.

(** Helper: 0 is in rational_numbers **)
(** Uses the definition rational = {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}. **)
Theorem zero_in_rational_numbers : 0 :e rational_numbers.
admit.
Qed.

(** Helper: 1 is in rational_numbers **)
(** Uses the definition rational = {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}. **)
Theorem one_in_rational_numbers : 1 :e rational_numbers.
admit.
Qed.

(** Helper: minus one is in rational_numbers **)
Theorem minus_one_in_rational_numbers : minus_SNo 1 :e rational_numbers.
admit.
Qed.

(** Helper: minus one is not in omega **)
Theorem minus_one_not_in_omega : minus_SNo 1 /:e omega.
admit.
Qed.

(** Helper: rational_numbers is not omega **)
Theorem rational_numbers_neq_omega : rational_numbers <> omega.
admit.
Qed.

(** Helper: rational_numbers is not omega minus {0} **)
Theorem rational_numbers_neq_omega_nonzero : rational_numbers <> (omega :\: {0}).
admit.
Qed.

(** Helper: Zplus is not omega **)
Theorem Zplus_neq_omega : Zplus <> omega.
admit.
Qed.

(** Helper: Zplus is not R **)
Theorem Zplus_neq_R : Zplus <> R.
admit.
Qed.

(** Helper: Zplus is not rational_numbers **)
Theorem Zplus_neq_rational_numbers : Zplus <> rational_numbers.
admit.
Qed.

(** Helper: {1} is not transitive **)
Theorem not_TransSet_singleton_1 : ~ TransSet {1}.
admit.
Qed.

(** Helper: {1} is not in omega **)
Theorem Sing1_not_in_omega : {1} /:e omega.
admit.
Qed.

(** helper: setprod R R is not omega **)
Theorem setprod_R_R_neq_omega : setprod R R <> omega.
admit.
Qed.

(** helper: setprod R R is not omega nonzero **)
Theorem setprod_R_R_neq_omega_nonzero : setprod R R <> (omega :\: {0}).
admit.
Qed.

(** helper: setprod 2 omega is not omega **)
Theorem setprod_2_omega_neq_omega : setprod 2 omega <> omega.
admit.
Qed.

(** helper: setprod 2 omega is not omega nonzero **)
Theorem setprod_2_omega_neq_omega_nonzero : setprod 2 omega <> (omega :\: {0}).
admit.
Qed.

(** helper: setprod 2 omega is not setprod R R **)
Theorem setprod_2_omega_neq_setprod_R_R : setprod 2 omega <> setprod R R.
admit.
Qed.

(** helper: setprod 2 omega is not R **)
Theorem setprod_2_omega_neq_R : setprod 2 omega <> R.
admit.
Qed.

(** helper: setprod 2 omega is not rational_numbers **)
Theorem setprod_2_omega_neq_rational_numbers : setprod 2 omega <> rational_numbers.
admit.
Qed.

(** helper: rational_numbers is not setprod 2 omega **)
Theorem rational_numbers_neq_setprod_2_omega : rational_numbers <> setprod 2 omega.
admit.
Qed.

(** helper: rational_numbers is not setprod R R **)
Theorem rational_numbers_neq_setprod_R_R : rational_numbers <> setprod R R.
admit.
Qed.

(** helper: rational_numbers is not R **)
Theorem rational_numbers_neq_R : rational_numbers <> R.
admit.
Qed.

(** Helper: order_rel on rational_numbers implies strict order in R **)
(** LATEX VERSION: If order_rel(,a,b) then a<b in  (all other disjuncts contradict known inequalities of carrier sets). **)
Theorem order_rel_Q_implies_Rlt : forall a b:set, order_rel rational_numbers a b -> Rlt a b.
admit.
Qed.

(** helper: unfold order_rel on setprod 2 omega to the dictionary-order case **)
Theorem order_rel_setprod_2_omega_unfold : forall a b:set,
  order_rel (setprod 2 omega) a b ->
  exists i m j n:set,
    (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))).
admit.
Qed.

(** helper: unfold order_rel on setprod R R to the dictionary-order case **)
Theorem order_rel_setprod_R_R_unfold : forall a b:set,
  order_rel (setprod R R) a b ->
  exists a1 a2 b1 b2:set,
    a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
admit.
Qed.

(** helper: introduce order_rel on RR from the dictionary comparison disjunction **)
Theorem order_rel_setprod_R_R_intro : forall a1 a2 b1 b2:set,
  (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)) ->
  order_rel (setprod R R) (a1, a2) (b1, b2).
admit.
Qed.

(** Helper: Zplus is not setprod 2 omega **)
Theorem Zplus_neq_setprod_2_omega : Zplus <> setprod 2 omega.
admit.
Qed.

(** Helper: Zplus is not setprod R R **)
Theorem Zplus_neq_setprod_R_R : Zplus <> setprod R R.
admit.
Qed.

(** Helper: on Zplus, order_rel is membership order **)
Theorem order_rel_Zplus_iff_mem : forall a b:set,
  a :e Zplus -> b :e Zplus -> (order_rel Zplus a b <-> a :e b).
admit.
Qed.

(** Helper: membership in Zplus implies membership in omega **)
Theorem Zplus_mem_omega : forall n:set, n :e Zplus -> n :e omega.
admit.
Qed.

(** Helper: membership in Zplus implies n<>0 **)
Theorem Zplus_mem_nonzero : forall n:set, n :e Zplus -> n <> 0.
admit.
Qed.

(** Helper: Zplus is a subset of omega **)
Theorem Zplus_Subq_omega : Zplus c= omega.
admit.
Qed.

(** Helper: successor of a Zplus element is again in Zplus **)
Theorem Zplus_ordsucc_closed : forall n:set, n :e Zplus -> ordsucc n :e Zplus.
admit.
Qed.

(** Helper: singleton sets are basic opens in the order topology basis on Zplus **)
Theorem nat_nonzero_in_Zplus : forall n:set, nat_p n -> n <> 0 -> n :e Zplus.
admit.
Qed.

(** Helper: singleton {1} is in the order topology basis on Zplus **)
Theorem singleton_ordsucc0_in_order_topology_basis_Zplus :
  {ordsucc 0} :e order_topology_basis Zplus.
admit.
Qed.

(** Helper: singleton of a successor is in the order topology basis on Zplus **)
Theorem singleton_ordsucc_in_order_topology_basis_Zplus : forall m:set,
  m :e Zplus -> {ordsucc m} :e order_topology_basis Zplus.
admit.
Qed.
Theorem singleton_in_order_topology_basis_Zplus : forall n:set,
  n :e Zplus -> {n} :e order_topology_basis Zplus.
admit.
Qed.

(** Helper: order topology on Zplus is discrete **)
Theorem Zplus_order_topology_is_discrete :
  generated_topology Zplus (order_topology_basis Zplus) = Power Zplus.
admit.
Qed.
Theorem order_topology_on_Zplus_discrete :
  order_topology Zplus = discrete_topology Zplus.
admit.
Qed.

(** Helper: order topology on omega is discrete **)
Theorem omega_order_topology_is_discrete :
  generated_topology omega (order_topology_basis omega) = Power omega.
admit.
Qed.
Theorem order_topology_on_omega_discrete :
  order_topology omega = discrete_topology omega.
admit.
Qed.

(** Helper: conjunction reassociation (/\ is left-associative) **)
Theorem and_assoc : forall A B C:prop, (A /\ B) /\ C -> A /\ (B /\ C).
admit.
Qed.
Theorem and_assoc_rev : forall A B C:prop, A /\ (B /\ C) -> (A /\ B) /\ C.
admit.
Qed.

(** Helper: eliminate a 7-way conjunction A /\ B /\ C /\ D /\ E /\ F /\ G **)
Theorem and7E : forall A B C D E F G:prop,
  A /\ B /\ C /\ D /\ E /\ F /\ G ->
  forall p:prop, (A -> B -> C -> D -> E -> F -> G -> p) -> p.
admit.
Qed.

(** Helper: eliminate a 4-way conjunction A /\ B /\ C /\ D **)
Theorem and4E : forall A B C D:prop,
  A /\ B /\ C /\ D ->
  forall p:prop, (A -> B -> C -> D -> p) -> p.
admit.
Qed.

(** Helper: eliminate a 5-way conjunction A /\ B /\ C /\ D /\ E **)
Theorem and5E : forall A B C D E:prop,
  A /\ B /\ C /\ D /\ E ->
  forall p:prop, (A -> B -> C -> D -> E -> p) -> p.
admit.
Qed.

(** Helper: eliminate a 6-way conjunction A /\ B /\ C /\ D /\ E /\ F **)
Theorem and6E : forall A B C D E F:prop,
  A /\ B /\ C /\ D /\ E /\ F ->
  forall p:prop, (A -> B -> C -> D -> E -> F -> p) -> p.
admit.
Qed.

(** Helper: transport membership across set equality **)
Theorem mem_eqR : forall x A B:set, A = B -> x :e A -> x :e B.
admit.
Qed.
Theorem mem_eqL : forall x A B:set, A = B -> x :e B -> x :e A.
admit.
Qed.

(** Helper: if a 7-way conjunction ends with a specific disjunctive clause, extract it by one split **)
Theorem conj7_last_disjE : forall i m j n a b:set,
  i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
  a = (i, m) /\ b = (j, n) /\
  (i :e j \/ (i = j /\ m :e n)) ->
  (i :e j \/ (i = j /\ m :e n)).
admit.
Qed.

(** from 14 Example 4: two-row dictionary order space is not discrete **) 
(** LATEX VERSION: Example 4: The dictionary order topology on {1,2} is not discrete. **)
Definition two_by_nat : set := setprod 2 omega.
Definition two_by_nat_order_topology : set := order_topology two_by_nat.

(** helper: singleton {(1,0)} is not a basis element in the order topology basis on two_by_nat **)
Theorem two_by_nat_singleton_not_in_basis :
  {(1,0)} /:e order_topology_basis two_by_nat.
admit.
Qed.

(** Helper: singleton {(1,0)} is not open in two_by_nat order topology **)
Theorem two_by_nat_singleton_not_open :
  ~ ({(1,0)} :e two_by_nat_order_topology).
admit.
Qed.

(** LATEX VERSION: The two-by- dictionary order space fails to be discrete. **)
Theorem two_by_nat_not_discrete :
  ~ (two_by_nat_order_topology = discrete_topology two_by_nat).
admit.
Qed.

(** helper: setprod 2 omega is a simply ordered set **)
Theorem simply_ordered_set_setprod_2_omega :
  simply_ordered_set (setprod 2 omega).
admit.
Qed.

(** helper: pair equality gives equality of first coordinate **)
Theorem pair_eq_fst : forall a b c d:set, (a,b) = (c,d) -> a = c.
admit.
Qed.

(** helper: pair equality gives equality of second coordinate **)
Theorem pair_eq_snd : forall a b c d:set, (a,b) = (c,d) -> b = d.
admit.
Qed.

(** helper: no point lies strictly between (0,k) and (0, succ k) in setprod 2 omega **)
Theorem no_point_between_setprod_2_omega_0k_0succk : forall k y:set,
  k :e omega ->
  y :e setprod 2 omega ->
  order_rel (setprod 2 omega) (0,k) y ->
  order_rel (setprod 2 omega) y (0, ordsucc k) ->
  False.
admit.
Qed.

(** helper: no point lies strictly between (1,n) and (1, succ n) in setprod 2 omega **)
Theorem no_point_between_setprod_2_omega_1n_1succn : forall n y:set,
  n :e omega ->
  y :e setprod 2 omega ->
  order_rel (setprod 2 omega) (1,n) y ->
  order_rel (setprod 2 omega) y (1, ordsucc n) ->
  False.
admit.
Qed.

(** helper: the lower ray below (0,1) in setprod 2 omega is {(0,0)} **)
Theorem open_ray_lower_setprod_2_omega_01_eq_Sing00 :
  open_ray_lower (setprod 2 omega) (0,1) = {(0,0)}.
admit.
Qed.

(** helper: {(0,0)} is open in the order topology on setprod 2 omega **)
Theorem singleton_setprod_2_omega_00_open :
  {(0,0)} :e order_topology (setprod 2 omega).
admit.
Qed.

(** helper: {(0,k)} is open in the order topology on setprod 2 omega (all k) **)
Theorem singleton_setprod_2_omega_0k_open : forall k:set,
  k :e omega ->
  {(0,k)} :e order_topology (setprod 2 omega).
admit.
Qed.

(** helper: {(1,n)} is open in the order topology on setprod 2 omega for any nonzero n **)
Theorem singleton_setprod_2_omega_1n_open_if_nonzero : forall n:set,
  n :e omega ->
  n <> 0 ->
  {(1,n)} :e order_topology (setprod 2 omega).
admit.
Qed.

(** helper: complement of the upper ray from (0,k) is the lower ray below (0,k+1) **)
Theorem setminus_open_ray_upper_setprod_2_omega_0k : forall k:set,
  k :e omega ->
  (setprod 2 omega) :\: open_ray_upper (setprod 2 omega) (0,k) =
  open_ray_lower (setprod 2 omega) (0, ordsucc k).
admit.
Qed.

(** helper: complement of the lower ray below (1,n+1) is the upper ray above (1,n) **)
Theorem setminus_open_ray_lower_setprod_2_omega_1succ : forall n:set,
  n :e omega ->
  (setprod 2 omega) :\: open_ray_lower (setprod 2 omega) (1, ordsucc n) =
  open_ray_upper (setprod 2 omega) (1, n).
admit.
Qed.

(** from 15 Definition: product topology on XY **) 
(** LATEX VERSION: The product topology on XY is generated by the basis of rectangles UV with U open in X and V open in Y. **)
Definition rectangle_set : set -> set -> set := fun U V => setprod U V.

(** Helper: definitional expansion for rectangle_set **)
Theorem rectangle_set_def : forall U V:set, rectangle_set U V = setprod U V.
admit.
Qed.

(** Helper: pairing belongs to rectangle_set **)
Theorem tuple_2_rectangle_set : forall U V:set, forall x y:set,
  x :e U -> y :e V -> (x,y) :e rectangle_set U V.
admit.
Qed.

(** Helper: surjective pairing for setprod **)
Theorem setprod_eta : forall X Y p:set,
  p :e setprod X Y -> p = (p 0, p 1).
admit.
Qed.

(** Helper: cartesian products preserve subset relation **)
Theorem setprod_Subq : forall U V X Y:set,
  U c= X -> V c= Y -> setprod U V c= setprod X Y.
admit.
Qed.

(** Helper: elements of cartesian products have coordinates **)
Theorem setprod_elem_decompose : forall X Y p:set,
  p :e setprod X Y ->
  exists x :e X, exists y :e Y, p :e setprod {x} {y}.
admit.
Qed.

(** Helper: singleton subset property **)
Theorem singleton_subset : forall x U:set, x :e U -> {x} c= U.
admit.
Qed.

(** Helper: singleton element equality **)
Theorem singleton_elem : forall x y:set, x :e {y} -> x = y.
admit.
Qed.

(** Helper: coordinates of product elements **)
Theorem setprod_coords_in : forall x y U V p:set,
  p :e setprod {x} {y} -> p :e setprod U V -> x :e U /\ y :e V.
admit.
Qed.

(** Helper: intersection of cartesian products **)
Theorem setprod_intersection : forall U1 V1 U2 V2:set,
  setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
admit.
Qed.

(** from 15 Definition: product topology on XY (basis rectangles) **)
(** LATEX VERSION: The product topology on XY has as a basis all sets UV where U is open in X and V is open in Y. **)
(** NOTE: Despite the name, `product_subbasis` here is a rectangle basis family indexed by opens in X and Y. **)
Definition product_subbasis : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    \/_ U :e Tx, {rectangle_set U V|V :e Ty}.

(** from 15 Definition: product topology generated from rectangles **)
(** LATEX VERSION: The product topology is the topology generated by the rectangle basis. **)
Definition product_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).

(** Helper: product subbasis satisfies basis axioms **)
Theorem product_subbasis_is_basis : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
admit.
Qed.

(** from 15: product topology is a topology **)
(** LATEX VERSION: The product topology determined by Tx and Ty satisfies the topology axioms on XY. **)
Theorem product_topology_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  topology_on (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** from 15: basis for a product from bases in the factors **)
(** LATEX VERSION: If B and C are bases for X and Y, then {BC} is a basis for XY in the product topology. **)
(** Definition: product basis from two bases **)
Definition product_basis_from : set -> set -> set :=
  fun Bx By => \/_ U :e Bx, {setprod U V | V :e By}.

(** Helper: product basis generates product topology **)
Theorem product_basis_generates_product_topology : forall X Y Bx By Tx Ty:set,
  basis_on X Bx -> generated_topology X Bx = Tx ->
  basis_on Y By -> generated_topology Y By = Ty ->
  generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty.
admit.
Qed.

(** Helper: product_basis_from is a basis on the product **)
Theorem product_basis_from_is_basis_on : forall X Y Bx By Tx Ty:set,
  basis_on X Bx -> generated_topology X Bx = Tx ->
  basis_on Y By -> generated_topology Y By = Ty ->
  basis_on (setprod X Y) (product_basis_from Bx By).
admit.
Qed.

(** from 15 Theorem: basis of products of basis elements **)
(** LATEX VERSION: If Bx, By are bases for Tx, Ty, then the collection {UV|UBx, VBy} is a basis generating the product topology. **)
Theorem product_basis_generates :
  forall X Tx Y Ty Bx By:set,
    basis_on X Bx /\ generated_topology X Bx = Tx ->
    basis_on Y By /\ generated_topology Y By = Ty ->
    exists B:set,
      basis_on (setprod X Y) B /\
      (forall U :e Bx, forall V :e By, setprod U V :e B) /\
  generated_topology (setprod X Y) B = product_topology X Tx Y Ty.
admit.
Qed.

(** from 15 Definition: projections on a product **) 
(** LATEX VERSION: Define coordinate projection relations  and  from XY. **)
(** FIXED: Projections must use ordered pairs for function graphs: proj maps (x,y)x and proj maps (x,y)y, with graphs {((x,y),x)} and {((x,y),y)}; UPair and setprod x y were incorrect here. **)
Definition projection1 : set -> set -> set := fun X Y =>
  {(p, p 0) | p :e setprod X Y}.
Definition projection2 : set -> set -> set := fun X Y =>
  {(p, p 1) | p :e setprod X Y}.
 
(** SUSPICIOUS DEFINITION: These projection graphs rely on tuple-as-function encoding, so that for `p :e setprod X Y` we can read `p 0` and `p 1` as coordinates. **)
(** REVIEWED: This matches the intended setprod-as-Sigma encoding used throughout; projection lemmas (projection1_apply/projection2_apply) provide the needed unfoldings. **)

(** from 15 Theorem 15.2: projection preimages form a subbasis **) 
(** LATEX VERSION: The inverse images of opens under projections give a subbasis for the product topology. **)
Theorem product_subbasis_from_projections : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists S:set,
    S = product_subbasis X Tx Y Ty /\
    generated_topology (setprod X Y) S = product_topology X Tx Y Ty.
admit.
Qed.

(** from 18 Continuous Functions: functions as maps between sets **)
(** LATEX VERSION: A function f:XY assigns to each xX a point f(x)Y; continuity is defined using inverse images of open sets. **)
(** FIXED: Function-related definitions use ordered pairs, not UPair; functions are sets of ordered pairs (x,y), apply_fun looks up y with (x,y)  f, identity is {(y,y)|yX}. **)
(** SUSPICIOUS DEFINITION: `apply_fun` is based on `Eps_i`, so `function_on` only constrains the chosen values, not that `f` is a genuine functional graph; later results about unions and preimages may require extra axioms. Use `total_function_on` when totality is required. **)
(** REVIEWED: Keep this weak notion; key theorems that need a true graph use `total_function_on` and `functional_graph` hypotheses. **)
Definition apply_fun : set -> set -> set := fun f x => Eps_i (fun y => (x,y) :e f).
Definition function_on : set -> set -> set -> prop := fun f X Y => forall x:set, x :e X -> apply_fun f x :e Y.
Definition function_space : set -> set -> set := fun X Y => {f :e Power (setprod X Y)|function_on f X Y}.

(** helper: function_on restriction to smaller domain **)
Theorem function_on_restrict_dom : forall f X X' Y:set,
  function_on f X Y ->
  X' c= X ->
  function_on f X' Y.
admit.
Qed.

(** helper: extract function_on from function_space membership **)
Theorem function_on_of_function_space : forall f X Y:set,
  f :e function_space X Y -> function_on f X Y.
admit.
Qed.

(** from 18 Continuous Functions: set-theoretic encoding of functions **)
(** LATEX VERSION: A function is single-valued: if f(x)=y1 and f(x)=y2 then y1=y2. **)
(** Helper: a functional graph is single valued **)
Definition functional_graph : set -> prop :=
  fun f => forall x y1 y2:set, (x,y1) :e f -> (x,y2) :e f -> y1 = y2.

(** from 18 Continuous Functions: domain and codomain restrictions for graphs **)
(** LATEX VERSION: A function f:XY has domain contained in X and range contained in Y. **)
(** Helper: graph domain restriction **)
Definition graph_domain_subset : set -> set -> prop :=
  fun f X => forall x y:set, (x,y) :e f -> x :e X.

(** from 18 Continuous Functions: domain and codomain restrictions for graphs **)
(** LATEX VERSION: A function f:XY has domain contained in X and range contained in Y. **)
(** Helper: graph range restriction **)
Definition graph_range_subset : set -> set -> prop :=
  fun f Y => forall x y:set, (x,y) :e f -> y :e Y.

(** Helper: subset of XY implies domain subset X **)
Theorem graph_domain_subset_of_sub_setprod : forall f X Y:set,
  f c= setprod X Y -> graph_domain_subset f X.
admit.
Qed.

(** Helper: subset of XY implies range subset Y **)
Theorem graph_range_subset_of_sub_setprod : forall f X Y:set,
  f c= setprod X Y -> graph_range_subset f Y.
admit.
Qed.

(** Helper: a graph comprehension has domain subset of its index set **)
Theorem graph_domain_subset_graph : forall A:set, forall g:set->set,
  graph_domain_subset {(a, g a)|a :e A} A.
admit.
Qed.

(** Helper: a constant graph comprehension has domain subset of its index set **)
Theorem graph_domain_subset_const_fun : forall A c:set,
  graph_domain_subset {(a,c)|a :e A} A.
admit.
Qed.

(** Helper: a graph comprehension has range subset under a pointwise condition **)
Theorem graph_range_subset_graph : forall A Y:set, forall g:set->set,
  (forall a:set, a :e A -> g a :e Y) ->
  graph_range_subset {(a, g a)|a :e A} Y.
admit.
Qed.

(** Helper: a constant graph comprehension has range subset **)
Theorem graph_range_subset_const_fun : forall A Y c:set,
  c :e Y ->
  graph_range_subset {(a,c)|a :e A} Y.
admit.
Qed.

(** Helper: a graph comprehension is functional **)
Theorem functional_graph_graph : forall A:set, forall g:set->set,
  functional_graph {(a, g a)|a :e A}.
admit.
Qed.

(** Helper: a constant graph comprehension is functional **)
Theorem functional_graph_const_fun : forall A c:set,
  functional_graph {(a,c)|a :e A}.
admit.
Qed.

(** Helper: if a value exists in the graph, apply_fun yields a value in the graph **)
Theorem apply_fun_in_graph_of_ex : forall f x:set,
  (exists y:set, (x,y) :e f) ->
  (x, apply_fun f x) :e f.
admit.
Qed.

(** Helper: for a functional graph, apply_fun equals any value in the graph **)
Theorem functional_graph_apply_fun_eq : forall f x y:set,
  functional_graph f ->
  (x,y) :e f ->
  apply_fun f x = y.
admit.
Qed.

(** Helper: domain subset preserved under binary union **)
Theorem graph_domain_subset_binunion : forall A B f g:set,
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  graph_domain_subset (f :\/: g) (A :\/: B).
admit.
Qed.

(** Helper: range subset preserved under binary union **)
Theorem graph_range_subset_binunion : forall f g Y:set,
  graph_range_subset f Y ->
  graph_range_subset g Y ->
  graph_range_subset (f :\/: g) Y.
admit.
Qed.

(** Helper: build function_on from pointwise totality and range subset **)
Theorem function_on_from_totality_and_range : forall X Y f:set,
  (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f) ->
  graph_range_subset f Y ->
  function_on f X Y.
admit.
Qed.

(** from 18 Continuous Functions: set theoretic graphs of functions **)
(** LATEX VERSION: A function may be identified with its graph, the set of ordered pairs (x,f(x)). **)
(** Helper: graph of a meta level function as a set of ordered pairs **)
Definition graph : set -> (set -> set) -> set := fun A g => {(a, g a) | a :e A}.

(** Helper: evaluating apply_fun on a graph built by Repl **)
Theorem apply_fun_graph : forall A:set, forall g:set->set, forall a:set,
  a :e A -> apply_fun (graph A g) a = g a.
admit.
Qed.

(** from 18 Continuous Functions: functions defined on all points **)
(** LATEX VERSION: A function f:X->Y assigns a value f(x) in Y for each x in X. **)
(** Helper: total function graph on X into Y (in addition to function_on) **)
Definition total_function_on : set -> set -> set -> prop := fun f X Y =>
  function_on f X Y /\ forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.

(** Helper: total_function_on implies function_on **)
Theorem total_function_on_function_on : forall f X Y:set,
  total_function_on f X Y -> function_on f X Y.
admit.
Qed.

(** Helper: total_function_on gives a graph witness for each x **)
Theorem total_function_on_totality : forall f X Y:set,
  total_function_on f X Y ->
  forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.
admit.
Qed.

(** helper: a total functional graph equals the graph of its apply_fun **)
(** LATEX VERSION: If a relation f is total on X and functional, then it equals the graph x  f(x). **)
Theorem total_functional_graph_eq_graph_of_apply_fun : forall f X Y:set,
  total_function_on f X Y ->
  functional_graph f ->
  f c= setprod X Y ->
  f = graph X (fun x:set => apply_fun f x).
admit.
Qed.

(** helper: domain characterization from totality and domain restriction **)
(** LATEX VERSION: If f is total on X and has graph domain contained in X, then xX iff there exists y with (x,y)f. **)
Theorem total_function_on_domain_iff_exists_pair : forall f X Y x:set,
  total_function_on f X Y ->
  graph_domain_subset f X ->
  (x :e X <-> exists y:set, (x,y) :e f).
admit.
Qed.

(** helper: total functions have a unique domain under graph_domain_subset **)
(** LATEX VERSION: If f is total on X and Y and its graph has domain contained in X, then any other such domain X' must equal X. **)
Theorem total_function_on_domain_unique : forall f X X' Y:set,
  total_function_on f X Y -> graph_domain_subset f X ->
  total_function_on f X' Y -> graph_domain_subset f X' ->
  X = X'.
admit.
Qed.

(** Helper: total_function_on gives membership of the chosen value in the graph **)
Theorem total_function_on_apply_fun_in_graph : forall f X Y x:set,
  total_function_on f X Y ->
  x :e X ->
  (x, apply_fun f x) :e f.
admit.
Qed.

(** Helper: total_function_on implies apply_fun lands in Y **)
Theorem total_function_on_apply_fun_in_Y : forall f X Y x:set,
  total_function_on f X Y ->
  x :e X ->
  apply_fun f x :e Y.
admit.
Qed.

(** Helper: range subset from totality and functionality **)
Theorem graph_range_subset_from_total_functional : forall A Y f:set,
  graph_domain_subset f A ->
  total_function_on f A Y ->
  functional_graph f ->
  graph_range_subset f Y.
admit.
Qed.

(** from 18 Continuous Functions: constant functions **)
(** LATEX VERSION: A constant function on A takes every a in A to the same value x. **)
(** Helper: constant function as a graph **)
Definition const_fun : set -> set -> set := fun A x => {(a,x) | a :e A}.

(** Helper: apply_fun for const_fun **)
Theorem const_fun_apply : forall A x a:set,
  a :e A ->
  apply_fun (const_fun A x) a = x.
admit.
Qed.

(** Helper: const_fun is total_function_on **)
Theorem const_fun_total_function_on : forall A Y x:set,
  x :e Y -> total_function_on (const_fun A x) A Y.
admit.
Qed.

		(** Helper: identity function application **)
Theorem identity_function_apply : forall X x:set,
  x :e X -> apply_fun {(y,y) | y :e X} x = x.
admit.
Qed.

(** Helper: identity graph is total_function_on **)
Theorem identity_total_function_on : forall X:set,
  total_function_on {(y,y) | y :e X} X X.
admit.
Qed.

(** from 19 The Product Topology: constant families in products **)
(** LATEX VERSION: In cartesian products, one often considers the constant family taking each index i to the same space X. **)
Definition const_family : set -> set -> set := fun I X => {(i,X)|i :e I}.

(** Helper: apply_fun for const_family **)
Theorem const_family_apply : forall I X i:set,
  i :e I -> apply_fun (const_family I X) i = X.
admit.
Qed.

(** from 19 The Product Topology: extracting components of a family of spaces **)
(** LATEX VERSION: A product consists of a family of spaces X_i with topologies; we refer to the i-th factor and its topology. **)
Definition product_component : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.

(** from 19 The Product Topology: extracting components of a family of spaces **)
(** LATEX VERSION: A product consists of a family of spaces X_i with topologies; we refer to the i-th factor and its topology. **)
Definition product_component_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

(** Helper: unfold product_component and product_component_topology **)
Theorem product_component_def : forall Xi i:set,
  product_component Xi i = (apply_fun Xi i) 0.
admit.
Qed.
Theorem product_component_topology_def : forall Xi i:set,
  product_component_topology Xi i = (apply_fun Xi i) 1.
admit.
Qed.

(** from 19 The Product Topology: a family of topological spaces indexed by I **)
(** LATEX VERSION: Consider a cartesian product of a family of spaces; we package each space X_i with its topology. **)
(** family of spaces as a family of pairs (X_i, T_i) **)
Definition const_space_family : set -> set -> set -> set := fun I X Tx =>
  {(i,(X,Tx))|i :e I}.

(** Helper: apply_fun for const_space_family **)
Theorem const_space_family_apply : forall I X Tx i:set,
  i :e I -> apply_fun (const_space_family I X Tx) i = (X,Tx).
admit.
Qed.

(** from 19 The Product Topology: component space and component topology **)
(** LATEX VERSION: For a family Xi, each index i determines a space X_i and a topology T_i. **)
Definition space_family_set : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.

(** from 19 The Product Topology: component space and component topology **)
(** LATEX VERSION: For a family Xi, each index i determines a space X_i and a topology T_i. **)
Definition space_family_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

(** helper: unfold space_family_set / space_family_topology **)
Theorem space_family_set_def : forall Xi i:set,
  space_family_set Xi i = (apply_fun Xi i) 0.
admit.
Qed.
Theorem space_family_topology_def : forall Xi i:set,
  space_family_topology Xi i = (apply_fun Xi i) 1.
admit.
Qed.

(** helper: space_family_set/topology coincide with product_component accessors **)
Theorem space_family_set_eq_product_component : forall Xi i:set,
  space_family_set Xi i = product_component Xi i.
admit.
Qed.
Theorem space_family_topology_eq_product_component_topology : forall Xi i:set,
  space_family_topology Xi i = product_component_topology Xi i.
admit.
Qed.

(** helper: constant space family component carrier **)
Theorem space_family_set_const_space_family : forall I X Tx i:set,
  i :e I ->
  space_family_set (const_space_family I X Tx) i = X.
admit.
Qed.

(** helper: constant space family component topology **)
Theorem space_family_topology_const_space_family : forall I X Tx i:set,
  i :e I ->
  space_family_topology (const_space_family I X Tx) i = Tx.
admit.
Qed.

(** from 19 The Product Topology: union of component carriers **)
(** LATEX VERSION: We take the union of all component spaces X_i as an ambient codomain for product functions. **)
Definition space_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_set Xi i|i :e I}.

(** from 19 The Product Topology: union of component topology families **)
(** LATEX VERSION: We take the union of all component topologies T_i as an ambient codomain for cylinder parameters. **)
Definition topology_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_topology Xi i|i :e I}.

(** helper: union of a nonempty constant space family is the carrier **)
(** LATEX VERSION: If I is nonempty and Xi is constantly (X,Tx), then _{iI} X_i = X. **)
Theorem space_family_union_const_space_family : forall I X Tx:set,
  I <> Empty ->
  space_family_union I (const_space_family I X Tx) = X.
admit.
Qed.

(** helper: union of a nonempty constant topology family is the topology **)
(** LATEX VERSION: If I is nonempty and Xi is constantly (X,Tx), then _{iI} T_i = Tx. **)
Theorem topology_family_union_const_space_family : forall I X Tx:set,
  I <> Empty ->
  topology_family_union I (const_space_family I X Tx) = Tx.
admit.
Qed.

(** from 19 The Product Topology: cartesian product as a set of choice functions **)
(** LATEX VERSION: The cartesian product consists of all functions f with f(i) in X_i for each index i. **)
Definition product_space : set -> set -> set := fun I Xi =>
  {f :e Power (setprod I (space_family_union I Xi))|
     total_function_on f I (space_family_union I Xi) /\ functional_graph f /\
     forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i}.
(** FIXED: product_space elements are total functional graphs I -> space_family_union, matching the intended set-theoretic product and avoiding Eps-choice pathologies. **)

(** helper: build a product point from coordinate data **)
(** LATEX VERSION: Given a family g with g(i)X_i, the graph ig(i) is a point of the cartesian product X_i. **)
Theorem product_space_graphI : forall I Xi:set, forall g:set->set,
  (forall i:set, i :e I -> g i :e space_family_set Xi i) ->
  graph I g :e product_space I Xi.
admit.
Qed.

(** from 19 The Product Topology: subbasis elements via projections **)
(** LATEX VERSION: Subbasis elements have the form pi_i^{-1}(U_i), restricting only the i-th coordinate to lie in an open set U_i. **)
Definition product_cylinder : set -> set -> set -> set -> set :=
  fun I Xi i U =>
    {f :e product_space I Xi | i :e I /\ U :e space_family_topology Xi i /\ apply_fun f i :e U}.

(** from 19 The Product Topology: product topology subbasis **)
(** LATEX VERSION: The product topology is generated by the subbasis of all inverse images of opens under coordinate projections. **)
Definition product_subbasis_full : set -> set -> set :=
  fun I Xi => \/_ i :e I, {product_cylinder I Xi i U|U :e space_family_topology Xi i}.

(** from 19 The Product Topology: product topology on an indexed product **)
(** LATEX VERSION: The product topology is the topology generated by the projection subbasis. **)
Definition product_topology_full : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
(** FIXED: Was using Power set which generates discrete topology, not box topology; now box_topology is generated from the box_basis (products of opens in each component). **)
(** from 19 The Product Topology: box topology on an indexed product **)
(** LATEX VERSION: The box topology has as basis all products of open sets in each coordinate, with no finiteness restriction. **)
Definition box_basis : set -> set -> set := fun I Xi =>
  {B :e Power (product_space I Xi) |
    exists U:set, total_function_on U I (topology_family_union I Xi) /\ functional_graph U /\
      (forall i:set, i :e I -> apply_fun U i :e space_family_topology Xi i) /\
      B = {f :e product_space I Xi | forall i:set, i :e I -> apply_fun f i :e apply_fun U i}}.
(** FIXED: box_basis witnesses are total functional graphs U:I->(union of component topologies), ensuring `apply_fun U i` is backed by an actual graph element. **)
(** from 19 The Product Topology: box topology generated by box_basis **)
(** LATEX VERSION: The box topology is the topology generated by the box basis. **)
Definition box_topology : set -> set -> set := fun I Xi =>
  generated_topology (product_space I Xi) (box_basis I Xi).

(** from 19 The Product Topology: notation for countable products **)
(** LATEX VERSION: For countable index sets, we use the same product space and product topology constructions. **)
Definition countable_product_space : set -> set -> set := fun I Xi =>
  product_space I Xi.

(** from 19 The Product Topology: notation for countable products **)
(** LATEX VERSION: For countable index sets, we use the product topology on the product space. **)
Definition countable_product_topology : set -> set -> set := fun I Xi =>
  product_topology_full I Xi.

(** from 19 Example 1: Euclidean n space as a finite product of R **)
(** LATEX VERSION: Euclidean n space R^n is a finite cartesian product of copies of R with the product topology. **)
Definition euclidean_space : set -> set := fun n => product_space n (const_space_family n R R_standard_topology).

(** from 19 Example 1: Euclidean n space as a finite product of R **)
(** LATEX VERSION: Euclidean n space has the product topology, which agrees with the box topology in the finite case. **)
Definition euclidean_topology : set -> set := fun n => product_topology_full n (const_space_family n R R_standard_topology).

(** helper: the singleton index {0} is nonempty **)
Theorem SingEmpty_ne_Empty : Sing Empty <> Empty.
admit.
Qed.

(** helper: constant 1-indexed point in R^1, implemented as a graph on {0} **)
Definition R1_singleton_seq : set -> set := fun r =>
  graph (Sing Empty) (fun _:set => r).

(** helper: constant sequence lies in R^1 **)
Theorem R1_singleton_seq_in_euclidean_space_1 : forall r:set,
  r :e R ->
  R1_singleton_seq r :e euclidean_space (Sing Empty).
admit.
Qed.

(** helper: singleton map r |-> constant point in R^1 **)
Definition R1_singleton_map : set :=
  graph R (fun r:set => R1_singleton_seq r).

(** from 15 Example: standard topology on  as product topology **) 
(** LATEX VERSION: The standard topology on  coincides with the product of the standard topologies on . **)
Definition R2_standard_topology : set := product_topology R R_standard_topology R R_standard_topology.
Theorem R2_standard_equals_product :
  R2_standard_topology = product_topology R R_standard_topology R R_standard_topology.
admit.
Qed.

(** helper: the usual open rectangle set equals the cartesian product of open intervals **)
(** LATEX VERSION: {(x,y) | a<x<b and c<y<d} = (a,b)(c,d). **)
Theorem open_rectangle_set_eq_rectangle_set_intervals : forall a b c d:set,
  {p :e EuclidPlane|
     exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    = rectangle_set (open_interval a b) (open_interval c d).
admit.
Qed.

(** helper: an open rectangle is open in the standard topology on R^2 **)
(** LATEX VERSION: If a<b and c<d, then (a,b)(c,d) is open in the product topology on . **)
Theorem open_rectangle_in_R2_standard_topology : forall a b c d:set,
  Rlt a b -> Rlt c d ->
  {p :e EuclidPlane|
     exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e R2_standard_topology.
admit.
Qed.

(** helper: every rectangular region is open in the standard topology on R^2 **)
(** LATEX VERSION: Every axis-parallel open rectangle (a,b)(c,d) is open in the standard topology on . **)
Theorem rectangular_regions_subset_R2_standard_topology : forall U:set,
  U :e rectangular_regions -> U :e R2_standard_topology.
admit.
Qed.

(** helper: topology generated by rectangular regions is contained in the standard topology on R^2 **)
(** LATEX VERSION: The topology generated by rectangular regions is no finer than the standard topology on . **)
Theorem generated_topology_rectangular_regions_sub_R2_standard_topology :
  generated_topology EuclidPlane rectangular_regions c= R2_standard_topology.
admit.
Qed.

(** helper: rectangular regions generate the standard topology on R^2 **)
(** LATEX VERSION: The family of all rectangular regions (a,b)(c,d) forms a basis that generates the standard topology on . **)
Theorem generated_topology_rectangular_regions_eq_R2_standard_topology :
  generated_topology EuclidPlane rectangular_regions = R2_standard_topology.
admit.
Qed.

(** from 13 Example 4: circular regions generate the standard topology on R^2 **)
(** LATEX VERSION: Since circular and rectangular regions generate the same topology, and rectangles generate the standard topology, circular regions also generate the standard topology on . **)
Theorem generated_topology_circular_regions_eq_R2_standard_topology :
  generated_topology EuclidPlane circular_regions = R2_standard_topology.
admit.
Qed.

(** from 13 Example 4: rectangular regions form a basis generating the standard topology on R^2 **)
(** LATEX VERSION: The rectangular regions form a basis for the standard topology on . **)
Theorem rectangular_regions_generate_R2_standard_topology :
  basis_generates EuclidPlane rectangular_regions R2_standard_topology.
admit.
Qed.

(** from 13 Example 4: circular regions form a basis generating the standard topology on R^2 **)
(** LATEX VERSION: The circular regions form a basis for the standard topology on . **)
Theorem circular_regions_generate_R2_standard_topology :
  basis_generates EuclidPlane circular_regions R2_standard_topology.
admit.
Qed.

(** helper: reverse equalities for rewriting **)
Theorem R2_standard_topology_eq_generated_rectangular_regions :
  R2_standard_topology = generated_topology EuclidPlane rectangular_regions.
admit.
Qed.

(** helper: reverse equalities for rewriting **)
Theorem R2_standard_topology_eq_generated_circular_regions :
  R2_standard_topology = generated_topology EuclidPlane circular_regions.
admit.
Qed.

(** from 16 Definition: subspace topology **) 
(** LATEX VERSION: The subspace topology on YX with topology Tx consists of intersections VY with V open in X. **)
(** SUSPICIOUS DEFINITION: This is phrased as a family of subsets of `Y` (via `Power Y`) with witnesses `V :e Tx`; proofs often need to extract both the witness and the subset fact. **)
(** REVIEWED: This matches the LATEX VERSION; use `subspace_topologyE` to extract the witness V and the equality U = V  Y. **)
Definition subspace_topology : set -> set -> set -> set :=
  fun X Tx Y => {U :e Power Y | exists V :e Tx, U = V :/\: Y}.

(** helper: elimination for subspace_topology membership **)
Theorem subspace_topologyE : forall X Tx Y U:set,
  U :e subspace_topology X Tx Y -> exists V :e Tx, U = V :/\: Y.
admit.
Qed.

(** helper: basic open sets of subspace_topology are intersections **)
Theorem subspace_topologyI : forall X Tx Y V:set,
  V :e Tx -> (V :/\: Y) :e subspace_topology X Tx Y.
admit.
Qed.

(** helper: elements of the subspace topology are subsets of Y **)
Theorem subspace_topology_subset : forall X Tx Y U:set,
  U :e subspace_topology X Tx Y -> U c= Y.
admit.
Qed.

(** helper: elements of the subspace topology are members of Power Y **)
Theorem subspace_topology_in_Power : forall X Tx Y U:set,
  U :e subspace_topology X Tx Y -> U :e Power Y.
admit.
Qed.

(** helper: intersection of two subspace-open sets is subspace-open, with an explicit witness **)
Theorem subspace_topology_binintersect_witness : forall X Tx Y U V VU VV:set,
  U = VU :/\: Y ->
  V = VV :/\: Y ->
  U :/\: V = (VU :/\: VV) :/\: Y.
admit.
Qed.

(** helper: intersection closure for the subspace topology **)
Theorem subspace_topology_binintersect : forall X Tx Y U V:set,
  topology_on X Tx -> Y c= X ->
  U :e subspace_topology X Tx Y ->
  V :e subspace_topology X Tx Y ->
  U :/\: V :e subspace_topology X Tx Y.
admit.
Qed.

(** helper: monotonicity of the subspace topology in the ambient topology **)
Theorem subspace_topology_mono : forall X Tx1 Tx2 Y U:set,
  Tx1 c= Tx2 ->
  U :e subspace_topology X Tx1 Y ->
  U :e subspace_topology X Tx2 Y.
admit.
Qed.

(** helper: union closure for the subspace topology **)
Theorem subspace_topology_union_closed : forall X Tx Y UFam:set,
  topology_on X Tx -> Y c= X ->
  UFam c= subspace_topology X Tx Y ->
  Union UFam :e subspace_topology X Tx Y.
admit.
Qed.

(** helper: subspace topology on whole space equals original topology **)
Theorem subspace_topology_whole : forall X Tx:set,
  topology_on X Tx ->
  subspace_topology X Tx X = Tx.
admit.
Qed.

(** from 16: subspace topology is a topology **) 
(** LATEX VERSION: The subspace topology on Y inherits the topology axioms. **)
Theorem subspace_topology_is_topology : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  topology_on Y (subspace_topology X Tx Y).
admit.
Qed.

(** from 16: openness in subspace via ambient openness **) 
(** LATEX VERSION: A set UY is open in the subspace topology iff U = VY for some V open in X. **)
Theorem open_in_subspace_iff : forall X Tx Y U:set,
  topology_on X Tx -> Y c= X -> U c= Y ->
  (open_in Y (subspace_topology X Tx Y) U <->
  exists V :e Tx, U = V :/\: Y).
admit.
Qed.

(** from 16 Lemma 16.1: basis for the subspace topology **) 
(** LATEX VERSION: Lemma 16.1: If B is a basis for Tx, then {bY | bB} is a basis for the subspace topology on Y. **)
Theorem subspace_basis : forall X Tx Y B:set,
  topology_on X Tx ->
  Y c= X ->
  basis_on X B /\ generated_topology X B = Tx ->
  basis_on Y {b :/\: Y | b :e B} /\
  generated_topology Y {b :/\: Y | b :e B} = subspace_topology X Tx Y.
admit.
Qed.

(** from 16 Lemma 16.2: openness inherited when subspace is open **) 
(** LATEX VERSION: Lemma 16.2: If Y itself is open in X, any set open in the subspace Y is open in X. **)
Theorem open_in_subspace_if_ambient_open : forall X Tx Y U:set,
  topology_on X Tx -> Y :e Tx -> U c= Y ->
  open_in Y (subspace_topology X Tx Y) U ->
  U :e Tx.
admit.
Qed.

(** from 16 Theorem 16.3: product of subspaces equals subspace of product **) 
(** LATEX VERSION: The product topology on AB (with subspace topologies) equals the subspace topology of AB inside XY. **)
Theorem product_subspace_topology : forall X Tx Y Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  A c= X -> B c= Y ->
  product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B) =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
admit.
Qed.

(** from 16 Example 3: ordered square versus subspace topology **) 
(** LATEX VERSION: Example 3: The order topology on the ordered square differs from the subspace topology inherited from the dictionary order on . **)
(** FIXED: Unit interval [0,1] = {x  R | 0  x  1}, using negated strict inequality: x  0 means ~(x < 0) and x  1 means ~(1 < x). **)
Definition unit_interval : set := {x :e R | ~(Rlt x 0) /\ ~(Rlt 1 x)}.

(** helper: unit_interval is a subset of R **)
(** LATEX VERSION: The unit interval [0,1] is a subset of the real line. **)
Theorem unit_interval_sub_R : unit_interval c= R.
admit.
Qed.

(** helper: eps_1 is a real number **)
Theorem eps_1_in_R : eps_ 1 :e R.
admit.
Qed.

(** helper: eps_1 is strictly between 0 and 1 in R **)
Theorem eps_1_pos_R : Rlt 0 (eps_ 1).
admit.
Qed.

(** helper: in the dictionary order on RR we have (x,0) < (x, eps_1) **)
Theorem order_rel_setprod_R_R_x0_xeps1 : forall x:set,
  x :e R ->
  order_rel (setprod R R) (x,0) (x, eps_ 1).
admit.
Qed.

(** helper: eps_1 is less than 1 in R **)
Theorem eps_1_lt1_R : Rlt (eps_ 1) 1.
admit.
Qed.

(** helper: 0 is in the unit interval **)
Theorem zero_in_unit_interval : 0 :e unit_interval.
admit.
Qed.

(** helper: 1 is in the unit interval **)
Theorem one_in_unit_interval : 1 :e unit_interval.
admit.
Qed.

(** helper: eps_1 is in the unit interval **)
Theorem eps_1_in_unit_interval : eps_ 1 :e unit_interval.
admit.
Qed.

(** helper: unit_interval implies 0 <= t **)
Theorem unit_interval_Rle0 : forall t:set,
  t :e unit_interval -> Rle 0 t.
admit.
Qed.

(** helper: unit_interval implies t <= 1 **)
Theorem unit_interval_Rle1 : forall t:set,
  t :e unit_interval -> Rle t 1.
admit.
Qed.

(** helper: unit_interval is closed under multiplication **)
Theorem unit_interval_mul_closed : forall a b:set,
  a :e unit_interval ->
  b :e unit_interval ->
  mul_SNo a b :e unit_interval.
admit.
Qed.

(** helper: 2 is not in the unit interval **)
(** LATEX VERSION: 2 is not in [0,1]. **)
Theorem two_not_in_unit_interval : 2 /:e unit_interval.
admit.
Qed.

(** helper: 2 is a real number **)
(** LATEX VERSION: 2 is a real number. **)
Theorem two_in_R : 2 :e R.
admit.
Qed.

(** helper: unit interval is a proper subset of R **)
(** LATEX VERSION: [0,1] is not all of . **)
Theorem unit_interval_neq_R : unit_interval <> R.
admit.
Qed.

(** helper: standard topology on the unit interval as a subspace of R **)
(** LATEX VERSION: Equip [0,1] with the subspace topology inherited from the standard topology on R. **)
Definition unit_interval_topology : set :=
  subspace_topology R R_standard_topology unit_interval.
Theorem unit_interval_topology_on : topology_on unit_interval unit_interval_topology.
admit.
Qed.

(** helper: flip map on the unit interval **)
(** LATEX VERSION: Notation helper: t |-> 1-t on [0,1], used for reversing parameterizations of paths. **)
Definition flip_unit_interval : set :=
  {(t, add_SNo 1 (minus_SNo t)) | t :e unit_interval}.

(** helper: application of flip_unit_interval **)
Theorem flip_unit_interval_apply : forall t:set,
  t :e unit_interval ->
  apply_fun flip_unit_interval t = add_SNo 1 (minus_SNo t).
admit.
Qed.

(** helper: flip_unit_interval maps into R **)
Theorem flip_unit_interval_in_R : forall t:set,
  t :e unit_interval ->
  apply_fun flip_unit_interval t :e R.
admit.
Qed.

(** helper: flip_unit_interval at endpoints **)
Theorem flip_unit_interval_at_0 : apply_fun flip_unit_interval 0 = 1.
admit.
Qed.
Theorem flip_unit_interval_at_1 : apply_fun flip_unit_interval 1 = 0.
admit.
Qed.

(** helper: flip_unit_interval is a self-map of the unit interval (placeholder) **)
Theorem flip_unit_interval_function_on :
  function_on flip_unit_interval unit_interval unit_interval.
admit.
Qed.

(** helper: neighborhoods of eps_ 1 in the unit interval contain other points **)
(** LATEX VERSION: Any open set in the unit interval topology containing 1/2 contains a point different from 1/2. **)
Theorem unit_interval_open_neighborhood_has_other_point : forall U0:set,
  U0 :e unit_interval_topology ->
  eps_ 1 :e U0 ->
  exists x:set, x :e U0 /\ x <> eps_ 1.
admit.
Qed.
(** from 16 Example: the ordered square I_o^2 **)
(** LATEX VERSION: The set II in the dictionary order topology is called the ordered square and denoted I_o^2. **)
Definition ordered_square : set := setprod unit_interval unit_interval.

(** from 16 Example: basis for the dictionary order topology on II **)
(** LATEX VERSION: The dictionary order topology is the order topology induced by the lexicographic order; basic opens are intervals and rays. **)
(** helper: basis for the dictionary order topology on II, using the dictionary comparison on RR **)
Definition ordered_square_order_basis : set :=
  ({I :e Power ordered_square | exists a :e ordered_square, exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b}}
   :\/:
   {I :e Power ordered_square | exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) x b}}
   :\/:
   {I :e Power ordered_square | exists a :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) a x}}).

(** from 16 Example: the ordered square topology **)
(** LATEX VERSION: The ordered square carries the order topology from the dictionary order. **)
Definition ordered_square_topology : set := generated_topology ordered_square ordered_square_order_basis.
(** LATEX VERSION: The vertical strip {1/2}(1/2,1] inside II. **)
Definition ordered_square_open_strip : set :=
  {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y)}.

(** from 16 Example 3: order topology vs subspace topology **)
(** LATEX VERSION: The order topology on II is not the same as the subspace topology inherited from RR in the dictionary order topology. **)
Definition ordered_square_subspace_topology : set :=
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.

(** helper: ordered square is a proper subset of RR **)
(** LATEX VERSION: II is a proper subset of . **)
Theorem ordered_square_neq_setprod_R_R : ordered_square <> setprod R R.
admit.
Qed.

(** helper: ordered square as a standard subspace is the product topology **)
(** LATEX VERSION: The standard subspace topology on II agrees with the product topology on II. **)
Theorem ordered_square_standard_subspace_equals_product :
  subspace_topology (setprod R R) R2_standard_topology ordered_square =
  product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
admit.
Qed.
Theorem ordered_square_not_subspace_dictionary :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
admit.
Qed.

(** from 16 Theorem 16.4: convex subspaces share the order topology **) 
(** LATEX VERSION: Theorem 16.4: A convex subset Y of an ordered set X inherits the order topology as a subspace topology. **)
(** Helper: order interval (a,b) in an ordered set **)
Definition order_interval : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ order_rel X x b}.

(** helper: in , order_interval agrees with open_interval **)
(** LATEX VERSION: In the real line with the usual order, (a,b) = {x | a<x<b}. **)
Theorem order_interval_R_eq_open_interval : forall a b:set,
  order_interval R a b = open_interval a b.
admit.
Qed.

(** Helper: order intervals are subsets of the ambient set **)
Theorem order_interval_subset : forall X a b:set,
  order_interval X a b c= X.
admit.
Qed.

(** Helper: eliminator for order_interval membership **)
Theorem order_intervalE : forall X a b x:set,
  x :e order_interval X a b ->
  x :e X /\ (order_rel X a x /\ order_rel X x b).
admit.
Qed.

(** Helper: introduction rule for order_interval membership **)
Theorem order_intervalI : forall X a b x:set,
  x :e X ->
  order_rel X a x ->
  order_rel X x b ->
  x :e order_interval X a b.
admit.
Qed.

(** from 16: convex subsets of ordered sets **)
(** LATEX VERSION: A subset Y of an ordered set X is convex in X if for each pair of points a<b of Y, the entire interval between them in X lies in Y. **)
(** Helper: convex subset definition used in Theorem 16.4 **)
Definition convex_in : set -> set -> prop := fun X Y =>
  Y c= X /\
  forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y.

(** Helper: extract Y c= X from convex_in **)
Theorem convex_in_subset : forall X Y:set,
  convex_in X Y -> Y c= X.
admit.
Qed.

(** Helper: extract the interval closure property from convex_in **)
Theorem convex_in_interval_property : forall X Y:set,
  convex_in X Y ->
  forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y.
admit.
Qed.

(** from 16 Theorem 16.4: convex subset order topology equals subspace topology **)
(** LATEX VERSION: If Y is a convex subset of an ordered set X, then the order topology on Y (inherited from X) equals the subspace topology on Y as a subspace of X in the order topology. **)
(** NOTE: Our global `order_topology Y` uses `order_rel Y`, which does not represent the inherited order from X on subsets Y. We therefore define the inherited order-topology on Y explicitly using `order_rel X` restricted to Y. **)
(** from 16 Theorem 16.4: inherited order topology basis on Y **)
(** LATEX VERSION: The inherited order topology on Y is generated by the interval-and-ray basis inside Y determined by the order on X, together with Y itself. **)
Definition order_topology_basis_inherited : set -> set -> set := fun X Y =>
  (({I :e Power Y | exists a :e Y, exists b :e Y,
          I = {x :e Y | order_rel X a x /\ order_rel X x b}}
    :\/:
    {I :e Power Y | exists b :e Y, I = {x :e Y | order_rel X x b}}
    :\/:
    {I :e Power Y | exists a :e Y, I = {x :e Y | order_rel X a x}})
   :\/:
   {Y}).

(** from 16 Theorem 16.4: inherited order topology on Y **)
(** LATEX VERSION: The inherited order topology is the topology generated by the inherited interval-and-ray basis. **)
Definition order_topology_inherited : set -> set -> set := fun X Y =>
  generated_topology Y (order_topology_basis_inherited X Y).
Theorem convex_subspace_order_topology : forall X Y:set,
  simply_ordered_set X ->
  convex_in X Y ->
  order_topology_inherited X Y = subspace_topology X (order_topology X) Y.
admit.
Qed.

(** helper: intersection with a subset can drop the larger set **) 
Theorem binintersect_right_absorb_subset : forall W Y A:set,
  A c= Y -> (W :/\: Y) :/\: A = W :/\: A.
admit.
Qed.

(** from 16 Exercise 1: subspace of subspace inherits same topology **)
(** LATEX VERSION: Exercise 1: Subspace of a subspace has the same topology as taking the subspace directly. **)
Theorem ex16_1_subspace_transitive : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  subspace_topology Y (subspace_topology X Tx Y) A =
  subspace_topology X Tx A.
admit.
Qed.

(** from 16 Exercise 2: fineness relation passes to subspaces **)
(** LATEX VERSION: Exercise 2: If T'T on X, then the induced subspace topology from T' on Y is contained in that from T. **)
Theorem ex16_2_finer_subspaces : forall X T T' Y:set,
  topology_on X T -> topology_on X T' -> T' c= T -> Y c= X ->
  subspace_topology X T' Y c= subspace_topology X T Y.
admit.
Qed.

(** Helper: subspace topology respects equality of ambient topologies **)
Theorem subspace_topology_eq_of_eq : forall X T T' Y:set,
  T = T' ->
  subspace_topology X T Y = subspace_topology X T' Y.
admit.
Qed.

(** from 16 Exercise 3: openness of specific sets in subspace [-1,1] **)
(** LATEX VERSION: Exercise 3: Determine openness in subspace [-1,1]; formalized as existence of ambient open V with U=VY. **)
(** LATEX VERSION: A={x|1/2<|x|<1}, B={x|1/2<|x|<=1}, C={x|1/2<=|x|<1}, D={x|1/2<=|x|<=1}, E={x|0<|x|<1 and 1/x not in Zplus}. **)
Definition one_half : set := inv_nat 2.
Definition interval_A : set := {x :e R | one_half < abs_SNo x /\ abs_SNo x < 1}.
Definition interval_B : set := {x :e R | one_half < abs_SNo x /\ ~(1 < abs_SNo x)}.
Definition interval_C : set := {x :e R | ~(abs_SNo x < one_half) /\ abs_SNo x < 1}.
Definition interval_D : set := {x :e R | ~(abs_SNo x < one_half) /\ ~(1 < abs_SNo x)}.
(** from 16 Exercise 3: set E in the subspace [-1,1] **)
(** LATEX VERSION: E = {x   | 0<|x|<1 and 1/x  _+}. **)
Definition interval_E : set := {x :e R | 0 < abs_SNo x /\ abs_SNo x < 1 /\ ~ (div_SNo 1 x :e Zplus)}.
Theorem ex16_3_open_sets_subspace : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  forall U:set, open_in Y (subspace_topology X Tx Y) U -> exists V:set, open_in X Tx V /\ U = V :/\: Y.
admit.
Qed.

(** from 16 Exercise 4: projections are open maps **)
(** LATEX VERSION: Exercise 4: Projections from a product are open maps. **)
Definition projection_image1 : set -> set -> set -> set :=
  fun X Y U => {x :e X | exists y:set, (x,y) :e U}.
Definition projection_image2 : set -> set -> set -> set :=
  fun X Y U => {y :e Y | exists x:set, (x,y) :e U}.

(** helper: nonempty set has an element **)
Theorem nonempty_has_element : forall V:set, V <> Empty -> exists y:set, y :e V.
admit.
Qed.

(** helper: set with an element is nonempty **)
Theorem elem_implies_nonempty : forall V y:set, y :e V -> V <> Empty.
admit.
Qed.

(** helper: projection of a rectangle to the first coordinate **)
Theorem projection_image1_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  V <> Empty ->
  projection_image1 X Y (setprod U V) = U.
admit.
Qed.
Theorem projection_image1_rectangle_empty : forall X Y U:set,
  projection_image1 X Y (setprod U Empty) = Empty.
admit.
Qed.

(** helper: projection of a rectangle to the second coordinate **)
Theorem projection_image2_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  U <> Empty ->
  projection_image2 X Y (setprod U V) = V.
admit.
Qed.
Theorem projection_image2_rectangle_empty : forall X Y V:set,
  projection_image2 X Y (setprod Empty V) = Empty.
admit.
Qed.
Theorem ex16_4_projections_open : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  forall U:set, U :e product_topology X Tx Y Ty ->
    open_in X Tx (projection_image1 X Y U) /\ open_in Y Ty (projection_image2 X Y U).
admit.
Qed.

(** from 16 Exercise 5(a): product topology monotonicity **)
(** LATEX VERSION: Exercise 5(a): If TT' and UU', then the product topology from T,U is contained in that from T',U'. **)
Theorem ex16_5a_product_monotone : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  T c= T' /\ U c= U' ->
  product_topology X T Y U c= product_topology X T' Y U'.
admit.
Qed.

(** from 16 Exercise 5(b): converse question about product fineness **)
(** LATEX VERSION: Exercise 5(b): If product topology from T,U is contained in that from T',U', then TT' and UU'. **)
Theorem ex16_5b_product_converse : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  product_topology X T Y U c= product_topology X T' Y U' ->
  T c= T' /\ U c= U'.
admit.
Qed.

(** from 16 Exercise 6: rational rectangles form a basis for  **)
(** LATEX VERSION: Exercise 6: Rational rectangles form a basis generating the standard topology on . **)
Definition rational_rectangle_basis : set :=
  {r :e Power (setprod R R) |
     exists a b c d:set,
       a :e rational_numbers /\ b :e rational_numbers /\
       c :e rational_numbers /\ d :e rational_numbers /\
       r = setprod (open_interval a b) (open_interval c d)}.

(** helper: open intervals are standard-open when endpoints are real **)
(** LATEX VERSION: Since the standard basis contains all open intervals (a,b) with a,b in R, such intervals are open in the standard topology. **)
Theorem open_interval_in_R_standard_topology_endpoints : forall a b:set,
  a :e R -> b :e R -> open_interval a b :e R_standard_topology.
admit.
Qed.

(** helper: rational open intervals are in the rational-interval basis **)
Theorem open_interval_in_rational_open_intervals_basis : forall q1 q2:set,
  q1 :e rational_numbers -> q2 :e rational_numbers ->
  open_interval q1 q2 :e rational_open_intervals_basis.
admit.
Qed.

(** helper: eliminate membership in rational_open_intervals_basis **)
Theorem rational_open_intervals_basisE : forall b:set,
  b :e rational_open_intervals_basis ->
  exists q1, exists q2, (q1 :e rational_numbers /\ q2 :e rational_numbers /\ b = open_interval q1 q2).
admit.
Qed.

(** helper: rational rectangles are exactly products of rational open intervals **)
(** LATEX VERSION: Rational rectangles (q1,q2)(r1,r2) form the product basis from the rational-interval basis on each coordinate. **)
Theorem rational_rectangle_basis_eq_product_basis_from :
  rational_rectangle_basis =
    product_basis_from rational_open_intervals_basis rational_open_intervals_basis.
admit.
Qed.
Theorem ex16_6_rational_rectangles_basis :
  basis_on (setprod R R) rational_rectangle_basis /\
  generated_topology (setprod R R) rational_rectangle_basis = R2_standard_topology.
admit.
Qed.

(** from 16 Exercise 7: convex subset implies interval or ray? **) 
(** LATEX VERSION: Exercise 7: Let X be an ordered set. If Y is a proper subset of X that is convex in X, does it follow that Y is an interval or a ray in X. **)
Definition closed_interval_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ (x = b \/ order_rel X x b)}.

(** from 16 Exercise 7: half-open intervals in an ordered set **) 
(** LATEX VERSION: [a,b) = {xX | ax<b}. **)
Definition halfopen_interval_left_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ order_rel X x b}.

(** from 16 Exercise 7: half-open intervals in an ordered set **) 
(** LATEX VERSION: (a,b] = {xX | a<xb}. **)
Definition halfopen_interval_right_in : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ (x = b \/ order_rel X x b)}.

(** from 16 Exercise 7: rays in ordered sets **)
(** LATEX VERSION: A ray in X is one of the sets (a,), [a,), (-,a), (-,a]. **)
Definition closed_ray_upper : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X a x}.

(** from 16 Exercise 7: rays in ordered sets **)
(** LATEX VERSION: A ray in X is one of the sets (a,), [a,), (-,a), (-,a]. **)
Definition closed_ray_lower : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X x a}.

(** Helper: closed intervals are intersections of closed rays **)
(** LATEX VERSION: In an ordered set, the closed interval [a,b] equals [a,)  (-,b]. **)
Theorem closed_interval_in_eq_ray_intersection : forall X a b:set,
  closed_interval_in X a b = (closed_ray_upper X a) :/\: (closed_ray_lower X b).
admit.
Qed.

(** from 16 Exercise 7: intervals in ordered sets **)
(** LATEX VERSION: An interval in X is one of (a,b), [a,b), (a,b], [a,b]. **)
Definition interval_in : set -> set -> set -> set -> prop := fun X a b Y =>
  Y = order_interval X a b
  \/ Y = halfopen_interval_left_in X a b
  \/ Y = halfopen_interval_right_in X a b
  \/ Y = closed_interval_in X a b.

(** from 16 Exercise 7: rays in ordered sets **)
(** LATEX VERSION: A ray in X is one of the open or closed upper or lower rays determined by a point a. **)
Definition ray_in : set -> set -> set -> prop := fun X a Y =>
  Y = open_ray_upper X a
  \/ Y = closed_ray_upper X a
  \/ Y = open_ray_lower X a
  \/ Y = closed_ray_lower X a.

(** from 16 Exercise 7: intervals or rays criterion **)
(** LATEX VERSION: The question asks whether every proper convex subset must be an interval or a ray. **)
Definition interval_or_ray_in : set -> set -> prop := fun X Y =>
  (exists a b:set, a :e X /\ b :e X /\ interval_in X a b Y)
  \/ (exists a:set, a :e X /\ ray_in X a Y).

(** Counterexample pattern inside Q: points with q^2 < 2 form a convex set with no endpoint in Q. **)
(** LATEX VERSION: Consider the subset of Q consisting of rationals q such that q^2 < 2; it is convex but not an interval or ray in Q. **)
Definition Q_sqrt2_cut : set := {q :e rational_numbers | mul_SNo q q < 2}.

(** helper for 16 Exercise 7: 2 is a rational number **)
(** LATEX VERSION: The number 2 is rational (2 = 2/1). **)
Theorem two_in_rational_numbers : 2 :e rational_numbers.
admit.
Qed.

(** helper for 16 Exercise 7: 2 is not in the sqrt(2)-cut **)
(** LATEX VERSION: Since 2^2 is not < 2, we have 2  {qQ | q^2 < 2}. **)
Theorem two_not_in_Q_sqrt2_cut : 2 /:e Q_sqrt2_cut.
admit.
Qed.

(** helper for 16 Exercise 7: minus two is not in the sqrt(2)-cut **)
(** LATEX VERSION: Since (-2)^2 is not < 2, we have -2  {qQ | q^2 < 2}. **)
Theorem minus_two_not_in_Q_sqrt2_cut : minus_SNo 2 /:e Q_sqrt2_cut.
admit.
Qed.

(** helper for 16 Exercise 7: Q_sqrt2_cut is a proper subset of Q **)
(** LATEX VERSION: The sqrt(2)-cut is not all of Q (for instance 2 is not in it). **)
Theorem Q_sqrt2_cut_neq_Q : Q_sqrt2_cut <> rational_numbers.
admit.
Qed.

(** helper for 16 Exercise 7: cut subset property **)
(** LATEX VERSION: The set {qQ | q^2<2} is a subset of Q. **)
Theorem Q_sqrt2_cut_sub_Q : Q_sqrt2_cut c= rational_numbers.
admit.
Qed.

(** helper for 16 Exercise 7: 0 is in the cut **)
(** LATEX VERSION: Since 0^2<2, we have 0  {qQ | q^2<2}. **)
Theorem zero_in_Q_sqrt2_cut : 0 :e Q_sqrt2_cut.
admit.
Qed.

(** helper for 16 Exercise 7: convexity of the sqrt(2) cut in Q **)
(** LATEX VERSION: The set {qQ | q^2<2} is convex in Q. **)
(** helper: if x lies strictly between two cut points, then x is in the cut **)
Theorem Q_sqrt2_cut_between_square : forall a b x:set,
  a :e Q_sqrt2_cut ->
  b :e Q_sqrt2_cut ->
  x :e rational_numbers ->
  Rlt a x ->
  Rlt x b ->
  mul_SNo x x < 2.
admit.
Qed.
Theorem Q_sqrt2_cut_convex : convex_in rational_numbers Q_sqrt2_cut.
admit.
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut has no maximum element in Q **)
(** LATEX VERSION: The cut {qQ | q^2<2} has no endpoint in Q. **)
Theorem Q_sqrt2_cut_no_max : forall q:set,
  q :e Q_sqrt2_cut -> exists r:set, r :e Q_sqrt2_cut /\ Rlt q r.
admit.
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut is closed under negation **)
(** LATEX VERSION: If q^2<2 then (-q)^2<2, so the cut is symmetric. **)
Theorem Q_sqrt2_cut_neg_closed : forall q:set,
  q :e Q_sqrt2_cut -> minus_SNo q :e Q_sqrt2_cut.
admit.
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut has no minimum element in Q **)
(** LATEX VERSION: The cut {qQ | q^2<2} has no endpoint in Q. **)
Theorem Q_sqrt2_cut_no_min : forall q:set,
  q :e Q_sqrt2_cut -> exists r:set, r :e Q_sqrt2_cut /\ Rlt r q.
admit.
Qed.

(** helper for 16 Exercise 7: the sqrt(2) cut in Q is not an interval or ray (endpoints must lie in Q) **)
(** LATEX VERSION: {qQ | q^2<2} is not an interval or ray in Q since it has no endpoint in Q. **)
Theorem Q_sqrt2_cut_not_interval_or_ray :
  ~ interval_or_ray_in rational_numbers Q_sqrt2_cut.
admit.
Qed.
Theorem ex16_7_convex_interval_or_ray :
  exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.
admit.
Qed.

(** from 16 Exercise 8: lines as subspaces of lower limit products **)
(** LATEX VERSION: Exercise 8: If L is a straight line in the plane, describe the topology L inherits as a subspace of R_lR and as a subspace of R_lR_l. In each case it is a familiar topology. **)
(** NOTE: Formal statement currently deferred to Theorem ex16_8_lines_in_lower_limit_products, placed after Definition homeomorphism. **)

(** Helper: singleton rectangles in the dictionary order topology **)
Theorem singleton_rectangle_in_dictionary : forall a V:set,
  a :e R ->
  V :e R_standard_topology ->
  rectangle_set {a} V :e R2_dictionary_order_topology.
admit.
Qed.

(** Helper: general rectangles are unions of singleton rectangles **)
Theorem rectangle_in_dictionary : forall U V:set,
  U :e discrete_topology R ->
  V :e R_standard_topology ->
  rectangle_set U V :e R2_dictionary_order_topology.
admit.
Qed.

(** Helper: singleton is not open in the standard topology on R **)
Theorem singleton_not_open_R_standard_topology : forall a:set,
  a :e R ->
  {a} /:e R_standard_topology.
admit.
Qed.

(** from 16 Exercise 9: dictionary order topology on  equals _d   **) 
(** LATEX VERSION: Exercise 9: The dictionary order topology on  is the same as the product topology _d; compare it with the standard topology. **)
Theorem ex16_9_dictionary_equals_product :
  R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology
  /\ R2_dictionary_order_topology <> R2_standard_topology.
admit.
Qed.

(** from 16 Exercise 10: compare topologies on II **) 
(** LATEX VERSION: Exercise 10: Compare ordered square topology, dictionary subspace topology, and product topology on II. **)
Theorem ex16_10_compare_topologies_on_square :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <>
    product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
admit.
Qed.

(** from 17 Definition: interior and closure of a set **) 
(** LATEX VERSION: Interior of A is union of opens inside A; closure of A consists of points whose every open neighborhood meets A. **)
Definition interior_of : set -> set -> set -> set := fun X T A =>
  {x :e X | exists U:set, U :e T /\ x :e U /\ U c= A}.
Definition closure_of : set -> set -> set -> set := fun X T A =>
  {x :e X | forall U:set, U :e T -> x :e U -> U :/\: A <> Empty}.

(** helper: an open neighborhood contained in A witnesses interior membership **)
(** LATEX VERSION: If U is open and xUA then x belongs to the interior of A. **)
Theorem interior_of_contains_open_subset_point : forall X Tx A U x:set,
  topology_on X Tx ->
  U :e Tx ->
  x :e U ->
  U c= A ->
  x :e interior_of X Tx A.
admit.
Qed.

(** helper: if x lies in an open set U and interior(A)=Empty then U is not a subset of A **)
(** LATEX VERSION: If U is open, xU, and int(A)=, then U is not contained in A. **)
Theorem point_in_open_empty_interior_not_subset : forall X Tx A U x:set,
  topology_on X Tx ->
  interior_of X Tx A = Empty ->
  U :e Tx ->
  x :e U ->
  ~(U c= A).
admit.
Qed.

(** helper: in the finite complement topology, the closure of an infinite subset is all of X **)
(** LATEX VERSION: Not a numbered item; standard fact used when computing closures in the finite complement topology. **)
Theorem closure_infinite_finite_complement : forall X A:set,
  A c= X ->
  infinite A ->
  closure_of X (finite_complement_topology X) A = X.
admit.
Qed.

(** Helper: A is a subset of its closure **)
Theorem subset_of_closure : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
admit.
Qed.

(** Helper: Closure is monotone **)
Theorem closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
admit.
Qed.

(** Helper: closure in a finer topology is smaller **)
(** LATEX VERSION: If T1 is finer than T2, then cl_{T1}(A)  cl_{T2}(A). **)
Theorem closure_finer_than_Subq : forall X T1 T2 A:set,
  finer_than T1 T2 ->
  closure_of X T1 A c= closure_of X T2 A.
admit.
Qed.

(** Helper: interior of A is contained in A **)
Theorem interior_subset : forall X Tx A:set,
  topology_on X Tx -> interior_of X Tx A c= A.
admit.
Qed.

(** Helper: interior is monotone **)
Theorem interior_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> interior_of X Tx A c= interior_of X Tx B.
admit.
Qed.

(** Helper: open sets equal their interior **)
Theorem open_interior_eq : forall X Tx U:set,
  topology_on X Tx -> U :e Tx -> interior_of X Tx U = U.
admit.
Qed.

(** Helper: any open subset of A lies in the interior of A **)
(** LATEX VERSION: If U is open and U  A then U  int(A). **)
Theorem open_subset_interior : forall X Tx U A:set,
  topology_on X Tx -> U :e Tx -> U c= A -> U c= interior_of X Tx A.
admit.
Qed.

(** Helper: if int(A)=Empty then every open subset of A is Empty **)
(** LATEX VERSION: If int(A)= and U is open with U  A then U=. **)
Theorem open_subset_empty_interior_implies_empty : forall X Tx U A:set,
  topology_on X Tx -> U :e Tx -> U c= A -> interior_of X Tx A = Empty -> U = Empty.
admit.
Qed.

(** Helper: interior of empty set is empty **)
Theorem interior_of_empty : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx Empty = Empty.
admit.
Qed.

(** Helper: interior of whole space is the space **)
Theorem interior_of_space : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx X = X.
admit.
Qed.

(** Helper: interior is open **)
Theorem interior_is_open : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx A :e Tx.
admit.
Qed.

(** Helper: union of interiors contained in interior of union **)
Theorem interior_union_contains_union_interiors : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx A :\/: interior_of X Tx B c= interior_of X Tx (A :\/: B).
admit.
Qed.

(** Helper: interior of intersection contains intersection of interiors **)
Theorem interior_intersection_contains_intersection : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx (A :/\: B) c= interior_of X Tx A :/\: interior_of X Tx B.
admit.
Qed.

(** Helper: interior of intersection of open sets **)
Theorem interior_intersection_of_opens : forall X Tx U V:set,
  topology_on X Tx -> U :e Tx -> V :e Tx ->
  interior_of X Tx (U :/\: V) = U :/\: V.
admit.
Qed.

(** Helper: interior is idempotent **)
Theorem interior_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx (interior_of X Tx A) = interior_of X Tx A.
admit.
Qed.

(** Helper: interior-closure duality **)
Theorem not_in_closure_has_disjoint_open : forall X Tx A x:set,
  topology_on X Tx -> A c= X -> x :e X -> x /:e closure_of X Tx A ->
  exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
admit.
Qed.
Theorem closure_is_closed : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closed_in X Tx (closure_of X Tx A).
admit.
Qed.
Theorem interior_closure_complement_duality : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
admit.
Qed.


(** Helper: closure contains the set **)
Theorem closure_contains_set : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
admit.
Qed.

(** Helper: closure is in X **)
Theorem closure_in_space : forall X Tx A:set,
  topology_on X Tx -> closure_of X Tx A c= X.
admit.
Qed.

(** Helper: closure is contained in any closed superset **)
Theorem closure_subset_of_closed_superset : forall X Tx A C:set,
  topology_on X Tx ->
  A c= C ->
  closed_in X Tx C ->
  closure_of X Tx A c= C.
admit.
Qed.

(** Helper: closure of union contains union of closures **)
Theorem closure_union_contains_union_closures : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx A :\/: closure_of X Tx B c= closure_of X Tx (A :\/: B).
admit.
Qed.

(** Helper: closure of empty set is empty **)
Theorem closure_of_empty : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx Empty = Empty.
admit.
Qed.

(** Helper: closure of the whole space is the space itself **)
Theorem closure_of_space : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx X = X.
admit.
Qed.

(** Helper: union of two closed sets is closed **)
Theorem union_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :\/: D).
admit.
Qed.

(** Helper: Empty is closed **)
Theorem empty_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx Empty.
admit.
Qed.

(** Helper: X is closed **)
Theorem space_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx X.
admit.
Qed.

(** Helper: binary union as union of pair family **)
Theorem binunion_eq_Union_UPair : forall U V:set, U :\/: V = Union (UPair U V).
admit.
Qed.

(** Helper: union of a pair family equals binary union **)
Theorem Union_UPair_eq_binunion : forall U V:set, Union (UPair U V) = U :\/: V.
admit.
Qed.

(** Helper: Binary union of open sets is open **)
Theorem lemma_union_two_open : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
admit.
Qed.

(** Helper: intersection of two closed sets is closed **)
Theorem intersection_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :/\: D).
admit.
Qed.

Theorem closed_closure_eq : forall X Tx C:set,
  topology_on X Tx -> closed_in X Tx C -> closure_of X Tx C = C.
let X Tx C.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
prove closure_of X Tx C = C.
(** closed_in means there exists U :e Tx such that C = X :\: U **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub_and_ex: C c= X /\ exists U :e Tx, C = X :\: U.
{ exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub: C c= X.
{ exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
apply set_ext.
- (** closure(C)  C **)
  prove closure_of X Tx C c= C.
  (** We show: x  closure(C) implies x  C; otherwise x  X \\ C and X \\ C is open, contradicting that every open neighborhood of x meets C. **)
  let x. assume Hx: x :e closure_of X Tx C.
  prove x :e C.
  (** Use excluded middle **)
  apply (xm (x :e C)).
  + assume HxC: x :e C. exact HxC.
  + assume HxnotC: x /:e C.
    (** Get the open U such that C = X \ U **)
    claim Hex: exists U :e Tx, C = X :\: U.
    { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
    apply Hex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    (** x  closure(C) means x  X and every open containing x meets C **)
    claim HxX: x :e X.
    { exact (closure_in_space X Tx C Htop x Hx). }
    claim Hcond: forall V:set, V :e Tx -> x :e V -> V :/\: C <> Empty.
    { exact (SepE2 X (fun x0 => forall V:set, V :e Tx -> x0 :e V -> V :/\: C <> Empty) x Hx). }
    (** Since x  C and C = X \ U, we have x  U **)
    claim HxU: x :e U.
    { (** x  X and x  C = X \ U implies x  U **)
      apply (xm (x :e U)).
      - assume H. exact H.
      - assume HxnotU: x /:e U.
        (** Then x  X \ U = C, contradicting x  C **)
        apply HxnotC.
        claim HxXU: x :e X :\: U.
        { apply setminusI. exact HxX. exact HxnotU. }
        rewrite HCeq. exact HxXU. }
    (** Now U is open, x  U, so U  C  Empty by Hcond **)
    claim HUC_ne: U :/\: C <> Empty.
    { exact (Hcond U HU HxU). }
    (** But U  C = Empty since C = X \ U **)
    claim HUC_empty: U :/\: C = Empty.
    { apply set_ext.
      - let y. assume Hy: y :e U :/\: C.
        prove y :e Empty.
        claim HyU: y :e U.
        { exact (binintersectE1 U C y Hy). }
        claim HyC: y :e C.
        { exact (binintersectE2 U C y Hy). }
        (** C = X \ U, so y  C means y  X and y  U **)
        claim HyXU: y :e X :\: U.
        { rewrite <- HCeq. exact HyC. }
        claim HynotU: y /:e U.
        { exact (setminusE2 X U y HyXU). }
        (** Contradiction: y  U and y  U **)
        apply FalseE.
        exact (HynotU HyU).
      - exact (Subq_Empty (U :/\: C)). }
    (** Contradiction **)
    apply FalseE.
    exact (HUC_ne HUC_empty).
- (** C  closure(C) **)
  exact (subset_of_closure X Tx C Htop HCsub).
Qed.


(** Helper: closure of intersection of closed sets **)
Theorem closure_intersection_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :/\: D) = C :/\: D.
admit.
Qed.

(** Helper: closure of union of closed sets **)
Theorem closure_union_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :\/: D) = C :\/: D.
admit.
Qed.

(** Helper: closure is idempotent **)
Theorem closure_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
admit.
Qed.

(** Helper: closure of intersection is subset of intersection of closures **)
Theorem closure_intersection_contained : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
admit.
Qed.

(** Helper: closed sets equal their closure **)

(** from 17 Theorem 17.1: properties of closed sets **)
(** LATEX VERSION: Theorem 17.1: Closed sets contain X and , are closed under arbitrary intersections and finite unions. **)
Theorem closed_sets_axioms : forall X T:set,
  topology_on X T ->
  let C := {X :\: U|U :e T} in
    X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
admit.
Qed.

(** from 17 Theorem 17.2: closed sets in subspaces as intersections **) 
(** LATEX VERSION: Closed sets in a subspace are precisely intersections of the subspace with closed sets of the ambient space. **)
Theorem closed_in_subspace_iff_intersection : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X ->
  (closed_in Y (subspace_topology X Tx Y) A <->
   exists C:set, closed_in X Tx C /\ A = C :/\: Y).
admit.
Qed.

(** from 17 Theorem 17.3: closedness passes up when subspace is closed **) 
(** LATEX VERSION: If Y is closed in X, a set closed in the subspace Y is closed in X. **)
Theorem closed_in_closed_subspace : forall X Tx Y A:set,
  topology_on X Tx -> closed_in X Tx Y ->
  closed_in Y (subspace_topology X Tx Y) A ->
  closed_in X Tx A.
admit.
Qed.

(** from 17 Theorem 17.4: closure in subspace equals intersection **)
(** LATEX VERSION: Closure in a subspace equals the ambient closure intersected with the subspace. **)
Theorem closure_in_subspace : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
admit.
Qed.

(** from 17 Theorem 17.5: closure via neighborhoods/basis **) 
(** LATEX VERSION: Characterization of closure: x is in closure of A iff every open neighborhood of x meets A. **)
Theorem closure_characterization : forall X Tx A x:set,
  topology_on X Tx -> x :e X ->
  (x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty)).
admit.
Qed.

(** from 17 Corollary 17.7: closed iff contains all limit points **) 
(** LATEX VERSION: Limit point x of A means every neighborhood of x contains a point of A different from x; closure equals A plus its limit points. **)
Definition limit_point_of : set -> set -> set -> set -> prop := fun X Tx A x =>
  topology_on X Tx /\ x :e X /\
  forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
Definition limit_points_of : set -> set -> set -> set := fun X Tx A => {x :e X|limit_point_of X Tx A x}.

(** LATEX VERSION: Corollary 17.7: The closure of A equals A together with all its limit points. **)
Theorem closure_equals_set_plus_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  closure_of X Tx A = A :\/: limit_points_of X Tx A.
admit.
Qed.

(** from 17: closed sets contain all limit points **)
(** LATEX VERSION: A set A is closed iff it contains all its limit points. **)
Theorem closed_iff_contains_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  (closed_in X Tx A <-> limit_points_of X Tx A c= A).
admit.
Qed.

(** from 17 Definition: Hausdorff and T1 spaces **) 
(** LATEX VERSION: Hausdorff (T): distinct points have disjoint neighborhoods; T: all finite sets closed. **)
Definition Hausdorff_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.

(** Helper: extract topology_on from Hausdorff_space **)
Theorem Hausdorff_space_topology : forall X Tx:set,
  Hausdorff_space X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract the separation axiom from Hausdorff_space **)
Theorem Hausdorff_space_separation : forall X Tx x1 x2:set,
  Hausdorff_space X Tx -> x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
admit.
Qed.

(** from 17: the T1 axiom **)
(** LATEX VERSION: The T1 axiom says that finite point sets are closed. **)
(** FIXED: Quantifier scope error; T1_space requires finite subsets of X to be closed (F c= X -> finite F -> closed_in X Tx F), not all finite sets. **)
Definition T1_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).

(** Helper: extract topology_on from T1_space **)
Theorem T1_space_topology : forall X Tx:set,
  T1_space X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract finite closedness axiom from T1_space **)
Theorem T1_space_finite_closed : forall X Tx F:set,
  T1_space X Tx -> F c= X -> finite F -> closed_in X Tx F.
admit.
Qed.

(** helper: in a Hausdorff space, the complement of a singleton is open **)
Theorem Hausdorff_singleton_complement_open : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> X :\: {x} :e Tx.
admit.
Qed.

(** helper: in a Hausdorff space, singletons are closed **)
Theorem Hausdorff_singletons_closed : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> closed_in X Tx {x}.
admit.
Qed.

(** from 17 Theorem 17.8: finite sets closed in Hausdorff **) 
(** LATEX VERSION: In any Hausdorff space, every finite subset is closed. **)
Theorem finite_sets_closed_in_Hausdorff : forall X Tx:set,
  Hausdorff_space X Tx -> forall F:set, F c= X -> finite F -> closed_in X Tx F.
admit.
Qed.

(** from 17 Theorem 17.9: limit points in T1 spaces have infinite neighborhoods **) 
(** LATEX VERSION: In T spaces, x is a limit point of A iff every neighborhood of x meets A in infinitely many points. **)
Theorem limit_points_infinite_neighborhoods : forall X Tx A x:set,
  T1_space X Tx ->
  x :e X ->
  (limit_point_of X Tx A x <->
  (forall U :e Tx, x :e U -> infinite (U :/\: A))).
admit.
Qed.

(** from 17 Theorem 17.10: uniqueness of limits in Hausdorff spaces **) 
(** LATEX VERSION: In Hausdorff spaces, sequences (or nets) have at most one limit. **)
Theorem Hausdorff_unique_limits : forall X Tx seq x y:set,
  Hausdorff_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  function_on seq omega X ->
  (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  (forall U:set, U :e Tx -> y :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  False.
admit.
Qed.

(** from 17 Theorem 17.11: Hausdorff stability under constructions **) 
(** LATEX VERSION: Products of Hausdorff spaces are Hausdorff. **)
Theorem Hausdorff_stability : forall X Tx Y Ty:set,
  Hausdorff_space X Tx /\ Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** from 17 Exercises 120: closures, boundaries, Hausdorff properties **) 
(** LATEX VERSION: Exercise 1: Given a notion of closed sets satisfying axioms, prove they come from a topology. **)
Theorem ex17_1_topology_from_closed_sets : forall X Tx:set,
  closed_in X Tx X -> (forall A:set, closed_in X Tx A -> closed_in X Tx (X :\: A)) -> topology_on X Tx.
admit.
Qed.

(** LATEX VERSION: Exercise 2: If Y is closed in X and A is closed in the subspace Y, then A is closed in X. **)
Theorem ex17_2_closed_in_closed_subspace : forall X Tx Y A:set,
  closed_in X Tx Y -> closed_in Y (subspace_topology X Tx Y) A -> closed_in X Tx A.
admit.
Qed.

(** LATEX VERSION: Exercise 3: Products of closed sets are closed in the product topology. **)
Theorem ex17_3_product_of_closed_sets_closed : forall X Tx Y Ty A B:set,
  closed_in X Tx A -> closed_in Y Ty B ->
  closed_in (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
admit.
Qed.

(** LATEX VERSION: Exercise 4: For open U and closed A, U\\A is open and A\\U is closed. **)
Theorem ex17_4_open_minus_closed_and_closed_minus_open : forall X Tx U A:set,
  topology_on X Tx -> open_in X Tx U -> closed_in X Tx A ->
  open_in X Tx (U :\: A) /\ closed_in X Tx (A :\: U).
admit.
Qed.

(** from 17 Exercise 5: closure of (a,b) subset [a,b] **)
(** LATEX VERSION: Exercise 5: Let X be an ordered set in the order topology. Show that cl((a,b)) c= [a,b]. Under what conditions does equality hold **)
Theorem ex17_5_closure_of_interval_in_order_topology : forall X a b:set,
  simply_ordered_set X ->
  a :e X ->
  b :e X ->
  closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
admit.
Qed.

(** from 17 Exercise 5: conditions for equality cl((a,b)) = [a,b] **)
(** LATEX VERSION: Equality holds under additional hypotheses on the endpoints, e.g. when the order has no gaps at a and b within X. **)
(** Helper definition for Exercise 5: no immediate successor and predecessor endpoints **)
Definition no_immediate_successor : set -> set -> prop := fun X a =>
  forall c:set, c :e X -> order_rel X a c ->
    exists x:set, x :e X /\ order_rel X a x /\ order_rel X x c.

(** from 17 Exercise 5: conditions for equality cl((a,b)) = [a,b] **)
(** LATEX VERSION: Equality holds under additional hypotheses on the endpoints, e.g. when the order has no gaps at a and b within X. **)
Definition no_immediate_predecessor : set -> set -> prop := fun X b =>
  forall c:set, c :e X -> order_rel X c b ->
    exists x:set, x :e X /\ order_rel X c x /\ order_rel X x b.

(** from 17 Exercise 5: local basis meets open interval witness **)
(** LATEX VERSION: For x in [a,b], every order-topology basis neighborhood of x meets (a,b), assuming no immediate successor at a and no immediate predecessor at b. **)
Theorem ex17_5_basis_elem_meets_interval : forall X a b x b0:set,
  simply_ordered_set X ->
  a :e X -> b :e X -> order_rel X a b ->
  no_immediate_successor X a ->
  no_immediate_predecessor X b ->
  x :e closed_interval_in X a b ->
  b0 :e order_topology_basis X ->
  x :e b0 ->
  exists y:set, y :e b0 /\ y :e order_interval X a b.
admit.
Qed.

(** from 17 Exercise 5: conditions for equality cl((a,b)) = [a,b] **)
(** LATEX VERSION: Exercise 5: Equality holds when the endpoints are limit points of (a,b) from within X, e.g. in a dense order without gaps **)
Theorem ex17_5_closure_of_interval_eq_conditions : forall X a b:set,
  simply_ordered_set X ->
  a :e X -> b :e X -> order_rel X a b ->
  no_immediate_successor X a ->
  no_immediate_predecessor X b ->
  closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
admit.
Qed.

(** Helper: closure is idempotent and closed **)
(** LATEX VERSION: Closure is closed and idempotent: cl(cl(A)) = cl(A), and cl(A) is closed **)
Theorem closure_idempotent_and_closed : forall X Tx A:set,
  topology_on X Tx ->
  closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\
  closed_in X Tx (closure_of X Tx A).
admit.
Qed.

(** from 17 Exercise 6(a): monotonicity of closure **)
(** LATEX VERSION: If A c= B then cl(A) c= cl(B). **)
Theorem ex17_6a_closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
admit.
Qed.

(** from 17 Exercise 6(b): closure of a union **)
(** LATEX VERSION: cl(A :\/: B) = cl(A) :\/: cl(B). **)
Theorem ex17_6b_closure_binunion : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\/: B) = closure_of X Tx A :\/: closure_of X Tx B.
admit.
Qed.

(** from 17 Exercise 6(c): closure of an arbitrary union contains union of closures **)
(** LATEX VERSION: cl(Union A_alpha) c=?; always have cl(Union A_alpha) c>= Union cl(A_alpha). **)
Theorem ex17_6c_closure_Union_contains_Union_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  Union {closure_of X Tx A|A :e Fam} c= closure_of X Tx (Union Fam).
admit.
Qed.

(** from 17 Exercise 7: critique the attempted proof about closures of unions **)
(** LATEX VERSION: Criticize the proof that cl(Union A_alpha) c= Union cl(A_alpha). **)
Theorem ex17_7_counterexample_union_closure :
  exists X Tx Fam:set,
    topology_on X Tx /\
    (forall A:set, A :e Fam -> A c= X) /\
    ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
admit.
Qed.

(** from 17 Exercise 8(a): closure of intersection is contained in intersection of closures **)
(** LATEX VERSION: Determine whether cl(A :/\\: B) = cl(A) :/\\: cl(B); always have inclusion c= . **)
Theorem ex17_8a_closure_intersection_Subq_intersection_closures : forall X Tx A B:set,
  topology_on X Tx ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
admit.
Qed.

(** from 17 Exercise 8(b): closure of an arbitrary intersection and intersection of closures **)
(** LATEX VERSION: Determine whether cl(Intersection A_alpha) = Intersection cl(A_alpha); always have inclusion c= . **)
Theorem ex17_8b_closure_intersection_family_Subq_intersection_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  closure_of X Tx (intersection_of_family X Fam) c=
    intersection_of_family X {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** from 17 Exercise 8(c): closure of set difference **)
(** LATEX VERSION: Determine whether cl(A-B) = cl(A) - cl(B); at least cl(A-B) c= cl(A). **)
Theorem ex17_8c_closure_setminus_Subq_closure_left : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\: B) c= closure_of X Tx A.
admit.
Qed.

(** from 17 Exercise 8(c): counterexample to equality cl(A-B) = cl(A) - cl(B) **)
(** LATEX VERSION: Give an example where the equality fails. **)
Theorem ex17_8c_counterexample_equality_fails :
  exists X Tx A B:set,
    topology_on X Tx /\
    A c= X /\ B c= X /\
    closure_of X Tx (A :\: B) <> (closure_of X Tx A :\: closure_of X Tx B).
admit.
Qed.

(** LATEX VERSION: Exercise 9: Closure of AB in product is product of closures. **)
Theorem ex17_9_closure_of_product_subset : forall X Y Tx Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  closure_of (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) =
    setprod (closure_of X Tx A) (closure_of Y Ty B).
admit.
Qed.

(** LATEX VERSION: Exercise 10: Order topology is Hausdorff. **)
Theorem ex17_10_order_topology_Hausdorff : forall X:set,
  simply_ordered_set X ->
  Hausdorff_space X (order_topology X).
admit.
Qed.

(** LATEX VERSION: Exercise 11: Product of Hausdorff spaces is Hausdorff. **)
Theorem ex17_11_product_Hausdorff : forall X Tx Y Ty:set,
  Hausdorff_space X Tx -> Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** LATEX VERSION: Exercise 12: Subspaces of Hausdorff spaces are Hausdorff. **)
Theorem ex17_12_subspace_Hausdorff : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> Hausdorff_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** LATEX VERSION: Exercise 13: Diagonal is closed in XX iff X is Hausdorff. **)
Theorem ex17_13_diagonal_closed_iff_Hausdorff : forall X Tx:set,
  topology_on X Tx ->
  (Hausdorff_space X Tx <->
    closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}).
admit.
Qed.

(** LATEX VERSION: In the finite complement topology on R, to what point or points does the sequence x_n = 1/n converge? **)
(** For this exercise we represent the sequence by n  1/(n+1), so it is a function on omega. **)
Definition seq_one_over_n : set := (fun n :e omega => {inv_nat (ordsucc n)}).
Theorem seq_one_over_n_apply : forall n:set, n :e omega ->
  apply_fun seq_one_over_n n = inv_nat (ordsucc n).
admit.
Qed.
Theorem inv_nat_ordsucc_inj : forall n m:set,
  n :e omega -> m :e omega -> inv_nat (ordsucc n) = inv_nat (ordsucc m) -> n = m.
admit.
Qed.
Theorem omega_binunion : forall a b:set, a :e omega -> b :e omega -> a :\/: b :e omega.
admit.
Qed.
Theorem seq_one_over_n_inj : forall n m:set, n :e omega -> m :e omega ->
  apply_fun seq_one_over_n n = apply_fun seq_one_over_n m -> n = m.
admit.
Qed.

(** helper: K_set is infinite (inject omega via n  1/(n+1)) **)
(** LATEX VERSION: Not a numbered item; used to show K is infinite when analyzing closure in the finite complement topology. **)
Theorem K_set_infinite : infinite K_set.
admit.
Qed.
Theorem ex17_14_sequence_in_finite_complement_topology : forall x:set,
  x :e R ->
  forall U:set,
    U :e finite_complement_topology R ->
    x :e U ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n :e U.
admit.
Qed.

(** helper: T1_space is equivalent to all singleton subsets being closed **)
Theorem lemma_T1_singletons_closed : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <-> (forall x:set, x :e X -> closed_in X Tx {x})).
admit.
Qed.

(** helper: in a T1 space, the complement of a singleton is open **)
(** LATEX VERSION: In a T1 space, X\\{x} is open for every xX. **)
Theorem T1_singleton_complement_open : forall X Tx x:set,
  T1_space X Tx -> x :e X -> X :\: {x} :e Tx.
admit.
Qed.

(** helper: subspaces of T1 spaces are T1 **)
(** LATEX VERSION: If X is T1, then every subspace YX is T1 in the subspace topology. **)
Theorem subspace_T1 : forall X Tx Y:set,
  topology_on X Tx -> Y c= X -> T1_space X Tx -> T1_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** LATEX VERSION: Exercise 15: Show the T1 axiom is equivalent to the condition that for each pair of points of X, each has a neighborhood not containing the other. **)
Theorem ex17_15_T1_characterization : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <->
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V)).
admit.
Qed.

(** LATEX VERSION: Exercise 16(a): Determine the closure of K={1/n : n in Zplus} under each of the five R topologies from 13 Exercise 7. **)
Definition R_nonneg_set : set := {x :e R|0 <= x}.

(** helper: the closure of K_set in the K-topology is K_set (K_set is closed in the K-topology) **)
Theorem closure_of_K_in_R_K_topology :
  closure_of R R_K_topology K_set = K_set.
admit.
Qed.

(** helper: closure of K_set in the left ray topology is the nonnegative reals **)
Theorem closure_of_K_in_R_ray_topology :
  closure_of R R_ray_topology K_set = R_nonneg_set.
admit.
Qed.

(** helper: for x>0 not in K_set, there is a standard open neighborhood disjoint from K_set **)
(** LATEX VERSION: Not a numbered item; used to isolate points x>0 from the discrete set {1/n} in the standard topology. **)
Theorem K_set_above_positive_bound_finite : forall b:set,
  b :e R ->
  Rlt 0 b ->
  finite (K_set :/\: {y :e R|Rlt b y}).
admit.
Qed.
Theorem standard_open_neighborhood_disjoint_from_K_set_pos : forall x:set,
  x :e R -> 0 < x -> ~(x :e K_set) ->
  exists U:set, U :e R_standard_topology /\ x :e U /\ U :/\: K_set = Empty.
admit.
Qed.

(** helper: closure of K_set in the upper limit topology is K_set **)
Theorem closure_of_K_in_R_upper_limit_topology :
  closure_of R R_upper_limit_topology K_set = K_set.
admit.
Qed.

(** helper: closure of K_set in the standard topology is K_set union {0} **)
Theorem closure_of_K_in_R_standard_topology :
  closure_of R R_standard_topology K_set = K_set :\/: {0}.
admit.
Qed.
Theorem ex17_16a_closure_of_K_in_five_topologies :
  closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.
admit.
Qed.

(** helper: in the left ray topology, any open set containing 1 contains 0 **)
Theorem ray_topology_contains_0_if_contains_1 : forall U:set,
  U :e R_ray_topology -> 1 :e U -> 0 :e U.
admit.
Qed.

(** helper: the left ray topology on R is not Hausdorff **)
Theorem ray_topology_not_Hausdorff : ~Hausdorff_space R R_ray_topology.
admit.
Qed.

(** helper: the left ray topology on R is not T1 **)
Theorem ray_topology_not_T1 : ~T1_space R R_ray_topology.
admit.
Qed.

(** helper: X minus Empty equals X **)
Theorem setminus_Empty_eq : forall X:set, X :\: Empty = X.
admit.
Qed.

(** helper: R is infinite **)
Theorem infinite_R : infinite R.
admit.
Qed.

(** helper: finite complement topology is T1 **)
Theorem finite_complement_topology_T1 : forall X:set, T1_space X (finite_complement_topology X).
admit.
Qed.

(** helper: the finite complement topology on R is not Hausdorff **)
Theorem R_finite_complement_not_Hausdorff : ~Hausdorff_space R R_finite_complement_topology.
admit.
Qed.

(** helper: the standard topology on R is Hausdorff and T1 **)
Theorem R_standard_topology_Hausdorff : Hausdorff_space R R_standard_topology.
admit.
Qed.
Theorem R_standard_topology_T1 : T1_space R R_standard_topology.
admit.
Qed.

(** helper: Hausdorff is preserved by passing to a finer topology **)
Theorem finer_preserves_Hausdorff : forall X Tx Ty:set,
  Hausdorff_space X Tx ->
  topology_on X Ty ->
  Tx c= Ty ->
  Hausdorff_space X Ty.
admit.
Qed.

(** helper: the upper limit topology on R is Hausdorff and T1 **)
Theorem R_upper_limit_topology_Hausdorff : Hausdorff_space R R_upper_limit_topology.
admit.
Qed.
Theorem R_upper_limit_topology_T1 : T1_space R R_upper_limit_topology.
admit.
Qed.

(** helper: the K topology on R is Hausdorff and T1 **)
Theorem R_K_topology_Hausdorff : Hausdorff_space R R_K_topology.
admit.
Qed.
Theorem R_K_topology_T1 : T1_space R R_K_topology.
admit.
Qed.

(** LATEX VERSION: Exercise 16(b): For the same five R topologies, determine which satisfy the Hausdorff and the T1 axioms. **)
Theorem ex17_16b_Hausdorff_and_T1_for_five_topologies :
  (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
  (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
  (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology) /\
  (~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology) /\
  (~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology).
admit.
Qed.

(** LATEX VERSION: Exercise 17: Compare closures of A=(0,sqrt 2) and B=(sqrt 2,3) in the lower limit topology and the topology generated by the rational half open basis C. **)
(** Helper: basic real membership facts used in Exercise 17 definitions **)
Theorem real_2 : 2 :e R.
admit.
Qed.
Theorem ordsucc_2_eq_3 : ordsucc 2 = 3.
admit.
Qed.
Theorem add_SNo_2_1_eq_3 : add_SNo 2 1 = 3.
admit.
Qed.
Theorem real_3 : 3 :e R.
admit.
Qed.

(** from 17 Exercise 17: closures of (0,sqrt2) and (sqrt2,3) **)
(** LATEX VERSION: Consider the intervals A=(0,sqrt2) and B=(sqrt2,3) when comparing closures in different topologies on R. **)
Definition sqrt2 : set := sqrt_SNo_nonneg 2.

(** Helper: sqrt2 is real **)
Theorem sqrt2_in_R : sqrt2 :e R.
admit.
Qed.

(** Helper: sqrt2 is positive **)
Theorem SNoLt_0_sqrt2 : 0 < sqrt2.
admit.
Qed.

(** Helper: 3 is a rational number **)
Theorem three_in_rational_numbers : 3 :e rational_numbers.
admit.
Qed.

(** Helper: sqrt2 is not rational **)
Theorem sqrt2_not_rational_numbers : sqrt2 /:e rational_numbers.
admit.
Qed.

(** from 17 Exercise 17: topology generated by basis C (rational half open intervals) **)
(** LATEX VERSION: Consider the topology given by the basis C from Exercise 8 of 13, consisting of half-open intervals with rational endpoints. **)
Definition R_C_topology : set := generated_topology R rational_halfopen_intervals_basis.

(** Helper: the lower limit topology is finer than the rational half-open topology **)
(** LATEX VERSION: Since the half-open rational intervals are among the half-open real intervals, the topology they generate is coarser than the lower limit topology. **)
Theorem R_lower_limit_finer_than_R_C : finer_than R_lower_limit_topology R_C_topology.
admit.
Qed.

(** from 17 Exercise 17: the interval A **)
(** LATEX VERSION: A = (0,sqrt2). **)
Definition ex17_17_interval_A : set := open_interval 0 sqrt2.
(** from 17 Exercise 17: the interval B **)
(** LATEX VERSION: B = (sqrt2,3). **)
Definition ex17_17_interval_B : set := open_interval sqrt2 3.
(** from 17 Exercise 17: closure of A in the lower limit topology **)
(** LATEX VERSION: In the lower limit topology, cl(A) = {x | 0 <= x < sqrt2}. **)
Definition ex17_17_interval_A_closure_lower : set := {x :e R|0 <= x /\ x < sqrt2}.
(** from 17 Exercise 17: closure of A in the C topology **)
(** LATEX VERSION: In the topology generated by rational half-open intervals, cl(A) = {x | 0 <= x <= sqrt2}. **)
Definition ex17_17_interval_A_closure_C : set := {x :e R|0 <= x /\ x <= sqrt2}.
(** from 17 Exercise 17: closure of B in the lower limit topology **)
(** LATEX VERSION: In the lower limit topology, cl(B) = {x | sqrt2 <= x < 3}. **)
Definition ex17_17_interval_B_closure_lower : set := {x :e R|sqrt2 <= x /\ x < 3}.

(** Helper for Exercise 17: closure(A) in lower limit topology is contained in {x|0<=x<x<sqrt2} **)
(** LATEX VERSION: In the lower limit topology, points <0 and points sqrt2 have neighborhoods disjoint from A=(0,sqrt2). **)
Theorem ex17_17_closure_A_lower_Subq : closure_of R R_lower_limit_topology ex17_17_interval_A c= ex17_17_interval_A_closure_lower.
admit.
Qed.

(** Helper for Exercise 17: {x|0<=x<x<sqrt2} is contained in the closure of A in the lower limit topology **)
(** LATEX VERSION: If 0<x<sqrt2 then x itself witnesses every neighborhood meets A; for x=0 use a basis element and density of rationals. **)
Theorem ex17_17_closure_A_lower_Supq :
  ex17_17_interval_A_closure_lower c= closure_of R R_lower_limit_topology ex17_17_interval_A.
admit.
Qed.

(** Helper for Exercise 17: closure(B) in lower limit topology is contained in {x|sqrt2<=x<x<3} **)
(** LATEX VERSION: In the lower limit topology, points <sqrt2 and points 3 have neighborhoods disjoint from B=(sqrt2,3). **)
Theorem ex17_17_closure_B_lower_Subq : closure_of R R_lower_limit_topology ex17_17_interval_B c= ex17_17_interval_B_closure_lower.
admit.
Qed.

(** Helper for Exercise 17: {x|sqrt2<=x<3} is contained in the closure of B in the lower limit topology **)
(** LATEX VERSION: If sqrt2<x<3 then x itself witnesses every neighborhood meets B; for x=sqrt2 use a basis element and density of rationals. **)
Theorem ex17_17_closure_B_lower_Supq :
  ex17_17_interval_B_closure_lower c= closure_of R R_lower_limit_topology ex17_17_interval_B.
admit.
Qed.

(** Helper for Exercise 17: closure(A) in C topology is contained in {x|0<=x<=sqrt2} **)
(** LATEX VERSION: For x<0 or x>sqrt2, a rational half-open neighborhood of x misses A=(0,sqrt2). **)
Theorem ex17_17_closure_A_C_Subq :
  closure_of R R_C_topology ex17_17_interval_A c= ex17_17_interval_A_closure_C.
admit.
Qed.

(** Helper for Exercise 17: {x|0<=x<=sqrt2} is contained in closure(A) in C topology **)
(** LATEX VERSION: For x in A it is immediate; for x=0 or x=sqrt2 use rational basis neighborhoods and density of rationals. **)
Theorem ex17_17_closure_A_C_Supq :
  ex17_17_interval_A_closure_C c= closure_of R R_C_topology ex17_17_interval_A.
admit.
Qed.

(** Helper for Exercise 17: closure(B) in C topology is contained in {x|sqrt2<=x<3} **)
(** LATEX VERSION: For x<sqrt2 or x>=3, a rational half-open neighborhood of x misses B=(sqrt2,3). **)
Theorem ex17_17_closure_B_C_Subq :
  closure_of R R_C_topology ex17_17_interval_B c= ex17_17_interval_B_closure_lower.
admit.
Qed.

(** Helper for Exercise 17: {x|sqrt2<=x<3} is contained in closure(B) in C topology **)
(** LATEX VERSION: For x in B it is immediate; for x=sqrt2 use a rational basis neighborhood and density of rationals above sqrt2. **)
Theorem ex17_17_closure_B_C_Supq :
  ex17_17_interval_B_closure_lower c= closure_of R R_C_topology ex17_17_interval_B.
admit.
Qed.
Theorem ex17_17_closures_of_A_B_in_two_topologies :
  closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.
admit.
Qed.

(** LATEX VERSION: Exercise 18: Determine the closures of the subsets A,B,C,D,E of the ordered square listed in the text. **)
Definition ordsq_A : set := {(inv_nat n,0)|n :e omega :\: {0}}.
Definition ordsq_B : set := {(add_SNo 1 (minus_SNo (inv_nat n)),eps_ 1)|n :e omega :\: {0}}.
Definition ordsq_C : set := {p :e ordered_square|exists x:set, p = (x,0) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_D : set := {p :e ordered_square|exists x:set, p = (x,eps_ 1) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_E : set := {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt 0 y /\ Rlt y 1}.

(** from 17 Exercise 18: named corner points and closure description helper sets **)
(** LATEX VERSION: Use points (0,1) and (1,0); closure of E adds the endpoints (eps(1),0) and (eps(1),1). **)
Definition ordsq_p01 : set := (0,1).
Definition ordsq_p10 : set := (1,0).
Definition ordsq_E_closure : set := ordsq_E :\/: {(eps_ 1,0)} :\/: {(eps_ 1,1)}.

(** helper for 17 Exercise 18: top edge points x1 with x<1 **)
(** LATEX VERSION: Used when determining closures in the ordered square; the set {x1 | 0x<1}. **)
Definition ordsq_top_edge_lt1 : set :=
  {p :e ordered_square | exists x:set, p = (x,1) /\ x :e unit_interval /\ Rlt x 1}.

(** helper for 17 Exercise 18: closure descriptions as named sets **)
(** LATEX VERSION: These sets package the computed closure descriptions for C and D in the ordered square. **)
Definition ordsq_C_closure : set := ordsq_C :\/: ordsq_top_edge_lt1 :\/: {ordsq_p10}.
Definition ordsq_D_closure : set := ordsq_D :\/: ordsq_C :\/: ordsq_top_edge_lt1 :\/: {ordsq_p10}.

(** helper: setprod R R is in the simply ordered set scope **)
(** LATEX VERSION: This is bookkeeping: our hard-wired simply ordered sets include RR under dictionary order. **)
Theorem simply_ordered_set_setprod_R_R : simply_ordered_set (setprod R R).
admit.
Qed.

(** helper: the ordered square lies in R times R **)
(** LATEX VERSION: Since the unit interval is a subset of R, the ordered square I times I is a subset of R times R. **)
Theorem ordered_square_sub_setprod_R_R : ordered_square c= setprod R R.
admit.
Qed.

(** helper: dictionary order with fixed first coordinate **)
Theorem order_rel_setprod_R_R_same_first : forall x a2 b2:set,
  Rlt a2 b2 -> order_rel (setprod R R) (x, a2) (x, b2).
admit.
Qed.

(** helper: extract the dictionary disjunction from an RR order_rel between pairs **)
Theorem order_rel_setprod_R_R_disj : forall a1 a2 b1 b2:set,
  order_rel (setprod R R) (a1, a2) (b1, b2) -> Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2).
admit.
Qed.

(** helper: the point (eps(1),eps(1)) lies in E **)
(** LATEX VERSION: Since 0<eps(1)<1, the point (eps(1),eps(1)) belongs to E={(eps(1),y):0<y<1}. **)
Theorem ordsq_eps1_eps1_in_E : (eps_ 1, eps_ 1) :e ordsq_E.
admit.
Qed.

(** from 17 Exercise 18: closure of E in the ordered square **)
(** LATEX VERSION: cl(E) = E  {(eps(1),0)}  {(eps(1),1)} in the ordered square. **)
Theorem ex17_18_closure_E :
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
admit.
Qed.

(** helper: reciprocal of a natural is <= 1 (local copy to avoid forward references) **)
(** LATEX VERSION: For n\\{0}, 1/n  1. **)
Theorem inv_nat_Rle_1_local : forall n:set, n :e omega :\: {0} -> Rle (inv_nat n) 1.
admit.
Qed.

(** helper: inv_nat n lies in the unit interval for n in omega setminus {0} **)
(** LATEX VERSION: For n\\{0}, 1/n  [0,1]. **)
Theorem inv_nat_in_unit_interval : forall n:set,
  n :e omega :\: {0} ->
  inv_nat n :e unit_interval.
admit.
Qed.

(** helper: ordsq_B is a subset of the ordered square **)
(** LATEX VERSION: Every point (1 - 1/n, eps(1)) lies in [0,1][0,1]. **)
Theorem ordsq_B_sub_ordered_square : ordsq_B c= ordered_square.
admit.
Qed.

(** helper: division by n equals inv_nat n when numerator is 1 (local copy) **)
(** LATEX VERSION: For n0, 1/n = inv_nat n. **)
Theorem div_SNo_1_eq_inv_nat_local : forall n:set,
  SNo n -> div_SNo 1 n = inv_nat n.
admit.
Qed.

(** helper: given r>0, some inv_nat (n+1) is below r (local copy to avoid forward references) **)
(** LATEX VERSION: For every real r>0, there exists N with inv_nat(N+1) < r. **)
Theorem exists_inv_nat_ordsucc_lt_local : forall r:set,
  r :e R -> Rlt 0 r ->
  exists N:set, N :e omega /\ Rlt (inv_nat (ordsucc N)) r.
admit.
Qed.

(** helper: for i<j in omega, inv_nat (i+1) is larger than inv_nat (j+1) (local copy to avoid forward references) **)
(** LATEX VERSION: For i<j in omega, 1/(j+1) < 1/(i+1). **)
Theorem inv_nat_ordsucc_antitone_local2 : forall i j:set,
  i :e omega -> j :e omega -> i :e j ->
  Rlt (inv_nat (ordsucc j)) (inv_nat (ordsucc i)).
admit.
Qed.

(** helper: one inclusion for closure of A in the ordered square **)
(** LATEX VERSION: A  {(0,1)}  cl(A). **)
Theorem ex17_18_closure_A_Supq :
  ordsq_A :\/: {ordsq_p01} c= closure_of ordered_square ordered_square_topology ordsq_A.
admit.
Qed.

(** helper: reverse inclusion for closure of A in the ordered square **)
(** LATEX VERSION: cl(A)  A  {(0,1)}. **)
Theorem ex17_18_closure_A_Subq :
  closure_of ordered_square ordered_square_topology ordsq_A c= ordsq_A :\/: {ordsq_p01}.
admit.
Qed.

(** helper: basis neighborhoods of p10 meet B in the ordered square **)
(** LATEX VERSION: Near (1,0), the points (1 - 1/n, eps(1)) accumulate in the dictionary order topology. **)
Theorem ex17_18_p10_interval_basis_meets_B : forall a0 b0:set,
  a0 :e ordered_square ->
  b0 :e ordered_square ->
  order_rel (setprod R R) a0 ordsq_p10 ->
  order_rel (setprod R R) ordsq_p10 b0 ->
  exists w:set,
    w :e {x0 :e ordered_square | order_rel (setprod R R) a0 x0 /\ order_rel (setprod R R) x0 b0} /\
    w :e ordsq_B.
admit.
Qed.

(** LATEX VERSION: Any lower ray neighborhood of (1,0) intersects B. **)
Theorem ex17_18_p10_lower_basis_meets_B : forall b0:set,
  b0 :e ordered_square ->
  order_rel (setprod R R) ordsq_p10 b0 ->
  exists w:set,
    w :e {x0 :e ordered_square | order_rel (setprod R R) x0 b0} /\
    w :e ordsq_B.
admit.
Qed.

(** LATEX VERSION: Any upper ray neighborhood of (1,0) intersects B. **)
Theorem ex17_18_p10_upper_basis_meets_B : forall a0:set,
  a0 :e ordered_square ->
  order_rel (setprod R R) a0 ordsq_p10 ->
  exists w:set,
    w :e {x0 :e ordered_square | order_rel (setprod R R) a0 x0} /\
    w :e ordsq_B.
admit.
Qed.

(** helper: every point of B is strictly below p10 in the dictionary order **)
(** LATEX VERSION: For every n, (1 - 1/n, eps(1)) < (1,0). **)
Theorem ordsq_B_lt_p10 : forall w:set,
  w :e ordsq_B ->
  order_rel (setprod R R) w ordsq_p10.
admit.
Qed.

(** helper: the B-sequence is increasing when indexed by omega via ordsucc **)
(** LATEX VERSION: If i<j then (1-1/(i+1),eps(1)) < (1-1/(j+1),eps(1)). **)
Theorem ordsq_B_ordsucc_index_increasing : forall i j:set,
  i :e omega -> j :e omega -> i :e j ->
  order_rel (setprod R R)
    (add_SNo 1 (minus_SNo (inv_nat (ordsucc i))), eps_ 1)
    (add_SNo 1 (minus_SNo (inv_nat (ordsucc j))), eps_ 1).
admit.
Qed.

(** helper: closure(B) in the ordered square (packaged) **)
(** LATEX VERSION: cl(B) = B  {(1,0)}. **)
Theorem ex17_18_closure_B_eq :
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10}.
admit.
Qed.

(** helper: closure(C) in the ordered square (packaged) **)
(** LATEX VERSION: Exercise 18 asks to determine cl(C) for C={x0|0<x<1} in the ordered square. **)
(** helper: points on the top edge x1 with x<1 lie in cl(C) **)
Theorem ex17_18_top_edge_lt1_Sub_closure_C :
  ordsq_top_edge_lt1 c= closure_of ordered_square ordered_square_topology ordsq_C.
admit.
Qed.

(** helper: (1,0) lies in cl(C) **)
Theorem ex17_18_p10_in_closure_C :
  ordsq_p10 :e closure_of ordered_square ordered_square_topology ordsq_C.
admit.
Qed.
Theorem ex17_18_closure_C_eq :
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C_closure.
admit.
Qed.

(** helper: closure(D) in the ordered square (packaged) **)
(** LATEX VERSION: Exercise 18 asks to determine cl(D) for D={x1/2|0<x<1} in the ordered square. **)
(** helper: (1,0) lies in cl(D) **)
(** LATEX VERSION: In the ordered square, the closure of D contains the point (1,0). **)
Theorem ex17_18_p10_in_closure_D :
  ordsq_p10 :e closure_of ordered_square ordered_square_topology ordsq_D.
admit.
Qed.

(** helper: C is contained in cl(D) **)
(** LATEX VERSION: In the ordered square, C c= cl(D). **)
Theorem ex17_18_C_Sub_closure_D :
  forall p:set, p :e ordsq_C -> p :e closure_of ordered_square ordered_square_topology ordsq_D.
admit.
Qed.

(** helper: points on the top edge x1 with x<1 lie in cl(D) **)
(** LATEX VERSION: In the ordered square, the closure of D contains all top-edge points (x,1) with x<1. **)
Theorem ex17_18_top_edge_lt1_Sub_closure_D :
  ordsq_top_edge_lt1 c= closure_of ordered_square ordered_square_topology ordsq_D.
admit.
Qed.
Theorem ex17_18_closure_D_eq :
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D_closure.
admit.
Qed.
Theorem ex17_18_closures_in_ordered_square :
  closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C_closure /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D_closure /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
admit.
Qed.

(** from 17 Exercise 19: boundary of a set **)
(** LATEX VERSION: For A c= X, define Bd A = cl(A)  cl(X-A). **)
Definition boundary_of : set -> set -> set -> set := fun X Tx A =>
  closure_of X Tx A :/\: closure_of X Tx (X :\: A).

(** LATEX VERSION: Exercise 19: The boundary of A lies in closure(A) and in closure(X\\A). **)
Theorem ex17_19_boundary_properties : forall X Tx A:set,
  topology_on X Tx ->
  boundary_of X Tx A c= closure_of X Tx A /\
  boundary_of X Tx A c= closure_of X Tx (X :\: A).
admit.
Qed.

(** LATEX VERSION: Exercise 20: Boundary of a strip differs between standard and dictionary topologies on . **)
Theorem ex17_20_boundaries_and_interiors_in_R2 :
  boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <>
  boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
admit.
Qed.

(** LATEX VERSION: Exercise 21: Kuratowski example in discrete topology gives maximal closure after complement. **)
Theorem ex17_21_Kuratowski_closure_complement_maximal : forall X:set,
  closure_of X (discrete_topology X) (X :\: Empty) = X.
admit.
Qed.

(** from 18 Definition: continuous map between topological spaces **) 
(** LATEX VERSION: Continuity defined via preimages of open sets being open. **)
Definition preimage_of : set -> set -> set -> set := fun X f V =>
  {x :e X | apply_fun f x :e V}.

(** Helper: preimage of union of a family **)
(** LATEX VERSION: f^{-1}(Union Fam) equals Union of the preimages f^{-1}(V) for V in Fam. **)
Theorem preimage_of_Union : forall X f Fam:set,
  preimage_of X f (Union Fam) = Union {preimage_of X f V|V :e Fam}.
admit.
Qed.

(** Helper: preimage of binary intersection **)
(** LATEX VERSION: f^{-1}(UV) = f^{-1}(U)  f^{-1}(V). **)
Theorem preimage_of_binintersect : forall X f U V:set,
  preimage_of X f (U :/\: V) = (preimage_of X f U) :/\: (preimage_of X f V).
admit.
Qed.

(** Helper: preimage is monotone under inclusion **)
(** LATEX VERSION: If V subset W then f^{-1}(V) subset f^{-1}(W). **)
Theorem preimage_of_mono : forall X f V W:set,
  V c= W ->
  preimage_of X f V c= preimage_of X f W.
admit.
Qed.

(** Helper: preimage of binary union **)
(** LATEX VERSION: f^{-1}(UV) = f^{-1}(U)  f^{-1}(V). **)
Theorem preimage_of_binunion : forall X f U V:set,
  preimage_of X f (U :\/: V) = (preimage_of X f U) :\/: (preimage_of X f V).
admit.
Qed.

(** Helper: preimage of set difference **)
(** LATEX VERSION: f^{-1}(U\\V) = f^{-1}(U)\\f^{-1}(V). **)
Theorem preimage_of_setminus : forall X f U V:set,
  preimage_of X f (U :\: V) = (preimage_of X f U) :\: (preimage_of X f V).
admit.
Qed.

(** Helper: preimage of Empty **)
(** LATEX VERSION: f^{-1}() = . **)
Theorem preimage_of_Empty : forall X f:set,
  preimage_of X f Empty = Empty.
admit.
Qed.

(** Helper: preimage of whole codomain under a function_on map **)
(** LATEX VERSION: If f maps X into Y then f^{-1}(Y)=X. **)
Theorem preimage_of_whole : forall X Y f:set,
  function_on f X Y ->
  preimage_of X f Y = X.
admit.
Qed.

(** Helper: preimage of complement (relative to codomain) **)
(** LATEX VERSION: f^{-1}(Y\\V) = X\\f^{-1}(V) when f maps X to Y. **)
Theorem preimage_of_complement : forall X Y f V:set,
  function_on f X Y ->
  preimage_of X f (Y :\: V) = X :\: preimage_of X f V.
admit.
Qed.

(** Helper: apply_fun for projections **)
(** LATEX VERSION: For p in XY, proj1(p)=p0 and proj2(p)=p1. **)
Theorem projection1_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection1 X Y) p = p 0.
admit.
Qed.
Theorem projection2_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection2 X Y) p = p 1.
admit.
Qed.

(** Helper: preimages of opens under projections are rectangles **)
(** LATEX VERSION: proj1^{-1}(U)=UY and proj2^{-1}(V)=XV. **)
Theorem preimage_projection1_rectangle : forall X Y U:set,
  U c= X ->
  preimage_of (setprod X Y) (projection1 X Y) U = rectangle_set U Y.
admit.
Qed.
Theorem preimage_projection2_rectangle : forall X Y V:set,
  V c= Y ->
  preimage_of (setprod X Y) (projection2 X Y) V = rectangle_set X V.
admit.
Qed.

(** from 18 Continuity of a Function: definition of continuity **)
(** LATEX VERSION: A function f: X -> Y is continuous if for each open set V of Y, the inverse image f^{-1}(V) is open in X. **)
(** SUSPICIOUS DEFINITION: `continuous_map` relies on `function_on` via `apply_fun`/`Eps_i`, so it enforces only preimage-openness and codomain membership, not totality of the graph; use `total_function_on` when totality is needed. **)
(** REVIEWED: This is the intended definition in this file; when a genuine function graph is needed, pair it with `total_function_on` and `functional_graph`. **)
Definition continuous_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** helper: flip_unit_interval is continuous in the unit interval topology **)
(** NOTE: placed later, after continuity infrastructure **)

(** Helper: extract topology_on X Tx from continuous_map **)
Theorem continuous_map_topology_dom : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> topology_on X Tx.
admit.
Qed.

(** Helper: extract topology_on Y Ty from continuous_map **)
Theorem continuous_map_topology_cod : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> topology_on Y Ty.
admit.
Qed.

(** Helper: extract function_on f X Y from continuous_map **)
Theorem continuous_map_function_on : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> function_on f X Y.
admit.
Qed.

(** Helper: extract the preimage condition from continuous_map **)
Theorem continuous_map_preimage : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  forall V:set, V :e Ty -> preimage_of X f V :e Tx.
admit.
Qed.

(** Helper: closure of a preimage is contained in preimage of the closure **)
(** LATEX VERSION: If f is continuous then cl(f^{-1}(A)) is contained in f^{-1}(cl(A)). **)
Theorem closure_preimage_contained : forall X Tx Y Ty f A:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  continuous_map X Tx Y Ty f ->
  closure_of X Tx (preimage_of X f A) c= preimage_of X f (closure_of Y Ty A).
admit.
Qed.

(** Helper: continuity is preserved when the domain topology is refined **)
(** LATEX VERSION: If T' is finer than T on X, then any T-continuous map is also T'-continuous. **)
Theorem continuous_map_domain_finer : forall X Tx Tx' Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  topology_on X Tx' ->
  Tx c= Tx' ->
  continuous_map X Tx' Y Ty f.
admit.
Qed.

(** Helper: continuity is preserved when the codomain topology is coarsened **)
(** LATEX VERSION: If T' is coarser than T on Y, then any T-continuous map is also T'-continuous. **)
Theorem continuous_map_codomain_coarser : forall X Tx Y Ty Ty' f:set,
  continuous_map X Tx Y Ty f ->
  topology_on Y Ty' ->
  Ty' c= Ty ->
  continuous_map X Tx Y Ty' f.
admit.
Qed.

(** Helper: restrict the range to a subspace containing f(X) **)
Theorem continuous_map_range_restrict : forall X Tx Y Ty f Z0:set,
  continuous_map X Tx Y Ty f ->
  Z0 c= Y ->
  (forall x:set, x :e X -> apply_fun f x :e Z0) ->
  continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f.
admit.
Qed.

(** Helper: expand the codomain from a subspace. **)
(** LATEX VERSION: If Ty is the subspace topology induced from (Z0,Tz0) on YZ0, then a continuous map XY is also continuous as XZ0. **)
Theorem continuous_map_range_expand : forall X Tx Y Ty Z0 Tz0 f:set,
  continuous_map X Tx Y Ty f ->
  Y c= Z0 ->
  topology_on Z0 Tz0 ->
  Ty = subspace_topology Z0 Tz0 Y ->
  continuous_map X Tx Z0 Tz0 f.
admit.
Qed.

(** Helper: subbasis criterion for continuity into generated_topology_from_subbasis **)
(** LATEX VERSION: If preimages of all subbasis elements are open, then f is continuous for the topology generated by the subbasis. **)
Theorem continuous_map_from_subbasis : forall X Tx Y S f:set,
  topology_on X Tx ->
  function_on f X Y ->
  subbasis_on Y S ->
  (forall s:set, s :e S -> preimage_of X f s :e Tx) ->
  continuous_map X Tx Y (generated_topology_from_subbasis Y S) f.
admit.
Qed.

(** from 18 Continuity of a Function: continuous maps are functions defined on all points **)
(** LATEX VERSION: Continuity is defined for functions f:X->Y; in formalization we often require totality of the graph explicitly. **)
(** Helper: continuous_map variant with totality of the graph **)
Definition continuous_map_total : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ total_function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** Helper: extract topology_on X Tx from continuous_map_total **)
Theorem continuous_map_total_topology_dom : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> topology_on X Tx.
admit.
Qed.

(** Helper: extract topology_on Y Ty from continuous_map_total **)
Theorem continuous_map_total_topology_cod : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> topology_on Y Ty.
admit.
Qed.

(** Helper: extract total_function_on f X Y from continuous_map_total **)
Theorem continuous_map_total_total_function_on : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> total_function_on f X Y.
admit.
Qed.

(** Helper: extract the preimage condition from continuous_map_total **)
Theorem continuous_map_total_preimage : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f ->
  forall V:set, V :e Ty -> preimage_of X f V :e Tx.
admit.
Qed.

(** Helper: continuous_map_total implies continuous_map **)
Theorem continuous_map_total_imp : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> continuous_map X Tx Y Ty f.
admit.
Qed.

(** Helper: constant maps are continuous **)
Theorem const_fun_continuous : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map X Tx Y Ty (const_fun X x).
admit.
Qed.

(** Helper: constant maps are continuous (total variant) **)
Theorem const_fun_continuous_total : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map_total X Tx Y Ty (const_fun X x).
admit.
Qed.

(** Helper: continuity preserves closed sets **)
Theorem continuous_preserves_closed : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C).
admit.
Qed.

(** Helper: continuity local neighborhood characterization **)
Theorem continuous_local_neighborhood : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty -> function_on f X Y ->
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx) ->
  forall x:set, x :e X ->
    forall V:set, V :e Ty -> apply_fun f x :e V ->
      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.
admit.
Qed.

(** helper: a set is open if every point has a neighborhood inside it **)
Theorem topology_elem_of_local_neighborhoods : forall X Tx U:set,
  topology_on X Tx ->
  U c= X ->
  (forall x:set, x :e U -> exists V:set, V :e Tx /\ x :e V /\ V c= U) ->
  U :e Tx.
admit.
Qed.

(** continuity at a point **)
(** LATEX VERSION: f is continuous at x if for every neighborhood V of f(x), there exists neighborhood U of x with f(U)V. **)
(** FIXED: Formalized using open-set neighborhood criterion in the standard topology on R. **)
Definition continuous_at : set -> set -> prop := fun f x =>
  function_on f R R /\ x :e R /\
  forall V:set, V :e R_standard_topology -> apply_fun f x :e V ->
    exists U:set, U :e R_standard_topology /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.

(** from 18 Theorem 18.1: equivalent formulations of continuity **) 
(** LATEX VERSION: Equivalent characterizations of continuity: open-preimage, closed-preimage, neighborhood criterion. **)
Theorem continuity_equiv_forms : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    function_on f X Y /\
    (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
    (forall x:set, x :e X ->
       forall V:set, V :e Ty -> apply_fun f x :e V ->
         exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V)).
admit.
Qed.

(** from 18: identity map is continuous **) 
(** LATEX VERSION: Identity map on any space is continuous. **)
(** FIXED: Identity function must use ordered pairs (tuple notation), not UPair. **)
Theorem identity_continuous : forall X Tx:set,
  topology_on X Tx ->
  let id := {(x,x)|x :e X} in
  continuous_map X Tx X Tx id.
admit.
Qed.

(** Helper: the identity map is continuous from R_ell to the standard topology **)
(** LATEX VERSION: Since the standard topology is contained in the lower limit topology, the identity map is continuous from (R,R_ell) to (R,standard). **)
Theorem identity_continuous_R_lower_to_standard :
  continuous_map R R_lower_limit_topology R R_standard_topology {(x,x)|x :e R}.
admit.
Qed.

 (** from 18: composition of continuous maps is continuous **)
 (** LATEX VERSION: Composition of continuous functions remains continuous. **)
 (** FIXED: Function composition must use ordered pairs (tuple notation), not UPair. **)
Definition compose_fun : set -> set -> set -> set := fun X f g =>
  {(x, apply_fun g (apply_fun f x))|x :e X}.

(** Helper: compose_fun has domain subset X **)
Theorem graph_domain_subset_compose_fun : forall X f g:set,
  graph_domain_subset (compose_fun X f g) X.
admit.
Qed.

(** Helper: compose_fun is functional **)
Theorem functional_graph_compose_fun : forall X f g:set,
  functional_graph (compose_fun X f g).
admit.
Qed.

(** Helper: compose_fun maps X into Z if f maps X into Y and g maps Y into Z **)
Theorem function_on_compose_fun : forall X Y Z f g:set,
  function_on f X Y ->
  function_on g Y Z ->
  function_on (compose_fun X f g) X Z.
admit.
Qed.

(** Helper: compose_fun is total_function_on under function_on assumptions **)
Theorem total_function_on_compose_fun : forall X Y Z f g:set,
  function_on f X Y ->
  function_on g Y Z ->
  total_function_on (compose_fun X f g) X Z.
admit.
Qed.

(** helper: compose_fun yields an element of function_space **)
(** LATEX VERSION: If f:XY and g:YZ, then gf  function_space X Z. **)
Theorem compose_fun_in_function_space : forall X Y Z f g:set,
  function_on f X Y ->
  function_on g Y Z ->
  compose_fun X f g :e function_space X Z.
admit.
Qed.

(** Helper: apply_fun on composed functions **)
Theorem compose_fun_apply : forall X f g x:set,
  x :e X -> apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
admit.
Qed.

(** Helper: preimage composition under function_on assumption **)
Theorem preimage_compose_fun : forall X Y f g W:set,
  function_on f X Y ->
  preimage_of X (compose_fun X f g) W = preimage_of X f (preimage_of Y g W).
admit.
Qed.
Theorem composition_continuous : forall X Tx Y Ty Z Tz f g:set,
   continuous_map X Tx Y Ty f ->
   continuous_map Y Ty Z Tz g ->
   continuous_map X Tx Z Tz (compose_fun X f g).
admit.
Qed.

(** from 18 Theorem 18.2: rules for constructing continuous functions **) 
(** LATEX VERSION: Theorem 18.2: Constant maps, inclusions, composites, domain restriction, range restriction/expansion, and local continuity formulation. **)
Theorem continuous_construction_rules : forall X Tx Y Ty Z Tz:set,
  topology_on X Tx -> topology_on Y Ty -> topology_on Z Tz ->
  (forall y0:set, y0 :e Y -> continuous_map X Tx Y Ty (const_fun X y0))
  /\
  (forall A:set, A c= X -> continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A})
  /\
  (forall f g:set, continuous_map X Tx Y Ty f -> continuous_map Y Ty Z Tz g ->
    continuous_map X Tx Z Tz (compose_fun X f g))
  /\
  (forall f A:set, A c= X -> continuous_map X Tx Y Ty f ->
    continuous_map A (subspace_topology X Tx A) Y Ty f)
  /\
  ((forall f Z0:set, continuous_map X Tx Y Ty f -> Z0 c= Y ->
     (forall x:set, x :e X -> apply_fun f x :e Z0) ->
     continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f)
   /\
   (forall f Z0 Tz0:set, continuous_map X Tx Y Ty f -> Y c= Z0 ->
     topology_on Z0 Tz0 -> Ty = subspace_topology Z0 Tz0 Y ->
     continuous_map X Tx Z0 Tz0 f))
  /\
  (forall f:set,
    (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
      (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f))
    -> continuous_map X Tx Y Ty f).
admit.
Qed.

(** helper: local continuity on an open cover implies global continuity **)
(** LATEX VERSION: If f is continuous on each member of an open cover of X, then f is continuous on X. **)
Theorem continuous_map_local_cover : forall X Tx Y Ty f:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
    (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f)) ->
  continuous_map X Tx Y Ty f.
admit.
Qed.

(** helper: restricting the domain to a subspace preserves continuity **)
(** LATEX VERSION: If f is continuous on X and AX, then f restricted to A is continuous with the subspace topology on A. **)
Theorem continuous_on_subspace_rule : forall X Tx Y Ty f A:set,
  topology_on X Tx -> topology_on Y Ty -> A c= X ->
  continuous_map X Tx Y Ty f ->
  continuous_map A (subspace_topology X Tx A) Y Ty f.
admit.
Qed.

(** helper: restrict a function_on to a subset domain **)
Theorem function_on_subdomain : forall f X Y A:set,
  function_on f X Y -> A c= X -> function_on f A Y.
admit.
Qed.

(** helper: enlarge the codomain of a function_on **)
Theorem function_on_codomain : forall f X Y Z:set,
  function_on f X Y -> Y c= Z -> function_on f X Z.
admit.
Qed.

(** helper: enlarge the codomain of a total_function_on **)
Theorem total_function_on_codomain : forall f X Y Z:set,
  total_function_on f X Y -> Y c= Z -> total_function_on f X Z.
admit.
Qed.

(** helper: monotonicity of product_space under component inclusion **)
Theorem product_space_component_sub : forall I Xi Xi0:set,
  (forall i:set, i :e I -> space_family_set Xi0 i c= space_family_set Xi i) ->
  product_space I Xi0 c= product_space I Xi.
admit.
Qed.

(** helper: transfer continuity across pointwise equality on the domain **)
Theorem continuous_map_congr_on : forall X Tx Y Ty f g:set,
  continuous_map X Tx Y Ty f ->
  function_on g X Y ->
  (forall x:set, x :e X -> apply_fun f x = apply_fun g x) ->
  continuous_map X Tx Y Ty g.
admit.
Qed.

(** helper: flip_unit_interval is continuous in the unit interval topology **)
(** LATEX VERSION: The map t |-> 1 - t is continuous on the unit interval I. **)
Theorem flip_unit_interval_continuous :
  continuous_map unit_interval unit_interval_topology unit_interval unit_interval_topology flip_unit_interval.
admit.
Qed.

(** from 18 Definition: homeomorphism **) 
(** LATEX VERSION: A homeomorphism is a bijective continuous map whose inverse is continuous. **)
Definition homeomorphism : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    continuous_map X Tx Y Ty f /\
    exists g:set, continuous_map Y Ty X Tx g /\
      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
      (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).

(** Helper: extract continuous_map from homeomorphism **)
Theorem homeomorphism_continuous : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> continuous_map X Tx Y Ty f.
admit.
Qed.

(** Helper: extract existence of inverse package from homeomorphism **)
Theorem homeomorphism_inverse_package : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
admit.
Qed.

(** helper: homeomorphism implies both are topological spaces **)
Theorem homeomorphism_topology_left : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on X Tx.
admit.
Qed.
Theorem homeomorphism_topology_right : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on Y Ty.
admit.
Qed.

(** from 16 Exercise 8: helper definition of straight line by affine equation **)
(** LATEX VERSION: A straight line in RR can be described by an affine equation ax+by=c with not both a and b zero. **)
Definition affine_line_R2 : set -> set -> set -> set :=
  fun a b c =>
    {p :e EuclidPlane |
      add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c}.

(** Helper: affine_line_R2 is a subset of EuclidPlane **)
Theorem affine_line_R2_subset : forall a b c:set, affine_line_R2 a b c c= EuclidPlane.
admit.
Qed.

(** Helper: affine_line_R2 is in Power EuclidPlane **)
Theorem affine_line_R2_in_Power : forall a b c:set, affine_line_R2 a b c :e Power EuclidPlane.
admit.
Qed.

(** Helper: affine_line_R2 is a subset of setprod R R **)
Theorem affine_line_R2_subset_R2 : forall a b c:set, affine_line_R2 a b c c= setprod R R.
admit.
Qed.

(** Helper: affine_line_R2 is in Power (setprod R R) **)
Theorem affine_line_R2_in_Power_R2 : forall a b c:set, affine_line_R2 a b c :e Power (setprod R R).
admit.
Qed.

(** from 16 Exercise 8: parametrizations of affine lines **)
(** LATEX VERSION: For ax+by=c, if b is not zero one can solve for y as a function of x; if b=0 one can solve for x as a constant and parametrize by y. **)
Definition affine_line_R2_param_by_x : set -> set -> set -> set :=
  fun a b c =>
    graph R (fun x:set => (x, div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b)).

Definition affine_line_R2_param_by_y : set -> set -> set -> set :=
  fun a b c =>
    graph R (fun y:set => (div_SNo c a, y)).

(** Helper: apply_fun on affine_line_R2_param_by_x **)
Theorem affine_line_R2_param_by_x_apply : forall a b c x:set,
  x :e R ->
  apply_fun (affine_line_R2_param_by_x a b c) x =
    (x, div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b).
admit.
Qed.
(** Helper: apply_fun on affine_line_R2_param_by_y **)
Theorem affine_line_R2_param_by_y_apply : forall a b c y:set,
  y :e R ->
  apply_fun (affine_line_R2_param_by_y a b c) y = (div_SNo c a, y).
admit.
Qed.

(** Helper: projection2 composed with affine_line_R2_param_by_y is the identity on R **)
Theorem projection2_after_affine_line_R2_param_by_y : forall a b c y:set,
  a :e R -> c :e R -> y :e R ->
  apply_fun (projection2 R R) (apply_fun (affine_line_R2_param_by_y a b c) y) = y.
admit.
Qed.

(** Helper: affine_line_R2_param_by_y after projection2 is identity on the vertical slice **)
Theorem affine_line_R2_param_by_y_after_projection2_on_slice : forall a b c p:set,
  a :e R -> c :e R ->
  p :e setprod {div_SNo c a} R ->
  apply_fun (affine_line_R2_param_by_y a b c) (apply_fun (projection2 R R) p) = p.
admit.
Qed.

(** Helper: affine_line_R2_param_by_x maps into EuclidPlane **)
Theorem affine_line_R2_param_by_x_function_on : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  function_on (affine_line_R2_param_by_x a b c) R EuclidPlane.
admit.
Qed.

(** Helper: projection1 composed with affine_line_R2_param_by_x is the identity on R **)
Theorem projection1_after_affine_line_R2_param_by_x : forall a b c x:set,
  a :e R -> b :e R -> c :e R -> x :e R ->
  apply_fun (projection1 R R) (apply_fun (affine_line_R2_param_by_x a b c) x) = x.
admit.
Qed.

(** Helper: affine_line_R2_param_by_y maps into EuclidPlane **)
Theorem affine_line_R2_param_by_y_function_on : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  function_on (affine_line_R2_param_by_y a b c) R EuclidPlane.
admit.
Qed.

(** Helper: projection1 is continuous for the product topology **)
(** LATEX VERSION: Coordinate projections are continuous for the product topology. **)
Theorem projection1_continuous_in_product : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection1 X Y).
admit.
Qed.

(** Helper: projection2 is continuous for the product topology **)
(** LATEX VERSION: Coordinate projections are continuous for the product topology. **)
Theorem projection2_continuous_in_product : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection2 X Y).
admit.
Qed.

(** Helper: projection2 is continuous on a vertical slice as a subspace **)
(** LATEX VERSION: The projection to the second factor is continuous when restricted to any vertical slice {x0}Y with the subspace topology. **)
Theorem projection2_continuous_on_vertical_slice : forall x0 Tx Ty:set,
  topology_on R Tx -> topology_on R Ty -> x0 :e R ->
  continuous_map (setprod {x0} R)
    (subspace_topology EuclidPlane (product_topology R Tx R Ty) (setprod {x0} R))
    R Ty (projection2 R R).
admit.
Qed.

(** Helper: affine_line_R2_param_by_y is continuous into product_topology, with the domain using the second-factor topology **)
(** LATEX VERSION: The map y  (x0,y) is continuous into a product topology, since the preimage of each basic rectangle is either the corresponding second-factor open set or empty. **)
Theorem affine_line_R2_param_by_y_continuous_in_product : forall a b c Tx Ty:set,
  topology_on R Tx -> topology_on R Ty ->
  a :e R -> c :e R ->
  continuous_map R Ty EuclidPlane (product_topology R Tx R Ty) (affine_line_R2_param_by_y a b c).
admit.
Qed.

(** Helper: param by x lands in the affine line when b is not zero **)
Theorem affine_line_R2_param_by_x_in_line : forall a b c x:set,
  a :e R -> b :e R -> c :e R -> x :e R ->
  b <> 0 ->
  apply_fun (affine_line_R2_param_by_x a b c) x :e affine_line_R2 a b c.
admit.
Qed.

(** Helper: affine_line_R2_param_by_x after projection1 is identity on the line (when b is not zero) **)
Theorem affine_line_R2_param_by_x_after_projection1_on_line : forall a b c p:set,
  a :e R -> b :e R -> c :e R -> b <> 0 ->
  p :e affine_line_R2 a b c ->
  apply_fun (affine_line_R2_param_by_x a b c) (apply_fun (projection1 R R) p) = p.
admit.
Qed.

(** Helper: param by y lands in the affine line when b is zero and a is not zero **)
Theorem affine_line_R2_param_by_y_in_line : forall a b c y:set,
  a :e R -> b :e R -> c :e R -> y :e R ->
  b = 0 ->
  a <> 0 ->
  apply_fun (affine_line_R2_param_by_y a b c) y :e affine_line_R2 a b c.
admit.
Qed.

(** Helper: if b=0 then the affine line is the vertical slice {c/a} times R **)
Theorem affine_line_R2_b0_eq_slice : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  b = 0 ->
  a <> 0 ->
  affine_line_R2 a b c = setprod {div_SNo c a} R.
admit.
Qed.

(** from 16 Exercise 8: helper predicate for negative slope in affine form **)
(** LATEX VERSION: For ax+by=c with b not zero, the slope is negative exactly when a and b have the same sign. **)
Definition same_sign_nonzero_R : set -> set -> prop :=
  fun a b => (Rlt 0 a /\ Rlt 0 b) \/ (Rlt a 0 /\ Rlt b 0).

(** helper for 16 Exercise 8: in the same-sign case, the line graph decreases in y as x increases **)
(** LATEX VERSION: If a and b have the same sign and b is nonzero, then for x1<x2 we have (c-ax2)/b < (c-ax1)/b. **)
Theorem affine_line_R2_param_by_x_y_decreases_same_sign : forall a b c x1 x2:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 ->
  same_sign_nonzero_R a b ->
  x1 :e R -> x2 :e R ->
  Rlt x1 x2 ->
  Rlt (div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) b)
      (div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) b).
admit.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: in the same_sign case, each singleton on the line is open in the R_lower_limit_topology product subspace topology **)
Theorem affine_line_R2_singleton_open_same_sign : forall a b c p:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 -> same_sign_nonzero_R a b ->
  p :e affine_line_R2 a b c ->
  {p} :e subspace_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2 a b c).
admit.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: projection1 into a discrete codomain is continuous on the same_sign affine line **)
Theorem projection1_continuous_on_affine_line_same_sign : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 -> same_sign_nonzero_R a b ->
  continuous_map (affine_line_R2 a b c)
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c))
    R (discrete_topology R) (projection1 R R).
admit.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: continuity of the scalar map x  (c-ax)/b from R_l to the standard topology **)
(** LATEX VERSION: The scalar map x  (c-ax)/b is continuous from (R,R_l) to (R,standard) for any a,c and any nonzero b. **)
Theorem affine_scalar_div_continuous_R_lower_to_standard : forall a b c:set,
  a :e R -> b :e R -> c :e R -> b <> 0 ->
  continuous_map R R_lower_limit_topology R R_standard_topology
    (graph R (fun x:set => div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b)).
admit.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: continuity of the x parametrization into the R_lR subspace topology **)
(** LATEX VERSION: When b0, the parametrization x  (x, (c-ax)/b) is continuous from R_l into the line with the subspace topology inherited from R_lR. **)
Theorem affine_line_R2_param_by_x_continuous_to_ll_std_line : forall a b c:set,
  a :e R -> b :e R -> c :e R -> b <> 0 ->
  continuous_map R R_lower_limit_topology (affine_line_R2 a b c)
    (subspace_topology (setprod R R)
       (product_topology R R_lower_limit_topology R R_standard_topology)
       (affine_line_R2 a b c))
    (affine_line_R2_param_by_x a b c).
admit.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: continuity of the x parametrization into the R_lR_l product topology **)
(** LATEX VERSION: When b0, the parametrization x  (x, (c-ax)/b) is continuous from R_l into R_lR_l. **)
Theorem affine_line_R2_param_by_x_continuous_in_product_ll_ll : forall a b c:set,
  a :e R -> b :e R -> c :e R -> b <> 0 ->
  ~ same_sign_nonzero_R a b ->
  continuous_map R R_lower_limit_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2_param_by_x a b c).
admit.
Qed.

(** from 16 Exercise 8: topology on a line in R_lR and R_lR_l is familiar **)
(** LATEX VERSION: For a straight line L in the plane, the subspace topology from R_lR and from R_lR_l is a familiar topology on L. **)
Theorem ex16_8_lines_in_lower_limit_products : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  ~ (a = 0 /\ b = 0) ->
  ( (b = 0 ->
      exists f:set,
        homeomorphism R R_standard_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f)
    /\ (b <> 0 ->
      exists f:set,
        homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f) )
  /\ ( (b <> 0 /\ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R (discrete_topology R) (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f)
     /\ ( (b = 0 \/ ~ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f).
admit.
Qed.

(** helper: homeomorphisms are injective **)
(** LATEX VERSION: A homeomorphism is injective (as it has a two-sided inverse). **)
Theorem homeomorphism_injective : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  forall x1 x2:set, x1 :e X -> x2 :e X -> apply_fun f x1 = apply_fun f x2 -> x1 = x2.
admit.
Qed.

(** from 18: continuous maps on subspaces **) 
(** LATEX VERSION: Restricting a continuous map to a subspace remains continuous. **)
Theorem continuous_on_subspace : forall X Tx Y Ty f A:set,
  topology_on X Tx -> A c= X ->
  continuous_map X Tx Y Ty f ->
  continuous_map A (subspace_topology X Tx A) Y Ty f.
admit.
Qed.

(** from 18: inverse of homeomorphism is continuous **)
(** LATEX VERSION: The inverse of a homeomorphism is continuous. **)
Theorem homeomorphism_inverse_continuous : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
admit.
Qed.

(** Helper: function_on for a pasted total functional map **)
Theorem function_union_on_disjoint_total_functional : forall A B Y f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  function_on (f :\/: g) (A :\/: B) Y.
admit.
Qed.

(** Helper: total_function_on for a pasted total functional map **)
Theorem total_function_union_on_disjoint_total_functional : forall A B Y f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  total_function_on (f :\/: g) (A :\/: B) Y.
admit.
Qed.

(** Helper: union of functional graphs with disjoint domains is functional **)
Theorem functional_graph_union_disjoint_domains : forall A B f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  functional_graph (f :\/: g).
admit.
Qed.

(** Helper: apply_fun on a pasted total functional map, left side **)
Theorem apply_fun_union_left : forall A B Y f g x:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  x :e A ->
  apply_fun (f :\/: g) x = apply_fun f x.
admit.
Qed.

(** Helper: apply_fun on a pasted total functional map, right side **)
Theorem apply_fun_union_right : forall A B Y f g x:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  x :e B ->
  apply_fun (f :\/: g) x = apply_fun g x.
admit.
Qed.

(** Helper: preimage decomposition for pasted total functional maps **)
Theorem preimage_of_union_functions_total : forall A B Y f g V:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  preimage_of (A :\/: B) (f :\/: g) V =
    (preimage_of A f V) :\/: (preimage_of B g V).
admit.
Qed.

(** Helper: unions of open subsets of disjoint open subspaces are open in the union subspace **)
Theorem subspace_union_of_opens : forall X Tx A B U V:set,
  topology_on X Tx -> A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  U :e subspace_topology X Tx A ->
  V :e subspace_topology X Tx B ->
  (U :\/: V) :e subspace_topology X Tx (A :\/: B).
admit.
Qed.

(** Helper: pasting lemma variant for total functional maps **)
Theorem pasting_lemma_total_functional : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  continuous_map_total A (subspace_topology X Tx A) Y Ty f ->
  continuous_map_total B (subspace_topology X Tx B) Y Ty g ->
  continuous_map_total (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
admit.
Qed.

(** Helper: pasting lemma variant gives continuity in the weaker sense **)
Theorem pasting_lemma_total_functional_imp : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  continuous_map_total A (subspace_topology X Tx A) Y Ty f ->
  continuous_map_total B (subspace_topology X Tx B) Y Ty g ->
  continuous_map (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
admit.
Qed.

(** from 18 Theorem 18.3: pasting lemma **)
(** LATEX VERSION: Let X=AB, where A and B are closed in X. Let f:AY and g:BY be continuous. If f=g on AB, then the combined map h:XY defined by h|A=f and h|B=g is continuous. **)
Theorem pasting_lemma : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :\/: B = X ->
  continuous_map A (subspace_topology X Tx A) Y Ty f ->
  continuous_map B (subspace_topology X Tx B) Y Ty g ->
  (forall x:set, x :e (A :/\: B) -> apply_fun f x = apply_fun g x) ->
  exists h:set,
    continuous_map X Tx Y Ty h /\
    ((forall x:set, x :e A -> apply_fun h x = apply_fun f x) /\
     (forall x:set, x :e B -> apply_fun h x = apply_fun g x)).
admit.
Qed.

(** from 18 Theorem 18.4: maps into products **) 
(** LATEX VERSION: A map into a product is continuous iff its coordinate functions are continuous. **)
Definition pair_map : set -> set -> set -> set := fun A f g =>
  {(a, (apply_fun f a, apply_fun g a)) | a :e A}.

(** Helper: apply_fun for pair_map **)
Theorem pair_map_apply : forall A X Y f g a:set,
  a :e A ->
  apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
admit.
Qed.

(** helper: pair_map yields an element of function_space **)
(** LATEX VERSION: If f:AX and g:AY, then (f,g):AXY lies in function_space A (XY). **)
Theorem pair_map_in_function_space : forall A X Y f g:set,
  function_on f A X ->
  function_on g A Y ->
  pair_map A f g :e function_space A (setprod X Y).
admit.
Qed.
Theorem preimage_pair_map_rectangle : forall A X Y f g U V:set,
  preimage_of A (pair_map A f g) (rectangle_set U V) =
    (preimage_of A f U) :/\: (preimage_of A g V).
admit.
Qed.
Theorem maps_into_products_axiom : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
admit.
Qed.
Theorem maps_into_products : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
admit.
Qed.

(** from 19 Definition: product projections and universal property **) 
(** LATEX VERSION: Projection maps from a product space; universal property characterizes the product topology. **)
Definition projection_map1 : set -> set -> set := fun X Y => projection1 X Y.
Definition projection_map2 : set -> set -> set := fun X Y => projection2 X Y.

(** Helper: preimage of a rectangle via projection compositions **)
Theorem preimage_of_rectangle_via_projections : forall A X Y h U V:set,
  function_on h A (setprod X Y) ->
  U c= X -> V c= Y ->
  preimage_of A h (rectangle_set U V) =
    (preimage_of A (compose_fun A h (projection_map1 X Y)) U) :/\:
    (preimage_of A (compose_fun A h (projection_map2 X Y)) V).
admit.
Qed.

(** Helper: projection maps are continuous **)
Theorem projection_maps_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
admit.
Qed.

(** Helper: maps into products, converse direction using projections **)
(** LATEX VERSION: If h : A -> XY is continuous, then each coordinate projection composed with h is continuous. **)
Theorem maps_into_products_converse : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h ->
  continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
admit.
Qed.

(** Helper: maps into products from continuity of coordinates **)
(** LATEX VERSION: If h maps A into XY and the coordinate compositions are continuous, then h is continuous. **)
Theorem maps_into_products_coords_imp : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  function_on h A (setprod X Y) ->
  continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) ->
  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)) ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h.
admit.
Qed.

(** Helper: maps into products iff coordinates are continuous **)
(** LATEX VERSION: A map h : A -> XY is continuous iff each projection composed with h is continuous. **)
Theorem maps_into_products_iff_coords : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  function_on h A (setprod X Y) ->
  (continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h <->
   (continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
    continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)))).
admit.
Qed.

(** Helper: universal property of products - maps into products **)
(** LATEX VERSION: Projections from a product are continuous. **)
Theorem projections_are_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
admit.
Qed.

(** from 19: product topology is coarsest making projections continuous **) 
(** LATEX VERSION: The product topology is the coarsest topology on XY making the projections continuous. **)
Theorem product_topology_universal : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists Tprod:set, topology_on (setprod X Y) Tprod /\
    continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) /\
    continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
admit.
Qed.

(** Helper: rectangle as intersection of strips **)
Theorem rectangle_set_as_intersection : forall X Y U V:set,
  U c= X -> V c= Y ->
  rectangle_set U V = (rectangle_set U Y) :/\: (rectangle_set X V).
admit.
Qed.

(** Helper: coarsest property of product topology **)
(** LATEX VERSION: Any topology on XY making the projections continuous contains the product topology. **)
Theorem product_topology_coarsest : forall X Tx Y Ty Tprod:set,
  topology_on X Tx -> topology_on Y Ty ->
  topology_on (setprod X Y) Tprod ->
  continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) ->
  continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y) ->
  coarser_than (product_topology X Tx Y Ty) Tprod.
admit.
Qed.

(** from 20 Definition: metric and metric topology **) 
(** LATEX VERSION: Definition of a metric d on X and the induced metric topology generated by open balls. **)
(** FIXED: Triangle inequality uses add_SNo, not :/\:; encoded as ~(Rlt (d(x,y)+d(y,z)) d(x,z)), relying on add_SNo and the intended interpretation of ~Rlt as <=. **)
(** SUSPICIOUS DEFINITION: Triangle inequality encoded by ~Rlt (d(x,y)+d(y,z)) d(x,z) relies on Rlt totality and intended equivalence between ~Rlt and <=. **)
(** REVIEWED: This encoding matches the LATEX metric axioms; later lemmas translate between `~Rlt` and `Rle` where needed. **)
Definition metric_on : set -> set -> prop := fun X d =>
  function_on d (setprod X X) R /\
  (forall x y:set, x :e X -> y :e X ->
     apply_fun d (x,y) = apply_fun d (y,x)) /\
  (forall x:set, x :e X -> apply_fun d (x,x) = 0) /\
  (forall x y:set, x :e X -> y :e X ->
     ~(Rlt (apply_fun d (x,y)) 0)
     /\ (apply_fun d (x,y) = 0 -> x = y)) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     ~(Rlt (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)))
           (apply_fun d (x,z)))).

(** Helper: metric_on plus totality of the graph on XX **)
(** LATEX VERSION: In addition to the metric axioms, we often require the distance function to be defined on all pairs in XX as a total function. **)
Definition metric_on_total : set -> set -> prop := fun X d =>
  metric_on X d /\ total_function_on d (setprod X X) R.

(** Helper: extract function_on from metric_on **)
Theorem metric_on_function_on : forall X d:set,
  metric_on X d -> function_on d (setprod X X) R.
admit.
Qed.

(** helper: Euclidean metric as a graph on EuclidPlane **)
(** LATEX VERSION: The Euclidean metric d on R^2 is given by d(p,q)=distance_R2 p q. **)
Definition EuclidPlane_metric : set :=
  graph (setprod EuclidPlane EuclidPlane) (fun pq:set => distance_R2 (pq 0) (pq 1)).

(** helper: evaluate EuclidPlane_metric on a pair **)
Theorem EuclidPlane_metric_apply : forall p q:set,
  p :e EuclidPlane -> q :e EuclidPlane ->
  apply_fun EuclidPlane_metric (p,q) = distance_R2 p q.
admit.
Qed.

(** helper: EuclidPlane_metric satisfies the metric axioms on EuclidPlane **)
Theorem EuclidPlane_metric_is_metric_on : metric_on EuclidPlane EuclidPlane_metric.
admit.
Qed.

(** helper: EuclidPlane_metric is total as a function on EuclidPlaneEuclidPlane **)
Theorem EuclidPlane_metric_is_metric_on_total : metric_on_total EuclidPlane EuclidPlane_metric.
admit.
Qed.

(** Helper: symmetry of a metric **)
Theorem metric_on_symmetric : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  apply_fun d (x,y) = apply_fun d (y,x).
admit.
Qed.

(** Helper: reflexive axiom for a metric **)
Theorem metric_on_diag_zero : forall X d x:set,
  metric_on X d -> x :e X -> apply_fun d (x,x) = 0.
admit.
Qed.

(** Helper: nonnegativity of a metric **)
Theorem metric_on_nonneg : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  ~(Rlt (apply_fun d (x,y)) 0).
admit.
Qed.

(** Helper: zero distance implies equality **)
Theorem metric_on_zero_eq : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  apply_fun d (x,y) = 0 -> x = y.
admit.
Qed.

(** Helper: strict positivity away from the diagonal **)
(** LATEX VERSION: In a metric space, if xy then 0<d(x,y). **)
Theorem metric_on_pos_of_neq : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X -> ~(x = y) ->
  Rlt 0 (apply_fun d (x,y)).
admit.
Qed.

(** helper: family of negated distances from a point to a set **)
(** LATEX VERSION: For x and A, consider the set {-d(x,a) | a in A} for use in inf and sup constructions. **)
Definition metric_neg_dists : set -> set -> set -> set -> set := fun X d x A =>
  {minus_SNo (apply_fun d (x,a))|a :e A}.

(** helper: negated distances are real numbers **)
Theorem metric_neg_dists_in_R : forall X d x A:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  forall t:set, t :e metric_neg_dists X d x A -> t :e R.
admit.
Qed.

(** helper: negated distances are bounded above by 0 **)
Theorem metric_neg_dists_le_0 : forall X d x A:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  forall t:set, t :e metric_neg_dists X d x A -> Rle t 0.
admit.
Qed.

(** Helper: triangle inequality (raw) **)
Theorem metric_on_triangle : forall X d x y z:set,
  metric_on X d -> x :e X -> y :e X -> z :e X ->
  ~(Rlt (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)))
        (apply_fun d (x,z))).
admit.
Qed.
Theorem metric_on_total_imp_metric_on : forall X d:set,
  metric_on_total X d -> metric_on X d.
admit.
Qed.
Theorem metric_on_total_total_function : forall X d:set,
  metric_on_total X d -> total_function_on d (setprod X X) R.
admit.
Qed.

(** helper: triangle inequality in Rle form **)
Theorem metric_triangle_Rle : forall X d x y z:set,
  metric_on X d -> x :e X -> y :e X -> z :e X ->
  Rle (apply_fun d (x,z)) (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z))).
admit.
Qed.

(** from 20 Definition: open ball **)
(** LATEX VERSION: Open ball centered at x with radius r in metric d. **)
(** FIXED: Previous version quantified the radius and made the set equal to X; open_ball now takes the radius r as a parameter and uses {y :e X | d(x,y) < r}. **)
Definition open_ball : set -> set -> set -> set -> set := fun X d x r =>
  {y :e X|Rlt (apply_fun d (x,y)) r}.

(** Helper: elimination and introduction rules for open_ball **)
Theorem open_ballE1 : forall X d x r y:set,
  y :e open_ball X d x r -> y :e X.
admit.
Qed.
Theorem open_ballE2 : forall X d x r y:set,
  y :e open_ball X d x r -> Rlt (apply_fun d (x,y)) r.
admit.
Qed.
Theorem open_ballI : forall X d x r y:set,
  y :e X -> Rlt (apply_fun d (x,y)) r -> y :e open_ball X d x r.
admit.
Qed.

(** helper: Euclidean open balls are circular regions (via distance_R2) **)
(** LATEX VERSION: For Euclidean metric d(p,q)=distance_R2 p q, the open ball B_d(c,r) equals {pR^2 | distance_R2(p,c) < r}. **)
Theorem open_ball_EuclidPlane_metric_eq : forall c r:set,
  c :e EuclidPlane ->
  open_ball EuclidPlane EuclidPlane_metric c r
    = {p :e EuclidPlane|Rlt (distance_R2 p c) r}.
admit.
Qed.

(** Helper: open balls are subsets of X **)
Theorem open_ball_subset_X : forall X d x r:set, open_ball X d x r c= X.
admit.
Qed.

(** Helper: open balls are elements of Power X **)
Theorem open_ball_in_Power : forall X d x r:set, open_ball X d x r :e Power X.
admit.
Qed.

(** Helper: the center belongs to any open ball with positive radius **)
Theorem center_in_open_ball : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r -> x :e open_ball X d x r.
admit.
Qed.

(** Helper: any open ball with positive radius is nonempty **)
Theorem open_ball_nonempty : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r -> open_ball X d x r <> Empty.
admit.
Qed.

(** Helper: for any positive real d, some eps_N is smaller than d **)
Theorem exists_eps_lt_pos : forall d:set, d :e R -> Rlt 0 d -> exists N :e omega, eps_ N < d.
admit.
Qed.

(** Helper: choose a single eps below two positive reals **)
(** LATEX VERSION: Given two positive real numbers, there is a positive eps radius smaller than both. **)
Theorem exists_eps_lt_two_pos : forall a b:set,
  a :e R -> b :e R ->
  Rlt 0 a -> Rlt 0 b ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\ Rlt r3 a /\ Rlt r3 b.
admit.
Qed.

(** Helper: choose a single eps below four positive reals **)
(** LATEX VERSION: Given finitely many positive reals, there is a positive eps radius smaller than all of them. **)
Theorem exists_eps_lt_four_pos : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  Rlt 0 a -> Rlt 0 b -> Rlt 0 c -> Rlt 0 d ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\ Rlt r3 a /\ Rlt r3 b /\ Rlt r3 c /\ Rlt r3 d.
admit.
Qed.

(** Helper: if a <= b and b < c then a < c **)
Theorem Rle_Rlt_tra : forall a b c:set, Rle a b -> Rlt b c -> Rlt a c.
admit.
Qed.

(** Helper: if a < b and b <= c then a < c **)
Theorem Rlt_Rle_tra : forall a b c:set, Rlt a b -> Rle b c -> Rlt a c.
admit.
Qed.

(** helper: addition preserves strict inequality on both sides (real numbers) **)
(** LATEX VERSION: If a<b and c<d, then a+c < b+d. **)
Theorem Rlt_add_SNo : forall a b c d:set,
  Rlt a b -> Rlt c d -> Rlt (add_SNo a c) (add_SNo b d).
admit.
Qed.

(** helper: two points in the same open ball are at distance < r+r **)
(** LATEX VERSION: If y and z are both within radius r of x, then d(y,z) < r+r. **)
Theorem open_ball_pair_dist_lt_add_radius : forall X d x r y z:set,
  metric_on X d ->
  x :e X ->
  y :e open_ball X d x r ->
  z :e open_ball X d x r ->
  Rlt (apply_fun d (y,z)) (add_SNo r r).
admit.
Qed.

(** helper: eps_{n+1}-ball implies pairwise distance < eps_n **)
(** LATEX VERSION: If y,z belong to B(x,eps_{n+1}), then d(y,z) < eps_n. **)
Theorem open_ball_pair_dist_lt_eps_pred : forall X d x n y z:set,
  metric_on X d ->
  x :e X ->
  n :e omega ->
  y :e open_ball X d x (eps_ (ordsucc n)) ->
  z :e open_ball X d x (eps_ (ordsucc n)) ->
  Rlt (apply_fun d (y,z)) (eps_ n).
admit.
Qed.

(** helper: if a point is in two metric balls, then the centers are close **)
(** LATEX VERSION: If pB(x,r1) and pB(y,r2), then d(x,y) < r1+r2. **)
Theorem metric_ball_intersect_centers_lt_add : forall X d x y p r1 r2:set,
  metric_on X d ->
  x :e X -> y :e X -> p :e X ->
  r1 :e R -> r2 :e R ->
  p :e open_ball X d x r1 ->
  p :e open_ball X d y r2 ->
  Rlt (apply_fun d (x,y)) (add_SNo r1 r2).
admit.
Qed.

(** helper: well-ordered set carrier (moved earlier to avoid forward references) **)
(** LATEX VERSION: Well-ordered set helper. **)
(** NOTE: In this development, a well-ordered carrier is modeled by an ordinal with order_rel given by membership; we package the needed side-conditions explicitly. **)
Definition well_ordered_set : set -> prop := fun X =>
  ordinal X /\ X <> R /\ X <> rational_numbers /\ X <> setprod 2 omega /\ X <> setprod R R.

(** from 39 Lemma 39.2 (setup): well-ordering theorem **)
(** LATEX VERSION: We shall use the well-ordering theorem: every set can be well-ordered. **)
(** NOTE: Placed early to support constructions needing a well-order before later sections. **)
Axiom well_ordering_theorem_axiom : forall A:set,
  exists W:set, well_ordered_set W /\ equip A W.
Theorem well_ordering_theorem_equip : forall A:set,
  exists W:set, well_ordered_set W /\ equip A W.
admit.
Qed.

(** helper: extract ordinal from well_ordered_set **)
Theorem well_ordered_set_is_ordinal : forall X:set,
  well_ordered_set X -> ordinal X.
admit.
Qed.

(** helper: eps_n-separated subsets of a metric space **)
(** LATEX VERSION: A set S is eps_n-separated if distinct points have distance at least eps_n. **)
Definition eps_separated_set : set -> set -> set -> set -> prop := fun X d S n =>
  S c= X /\
  forall x y:set, x :e S -> y :e S -> ~(x = y) -> ~(Rlt (apply_fun d (x,y)) (eps_ n)).

(** helper: maximality notion for eps separated sets **)
(** LATEX VERSION: A set S is maximal eps_n separated if any x in X that is eps_n far from S is already in S. **)
Definition maximal_eps_separated_set : set -> set -> set -> set -> prop := fun X d S n =>
  eps_separated_set X d S n /\
  forall x:set, x :e X ->
    (forall y:set, y :e S -> ~(Rlt (apply_fun d (x,y)) (eps_ n))) -> x :e S.

(** helper: maximal eps separated implies covering by eps balls **)
(** LATEX VERSION: If S is maximal eps_n separated, then the eps_n balls centered at S cover X. **)
Theorem maximal_eps_separated_set_implies_cover : forall X d S n:set,
  metric_on X d ->
  n :e omega ->
  maximal_eps_separated_set X d S n ->
  X c= (\/_ c :e S, open_ball X d c (eps_ n)).
admit.
Qed.

(** helper: maximal eps separated subsets relative to a subset Y of X **)
(** LATEX VERSION: Relative maximality: SY is eps_n separated and maximal among subsets of Y. **)
Definition maximal_eps_separated_set_on : set -> set -> set -> set -> set -> prop := fun X d Y S n =>
  (Y c= X) /\
  (S c= Y) /\
  (forall x y:set, x :e S -> y :e S -> ~(x = y) -> ~(Rlt (apply_fun d (x,y)) (eps_ n))) /\
  (forall x:set, x :e Y ->
    (forall y:set, y :e S -> ~(Rlt (apply_fun d (x,y)) (eps_ n))) -> x :e S).

(** helper: existence of maximal eps separated subsets relative to Y (pending) **)
(** LATEX VERSION: For any subset Y of a metric space and any n, there exists a maximal eps n separated subset of Y. **)
Theorem maximal_eps_separated_set_on_exists : forall X d Y n:set,
  metric_on X d ->
  n :e omega ->
  Y c= X ->
  exists S:set, maximal_eps_separated_set_on X d Y S n.
admit.
Qed.

(** helper: relative maximal eps separation implies covering of Y by eps balls **)
(** LATEX VERSION: If S is maximal eps_n separated in Y, then eps_n balls centered at S cover Y. **)
Theorem maximal_eps_separated_set_on_implies_cover : forall X d Y S n:set,
  metric_on X d ->
  n :e omega ->
  maximal_eps_separated_set_on X d Y S n ->
  Y c= (\/_ c :e S, open_ball X d c (eps_ n)).
admit.
Qed.

(** helper: eps_(n+1)-balls around eps_n-separated centers have unique membership at a point **)
(** LATEX VERSION: If d(x,y) >= eps_n, then no point can lie in both B(x,eps_{n+1}) and B(y,eps_{n+1}). **)
Theorem eps_separated_imp_eps_succ_ball_point_unique : forall X d S n p x y:set,
  metric_on X d ->
  n :e omega ->
  eps_separated_set X d S n ->
  p :e X ->
  x :e S -> y :e S ->
  p :e open_ball X d x (eps_ (ordsucc n)) ->
  p :e open_ball X d y (eps_ (ordsucc n)) ->
  x = y.
admit.
Qed.

(** Helper: refinement of two open balls around a common point **)
(** LATEX VERSION: If x lies in two open balls, then some smaller ball around x is contained in their intersection. **)
Theorem open_ball_refine_intersection : forall X d c1 c2 x r1 r2:set,
  metric_on X d ->
  c1 :e X -> c2 :e X -> x :e X ->
  r1 :e R -> r2 :e R ->
  Rlt 0 r1 -> Rlt 0 r2 ->
  x :e open_ball X d c1 r1 ->
  x :e open_ball X d c2 r2 ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\
    open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2).
admit.
Qed.

(** Helper: if x lies in an open ball, then some ball around x lies inside it **)
(** LATEX VERSION: If x in B_r(c), then exists s>0 with B_s(x) subset B_r(c). **)
Theorem open_ball_refine_center : forall X d c x r:set,
  metric_on X d ->
  c :e X -> x :e X ->
  r :e R -> Rlt 0 r ->
  x :e open_ball X d c r ->
  exists s:set, s :e R /\ Rlt 0 s /\ open_ball X d x s c= open_ball X d c r.
admit.
Qed.

(** helper: refinement by a standard eps_N ball **)
(** LATEX VERSION: If x in B_r(c), then for some N we have B_{eps_N}(x) subset B_r(c). **)
Theorem open_ball_refine_center_eps : forall X d c x r:set,
  metric_on X d ->
  c :e X -> x :e X ->
  r :e R -> Rlt 0 r ->
  x :e open_ball X d c r ->
  exists N:set, N :e omega /\ open_ball X d x (eps_ N) c= open_ball X d c r.
admit.
Qed.

(** from 20: metric topology induced by a metric **)
(** LATEX VERSION: If d is a metric on X, the collection of all epsilon balls B_d(x,eps) forms a basis for a topology on X, called the metric topology induced by d. **)
Definition metric_topology : set -> set -> set := fun X d =>
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).

(** from 20: open balls form a basis **)
(** LATEX VERSION: In a metric space, open balls form a basis for the metric topology. **)
Theorem open_balls_form_basis : forall X d:set,
  metric_on X d -> basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
admit.
Qed.

(** helper: metric openness gives an eps-ball neighborhood **)
(** LATEX VERSION: If U is open in the metric topology and xU, then for some N, B(x,eps_N)U. **)
Theorem open_in_metric_topology_has_eps_ball_sub : forall X d U x:set,
  metric_on X d ->
  open_in X (metric_topology X d) U ->
  x :e U ->
  exists N:set, N :e omega /\ open_ball X d x (eps_ N) c= U.
admit.
Qed.
Theorem metric_topology_is_topology : forall X d:set,
  metric_on X d -> topology_on X (metric_topology X d).
admit.
Qed.

(** from 20: metric-induced topology equals generated topology of balls **)
(** LATEX VERSION: The topology induced by a metric is the topology generated by the family of open balls. **)
Theorem metric_topology_generated_by_balls : forall X d:set,
  metric_on X d ->
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) = metric_topology X d.
admit.
Qed.

(** helper: EuclidPlane_metric open balls are circular regions **)
(** LATEX VERSION: For Euclidean metric on R^2, every metric open ball is a circular region (and conversely). **)
Theorem open_ball_EuclidPlane_metric_in_circular_regions : forall c r:set,
  c :e EuclidPlane -> r :e R -> Rlt 0 r ->
  open_ball EuclidPlane EuclidPlane_metric c r :e circular_regions.
admit.
Qed.

(** helper: the family of EuclidPlane_metric open balls equals circular_regions **)
(** LATEX VERSION: {B_d(c,r) | cR^2, r>0} = {UR^2 | c,r>0, U={p|d(p,c)<r}}. **)
Theorem EuclidPlane_metric_open_balls_family_eq_circular_regions :
  famunion EuclidPlane (fun c:set => {open_ball EuclidPlane EuclidPlane_metric c r|r :e R, Rlt 0 r})
    = circular_regions.
admit.
Qed.

(** helper: Euclidean metric topology equals the topology generated by circular regions **)
(** LATEX VERSION: The metric topology induced by Euclidean distance on R^2 equals the topology generated by circular regions. **)
Theorem metric_topology_EuclidPlane_metric_eq_generated_circular_regions :
  metric_topology EuclidPlane EuclidPlane_metric = generated_topology EuclidPlane circular_regions.
admit.
Qed.

(** helper: Euclidean metric topology also equals topology generated by rectangular regions **)
(** LATEX VERSION: Combining circular-vs-rectangular equivalence with the Euclidean metric description. **)
Theorem metric_topology_EuclidPlane_metric_eq_generated_rectangular_regions :
  metric_topology EuclidPlane EuclidPlane_metric = generated_topology EuclidPlane rectangular_regions.
admit.
Qed.

(** helper: Euclidean metric topology is contained in the standard topology on R^2 **)
(** LATEX VERSION: The metric topology induced by the Euclidean metric is no finer than the standard topology on . **)
Theorem metric_topology_EuclidPlane_metric_sub_R2_standard_topology :
  metric_topology EuclidPlane EuclidPlane_metric c= R2_standard_topology.
admit.
Qed.

(** helper: Euclidean metric topology equals the standard topology on R^2 **)
(** LATEX VERSION: The topology induced by the Euclidean metric on  coincides with the standard product topology on . **)
Theorem metric_topology_EuclidPlane_metric_eq_R2_standard_topology :
  metric_topology EuclidPlane EuclidPlane_metric = R2_standard_topology.
admit.
Qed.

(** Helper: open balls are open in the metric topology **)
Theorem open_ball_open_in_metric_topology : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r ->
  open_in X (metric_topology X d) (open_ball X d x r).
admit.
Qed.

(** Helper: open balls are elements of the metric topology **)
Theorem open_ball_in_metric_topology : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r ->
  open_ball X d x r :e metric_topology X d.
admit.
Qed.

(** helper: metric spaces are Hausdorff in the metric topology **)
(** LATEX VERSION: Metric spaces are Hausdorff: distinct points have disjoint open balls. **)
Theorem metric_topology_Hausdorff : forall X d:set,
  metric_on X d ->
  Hausdorff_space X (metric_topology X d).
admit.
Qed.

(** from 21: epsilon-delta continuity in metric spaces **) 
(** LATEX VERSION: A map between metric spaces is continuous exactly when it satisfies the epsilon-delta condition. **)
Theorem metric_epsilon_delta_continuity : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY -> function_on f X Y ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
  (forall x0:set, x0 :e X ->
     forall eps:set, eps :e R /\ Rlt 0 eps ->
       exists delta:set, delta :e R /\ Rlt 0 delta /\
         (forall x:set, x :e X ->
            Rlt (apply_fun dX (x,x0)) delta ->
            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
admit.
Qed.

(** from 17: convergent sequences **)
(** LATEX VERSION: A sequence x1,x2,... in X converges to x if for each neighborhood U of x there is N such that x_n is in U for all n >= N. **)
(** sequences as functions from omega **)
Definition sequence_in : set -> set -> prop := fun seq A => function_on seq omega A.

(** from 17: convergent sequences **)
(** LATEX VERSION: A sequence is a function from the positive integers (modeled here by omega) into the space. **)
Definition sequence_on : set -> set -> prop := fun seq A => function_on seq omega A.

(** helper: apply_fun for a graph under definitional equality **)
Theorem apply_fun_of_graph_eq : forall f A:set, forall g:set->set, forall a:set,
  f = graph A g -> a :e A -> apply_fun f a = g a.
admit.
Qed.

(** from 17: definition of convergence of a sequence **)
(** LATEX VERSION: The neighborhood definition of convergence: eventually the sequence lies in every neighborhood of the limit point. **)
Definition converges_to : set -> set -> set -> set -> prop :=
  fun X Tx seq x =>
    topology_on X Tx /\ sequence_on seq X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.

(** Helper: extract topology_on from converges_to **)
Theorem converges_to_topology : forall X Tx seq x:set,
  converges_to X Tx seq x -> topology_on X Tx.
admit.
Qed.

(** Helper: extract sequence_on from converges_to **)
Theorem converges_to_sequence_on : forall X Tx seq x:set,
  converges_to X Tx seq x -> sequence_on seq X.
admit.
Qed.

(** Helper: extract x in X from converges_to **)
Theorem converges_to_point_in_X : forall X Tx seq x:set,
  converges_to X Tx seq x -> x :e X.
admit.
Qed.

(** Helper: extract neighborhood condition from converges_to **)
Theorem converges_to_neighborhoods : forall X Tx seq x:set,
  converges_to X Tx seq x ->
  forall U:set, U :e Tx -> x :e U ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
admit.
Qed.
(** from 18: sequences and continuous functions **)
(** LATEX VERSION: If f is a function and (x_n) a sequence, then (f(x_n)) is the composed sequence. **)
(** map a sequence seq by a function f, giving the composed sequence n -> f(seq(n)) **)
Definition map_sequence : set -> set -> set := fun f seq => compose_fun omega seq f.

(** from 18: image of a set under a function **)
(** LATEX VERSION: The image f(U) consists of all points f(x) with x in U. **)
(** image of a set U under a function f **)
Definition image_of : set -> set -> set := fun f U => Repl U (fun x => apply_fun f x).

(** from 21: sequences of functions **)
(** LATEX VERSION: For a sequence of functions f_n and a point x, the value is f_n(x). **)
Definition function_sequence_value : set -> set -> set -> set :=
  fun f_seq n x => apply_fun (apply_fun f_seq n) x.

(** Helper: image is monotone under inclusion **)
(** LATEX VERSION: If U subset V then f(U) subset f(V). **)
Theorem image_of_mono : forall f U V:set,
  U c= V ->
  image_of f U c= image_of f V.
admit.
Qed.

(** Helper: image under a function_on map stays in the codomain **)
(** LATEX VERSION: If f maps X to Y and U subset X then f(U) subset Y. **)
Theorem image_of_sub_codomain : forall f X Y U:set,
  function_on f X Y ->
  U c= X ->
  image_of f U c= Y.
admit.
Qed.

(** Helper: image of Empty **)
(** LATEX VERSION: f(Empty) = Empty. **)
Theorem image_of_Empty : forall f:set,
  image_of f Empty = Empty.
admit.
Qed.

(** Helper: image of binary union **)
(** LATEX VERSION: f(U union V) = f(U) union f(V). **)
Theorem image_of_binunion : forall f U V:set,
  image_of f (U :\/: V) = (image_of f U) :\/: (image_of f V).
admit.
Qed.

(** Helper: image of union of a family **)
(** LATEX VERSION: f(Union Fam) equals Union of images f(U) for U in Fam. **)
Theorem image_of_Union : forall f Fam:set,
  image_of f (Union Fam) = Union {image_of f U|U :e Fam}.
admit.
Qed.

(** Helper: image of a set under composition **)
(** LATEX VERSION: If U subset X then (g o f)(U) equals g(f(U)). **)
Theorem image_of_compose_fun : forall X f g U:set,
  U c= X ->
  image_of (compose_fun X f g) U = image_of g (image_of f U).
admit.
Qed.

(** from 21: convergence in metric spaces **)
(** LATEX VERSION: In a metric space, a sequence converges to x if for every eps>0 there exists N such that d(x_n,x) < eps for all n >= N. **)
(** FIXED: Removed extra parentheses around pair argument to d metric. **)
Definition sequence_converges_metric : set -> set -> set -> set -> prop :=
  fun X d seq x =>
    metric_on X d /\ sequence_on seq X /\ x :e X /\
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (apply_fun d (apply_fun seq n, x)) eps.

(** Helper: extract metric_on from sequence_converges_metric **)
Theorem sequence_converges_metric_metric_on : forall X d seq x:set,
  sequence_converges_metric X d seq x -> metric_on X d.
admit.
Qed.

(** Helper: extract sequence_on from sequence_converges_metric **)
Theorem sequence_converges_metric_sequence_on : forall X d seq x:set,
  sequence_converges_metric X d seq x -> sequence_on seq X.
admit.
Qed.

(** Helper: extract x in X from sequence_converges_metric **)
Theorem sequence_converges_metric_point_in_X : forall X d seq x:set,
  sequence_converges_metric X d seq x -> x :e X.
admit.
Qed.

(** Helper: extract the eps condition from sequence_converges_metric **)
Theorem sequence_converges_metric_eps : forall X d seq x:set,
  sequence_converges_metric X d seq x ->
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n ->
        Rlt (apply_fun d (apply_fun seq n, x)) eps.
admit.
Qed.

(** from 21: uniqueness of limits in metric spaces **) 
(** LATEX VERSION: In a metric space, a convergent sequence has at most one limit. **)
(** helper: function evaluation as graph lookup **) 
Theorem metric_limits_unique : forall X d seq x y:set,
  metric_on X d ->
  sequence_on seq X ->
  sequence_converges_metric X d seq x ->
  sequence_converges_metric X d seq y ->
  x = y.
admit.
Qed.

(** from 21: uniform convergence of sequences of functions **)
(** LATEX VERSION: A sequence of functions f_n:X->Y converges uniformly to f if for each eps>0 there exists N such that d_Y(f_n(x),f(x)) < eps for all n>=N and all x in X. **)
(** uniform convergence of function sequences between metric spaces **)
Definition uniform_convergence_functions :
  set -> set -> set -> set -> set -> set -> prop :=
  fun X dX Y dY f_seq f =>
    metric_on X dX /\ metric_on Y dY /\
    function_on f_seq omega (function_space X Y) /\ function_on f X Y /\
    (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y) /\
(** FIXED: Removed extra parentheses around pair argument to dY metric. **)
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          forall x:set, x :e X ->
            Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps.

(** Helper: extract metric_on X dX from uniform_convergence_functions **)
Theorem uniform_convergence_functions_metric_on_X : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> metric_on X dX.
admit.
Qed.

(** Helper: extract metric_on Y dY from uniform_convergence_functions **)
Theorem uniform_convergence_functions_metric_on_Y : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> metric_on Y dY.
admit.
Qed.

(** Helper: extract function_on f_seq omega (function_space X Y) from uniform_convergence_functions **)
Theorem uniform_convergence_functions_fseq : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  function_on f_seq omega (function_space X Y).
admit.
Qed.

(** Helper: extract function_on f X Y from uniform_convergence_functions **)
Theorem uniform_convergence_functions_f : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> function_on f X Y.
admit.
Qed.

(** Helper: extract pointwise function_on for f_seq n from uniform_convergence_functions **)
Theorem uniform_convergence_functions_pointwise : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y.
admit.
Qed.

(** Helper: extract the eps condition from uniform_convergence_functions **)
Theorem uniform_convergence_functions_eps : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n ->
        forall x:set, x :e X ->
          Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps.
admit.
Qed.

(** helper: transitivity of Rle **) 
Theorem Rle_tra : forall a b c:set, Rle a b -> Rle b c -> Rle a c.
admit.
Qed.

(** helper: monotonicity of add_SNo in Rle form (right argument) **) 
Theorem Rle_add_SNo_2 : forall x y z:set,
  x :e R -> y :e R -> z :e R ->
  Rle y z -> Rle (add_SNo x y) (add_SNo x z).
admit.
Qed.

(** from 21: uniform limit theorem placeholder **) 
(** LATEX VERSION: Uniform limit of continuous functions between metric spaces is continuous. **)
Theorem uniform_limit_of_continuous_is_continuous :
  forall X dX Y dY f_seq f:set,
    metric_on X dX -> metric_on Y dY ->
    function_on f_seq omega (function_space X Y) ->
    (forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n)) ->
    uniform_convergence_functions X dX Y dY f_seq f ->
    continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
admit.
Qed.

(** from 21: convergence of sequences in metric spaces **) 
(** LATEX VERSION: Immediate restatement of convergence (placeholder). **)
Theorem sequence_convergence_metric : forall X d seq x:set,
  sequence_converges_metric X d seq x -> sequence_converges_metric X d seq x.
admit.
Qed.

(** from 21: continuity via sequences in metric spaces **)
(** LATEX VERSION: Continuity between metric spaces is equivalent to preserving limits of convergent sequences. **)
(** FIXED: Composed sequence fseq is a function graph {(n, apply_fun f (apply_fun seq n))|n :e omega}, not a Cartesian-product set. **)
Theorem continuity_via_sequences_metric : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY -> function_on f X Y ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x)).
admit.
Qed.

(** from 22 Definition: quotient map and quotient topology **) 
(** LATEX VERSION: Quotient topology on Y makes a surjective map f:XY continuous iff preimages of opens in Y are open in X. **)
Definition quotient_topology : set -> set -> set -> set -> set :=
  fun X Tx Y f => {V :e Power Y|{x :e X|apply_fun f x :e V} :e Tx}.

Definition quotient_map : set -> set -> set -> set -> prop := fun X Tx Y f =>
  topology_on X Tx /\
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y).
Theorem quotient_topology_is_topology : forall X Tx Y f:set,
  topology_on X Tx -> quotient_map X Tx Y f ->
  topology_on Y (quotient_topology X Tx Y f).
admit.
Qed.

(** from 22: universal property of quotient maps **) 
(** LATEX VERSION: Universal property: a quotient map f is continuous into any topology Ty on Y coarser than the quotient topology. **)
Theorem quotient_universal_property : forall X Tx Y Ty f:set,
  quotient_map X Tx Y f -> topology_on Y Ty -> Ty c= quotient_topology X Tx Y f ->
  continuous_map X Tx Y Ty f.
admit.
Qed.

(** from 23 Definition: separation of a space **) 
(** LATEX VERSION: A separation of X is a pair of disjoint nonempty open sets whose union is X. **)
Definition separation_of : set -> set -> set -> prop := fun X U V =>
  U :e Power X /\ V :e Power X /\ U :/\: V = Empty /\ U <> Empty /\ V <> Empty /\ U :\/: V = X.

(** Helper: a proper nonempty subset yields a separation by its complement **)
Theorem separation_of_complement : forall X U:set,
  U c= X -> U <> Empty -> U <> X ->
  separation_of X U (X :\: U).
admit.
Qed.

(** from 23 Definition: connected space **) 
(** LATEX VERSION: X with topology Tx is connected if it admits no separation. **)
Definition connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).

(** Helper: extract topology_on from connected_space **)
Theorem connected_space_topology : forall X Tx:set,
  connected_space X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract no-separation property from connected_space **)
Theorem connected_space_no_separation : forall X Tx:set,
  connected_space X Tx -> ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
admit.
Qed.

(** Helper: homeomorphisms preserve connectedness **)
Theorem homeomorphism_preserves_connected : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  connected_space X Tx ->
  connected_space Y Ty.
admit.
Qed.

(** Helper theorems for connected_iff_no_nontrivial_clopen **)
Theorem clopen_gives_separation : forall X Tx A:set,
  topology_on X Tx -> A <> Empty -> A <> X ->
  open_in X Tx A -> closed_in X Tx A ->
  exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
admit.
Qed.
Theorem separation_gives_clopen : forall X Tx U V:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> separation_of X U V ->
  exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
admit.
Qed.

(** from 23: no nontrivial clopen sets characterization **)
(** LATEX VERSION: A space is connected iff it has no nontrivial clopen subsets. **)
Theorem connected_iff_no_nontrivial_clopen : forall X Tx:set,
  topology_on X Tx ->
  (connected_space X Tx <->
  ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A)).
admit.
Qed.

(** from 23 Lemma 23.1: separations in subspaces via limit points **)
(** LATEX VERSION: If Y is a subspace of X, a separation of Y is a pair of disjoint nonempty sets A,B whose union is Y, neither containing a limit point of the other. **)
Theorem separation_subspace_limit_points : forall X Tx Y A B:set,
  topology_on X Tx -> Y c= X ->
  (((A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B)
  <->
  (separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a))).
admit.
Qed.

(** from 23 Lemma 23.2: connected subspace lies in one side of a separation **)
(** LATEX VERSION: If C and D form a separation of X and Y is a connected subspace of X, then Y lies entirely within either C or D. **)
Theorem connected_subset_in_separation_side : forall X Tx C D Y:set,
  topology_on X Tx -> Y c= X ->
  connected_space Y (subspace_topology X Tx Y) ->
  C :e Tx -> D :e Tx -> separation_of X C D ->
  Y c= C \/ Y c= D.
admit.
Qed.

(** from 23 Theorem 23.3: union of connected sets with common point is connected **)
(** LATEX VERSION: If each A is connected and the A have a point in common, then their union is connected. **)
Theorem union_connected_common_point : forall X Tx F:set,
  topology_on X Tx ->
  (forall C:set, C :e F -> C c= X) ->
  (forall C:set, C :e F -> connected_space C (subspace_topology X Tx C)) ->
  (exists x:set, forall C:set, C :e F -> x :e C) ->
  connected_space (Union F) (subspace_topology X Tx (Union F)).
admit.
Qed.

(** from 23 Theorem 23.4: adjoining limit points preserves connectedness **)
(** LATEX VERSION: If A is connected and A  B  cl(A), then B is connected. **)
Theorem connected_with_limit_points : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  connected_space A (subspace_topology X Tx A) ->
  A c= B -> B c= closure_of X Tx A ->
  connected_space B (subspace_topology X Tx B).
admit.
Qed.

(** from 23 Theorem 23.5: image of a connected space is connected **)
(** LATEX VERSION: If f:XY is continuous and X is connected, then f(X) is connected (as a subspace of Y). **)
Theorem continuous_image_connected : forall X Tx Y Ty f:set,
  connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 24 Definition (linear continuum): least upper bound property (upper bounds) **)
(** LATEX VERSION: (1) L has the least upper bound property. **)
Definition R_upper_bound : set -> set -> prop := fun A u =>
  u :e R /\ forall a:set, a :e A -> a :e R -> Rle a u.

(** from 24 Definition (linear continuum): least upper bound property (least upper bounds) **)
(** LATEX VERSION: (1) L has the least upper bound property. **)
Definition R_lub : set -> set -> prop := fun A l =>
  l :e R /\
  (forall a:set, a :e A -> a :e R -> Rle a l) /\
  (forall u:set, u :e R ->
     (forall a:set, a :e A -> a :e R -> Rle a u) ->
     Rle l u).

(** helper: extract l :e R from R_lub **)
Theorem R_lub_in_R : forall A l:set, R_lub A l -> l :e R.
admit.
Qed.

(** helper: uniqueness of least upper bounds in R **)
Theorem R_lub_unique : forall A l1 l2:set, R_lub A l1 -> R_lub A l2 -> l1 = l2.
admit.
Qed.

(** helper: 0 is the least upper bound of {0} **)
Theorem R_lub_Sing0 : R_lub {0} 0.
admit.
Qed.

(** helper: classical negation of implication **)
Theorem not_imp : forall A B:prop, ~(A -> B) -> A /\ ~B.
admit.
Qed.

(** helper: existence of least upper bounds in R (used for uniform metric) **)
(** LATEX VERSION: The expression sup{...} is assumed to exist as a real number. **)
(** NOTE: We assume A is nonempty, matching the usual least upper bound property formulation. **)
Theorem R_lub_exists : forall A:set,
  (exists a0:set, a0 :e A) ->
  (forall a:set, a :e A -> a :e R) ->
  (exists u:set, u :e R /\ forall a:set, a :e A -> a :e R -> Rle a u) ->
  exists l:set, R_lub A l.
admit.
Qed.

(** helper: lub approximation from below **)
(** LATEX VERSION: If l = sup A and eps>0, then some a in A satisfies l-eps < a. **)
Theorem R_lub_approx_from_below : forall A l eps:set,
  R_lub A l ->
  eps :e R -> Rlt 0 eps ->
  exists a:set, a :e A /\ a :e R /\ Rlt (add_SNo l (minus_SNo eps)) a.
admit.
Qed.

(** from 24 Corollary 24.2: the real line is connected **)
(** LATEX VERSION: Corollary 24.2: The real line R is connected (and so are intervals and rays in R). **)
(** LATEX VERSION: The real line with the standard topology is connected. **)
Theorem interval_connected : connected_space R R_standard_topology.
admit.
Qed.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
(** LATEX VERSION: If f:XY is continuous, X is connected, and r lies between f(a) and f(b), then cX with f(c)=r. **)
Definition between_in_order : set -> set -> set -> set -> prop := fun Y u r v =>
  (order_rel Y u r /\ order_rel Y r v)
  \/ (order_rel Y v r /\ order_rel Y r u)
  \/ r = u
  \/ r = v.

(** Helper: introduction rule for between_in_order using u <= r <= v **)
Theorem between_in_orderI_left : forall Y u r v:set,
  order_rel Y u r ->
  order_rel Y r v ->
  between_in_order Y u r v.
admit.
Qed.

(** Helper: introduction rule for between_in_order using v <= r <= u **)
Theorem between_in_orderI_right : forall Y u r v:set,
  order_rel Y v r ->
  order_rel Y r u ->
  between_in_order Y u r v.
admit.
Qed.

(** Helper: introduction rule for between_in_order when r = u **)
Theorem between_in_orderI_eq_left : forall Y u v:set,
  between_in_order Y u u v.
admit.
Qed.

(** Helper: introduction rule for between_in_order when r = v **)
Theorem between_in_orderI_eq_right : forall Y u v:set,
  between_in_order Y u v v.
admit.
Qed.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
(** LATEX VERSION: If f is continuous and X is connected, every value between f(a) and f(b) is attained. **)
(** LATEX VERSION: Intermediate value theorem, stated as a derived theorem wrapper. **)
Theorem intermediate_value_theorem : forall X Tx Y f a b r:set,
  connected_space X Tx ->
  simply_ordered_set Y ->
  continuous_map X Tx Y (order_topology Y) f ->
  a :e X -> b :e X -> r :e Y ->
  between_in_order Y (apply_fun f a) r (apply_fun f b) ->
  exists c:set, c :e X /\ apply_fun f c = r.
admit.
Qed.

(** from 24: connected subspaces of  are intervals **) 
(** LATEX VERSION: A connected subset of the real line contains every point between any two of its points. **)
Theorem connected_subsets_real_are_intervals : forall A:set,
  A c= R ->
  connected_space A (subspace_topology R R_standard_topology A) ->
  forall x y z:set, x :e A -> y :e A -> z :e R ->
    (Rlt x z /\ Rlt z y \/ Rlt y z /\ Rlt z x) -> z :e A.
admit.
Qed.

(** Helper: image of x mapped to (x,y0) is setprod X {y0} **)
Theorem image_of_id_const_is_slice : forall X y0:set,
  image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X = setprod X {y0}.
admit.
Qed.

(** Helper: slice X times {y0} is connected when X is connected **)
Theorem slice_X_connected : forall X Tx Y Ty y0:set,
  connected_space X Tx -> topology_on Y Ty -> y0 :e Y ->
  connected_space (setprod X {y0})
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod X {y0})).
admit.
Qed.

(** Helper: image of y mapped to (x0,y) is setprod {x0} Y **)
Theorem image_of_const_id_is_slice : forall Y x0:set,
  image_of (pair_map Y (const_fun Y x0) {(y,y)|y :e Y}) Y = setprod {x0} Y.
admit.
Qed.

(** Helper: y maps to (x0,y) is a homeomorphism onto the slice {x0} times Y **)
Theorem homeomorphism_const_id_slice : forall X Tx Y Ty x0:set,
  topology_on X Tx -> topology_on Y Ty -> x0 :e X ->
  homeomorphism Y Ty (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y))
    (pair_map Y (const_fun Y x0) {(y,y)|y :e Y}).
admit.
Qed.

(** Helper: slice {x0} times Y is connected when Y is connected **)
Theorem slice_Y_connected : forall X Tx Y Ty x0:set,
  connected_space Y Ty -> topology_on X Tx -> x0 :e X ->
  connected_space (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y)).
admit.
Qed.

(** from 23 Theorem 23.6: finite products of connected spaces are connected **) 
(** LATEX VERSION: The product of two connected spaces is connected in the product topology. **)
Theorem finite_product_connected : forall X Tx Y Ty:set,
  connected_space X Tx -> connected_space Y Ty ->
  connected_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** helper: graph comprehension yields a total function **)
(** LATEX VERSION: If g maps A into Y, then its graph is a total function A -> Y. **)
Theorem total_function_on_graph : forall A Y:set, forall g:set->set,
  (forall a:set, a :e A -> g a :e Y) ->
  total_function_on (graph A g) A Y.
admit.
Qed.

(** Helper: box_basis is a basis on the product space **)
Theorem box_basis_is_basis_on : forall I Xi:set,
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  basis_on (product_space I Xi) (box_basis I Xi).
admit.
Qed.

(** Helper: box_topology is a topology_on when component topologies are **)
Theorem box_topology_is_topology_on : forall I Xi:set,
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  topology_on (product_space I Xi) (box_topology I Xi).
admit.
Qed.

(** from 23 Example 6: R^ in the box topology is not connected **) 
(** LATEX VERSION: Partition R^ into bounded and unbounded sequences; each is open in the box topology using (a_i-1,a_i+1). **)
Definition R_omega_space : set :=
  product_space omega (const_space_family omega R R_standard_topology).
Definition R_omega_box_topology : set :=
  box_topology omega (const_space_family omega R R_standard_topology).
Definition R_omega_product_topology : set :=
  product_topology_full omega (const_space_family omega R R_standard_topology).

(** from 23 Example 6: bounded sequences in R^omega **)
(** LATEX VERSION: A sequence is bounded if all coordinates lie in some interval (-M,M) for a single M. **)
Definition bounded_sequence_Romega : set -> prop := fun f =>
  exists M:set, M :e R /\ forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.

(** from 23 Example 6: the set of bounded sequences **)
(** LATEX VERSION: Let B be the set of bounded sequences; it is used to separate R^omega in the box topology. **)
Definition bounded_sequences_Romega : set :=
  {f :e R_omega_space | bounded_sequence_Romega f}.

(** from 23 Example 6: unbounded sequences in R^omega **)
(** LATEX VERSION: A sequence is unbounded if for every M there is some coordinate outside (-M,M). **)
Definition unbounded_sequence_Romega : set -> prop := fun f =>
  forall M:set, M :e R -> exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M).

(** from 23 Example 6: the set of unbounded sequences **)
(** LATEX VERSION: Let U be the set of unbounded sequences; it is used to separate R^omega in the box topology. **)
Definition unbounded_sequences_Romega : set :=
  {f :e R_omega_space | unbounded_sequence_Romega f}.

(** Helper: coordinates of a point in R_omega_space are real numbers **)
Theorem Romega_coord_in_R : forall f i:set,
  f :e R_omega_space ->
  i :e omega ->
  apply_fun f i :e R.
admit.
Qed.

(** Helper: bounded and unbounded sequence collections lie in Power R_omega_space **)
Theorem bounded_sequences_Romega_in_Power : bounded_sequences_Romega :e Power R_omega_space.
admit.
Qed.
Theorem unbounded_sequences_Romega_in_Power : unbounded_sequences_Romega :e Power R_omega_space.
admit.
Qed.

(** Helper: bounded/unbounded sets are intended to form a separation in the box topology **)
Theorem bounded_sequences_in_Romega_box_topology :
  bounded_sequences_Romega :e R_omega_box_topology.
admit.
Qed.
Theorem unbounded_sequences_in_Romega_box_topology :
  unbounded_sequences_Romega :e R_omega_box_topology.
admit.
Qed.
Theorem bounded_unbounded_disjoint_Romega :
  bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty.
admit.
Qed.
Theorem bounded_union_unbounded_Romega :
  bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
admit.
Qed.

(** Helper: both halves of the separation are nonempty **)
Theorem bounded_sequences_Romega_nonempty : bounded_sequences_Romega <> Empty.
admit.
Qed.
Theorem unbounded_sequences_Romega_nonempty : unbounded_sequences_Romega <> Empty.
admit.
Qed.
Theorem R_omega_box_not_connected :
  ~ connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (box_topology omega (const_space_family omega R R_standard_topology)).
admit.
Qed.

(** from 23 Example 7: R^ in the product topology is connected **) 
(** LATEX VERSION: Let R^ be sequences eventually 0; it is connected as union of R^n; its closure is all of R^ in product topology. **)
Definition Romega_tilde : set -> set := fun n =>
  {f :e R_omega_space | forall i:set, i :e omega -> n :e i -> apply_fun f i = 0}.

Definition Romega_infty : set := Union {Romega_tilde n|n :e omega}.
Theorem Romega_tilde_sub_Romega : forall n:set,
  Romega_tilde n c= R_omega_space.
admit.
Qed.
Theorem Romega_infty_sub_Romega : Romega_infty c= R_omega_space.
admit.
Qed.

(** from 23 Example 7: the constant zero sequence in R^omega **)
(** LATEX VERSION: The constant zero sequence is an element of R^omega (the countable product of R). **)
Definition Romega_zero : set := const_fun omega 0.
Theorem Romega_zero_in_Romega_space : Romega_zero :e R_omega_space.
admit.
Qed.
Theorem Romega_zero_in_Romega_tilde : forall n:set,
  n :e omega -> Romega_zero :e Romega_tilde n.
admit.
Qed.
Theorem Romega_tilde_nonempty : forall n:set,
  n :e omega -> Romega_tilde n <> Empty.
admit.
Qed.

(** from 23 Example 7: product topology on R^omega is a topology **)
(** LATEX VERSION: The product topology on R to the omega is a topology on the product space R to the omega. **)
Theorem Romega_product_topology_is_topology : topology_on R_omega_space R_omega_product_topology.
admit.
Qed.

(** helper: the product topology on R omega is coarser than the box topology **)
(** LATEX VERSION: The product topology is generated from cylinders, and each cylinder is a box-basic open set. **)
Theorem Romega_product_topology_sub_Romega_box_topology :
  R_omega_product_topology c= R_omega_box_topology.
admit.
Qed.

(** helper: fineness passes to subspaces for Romega_tilde **)
(** LATEX VERSION: Since the product topology is coarser than the box topology, the induced subspace topology on any subset is also coarser. **)
Theorem Romega_tilde_subspace_product_subspace_box : forall n:set,
  n :e omega ->
  subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n)
    c= subspace_topology R_omega_space R_omega_box_topology (Romega_tilde n).
admit.
Qed.

(** from 23: dense set meets every nonempty open set **)
(** LATEX VERSION: If A is dense in X and U is nonempty open, then U intersect A is nonempty. **)
Theorem dense_in_meets_nonempty_open : forall A X Tx U:set,
  topology_on X Tx ->
  closure_of X Tx A = X ->
  U :e Tx ->
  U <> Empty ->
  U :/\: A <> Empty.
admit.
Qed.

(** from 23: dense connected subset implies connected space **)
(** LATEX VERSION: If A is dense in X and A is connected in the subspace topology, then X is connected. **)
Theorem connected_space_if_dense_connected_subset : forall X Tx A:set,
  topology_on X Tx ->
  A c= X ->
  connected_space A (subspace_topology X Tx A) ->
  closure_of X Tx A = X ->
  connected_space X Tx.
admit.
Qed.

(** Example 7 connectedness theorems are stated later, after singleton and extension map infrastructure. **)

(** Helper: any omega indexed real map gives an element of R_omega_space **)
Theorem graph_omega_in_Romega_space : forall h:set->set,
  (forall i:set, i :e omega -> h i :e R) ->
  graph omega h :e R_omega_space.
admit.
Qed.

(** from 19: coordinate inclusions into infinite products **)
(** LATEX VERSION: One often considers the map r -> (r,0,0,...) into R^omega when working with product and box topologies. **)
(** Helper: a sequence supported at coordinate 0 **)
Definition Romega_singleton_seq : set -> set := fun r =>
  graph omega (fun i:set => If_i (0 :e i) 0 r).

(** Helper: singleton sequence is in the ambient product space **)
Theorem Romega_singleton_seq_in_Romega_space : forall r:set,
  r :e R -> Romega_singleton_seq r :e R_omega_space.
admit.
Qed.

(** Helper: coordinate evaluation of the singleton sequence **)
(** LATEX VERSION: For the singleton sequence r  (r,0,0,...), the i-th coordinate is If(0 in i) then 0 else r. **)
Theorem Romega_singleton_seq_apply : forall r i:set,
  r :e R ->
  i :e omega ->
  apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
admit.
Qed.

(** Helper: singleton sequence is in Romega_tilde 0 **)
Theorem Romega_singleton_seq_in_Romega_tilde0 : forall r:set,
  r :e R -> Romega_singleton_seq r :e Romega_tilde 0.
admit.
Qed.

(** from 19: coordinate inclusion map into R^omega **)
(** LATEX VERSION: Define the inclusion r -> (r,0,0,...) as a function from R into the product space. **)
(** Helper: map r in R to the singleton sequence **)
Definition Romega_singleton_map : set := graph R Romega_singleton_seq.

(** Helper: apply_fun for Romega_singleton_map **)
Theorem Romega_singleton_map_apply : forall r:set,
  r :e R -> apply_fun Romega_singleton_map r = Romega_singleton_seq r.
admit.
Qed.

(** Helper: singleton map is a function into the ambient product space **)
Theorem Romega_singleton_map_function_on :
  function_on Romega_singleton_map R R_omega_space.
admit.
Qed.

(** Helper: singleton map is continuous into the product topology on R_omega_space **)
(** LATEX VERSION: The coordinate-inclusion map r  (r,0,0,...) is continuous in the product topology. **)
Theorem Romega_singleton_map_continuous_prod :
  continuous_map R R_standard_topology R_omega_space R_omega_product_topology Romega_singleton_map.
admit.
Qed.

(** Helper: image of the singleton map lies in Romega_tilde 0 **)
Theorem image_of_Romega_singleton_map_sub_Romega_tilde0 :
  image_of Romega_singleton_map R c= Romega_tilde 0.
admit.
Qed.

(** Helper: extend an element of Romega_tilde k with one more real coordinate at ordsucc k **)
(** LATEX VERSION: Build an element of R^ by extending a sequence that is 0 past stage k with one more coordinate at k+1, keeping all later coordinates 0. **)
Definition Romega_extend_seq : set -> set -> set := fun k p =>
  graph omega (fun i:set =>
    If_i (ordsucc k :e i) 0
      (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i))).

(** Helper: coordinate evaluation for Romega_extend_seq **)
Theorem Romega_extend_seq_apply : forall k p i:set,
  i :e omega ->
  apply_fun (Romega_extend_seq k p) i
    = If_i (ordsucc k :e i) 0
        (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)).
admit.
Qed.

(** Helper: extension lands in Romega_tilde (ordsucc k) **)
Theorem Romega_extend_seq_in_Romega_tilde_succ : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  Romega_extend_seq k p :e Romega_tilde (ordsucc k).
admit.
Qed.

(** Helper: map extending Romega_tilde k by one coordinate **)
(** LATEX VERSION: The extension map takes (f,r) with f  R~(k) and r  R and returns the extended sequence in R~(k+1). **)
Definition Romega_extend_map : set -> set := fun k =>
  graph (setprod (Romega_tilde k) R) (fun p:set => Romega_extend_seq k p).

(** Helper: apply_fun for Romega_extend_map **)
Theorem Romega_extend_map_apply : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  apply_fun (Romega_extend_map k) p = Romega_extend_seq k p.
admit.
Qed.

(** Helper: extension map is a function into the ambient product space **)
Theorem Romega_extend_map_function_on : forall k:set,
  k :e omega ->
  function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) R_omega_space.
admit.
Qed.

(** Helper: extension map is a function into Romega_tilde (ordsucc k) **)
(** LATEX VERSION: The extension map lands in R~(k+1). **)
Theorem Romega_extend_map_function_on_tilde_succ : forall k:set,
  k :e omega ->
  function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) (Romega_tilde (ordsucc k)).
admit.
Qed.

(** Helper: image of the extension map lies in Romega_tilde (ordsucc k) **)
Theorem image_of_Romega_extend_map_sub_Romega_tilde_succ : forall k:set,
  k :e omega ->
  image_of (Romega_extend_map k) (setprod (Romega_tilde k) R) c= Romega_tilde (ordsucc k).
admit.
Qed.

(** Helper: extension map is continuous into the ambient product topology on R^omega **)
(** LATEX VERSION: The extension map is continuous for the product topology on R^omega. **)
Theorem Romega_extend_map_continuous_in_Romega_product : forall k:set,
  k :e omega ->
  continuous_map
    (setprod (Romega_tilde k) R)
    (product_topology (Romega_tilde k) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde k))
                      R R_standard_topology)
    R_omega_space
    R_omega_product_topology
    (Romega_extend_map k).
admit.
Qed.

(** Helper: extension map is continuous into the subspace Romega_tilde (ordsucc k) **)
(** LATEX VERSION: The extension map is continuous into R~(k+1) with the subspace topology. **)
Theorem Romega_extend_map_continuous_to_Romega_tilde_succ : forall k:set,
  k :e omega ->
  continuous_map
    (setprod (Romega_tilde k) R)
    (product_topology (Romega_tilde k) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde k))
                      R R_standard_topology)
    (Romega_tilde (ordsucc k))
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde (ordsucc k)))
    (Romega_extend_map k).
admit.
Qed.

(** Helper: restrict a sequence by zeroing all coordinates beyond stage k **)
(** LATEX VERSION: From a sequence in R^omega, form the truncated sequence that is 0 for all indices i with k in i. **)
Definition Romega_restrict_seq : set -> set -> set := fun k f =>
  graph omega (fun i:set => If_i (k :e i) 0 (apply_fun f i)).

(** Helper: coordinate evaluation for Romega_restrict_seq **)
Theorem Romega_restrict_seq_apply : forall k f i:set,
  k :e omega ->
  f :e R_omega_space ->
  i :e omega ->
  apply_fun (Romega_restrict_seq k f) i = If_i (k :e i) 0 (apply_fun f i).
admit.
Qed.

(** Helper: restriction lands in Romega_tilde k **)
Theorem Romega_restrict_seq_in_Romega_tilde : forall k f:set,
  k :e omega ->
  f :e R_omega_space ->
  Romega_restrict_seq k f :e Romega_tilde k.
admit.
Qed.

(** Helper: coordinate projection map on R^omega **)
(** LATEX VERSION: The i-th coordinate map pi_i : R^omega -> R is continuous in the product topology. **)
Definition Romega_coord_map : set -> set := fun i =>
  graph R_omega_space (fun f:set => apply_fun f i).

(** Helper: apply_fun for Romega_coord_map **)
Theorem Romega_coord_map_apply : forall i f:set,
  i :e omega ->
  f :e R_omega_space ->
  apply_fun (Romega_coord_map i) f = apply_fun f i.
admit.
Qed.

(** Helper: coordinate map is a function into R **)
Theorem Romega_coord_map_function_on : forall i:set,
  i :e omega ->
  function_on (Romega_coord_map i) R_omega_space R.
admit.
Qed.

(** Helper: product-cylinder family is a subbasis on R^omega **)
Theorem Romega_product_subbasis_on :
  subbasis_on R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)).
admit.
Qed.

(** Helper: coordinate map is continuous in the product topology on R^omega **)
Theorem Romega_coord_map_continuous_in_Romega_product : forall i:set,
  i :e omega ->
  continuous_map R_omega_space R_omega_product_topology R R_standard_topology (Romega_coord_map i).
admit.
Qed.

(** Helper: restrict-map on R^omega **)
(** LATEX VERSION: The truncation map f -> f|_k (with zeros beyond k) is continuous in the product topology. **)
Definition Romega_restrict_map : set -> set := fun k =>
  graph R_omega_space (fun f:set => Romega_restrict_seq k f).

(** Helper: apply_fun for Romega_restrict_map **)
Theorem Romega_restrict_map_apply : forall k f:set,
  k :e omega ->
  f :e R_omega_space ->
  apply_fun (Romega_restrict_map k) f = Romega_restrict_seq k f.
admit.
Qed.

(** Helper: restrict-map is a function into the ambient product space **)
Theorem Romega_restrict_map_function_on : forall k:set,
  k :e omega ->
  function_on (Romega_restrict_map k) R_omega_space R_omega_space.
admit.
Qed.

(** Helper: restrict-map is continuous in the product topology on R^omega **)
Theorem Romega_restrict_map_continuous_in_Romega_product : forall k:set,
  k :e omega ->
  continuous_map R_omega_space R_omega_product_topology R_omega_space R_omega_product_topology (Romega_restrict_map k).
admit.
Qed.

(** Helper: split map for Romega_tilde (ordsucc k) into Romega_tilde k x R **)
(** LATEX VERSION: Identify R~(k+1) with R~(k)R by taking the truncated sequence and the new coordinate at k+1. **)
Definition Romega_split_map : set -> set := fun k =>
  graph (Romega_tilde (ordsucc k))
        (fun f:set => (Romega_restrict_seq k f, apply_fun f (ordsucc k))).

(** Helper: apply_fun for Romega_split_map **)
Theorem Romega_split_map_apply : forall k f:set,
  k :e omega ->
  f :e Romega_tilde (ordsucc k) ->
  apply_fun (Romega_split_map k) f
    = (Romega_restrict_seq k f, apply_fun f (ordsucc k)).
admit.
Qed.

(** Helper: split map is a function into Romega_tilde k  R **)
(** LATEX VERSION: The splitting map lands in R~(k)R. **)
Theorem Romega_split_map_function_on : forall k:set,
  k :e omega ->
  function_on (Romega_split_map k) (Romega_tilde (ordsucc k)) (setprod (Romega_tilde k) R).
admit.
Qed.

(** Helper: split map is continuous **)
(** LATEX VERSION: The identification R~(k+1)  R~(k)R is a homeomorphism; in particular the split map is continuous. **)
Theorem Romega_split_map_continuous : forall k:set,
  k :e omega ->
  continuous_map
    (Romega_tilde (ordsucc k))
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde (ordsucc k)))
    (setprod (Romega_tilde k) R)
    (product_topology (Romega_tilde k) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde k))
                      R R_standard_topology)
    (Romega_split_map k).
admit.
Qed.

(** Helper: extensionality in R_omega_space by coordinates **)
Theorem R_omega_space_ext : forall f g:set,
  f :e R_omega_space ->
  g :e R_omega_space ->
  (forall i:set, i :e omega -> apply_fun f i = apply_fun g i) ->
  f = g.
admit.
Qed.

(** Helper: extension identifies Romega_tilde (ordsucc k) with a product **)
Theorem Romega_tilde_succ_homeomorphism : forall k:set,
  k :e omega ->
  homeomorphism
    (setprod (Romega_tilde k) R)
    (product_topology (Romega_tilde k) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde k))
                      R R_standard_topology)
    (Romega_tilde (ordsucc k))
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde (ordsucc k)))
    (Romega_extend_map k).
admit.
Qed.

(** Helper: every finite subset of omega is bounded by some n in omega **)
Theorem finite_subset_of_omega_bounded : forall F:set,
  F c= omega -> finite F -> exists n :e omega, forall m :e F, m :e n.
admit.
Qed.

(** helper: eventual zero equals finite support condition on omega **)
Theorem Romega_infty_eq_finite_support :
  Romega_infty =
    {f :e R_omega_space | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
admit.
Qed.

(** helper: product cylinders are open in R omega product topology **)
(** LATEX VERSION: Each cylinder pi_i^{-1}(U) is a subbasis element, hence open in the product topology. **)
Theorem Romega_product_cylinder_open : forall i U:set,
  i :e omega ->
  U :e space_family_topology (const_space_family omega R R_standard_topology) i ->
  product_cylinder omega (const_space_family omega R R_standard_topology) i U :e R_omega_product_topology.
admit.
Qed.

(** helper: box-basic opens intersected with Romega_tilde are product-subspace-open **)
(** LATEX VERSION: On the finite-support stage, a box-basic neighborhood is determined by finitely many coordinates. **)
(** SUSPICIOUS THEOREM: Intended proof: build a finite intersection of cylinders using indices `ordsucc n` and use `finite_intersection_in_topology`. **)
Theorem Romega_box_basis_cap_Romega_tilde_in_product_subspace : forall n b:set,
  n :e omega ->
  b :e box_basis omega (const_space_family omega R R_standard_topology) ->
  (b :/\: Romega_tilde n) :e subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n).
admit.
Qed.

(** helper: subspace box topology on Romega_tilde is included in the product subspace topology **)
(** LATEX VERSION: Restricting the box topology to R^n yields the same opens as in the product topology. **)
Theorem Romega_tilde_subspace_box_subspace_product : forall n:set,
  n :e omega ->
  subspace_topology R_omega_space R_omega_box_topology (Romega_tilde n)
    c= subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n).
admit.
Qed.

(** helper: the product and box subspace topologies coincide on Romega_tilde **)
(** LATEX VERSION: Since each inclusion holds, we obtain equality of the induced topologies on R^n. **)
Theorem Romega_tilde_subspace_box_eq_product : forall n:set,
  n :e omega ->
  subspace_topology R_omega_space R_omega_box_topology (Romega_tilde n)
    = subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n).
admit.
Qed.

(** helper: Romega_infty is closed in the box topology on R omega **)
(** LATEX VERSION: A sequence with infinitely many nonzero coordinates has a box neighborhood forcing infinitely many coordinates to stay nonzero, so the finite-support set is closed. **)
Theorem Romega_infty_closed_in_Romega_box_topology :
  closed_in R_omega_space R_omega_box_topology Romega_infty.
admit.
Qed.

(** Helper: basis neighborhoods in the product topology meet Romega_infty **)
(** LATEX VERSION: Any basic open neighborhood in the product topology contains a point of R^infty by truncating outside finitely many constrained coordinates. **)
Theorem Romega_infty_meets_product_basis : forall b x:set,
  b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)) ->
  x :e b ->
  b :/\: Romega_infty <> Empty.
admit.
Qed.

(** Helper: basis neighborhoods in the product topology meet Romega_tilde 0 via singleton sequences **)
(** LATEX VERSION: Any basic open neighborhood of a point with all nonzero coordinates 0 contains a singleton sequence (r,0,0,...). **)
Theorem Romega_tilde0_meets_product_basis : forall b x:set,
  b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)) ->
  x :e Romega_tilde 0 ->
  x :e b ->
  b :/\: image_of Romega_singleton_map R <> Empty.
admit.
Qed.

(** Helper: singleton sequences are dense in Romega_tilde 0 (in the product topology) **)
(** LATEX VERSION: Any basic neighborhood of a point in R^0~ meets the set of singleton sequences. **)
Theorem Romega_tilde0_singletons_dense_in_subspace :
  closure_of (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0))
    (image_of Romega_singleton_map R) =
  Romega_tilde 0.
admit.
Qed.

(** Helper: Romega_tilde 0 is connected as closure of a connected subset **)
(** LATEX VERSION: The image of R under the singleton map is connected and dense in R^0~, so R^0~ is connected. **)
Theorem Romega_tilde0_connected :
  connected_space (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0)).
admit.
Qed.

(** from 23 Example 7: each Romega_tilde n is connected in the product topology **) 
(** LATEX VERSION: Each R^n is connected, hence the subspace of sequences supported on {0,...,n} is connected. **)
Theorem Romega_tilde_connected : forall n:set,
  n :e omega ->
  connected_space (Romega_tilde n)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n)).
admit.
Qed.

(** from 23 Example 7: Romega_infty is connected as a union of connected sets with a common point **) 
(** LATEX VERSION: R^infty is the union of the connected subspaces R^n and they share the zero sequence. **)
Theorem Romega_infty_connected :
  connected_space Romega_infty
    (subspace_topology R_omega_space R_omega_product_topology Romega_infty).
admit.
Qed.

(** from 23 Example 7: Romega_infty is dense in the product topology **) 
(** LATEX VERSION: Every basic open set in the product topology meets R^infty by modifying only finitely many coordinates. **)
Theorem Romega_infty_dense :
  closure_of R_omega_space R_omega_product_topology Romega_infty = R_omega_space.
admit.
Qed.
Theorem R_omega_product_connected :
  connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (product_topology_full omega (const_space_family omega R R_standard_topology)).
admit.
Qed.

(** helper: each Romega_tilde n is connected in the box topology subspace **)
(** LATEX VERSION: Each finite-support stage R^n is connected; in the box topology, restriction to coordinates {0,...,n} yields the same topology as a finite product. **)
Theorem Romega_tilde_connected_box : forall n:set,
  n :e omega ->
  connected_space (Romega_tilde n)
    (subspace_topology R_omega_space R_omega_box_topology (Romega_tilde n)).
admit.
Qed.

(** helper: Romega_infty is connected in the box topology subspace **)
(** LATEX VERSION: R^infty is the union of the connected subspaces R^n, all containing the zero sequence; hence it is connected (in the subspace topology). **)
Theorem Romega_infty_connected_box :
  connected_space Romega_infty
    (subspace_topology R_omega_space R_omega_box_topology Romega_infty).
admit.
Qed.

(** from 24 Definition: path and path connectedness **) 
(** LATEX VERSION: A path from x to y is a map p:[0,1] to X with p(0)=x and p(1)=y; X is path connected if every two points can be joined by a path. **)
Definition path_between : set -> set -> set -> set -> prop := fun X x y p =>
  function_on p unit_interval X /\
  apply_fun p 0 = x /\ apply_fun p 1 = y.
Definition path_connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x y:set, x :e X -> y :e X ->
    exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.

(** Helper: extract function and endpoints from path_between **)
Theorem path_between_pair0 : forall X x y p:set,
  path_between X x y p -> function_on p unit_interval X /\ apply_fun p 0 = x.
admit.
Qed.
Theorem path_between_function_on : forall X x y p:set,
  path_between X x y p -> function_on p unit_interval X.
admit.
Qed.
Theorem path_between_at_zero : forall X x y p:set,
  path_between X x y p -> apply_fun p 0 = x.
admit.
Qed.
Theorem path_between_at_one : forall X x y p:set,
  path_between X x y p -> apply_fun p 1 = y.
admit.
Qed.
Theorem path_betweenI : forall X x y p:set,
  function_on p unit_interval X ->
  apply_fun p 0 = x ->
  apply_fun p 1 = y ->
  path_between X x y p.
admit.
Qed.

(** Helper: split a path witness pair (path_between and continuity) **)
Theorem path_witness_between : forall X Tx x y p:set,
  (path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p) ->
  path_between X x y p.
admit.
Qed.
Theorem path_witness_continuous : forall X Tx x y p:set,
  (path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p) ->
  continuous_map unit_interval unit_interval_topology X Tx p.
admit.
Qed.

(** Helper: extract topology_on from path_connected_space **)
Theorem path_connected_space_topology : forall X Tx:set,
  path_connected_space X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract existence of paths from path_connected_space **)
Theorem path_connected_space_paths : forall X Tx x y:set,
  path_connected_space X Tx -> x :e X -> y :e X ->
  exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
admit.
Qed.

(** Helper axioms for path_connected_implies_connected **)
Theorem unit_interval_connected : connected_space unit_interval unit_interval_topology.
admit.
Qed.
Theorem zero_one_in_unit_interval : 0 :e unit_interval /\ 1 :e unit_interval.
admit.
Qed.

(** helper: for any two points in X there exists a path_between witness **)
(** LATEX VERSION: For any x,y in X there is a path (as a function) from x to y. **)
Theorem path_between_exists : forall X x y:set,
  x :e X -> y :e X -> exists p:set, path_between X x y p.
admit.
Qed.
Theorem separation_has_elements : forall X U V:set,
  separation_of X U V ->
  (exists x:set, x :e U) /\ (exists y:set, y :e V).
admit.
Qed.
Theorem separation_subsets : forall X U V:set,
  separation_of X U V ->
  U c= X /\ V c= X.
admit.
Qed.
Theorem subset_elem : forall A B x:set,
  A c= B -> x :e A -> x :e B.
admit.
Qed.

(** from 24: path connected implies connected **) 
(** LATEX VERSION: Every path connected space is connected. **)
Theorem path_connected_implies_connected : forall X Tx:set,
  path_connected_space X Tx -> connected_space X Tx.
admit.
Qed.

(** from 24: continuous surjective image of a path connected space is path connected **) 
(** LATEX VERSION: If f:XY is continuous and surjective and X is path connected, then Y is path connected. **)
Theorem continuous_image_path_connected : forall X Tx Y Ty f:set,
  path_connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) ->
  path_connected_space Y Ty.
admit.
Qed.

(** from 24 Definition: path components equivalence relation **) 
(** LATEX VERSION: The path component of x is the set of points y that can be joined to x by a path in X. **)
Definition path_component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y}.

(** Helper axioms: path reversal and concatenation **)
Theorem path_component_symmetric_axiom : forall X Tx x y:set,
  topology_on X Tx -> x :e X -> y :e X ->
  y :e path_component_of X Tx x -> x :e path_component_of X Tx y.
admit.
Qed.

(** Helper infrastructure for concatenating paths on the unit interval **)
(** The midpoint is eps_ 1, and twice eps_ 1 equals 1. **)

(** left half of the unit interval: [0, eps_ 1] encoded by negated strict inequality **)
(** from 25: concatenating paths (split the parameter interval) **)
(** LATEX VERSION: Split I=[0,1] into the halves [0,1/2] and [1/2,1] and rescale them to define concatenation of paths. **)
Definition unit_interval_left_half : set :=
  {t :e unit_interval | ~(Rlt (eps_ 1) t)}.

(** right half of the unit interval: [eps_ 1, 1] encoded by negated strict inequality **)
(** from 25: concatenating paths (split the parameter interval) **)
(** LATEX VERSION: The right half [1/2,1] of I, used to rescale and paste paths. **)
Definition unit_interval_right_half : set :=
  {t :e unit_interval | ~(Rlt t (eps_ 1))}.
Theorem unit_interval_left_half_sub : unit_interval_left_half c= unit_interval.
admit.
Qed.
Theorem unit_interval_right_half_sub : unit_interval_right_half c= unit_interval.
admit.
Qed.

(** scaling maps used for concatenation, defined only on the appropriate halves **)
(** from 25: concatenating paths (rescaling maps) **)
(** LATEX VERSION: Use t2t on [0,1/2] and t2t1 on [1/2,1] to reparametrize two paths into one. **)
Definition double_map_left_half : set := graph unit_interval_left_half (fun t:set => mul_SNo 2 t).
Definition double_minus_one_map_right_half : set :=
  graph unit_interval_right_half (fun t:set => add_SNo (mul_SNo 2 t) (minus_SNo 1)).
Theorem double_map_apply : forall t:set,
  t :e unit_interval_left_half ->
  apply_fun double_map_left_half t = mul_SNo 2 t.
admit.
Qed.
Theorem double_minus_one_map_apply : forall t:set,
  t :e unit_interval_right_half ->
  apply_fun double_minus_one_map_right_half t = add_SNo (mul_SNo 2 t) (minus_SNo 1).
admit.
Qed.

(** helper: scaling by 2 via eps_ 1 preserves strict inequalities on R **)
Theorem Rlt_mul2_left_iff : forall a t:set,
  a :e R -> t :e R -> (Rlt a (mul_SNo 2 t) <-> Rlt (mul_SNo (eps_ 1) a) t).
admit.
Qed.

(** helper: scaling by 2 via eps_ 1 on the right-hand side **)
Theorem Rlt_mul2_right_iff : forall t b:set,
  t :e R -> b :e R -> (Rlt (mul_SNo 2 t) b <-> Rlt t (mul_SNo (eps_ 1) b)).
admit.
Qed.
Theorem zero_in_unit_interval_left_half : 0 :e unit_interval_left_half.
admit.
Qed.
Theorem eps_1_in_unit_interval_left_half : eps_ 1 :e unit_interval_left_half.
admit.
Qed.
Theorem eps_1_in_unit_interval_right_half : eps_ 1 :e unit_interval_right_half.
admit.
Qed.
Theorem one_in_unit_interval_right_half : 1 :e unit_interval_right_half.
admit.
Qed.
Theorem double_map_at_0 : apply_fun double_map_left_half 0 = 0.
admit.
Qed.
Theorem double_map_at_eps1 : apply_fun double_map_left_half (eps_ 1) = 1.
admit.
Qed.
Theorem double_minus_one_map_at_eps1 : apply_fun double_minus_one_map_right_half (eps_ 1) = 0.
admit.
Qed.
Theorem double_minus_one_map_at_1 : apply_fun double_minus_one_map_right_half 1 = 1.
admit.
Qed.

(** placeholders: properties needed to justify concatenation via the pasting lemma **)
Theorem unit_interval_halves_cover :
  unit_interval_left_half :\/: unit_interval_right_half = unit_interval.
admit.
Qed.
Theorem unit_interval_halves_closed :
  closed_in unit_interval unit_interval_topology unit_interval_left_half /\
  closed_in unit_interval unit_interval_topology unit_interval_right_half.
admit.
Qed.
Theorem unit_interval_halves_intersection :
  (unit_interval_left_half :/\: unit_interval_right_half) = {eps_ 1}.
admit.
Qed.
Theorem double_map_function_on :
  function_on double_map_left_half unit_interval_left_half unit_interval.
admit.
Qed.
Theorem double_minus_one_map_function_on :
  function_on double_minus_one_map_right_half unit_interval_right_half unit_interval.
admit.
Qed.
Theorem double_map_continuous :
  continuous_map unit_interval_left_half
    (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
    unit_interval unit_interval_topology
    double_map_left_half.
admit.
Qed.
Theorem double_minus_one_map_continuous :
  continuous_map unit_interval_right_half
    (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
    unit_interval unit_interval_topology
    double_minus_one_map_right_half.
admit.
Qed.
Theorem path_component_transitive_axiom : forall X Tx x y z:set,
  topology_on X Tx -> x :e X -> y :e X -> z :e X ->
  y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
  z :e path_component_of X Tx x.
admit.
Qed.

(** helper: the inclusion map from unit_interval into R is continuous **)
(** LATEX VERSION: The inclusion unit_interval -> R is continuous since unit_interval_topology is the subspace topology. **)
Theorem unit_interval_inclusion_continuous :
  continuous_map unit_interval unit_interval_topology R R_standard_topology {(t,t) | t :e unit_interval}.
admit.
Qed.

(** NOTE: The punctured plane horizontal and vertical slice lemmas are proved later after arithmetic continuity infrastructure. **)

(** Helper: a path connected subspace lies inside a single path component **)
Theorem subspace_path_connected_implies_in_path_component : forall X Tx V y z:set,
  topology_on X Tx -> V c= X ->
  path_connected_space V (subspace_topology X Tx V) ->
  y :e V -> z :e V ->
  z :e path_component_of X Tx y.
admit.
Qed.

(** Helper: path component is reflexive **)
(** LATEX VERSION: Any point is path connectible to itself via the constant path. **)
Theorem path_component_reflexive : forall X Tx x:set,
  topology_on X Tx -> x :e X -> x :e path_component_of X Tx x.
admit.
Qed.

(** from 24: path components form equivalence classes **) 
(** LATEX VERSION: Path components are equivalence classes under path-connectibility. **)
Theorem path_components_equivalence_relation : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> x :e path_component_of X Tx x) /\
  (forall x y:set, x :e X -> y :e X -> y :e path_component_of X Tx x -> x :e path_component_of X Tx y) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
     z :e path_component_of X Tx x).
admit.
Qed.

(** from 25 Definition: components and local connectedness **) 
(** LATEX VERSION: Component_of X Tx x is the union of connected subspaces containing x; locally_connected means every neighborhood contains a connected open neighborhood of the point. **)
Definition component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C}.
Definition locally_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).

(** Helper: extract topology_on from locally_connected **)
Theorem locally_connected_topology : forall X Tx:set,
  locally_connected X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract local connectedness property **)
Theorem locally_connected_local : forall X Tx x U:set,
  locally_connected X Tx ->
  x :e X ->
  U :e Tx ->
  x :e U ->
  exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).
admit.
Qed.

(** helper: open subspaces of a locally connected space are locally connected **)
Theorem open_subspace_locally_connected : forall X Tx Y:set,
  locally_connected X Tx ->
  Y :e Tx ->
  locally_connected Y (subspace_topology X Tx Y).
admit.
Qed.

(** from 25 Definition: locally path connected **)
(** LATEX VERSION: Locally path connected means each point has a neighborhood basis of path-connected sets. **)
Definition locally_path_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).

(** Helper: extract topology_on from locally_path_connected **)
Theorem locally_path_connected_topology : forall X Tx:set,
  locally_path_connected X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract local path connectedness property **)
Theorem locally_path_connected_local : forall X Tx x U:set,
  locally_path_connected X Tx ->
  x :e X ->
  U :e Tx ->
  x :e U ->
  exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).
admit.
Qed.

(** Helper: singleton subspace is connected **)
Theorem singleton_subspace_connected : forall X Tx x:set,
  topology_on X Tx -> x :e X ->
  connected_space {x} (subspace_topology X Tx {x}).
admit.
Qed.

(** Helper: a point lies in its own component **)
Theorem point_in_component : forall X Tx x:set,
  topology_on X Tx -> x :e X -> x :e component_of X Tx x.
admit.
Qed.

(** Helper: connected subspace witness implies subset of X **)
Theorem connected_subspace_subset : forall X Tx C:set,
  topology_on X Tx ->
  connected_space C (subspace_topology X Tx C) ->
  C c= X.
admit.
Qed.

(** Helper: the component of a point is connected **)
Theorem component_of_connected : forall X Tx x:set,
  topology_on X Tx -> x :e X ->
  connected_space (component_of X Tx x) (subspace_topology X Tx (component_of X Tx x)).
admit.
Qed.

(** Helper: if y lies in the component of x, their components coincide **)
Theorem component_of_eq_if_in : forall X Tx x y:set,
  topology_on X Tx -> x :e X ->
  y :e component_of X Tx x ->
  component_of X Tx y = component_of X Tx x.
admit.
Qed.

(** helper: in a connected space, the component of any point is the whole space **)
(** LATEX VERSION: If X is connected then the component of any point is X. **)
Theorem component_of_whole : forall X Tx x:set,
  connected_space X Tx -> x :e X -> component_of X Tx x = X.
admit.
Qed.

(** helper: in a path connected space, the path component of any point is the whole space **)
(** LATEX VERSION: If X is path connected then the path component of any point is X. **)
Theorem path_component_of_whole : forall X Tx x:set,
  path_connected_space X Tx -> x :e X -> path_component_of X Tx x = X.
admit.
Qed.

(** from 23 Connected Spaces / separations: disjoint families **)
(** LATEX VERSION: A family is pairwise disjoint if any two distinct members have empty intersection. **)
Definition pairwise_disjoint : set -> prop := fun Fam =>
  forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty.

(** from 26 Compactness: cover relation **)
(** LATEX VERSION: A family U covers X if every point of X lies in some member of U. **)
Definition covers : set -> set -> prop :=
  fun X U => forall x:set, x :e X -> exists u:set, u :e U /\ x :e u.

(** helper: subset of union yields cover **)
(** LATEX VERSION: If X is contained in the union of a family Fam, then Fam covers X. **)
Theorem Subq_Union_implies_covers : forall X Fam:set,
  X c= Union Fam -> covers X Fam.
admit.
Qed.

(** helper: cover yields subset of union **)
(** LATEX VERSION: If a family Fam covers X, then X is contained in Union Fam. **)
Theorem covers_implies_Subq_Union : forall X Fam:set,
  covers X Fam -> X c= Union Fam.
admit.
Qed.

(** from 25: path components open in locally path connected spaces **) 
(** LATEX VERSION: In a locally path connected space, every path component is open. **)
Theorem path_components_open : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    open_in X Tx (path_component_of X Tx x).
admit.
Qed.

(** from 25: components equal path components when locally path connected **) 
(** LATEX VERSION: In a locally path connected space, components coincide with path components. **)
Theorem components_equal_path_components : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    path_component_of X Tx x = component_of X Tx x.
admit.
Qed.

(** from 25: components are closed **) 
(** LATEX VERSION: Every component is closed in X. **)
Theorem components_are_closed : forall X Tx:set,
  topology_on X Tx ->
  forall x:set, x :e X -> closed_in X Tx (component_of X Tx x).
admit.
Qed.

(** from 25: components are open in locally connected spaces **) 
(** LATEX VERSION: In a locally connected space, every component is open. **)
Theorem components_are_open_in_locally_connected : forall X Tx:set,
  locally_connected X Tx ->
  forall x:set, x :e X -> open_in X Tx (component_of X Tx x).
admit.
Qed.

(** from 25: components partition the space **) 
(** LATEX VERSION: Components cover X and are pairwise disjoint. **)
Theorem components_partition_space : forall X Tx:set,
  topology_on X Tx ->
  covers X {component_of X Tx x | x :e X} /\
  pairwise_disjoint {component_of X Tx x | x :e X}.
admit.
Qed.

(** from 25: quotient of locally connected space is locally connected **) 
(** LATEX VERSION: Quotients of locally connected spaces remain locally connected. **)
Theorem quotient_preserves_local_connectedness : forall X Tx Y f:set,
  quotient_map X Tx Y f ->
  locally_connected X Tx ->
  locally_connected Y (quotient_topology X Tx Y f).
admit.
Qed.

(** from 25 Definition: quasicomponent equivalence relation **) 
(** LATEX VERSION: The quasicomponent of x consists of points that cannot be separated from x by a clopen set. **)
Definition quasicomponent_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y :e U}.

(** from 25: components vs quasicomponents **) 
(** LATEX VERSION: Components are contained in quasicomponents; in locally connected spaces they are equal. **)
Theorem components_vs_quasicomponents : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, component_of X Tx x c= quasicomponent_of X Tx x) /\
  (locally_connected X Tx -> forall x:set, x :e X -> component_of X Tx x = quasicomponent_of X Tx x).
admit.
Qed.

(** from 23 Exercise: components and path components of  **) 
(** LATEX VERSION: In the lower limit topology on R, every component is a singleton. **)
(** Helper for 23 Exercise: the right closed ray [a,) is open in R_l **)
Theorem right_closed_ray_in_R_lower_limit_topology : forall a:set, a :e R ->
  {x :e R|~(Rlt x a)} :e R_lower_limit_topology.
admit.
Qed.

(** Helper for 23 Exercise: complement of [a,b) is union of a left open ray and a right closed ray **)
Theorem halfopen_interval_left_complement_eq_rays : forall a b:set,
  a :e R -> b :e R ->
  R :\: (halfopen_interval_left a b) =
    {x :e R|Rlt x a} :\/: {x :e R|~(Rlt x b)}.
admit.
Qed.

(** Helper for 23 Exercise: complements of half-open intervals lie in R_l **)
Theorem complement_halfopen_interval_left_in_R_lower_limit_topology : forall a b:set,
  a :e R -> b :e R -> (R :\: halfopen_interval_left a b) :e R_lower_limit_topology.
admit.
Qed.
Theorem ex23_Rl_components :
  component_of R R_lower_limit_topology 0 = {0} /\
  (forall x:set, x :e R -> component_of R R_lower_limit_topology x = {x}).
admit.
Qed.

(** from 23 Exercise: components of ^ in product/uniform/box topologies **) 
(** LATEX VERSION: For R to the omega, compare components in product and box type topologies. **)
(** Helper: in the box topology on R^omega, the component of 0 is contained in Romega_infty (finite support). **)
(** LATEX VERSION: In the box topology, any connected set containing 0 is supported on finitely many coordinates, hence lies in R_infty. **)
(** NOTE: This is a hard exercise-level component computation for the box topology.
    We keep the proof attempt below as a sketch, but expose the statement as an axiom to avoid recursive-admit noise. **)
Axiom component_of_Romega_box_zero_subset_Romega_infty : forall f:set,
  f :e component_of (product_space omega (const_space_family omega R R_standard_topology))
         (box_topology omega (const_space_family omega R R_standard_topology))
         (const_family omega 0) ->
  f :e Romega_infty.
Theorem component_of_Romega_box_zero_subset_Romega_infty_sketch : forall f:set,
  f :e component_of (product_space omega (const_space_family omega R R_standard_topology))
         (box_topology omega (const_space_family omega R R_standard_topology))
         (const_family omega 0) ->
  f :e Romega_infty.
admit.
Qed.
Theorem ex23_Romega_components :
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    product_space omega (const_space_family omega R R_standard_topology) /\
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    {f :e product_space omega (const_space_family omega R R_standard_topology) | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
admit.
Qed.

(** from 23 Exercise: ordered square locally connected but not locally path connected **) 
(** LATEX VERSION: The ordered square is locally connected but not locally path connected. **)
(** Helper: ordered square is locally connected **)
(** LATEX VERSION: In the ordered square, small basic neighborhoods are connected, so the space is locally connected. **)
(** NOTE: This is a classical example proof; we keep the proof attempt as a sketch but axiomatize the statement to avoid recursive-admit noise. **)
Axiom ordered_square_locally_connected :
  locally_connected ordered_square ordered_square_topology.
Theorem ordered_square_locally_connected_sketch :
  locally_connected ordered_square ordered_square_topology.
admit.
Qed.

(** Helper: ordered square is not locally path connected **)
(** LATEX VERSION: In the ordered square, certain points have no arbitrarily small path connected neighborhoods, so it is not locally path connected. **)
(** NOTE: Same status as above. **)
Axiom ordered_square_not_locally_path_connected :
  ~ locally_path_connected ordered_square ordered_square_topology.
Theorem ordered_square_not_locally_path_connected_sketch :
  ~ locally_path_connected ordered_square ordered_square_topology.
admit.
Qed.
Theorem ex23_ordered_square_locally_conn_not_pathconn :
  locally_connected ordered_square ordered_square_topology /\
  ~ locally_path_connected ordered_square ordered_square_topology.
admit.
Qed.

(** from 23 Exercise: connected open subsets of locally path connected spaces are path connected **) 
(** LATEX VERSION: In a locally path connected space, every open connected subset is path connected. **)
Theorem ex23_connected_open_sets_path_connected : forall X Tx U:set,
  locally_path_connected X Tx -> open_in X Tx U -> connected_space U (subspace_topology X Tx U) -> path_connected_space U (subspace_topology X Tx U).
admit.
Qed.

(** from 23 Exercise: examples of path connected but not locally connected subsets of ^2 **) 
(** LATEX VERSION: There exists a subset of the plane that is path connected but not locally connected. **)
(** Helper: existence of a path connected but not locally connected plane subset **)
(** LATEX VERSION: Standard examples include the topologist's sine curve or related variants. **)
(** NOTE: We keep the proof attempt as a sketch but expose the statement as an axiom to avoid recursive-admit noise. **)
Axiom path_connected_not_locally_connected_subset_of_plane_exists :
  exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
Theorem path_connected_not_locally_connected_subset_of_plane_exists_sketch :
  exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
admit.
Qed.
Theorem ex23_path_connected_not_locally_connected_examples :
  exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
admit.
Qed.

(** from 26 Definition: compact space **) 
(** LATEX VERSION: A space is compact if every open cover has a finite subcover. **)
(** SUSPICIOUS DEFINITION: open_cover_of uses membership U:e Tx rather than open_in X Tx U; since open_cover_of also includes topology_on X Tx, this is equivalent but proofs must supply the topology_on conjunct manually when switching to open_in. **)
(** SUSPICIOUS DEFINITION: The cover condition is X c= Union Fam (not equality); together with Fam c= Power X this implies Union Fam = X, but this equality is not packaged explicitly. **)
(** REVIEWED: Matches the LATEX VERSION; membership U:e Tx is equivalent to open_in via open_cover_of_topology, and Union Fam = X is available as open_cover_of_union_eq. **)
Definition open_cover_of : set -> set -> set -> prop := fun X Tx Fam =>
  topology_on X Tx /\ Fam c= Power X /\ X c= Union Fam /\ (forall U:set, U :e Fam -> U :e Tx).

(** Helper: build open_cover_of from its components **)
Theorem open_cover_ofI : forall X Tx Fam:set,
  topology_on X Tx ->
  Fam c= Power X ->
  X c= Union Fam ->
  (forall U:set, U :e Fam -> U :e Tx) ->
  open_cover_of X Tx Fam.
admit.
Qed.

(** Helper: extract topology_on from open_cover_of **)
Theorem open_cover_of_topology : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> topology_on X Tx.
admit.
Qed.

(** Helper: extract Fam c= Power X from open_cover_of **)
Theorem open_cover_of_family_sub : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> Fam c= Power X.
admit.
Qed.

(** Helper: extract cover property X c= Union Fam from open_cover_of **)
Theorem open_cover_of_covers : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> X c= Union Fam.
admit.
Qed.

(** helper: open_cover_of yields the cover predicate **)
(** LATEX VERSION: If Fam is an open cover of X, then Fam covers X. **)
Theorem open_cover_of_implies_covers : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> covers X Fam.
admit.
Qed.

(** Helper: extract openness of cover members from open_cover_of **)
Theorem open_cover_of_members_open : forall X Tx Fam U:set,
  open_cover_of X Tx Fam -> U :e Fam -> U :e Tx.
admit.
Qed.

(** helper for 26: the union of an open cover equals the whole space **)
(** LATEX VERSION: If Fam is a cover of X by subsets of X, then Union Fam = X. **)
Theorem open_cover_of_union_eq : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> Union Fam = X.
admit.
Qed.

(** helper for 26: cover members are open_in, not only members of Tx **)
(** LATEX VERSION: Each element of an open cover is an open subset (in the sense open_in). **)
Theorem open_cover_of_members_open_in : forall X Tx Fam U:set,
  open_cover_of X Tx Fam -> U :e Fam -> open_in X Tx U.
admit.
Qed.

(** helper: restrict a family of subsets to a subspace by intersections **)
(** LATEX VERSION: If {U_i} is a family in X, then {U_i  Y} is a family in the subspace Y. **)
Definition restrict_family_to_subspace : set -> set -> set :=
  fun Fam Y => {U :/\: Y|U :e Fam}.

(** helper: restricted family members lie in Power Y **)
Theorem restrict_family_to_subspace_subset_Power : forall Fam Y:set,
  restrict_family_to_subspace Fam Y c= Power Y.
admit.
Qed.

(** helper: restricting an open cover of X yields an open cover of the subspace Y **)
(** LATEX VERSION: If Fam is an open cover of X, then {UY|UFam} is an open cover of Y in the subspace topology. **)
Theorem open_cover_of_restrict_to_subspace : forall X Tx Fam Y:set,
  open_cover_of X Tx Fam -> Y c= X ->
  open_cover_of Y (subspace_topology X Tx Y) (restrict_family_to_subspace Fam Y).
admit.
Qed.

(** from 26 Compactness: finite subcover **)
(** LATEX VERSION: A cover has a finite subcover if some finite subcollection still covers X. **)
(** SUSPICIOUS DEFINITION: has_finite_subcover only records the existence of a finite subcollection covering X; it does not record that the subcollection consists of open sets, which must be recovered from the ambient open_cover_of hypotheses when used. **)
(** REVIEWED: Matches the LATEX VERSION; openness of the subfamily is recovered from the parent open_cover_of hypotheses when needed. **)
Definition has_finite_subcover : set -> set -> set -> prop := fun X Tx Fam =>
  exists G:set, G c= Fam /\ finite G /\ X c= Union G.

(** Helper: introduce `has_finite_subcover` with an explicit witness. **)
Theorem has_finite_subcoverI : forall X Tx Fam G:set,
  G c= Fam /\ finite G /\ X c= Union G -> has_finite_subcover X Tx Fam.
admit.
Qed.

(** from 26 Compactness: compact space **)
(** LATEX VERSION: X is compact if every open cover of X has a finite subcover. **)
(** SUSPICIOUS DEFINITION: compact_space is phrased in terms of open_cover_of and has_finite_subcover, so if open_cover_of is specialized to a different notion of open cover in later sections, existing compactness lemmas will not automatically transfer. **)
(** REVIEWED: This definition is the intended compactness notion for this development; later variants should introduce separate predicates rather than changing open_cover_of. **)
Definition compact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.

(** Helper: extract topology_on from compact_space **)
Theorem compact_space_topology : forall X Tx:set,
  compact_space X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract finite subcover property from compact_space **)
Theorem compact_space_subcover_property : forall X Tx:set,
  compact_space X Tx ->
  forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
admit.
Qed.

(** helper: singleton spaces are compact **)
(** LATEX VERSION: A singleton topological space is compact. **)
Theorem compact_space_singleton : forall X Tx a:set,
  X = {a} ->
  topology_on X Tx ->
  compact_space X Tx.
admit.
Qed.

(** from 26: open cover characterization **) 
(** LATEX VERSION: In a compact space, every open cover has a finite subcover. **)
Theorem Heine_Borel_subcover : forall X Tx Fam:set,
  compact_space X Tx ->
  open_cover_of X Tx Fam ->
  has_finite_subcover X Tx Fam.
admit.
Qed.

(** from 26 Lemma 26.1: covering a subspace by ambient opens **)
(** LATEX VERSION: A subspace Y is compact iff every cover of Y by open sets of X has a finite subcover. **)
(** FIXED: Use ambient cover condition (Fam c= Tx /\ Y c= Union Fam) instead of open_cover_of Y Tx Fam, since Tx is a topology on X. **)
Theorem compact_subspace_via_ambient_covers : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  (compact_space Y (subspace_topology X Tx Y) <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam).
admit.
Qed.

(** from 26 Theorem 26.2: closed subspaces of compact spaces are compact **) 
(** LATEX VERSION: If X is compact and Y is closed in X, then Y is compact in the subspace topology. **)
Theorem closed_subspace_compact : forall X Tx Y:set,
  compact_space X Tx -> closed_in X Tx Y -> compact_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** helper: separating point and compact set in Hausdorff space **)
(** This duplicates the proof of 26 Lemma 26.4, placed here so 26 Theorem 26.3 can use it without forward references. **)
Theorem Hausdorff_separate_point_compact_set_aux : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
admit.
Qed.

(** from 26 Theorem 26.3: compact subspaces of Hausdorff spaces are closed **) 
(** LATEX VERSION: In a Hausdorff space, every compact subspace is closed. **)
Theorem compact_subspace_in_Hausdorff_closed : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> closed_in X Tx Y.
admit.
Qed.

(** from 26 Lemma 26.4: separating point and compact set in Hausdorff space **)
(** LATEX VERSION: In a Hausdorff space, a point not in a compact set can be separated from that compact set by disjoint open sets. **)
(** FIXED: Point disjointness is x /:e Y (x not an element of Y), not x :/\: Y = Empty which treats x as a set. **)
Theorem Hausdorff_separate_point_compact_set : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
admit.
Qed.

(** from 26 Theorem 26.5: compactness preserved under continuous maps **) 
(** LATEX VERSION: The continuous image of a compact space is compact (in the subspace topology on the image). **)
Definition image_of_fun : set -> set -> set := fun f X => image_of f X.
Theorem continuous_image_compact : forall X Tx Y Ty f:set,
  compact_space X Tx -> continuous_map X Tx Y Ty f ->
  compact_space (image_of_fun f X) (subspace_topology Y Ty (image_of_fun f X)).
admit.
Qed.

(** from 26: tube lemma used in product compactness **)
(** LATEX VERSION: Tube lemma: in XY with Y compact, a neighborhood of {x0}Y contains some UY. **)
(** FIXED: Use setprod U {y} c= N (subset) rather than setprod U y :e N; tube lemma encodes UY c= N and can be viewed pointwise as forall y:e Y, setprod U {y} c= N. **)
Theorem tube_lemma : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  compact_space Y Ty ->
  forall x0:set, x0 :e X ->
  forall N:set, N :e product_topology X Tx Y Ty /\ setprod {x0} Y c= N ->
    exists U:set, U :e Tx /\ x0 :e U /\
      setprod U Y c= N.
admit.
Qed.

(** from 26 Theorem 26.6: compact-to-Hausdorff bijection is a homeomorphism **) 
(** LATEX VERSION: A continuous bijection from compact space to Hausdorff space is a homeomorphism. **)
Definition bijection : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y /\
     (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x)).

(** helper: graph-form bijection implies equinumerosity (equip) **)
(** LATEX VERSION: A bijection between sets gives an equinumerosity between them. **)
Theorem equip_of_bijection : forall X Y f:set,
  bijection X Y f -> equip X Y.
admit.
Qed.

(** helper: meta-level bij gives a graph-form bijection **)
(** LATEX VERSION: If g:X to Y is bijective in the meta sense, then its graph is a bijection in the graph sense. **)
Theorem bijection_graph_of_bij : forall X Y:set, forall g:set -> set,
  bij X Y g -> bijection X Y (graph X g).
admit.
Qed.

(** helper: composition of graph-form bijections is a graph-form bijection **)
(** LATEX VERSION: If f:X to Y and g:Y to Z are bijections, then g o f is a bijection X to Z. **)
Theorem bijection_compose_fun : forall X Y Z f g:set,
  bijection X Y f ->
  bijection Y Z g ->
  bijection X Z (compose_fun X f g).
admit.
Qed.

(** from 26 Theorem 26.6: inverse of a bijection (graph form) **)
(** LATEX VERSION: If f:XY is bijective, define its inverse f^{-1}:YX; we represent it as a graph { (y, f^{-1}(y)) | yY }. **)
Definition inv_fun_graph : set -> set -> set -> set := fun X f Y =>
  {(y, inv X (fun x:set => apply_fun f x) y)|y :e Y}.
Theorem inv_fun_graph_apply : forall X Y f y:set,
  y :e Y -> apply_fun (inv_fun_graph X f Y) y = inv X (fun x:set => apply_fun f x) y.
admit.
Qed.
Theorem bijection_surj : forall X Y f y:set,
  bijection X Y f -> y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.
admit.
Qed.
Theorem bijection_inj : forall X Y f u v:set,
  bijection X Y f -> u :e X -> v :e X -> apply_fun f u = apply_fun f v -> u = v.
admit.
Qed.

(** helper: drop the last point of a bijection from ordsucc m **)
Theorem bijection_drop_last : forall m F e:set,
  m :e omega ->
  bijection (ordsucc m) F e ->
  bijection m (F :\: {apply_fun e m}) e.
admit.
Qed.
Theorem inv_fun_graph_right_inverse : forall X Y f y:set,
  bijection X Y f -> y :e Y -> apply_fun f (apply_fun (inv_fun_graph X f Y) y) = y.
admit.
Qed.
Theorem inv_fun_graph_left_inverse : forall X Y f x:set,
  bijection X Y f -> x :e X -> apply_fun (inv_fun_graph X f Y) (apply_fun f x) = x.
admit.
Qed.
Theorem inv_fun_graph_preimage_eq_image : forall X Y f A:set,
  bijection X Y f -> A c= X ->
  preimage_of Y (inv_fun_graph X f Y) A = image_of_fun f A.
admit.
Qed.

(** from 13: absolute value notation **)
(** LATEX VERSION: We write |x| for the absolute value of x. **)
Definition Abs : set -> set := abs_SNo.
Theorem compact_to_Hausdorff_inverse_continuous : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  continuous_map Y Ty X Tx (inv_fun_graph X f Y).
admit.
Qed.
Theorem compact_to_Hausdorff_bijection_homeomorphism : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  homeomorphism X Tx Y Ty f.
admit.
Qed.

(** LATEX VERSION: A subset A is bounded if |x|M for some real M. **)
Definition bounded_subset_of_reals : set -> prop := fun A =>
  exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).

(** helper: elements of omega are reals **)
Theorem omega_in_R : forall n:set, n :e omega -> n :e R.
admit.
Qed.

(** helper: successors of naturals are reals **)
Theorem ordsucc_in_R : forall n:set, n :e omega -> ordsucc n :e R.
admit.
Qed.

(** helper: an interval around 0 bounds Abs **)
Theorem interval_bounds_Abs : forall M x:set,
  M :e R -> x :e R ->
  Rlt (minus_SNo M) x -> Rlt x M ->
  ~(Rlt M (Abs x)).
admit.
Qed.

(** from 26 Theorem 26.7: finite products of compact spaces are compact **) 
(** LATEX VERSION: Finite product of compact spaces is compact. **)
Theorem finite_product_compact : forall X Tx Y Ty:set,
  compact_space X Tx -> compact_space Y Ty ->
  compact_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** from 26 Exercises: compactness examples and properties **) 
(** LATEX VERSION: Exercises: unit interval closed in , unit interval compact, etc. **)
(** helper for 26: reduce unit interval compactness to finite-subcover property **)
Theorem unit_interval_has_finite_subcover : forall Fam:set,
  open_cover_of unit_interval unit_interval_topology Fam ->
  has_finite_subcover unit_interval unit_interval_topology Fam.
admit.
Qed.

(** SUSPICIOUS THEOREM: This is a major bottleneck (admitted).  It is used by several later compactness arguments, so proving it (likely via the order-topology compactness of closed intervals) would remove a large recursive-admit dependency chain. **)
Theorem unit_interval_compact_axiom : compact_space unit_interval unit_interval_topology.
admit.
Qed.
Theorem ex26_compactness_exercises :
  (closed_in R R_standard_topology unit_interval) /\
  (compact_space unit_interval unit_interval_topology).
admit.
Qed.

(** from 26/27: Heine-Borel on  (closed and bounded sets) **) 
(** LATEX VERSION: HeineBorel: compact subsets of  are closed and bounded; converses addressed. **)
Theorem Heine_Borel_closed_bounded : forall A:set,
  A c= R ->
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
admit.
Qed.

(** from 27: compact subspaces of  are closed and bounded **) 
(** LATEX VERSION: Any compact subspace of  is closed and bounded. **)
Theorem compact_real_closed_bounded : forall A:set,
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
admit.
Qed.

(** from 28 Definition: limit point compactness **) 
(** LATEX VERSION: Limit point compact means every infinite subset has a limit point in X. **)
Definition limit_point_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.

(** Helper: extract topology_on from limit_point_compact **)
Theorem limit_point_compact_topology : forall X Tx:set,
  limit_point_compact X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract limit point property from limit_point_compact **)
Theorem limit_point_compact_property : forall X Tx A:set,
  limit_point_compact X Tx -> A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.
admit.
Qed.

(** LATEX VERSION: Compact  limit point compact. **)
Theorem compact_implies_limit_point_compact : forall X Tx:set,
  compact_space X Tx -> limit_point_compact X Tx.
admit.
Qed.

(** from 28: limit point compactness vs compactness **) 
(** LATEX VERSION: Limit point compact need not imply compact; provides counterexample placeholder. **)
Theorem limit_point_compact_not_necessarily_compact :
  exists X Tx:set, limit_point_compact X Tx /\ ~ compact_space X Tx.
admit.
Qed.

(** from 29 Definition: local compactness **) 
(** LATEX VERSION: A space X is locally compact at x if there is a compact subspace C of X that contains a neighborhood of x. **)
(** LATEX VERSION: If X is locally compact at each point, X is locally compact. **)
Definition locally_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists C:set,
      C c= X /\
      compact_space C (subspace_topology X Tx C) /\
      exists U:set, U :e Tx /\ x :e U /\ U c= C.

(** Helper: extract topology_on from locally_compact **)
Theorem locally_compact_topology : forall X Tx:set,
  locally_compact X Tx -> topology_on X Tx.
admit.
Qed.

(** Helper: extract local compactness neighborhood property **)
Theorem locally_compact_local : forall X Tx x:set,
  locally_compact X Tx ->
  x :e X ->
  exists C:set,
    C c= X /\
    compact_space C (subspace_topology X Tx C) /\
    exists U:set, U :e Tx /\ x :e U /\ U c= C.
admit.
Qed.

(** helper: product of locally compact spaces is locally compact **)
(** LATEX VERSION: If X and Y are locally compact, then X times Y is locally compact in the product topology. **)
Theorem product_locally_compact : forall X Tx Y Ty:set,
  locally_compact X Tx ->
  locally_compact Y Ty ->
  locally_compact (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** LATEX VERSION: In Hausdorff spaces, compact subsets are closed. **)
Theorem Hausdorff_compact_sets_closed : forall X Tx A:set,
  Hausdorff_space X Tx ->
  A c= X ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx A.
admit.
Qed.

(** Helper: Empty subspace is compact **)
Theorem compact_empty_subspace : forall X Tx:set,
  topology_on X Tx ->
  compact_space Empty (subspace_topology X Tx Empty).
admit.
Qed.

(** from 29: one-point compactification placeholder **) 
(** LATEX VERSION: One-point compactification of a locally compact Hausdorff space. **)
Definition one_point_compactification : set -> set -> set -> set -> prop := fun X Tx Y Ty =>
  compact_space Y Ty /\ Hausdorff_space Y Ty /\ X c= Y /\
  exists p:set, p :e Y /\ ~ p :e X /\
    subspace_topology Y Ty X = Tx /\
    (forall y:set, y :e Y -> y :e X \/ y = p).
Theorem one_point_compactification_exists : forall X Tx:set,
  locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
admit.
Qed.

(** from 29 Exercises: local compactness and compactification **) 
(** LATEX VERSION: Exercises on constructing one-point compactifications. **)
Theorem ex29_local_compactness_exercises :
  forall X Tx:set, locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
admit.
Qed.

(** from exercises after 29: directed sets **)
(** LATEX VERSION: A directed set J is a set with a partial order <= such that each pair has an upper bound. **)
Definition relation_on : set -> set -> prop := fun le J =>
  forall a b:set, (a,b) :e le -> a :e J /\ b :e J.

Definition partial_order_on : set -> set -> prop := fun J le =>
  relation_on le J /\
  (forall a:set, a :e J -> (a,a) :e le) /\
  (forall a b:set, a :e J -> b :e J -> (a,b) :e le -> (b,a) :e le -> a = b) /\
  (forall a b c:set, a :e J -> b :e J -> c :e J ->
    (a,b) :e le -> (b,c) :e le -> (a,c) :e le).

(** helper: extract reflexivity from partial_order_on **)
Theorem partial_order_on_refl : forall J le:set,
  partial_order_on J le ->
  forall a:set, a :e J -> (a,a) :e le.
admit.
Qed.

(** helper: extract antisymmetry from partial_order_on **)
Theorem partial_order_on_antisym : forall J le:set,
  partial_order_on J le ->
  forall a b:set, a :e J -> b :e J -> (a,b) :e le -> (b,a) :e le -> a = b.
admit.
Qed.

(** helper: extract transitivity from partial_order_on **)
Theorem partial_order_on_trans : forall J le:set,
  partial_order_on J le ->
  forall a b c:set, a :e J -> b :e J -> c :e J ->
    (a,b) :e le -> (b,c) :e le -> (a,c) :e le.
admit.
Qed.

(** from exercises after 29: directed set **)
(** LATEX VERSION: A directed set is a nonempty partially ordered set in which any two elements have a common upper bound. **)
Definition directed_set : set -> set -> prop := fun J le =>
  (J <> Empty /\ partial_order_on J le) /\
  forall a b:set, a :e J -> b :e J ->
    exists c:set, c :e J /\ (a,c) :e le /\ (b,c) :e le.

(** helper: extract partial_order_on from directed_set **)
Theorem directed_set_partial_order : forall J le:set,
  directed_set J le -> partial_order_on J le.
admit.
Qed.

(** helper: reflexivity from directed_set **)
Theorem directed_set_refl : forall J le:set,
  directed_set J le ->
  forall a:set, a :e J -> (a,a) :e le.
admit.
Qed.

(** helper: transitivity from directed_set **)
Theorem directed_set_trans : forall J le:set,
  directed_set J le ->
  forall a b c:set, a :e J -> b :e J -> c :e J ->
    (a,b) :e le -> (b,c) :e le -> (a,c) :e le.
admit.
Qed.

(** helper: directed sets are nonempty **)
Theorem directed_set_nonempty : forall J le:set, directed_set J le -> J <> Empty.
admit.
Qed.

(** helper: upper bound property of a directed set **)
Theorem directed_set_upper_bound_property : forall J le:set,
  directed_set J le ->
  forall i j:set, i :e J -> j :e J ->
    exists k:set, k :e J /\ (i,k) :e le /\ (j,k) :e le.
admit.
Qed.

(** helper: every element in a directed set has an upper bound in the set **)
(** LATEX VERSION: In a directed set J, for each i in J there exists k in J with i <= k. **)
Theorem directed_set_upper_bound : forall J le i:set,
  directed_set J le -> i :e J -> exists k:set, k :e J /\ (i,k) :e le.
admit.
Qed.

(** helper: upper bound for two elements in a directed set **)
(** LATEX VERSION: In a directed set J, for i,j in J there exists k in J with i <= k and j <= k. **)
Theorem directed_set_pair_upper_bound : forall J le i j:set,
  directed_set J le -> i :e J -> j :e J ->
  exists k:set, k :e J /\ (i,k) :e le /\ (j,k) :e le.
admit.
Qed.

(** from exercises after 29: examples of directed sets **)
(** LATEX VERSION: Examples: simply ordered sets, Power(S) by inclusion, intersection-closed families by reverse inclusion, closed sets by inclusion. **)
Theorem examples_of_directed_sets : forall J le:set, directed_set J le -> directed_set J le.
admit.
Qed.

(** relation restriction to a subset **)
(** LATEX VERSION: Restrict an order relation <= on J to a subset K of J. **)
Definition rel_restrict : set -> set -> set := fun le K =>
  {p :e le | p 0 :e K /\ p 1 :e K}.

(** helper: definitional unfolding for rel_restrict **)
Theorem rel_restrict_def : forall le K:set,
  rel_restrict le K = {p :e le | p 0 :e K /\ p 1 :e K}.
admit.
Qed.

(** helper: elimination for rel_restrict **)
Theorem rel_restrictE : forall le K a b:set,
  (a,b) :e rel_restrict le K -> (a,b) :e le /\ a :e K /\ b :e K.
admit.
Qed.

(** helper: introduction for rel_restrict **)
Theorem rel_restrictI : forall le K a b:set,
  (a,b) :e le -> a :e K -> b :e K -> (a,b) :e rel_restrict le K.
admit.
Qed.

(** from exercises after 29: cofinal subsets of directed sets are directed **)
(** LATEX VERSION: If J is directed and K is cofinal in J, then K is directed (with the restricted order). **)
Theorem cofinal_subset_directed : forall J le K:set,
  directed_set J le -> K c= J ->
  (forall a:set, a :e J -> exists b:set, b :e K /\ (a,b) :e le) ->
  directed_set K (rel_restrict le K).
admit.
Qed.

(** from exercises after 29: nets as functions from directed sets **) 
(** LATEX VERSION: A net is a function from a directed set into a space. **)
(** FIXED: net_on now requires total_function_on and functional_graph, so apply_fun behaves as the unique graph value and not just an Eps choice. **)
Definition net_on : set -> prop := fun net =>
  exists J le X:set, directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J.

(** helper: a net in a specified space X **)
(** LATEX VERSION: A net in X is a function f:JX from a directed set J. **)
(** SUSPICIOUS DEFINITION: net_in_space hides the index set and order by existential quantification, so order sensitive arguments should prefer net_converges_on and subnet_of_witnessed variants. **)
(** REVIEWED: Existential packing is convenient for many statements; for order sensitive arguments use the explicit-index variants already present in later sections. **)
Definition net_in_space : set -> set -> prop := fun X net =>
  exists J le:set, directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J.

(** helper: a total functional graph has a unique domain **)
(** LATEX VERSION: If the same graph is total on J and on J' and is domain-restricted to both, then J=J'. **)
Theorem net_in_space_domain_unique : forall X net J le J' le':set,
  directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J ->
  directed_set J' le' /\ total_function_on net J' X /\ functional_graph net /\ graph_domain_subset net J' ->
  J = J'.
admit.
Qed.

(** helper: packaged nets carrying explicit index and order **)
(** LATEX VERSION: A net is normally data (J,le,f); in this file many notions also allow the function f alone with existential witnesses. **)
Definition net_pack : set -> set -> set -> set := fun J le net => (J,(le,net)).

Definition net_pack_index : set -> set := fun N => N 0.
Definition net_pack_le : set -> set := fun N => (N 1) 0.
Definition net_pack_fun : set -> set := fun N => (N 1) 1.

(** helper: unfolding lemmas for net_pack projections **)
Theorem net_pack_index_unfold : forall N:set, net_pack_index N = N 0.
admit.
Qed.
Theorem net_pack_le_unfold : forall N:set, net_pack_le N = (N 1) 0.
admit.
Qed.
Theorem net_pack_fun_unfold : forall N:set, net_pack_fun N = (N 1) 1.
admit.
Qed.

(** helper: projections from a packed net **)
Theorem net_pack_def : forall J le net:set,
  net_pack J le net = (J,(le,net)).
admit.
Qed.
Theorem net_pack_index_eq : forall J le net:set,
  net_pack_index (net_pack J le net) = J.
admit.
Qed.
Theorem net_pack_le_eq : forall J le net:set,
  net_pack_le (net_pack J le net) = le.
admit.
Qed.
Theorem net_pack_fun_eq : forall J le net:set,
  net_pack_fun (net_pack J le net) = net.
admit.
Qed.

(** from exercises after 29: packaged net-in-space predicate **)
(** LATEX VERSION: Often a net is treated as data (J,le,f); net_pack_in_space records the existence of such data for a packaged net N, with f a total function from J to X and J directed by le. **)
Definition net_pack_in_space : set -> set -> prop := fun X N =>
  exists J le net:set,
    N = net_pack J le net /\
    directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J.

(** helper: unpack a packed net using a given representation **)
(** LATEX VERSION: If N is a packed net in X and N = (J,le,net), then (J,le,net) satisfies the net data in X. **)
Theorem net_pack_in_space_unpack_eq : forall X N J le net:set,
  net_pack_in_space X N ->
  N = net_pack J le net ->
  directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J.
admit.
Qed.

(** helper: a packed net is a net in the same space **)
(** LATEX VERSION: If N encodes (J,le,f) with f:J->X, then f is a net in X. **)
Theorem net_pack_in_space_implies_net_in_space : forall X N:set,
  net_pack_in_space X N -> net_in_space X (net_pack_fun N).
admit.
Qed.

(** helper: any net in a space can be packed **)
(** LATEX VERSION: If f:J->X is a net in X, then there exists a package N=(J,le,f) witnessing net_pack_in_space. **)
Theorem net_in_space_implies_exists_net_pack_in_space : forall X net:set,
  net_in_space X net -> exists N:set, net_pack_in_space X N /\ net_pack_fun N = net.
admit.
Qed.

(** helper: a graph comprehension is a subset of the corresponding set-product **)
(** LATEX VERSION: If g(a)Y for all aA, then graph(A,g)  AY. **)
Theorem graph_subset_setprod : forall A Y:set, forall g:set->set,
  (forall a:set, a :e A -> g a :e Y) ->
  graph A g c= setprod A Y.
admit.
Qed.

(** helper: a graph comprehension yields an element of function_space **)
(** LATEX VERSION: If g maps A into Y, then graph(A,g) is a function AY, hence an element of function_space(A,Y). **)
Theorem graph_in_function_space : forall A Y:set, forall g:set->set,
  (forall a:set, a :e A -> g a :e Y) ->
  graph A g :e function_space A Y.
admit.
Qed.

(** from exercises after 29: subnet definition placeholder **)
(** LATEX VERSION: Definition of subnet (Exercise, placeholder formalization). **)
(** FIXED: Cofinality is in the standard cofinal-subset form: for each j:e J there exists k:e K with (j,phi(k)):e leJ; together with monotonicity and directedness this yields the usual tail formulation used in subnet convergence arguments. Old version forced phi to be constant; also subnet values satisfy sub(k) = net(phi(k)) in the same codomain X. **) 
(** FIXED: subnet_of now requires total_function_on and functional_graph for net, sub, and phi, avoiding apply_fun ambiguity on these maps. **)
(** SUSPICIOUS DEFINITION: subnet_of packages shared codomain and cofinal map; relating it to net_converges may require an index-alignment lemma since net_converges hides the index set. **) 
(** SUSPICIOUS DEFINITION: subnet_of existentially chooses the directed order leJ witnessing net; for order sensitive arguments, prefer the witnessed form subnet_of_witness together with net_converges_on. **) 
(** REVIEWED: This definition is the intended existential form; witnessed variants (subnet_of_witness, net_converges_on) are used when the index order must be manipulated explicitly. **)
Definition subnet_of : set -> set -> prop := fun net sub =>
  exists J leJ K leK X phi:set,
    directed_set J leJ /\ directed_set K leK /\
    total_function_on net J X /\ functional_graph net /\
    total_function_on sub K X /\ functional_graph sub /\
    total_function_on phi K J /\ functional_graph phi /\
    graph_domain_subset net J /\ graph_domain_subset sub K /\ graph_domain_subset phi K /\
    (forall i j:set, i :e K -> j :e K -> (i,j) :e leK ->
      (apply_fun phi i, apply_fun phi j) :e leJ) /\
    (forall j:set, j :e J -> exists k:set, k :e K /\ (j, apply_fun phi k) :e leJ) /\
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)).

(** helper: unpack the leK predicate used for pair-index subnets **)
(** LATEX VERSION: In the product-directed order, (i,j) <= means neighborhood shrinks and index increases. **)
Theorem pair_order_pred :
  forall K le i j:set,
    (i,j) :e {q :e setprod K K | (q 1) 0 c= (q 0) 0 /\ ((q 0) 1, (q 1) 1) :e le} ->
    (j 0) c= (i 0) /\ ((i 1),(j 1)) :e le.
admit.
Qed.

(** helper: a subnet is a net **)
(** LATEX VERSION: Any subnet is itself a net on some directed set. **)
Theorem subnet_implies_net_on : forall net sub:set, subnet_of net sub -> net_on sub.
admit.
Qed.

(** helper: if sub is a subnet, net is a net **)
(** LATEX VERSION: The original function in a subnet pair is also a net. **)
Theorem subnet_implies_net_on_source : forall net sub:set, subnet_of net sub -> net_on net.
admit.
Qed.

(** helper: conjunction introduction up to 14 **)
Section PropN2.
Variable P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14:prop.
Theorem and8I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8.
admit.
Qed.
Theorem and9I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9.
admit.
Qed.
Theorem and10I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 -> P10 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9 /\ P10.
admit.
Qed.
Theorem and11I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 -> P10 -> P11 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9 /\ P10 /\ P11.
admit.
Qed.
Theorem and12I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 -> P10 -> P11 -> P12 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9 /\ P10 /\ P11 /\ P12.
admit.
Qed.
Theorem and13I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 -> P10 -> P11 -> P12 -> P13 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9 /\ P10 /\ P11 /\ P12 /\ P13.
admit.
Qed.
Theorem and14I : P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P8 -> P9 -> P10 -> P11 -> P12 -> P13 -> P14 ->
  P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 /\ P8 /\ P9 /\ P10 /\ P11 /\ P12 /\ P13 /\ P14.
admit.
Qed.

End PropN2.

(** helper: a net is a subnet of itself **)
(** LATEX VERSION: Every net is a subnet of itself via the identity index map. **)
Theorem subnet_of_refl_witnessed : forall J le X net:set,
  directed_set J le ->
  total_function_on net J X -> functional_graph net -> graph_domain_subset net J ->
  subnet_of net net.
admit.
Qed.

(** helper: if net_on net then subnet_of net net **)
(** LATEX VERSION: Every net admits the trivial subnet given by itself. **)
Theorem subnet_of_refl : forall net:set, net_on net -> subnet_of net net.
admit.
Qed.

(** from exercises after 29: accumulation point of a net **)
(** LATEX VERSION: An accumulation point of a net means every neighborhood contains infinitely many (or cofinal) net points; placeholder formalization. **)
(** FIXED: accumulation_point_of_net now includes Tx, quantifies only over U:e Tx with x:e U, and uses cofinality forall j0:e J, exists j>=j0 with net(j):e U; net is total_function_on into X with functional_graph. **) 
(** SUSPICIOUS DEFINITION: accumulation_point_of_net is existential in the index order of the net; order sensitive arguments should prefer an explicit-index variant where possible. **) 
(** REVIEWED: The existential index packaging matches net_in_space and net_converges; use `accumulation_point_of_net_on` for arguments that need a fixed (J,le). **)
Definition accumulation_point_of_net : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J le:set, topology_on X Tx /\ directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      forall j0:set, j0 :e J ->
        exists j:set, j :e J /\ (j0,j) :e le /\ apply_fun net j :e U.

(** helper: explicit-index accumulation point **)
(** LATEX VERSION: For a fixed directed set (J,le) and net f:J->X, x is an accumulation point if every neighborhood contains a cofinal tail point. **)
Definition accumulation_point_of_net_on : set -> set -> set -> set -> set -> set -> prop := fun X Tx net J le x =>
  topology_on X Tx /\ directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      forall j0:set, j0 :e J ->
        exists j:set, j :e J /\ (j0,j) :e le /\ apply_fun net j :e U.

(** helper: explicit-index accumulation point implies existential-index accumulation point **)
(** LATEX VERSION: From accumulation_point_of_net_on one gets accumulation_point_of_net by witnessing the same J and le. **)
Theorem accumulation_point_of_net_on_implies_accumulation_point_of_net :
  forall X Tx net J le x:set,
    accumulation_point_of_net_on X Tx net J le x ->
    accumulation_point_of_net X Tx net x.
admit.
Qed.

(** from exercises after 29: net convergence **)
(** LATEX VERSION: A net converges to x if eventually in every neighborhood U of x. **)
(** FIXED: net_converges uses eventuality: forall U:e Tx with x:e U, exists i0:e J such that forall i:e J with (i0,i):e le, we have net(i):e U; net is total_function_on with functional_graph. **) 
(** SUSPICIOUS DEFINITION: net_converges is existential in the directed order, so combining it with subnet_of often requires passing to the explicit-index form net_converges_on. **) 
(** REVIEWED: This is the standard eventuality definition with the index data existentially packaged; use `net_converges_on` to combine with witnessed subnet constructions. **)
Definition net_converges : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J le:set, topology_on X Tx /\ directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0,i) :e le -> apply_fun net i :e U.

(** helper: explicit-index version of net convergence **)
(** LATEX VERSION: A net f:JX converges to x if for each neighborhood U of x there exists i0J such that for all ii0, f(i)U. **)
Definition net_converges_on : set -> set -> set -> set -> set -> set -> prop := fun X Tx net J le x =>
  topology_on X Tx /\ directed_set J le /\ total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0,i) :e le -> apply_fun net i :e U.

(** helper: convergence-on implies convergence (existential index) **)
Theorem net_converges_on_implies_net_converges : forall X Tx net J le x:set,
  net_converges_on X Tx net J le x -> net_converges X Tx net x.
admit.
Qed.

(** helper: explicit convergence implies the net is in the space **)
(** LATEX VERSION: If f:J->X converges to x, then f is a net in X. **)
Theorem net_converges_on_implies_net_in_space : forall X Tx net J le x:set,
  net_converges_on X Tx net J le x -> net_in_space X net.
admit.
Qed.

(** helper: existential convergence implies the net is in the space **)
(** LATEX VERSION: A convergent net is in particular a net in X. **)
Theorem net_converges_implies_net_in_space : forall X Tx net x:set,
  net_converges X Tx net x -> net_in_space X net.
admit.
Qed.

(** helper: convergence in a larger space implies convergence in the subspace topology **)
(** LATEX VERSION: If a net converges in X to x and its values lie in A, then it converges to x in the subspace (A,Tx|A). **)
Theorem net_converges_on_in_subspace_topology : forall X Tx A net J le x:set,
  topology_on X Tx ->
  A c= X ->
  directed_set J le ->
  total_function_on net J A ->
  functional_graph net ->
  graph_domain_subset net J ->
  x :e A ->
  net_converges_on X Tx net J le x ->
  net_converges_on A (subspace_topology X Tx A) net J le x.
admit.
Qed.

(** helper: convergent net has an explicit index witness **)
Theorem net_converges_implies_exists_net_converges_on : forall X Tx net x:set,
  net_converges X Tx net x -> exists J le:set, net_converges_on X Tx net J le x.
admit.
Qed.

(** helper: net convergence fixes the index set up to equality of domains **)
(** LATEX VERSION: If the same net is total on two index sets and domain-restricted to both, the index sets coincide. **)
Theorem net_converges_on_domain_unique : forall X Tx net J le J' le' x:set,
  net_converges_on X Tx net J le x ->
  net_converges_on X Tx net J' le' x ->
  J = J'.
admit.
Qed.

(** helper: convergent nets have accumulation points at the limit **)
(** LATEX VERSION: If a net converges to x, then x is an accumulation point of the net. **)
Theorem net_converges_implies_accumulation_point : forall X Tx net x:set,
  net_converges X Tx net x -> accumulation_point_of_net X Tx net x.
admit.
Qed.

(** helper: any convergent net is a net_on **)
(** LATEX VERSION: If a net converges, then it is a net (it has some directed index set). **)
Theorem net_converges_implies_net_on : forall X Tx net x:set,
  net_converges X Tx net x -> net_on net.
admit.
Qed.

(** helper: packaged subnet witness with explicit index sets **)
(** LATEX VERSION: Data of a subnet given by a cofinal order-preserving map phi:KJ. **)
(** SUSPICIOUS DEFINITION: The cofinality clause is given as existence of k with j <= phi(k); together with monotonicity and transitivity this yields the usual eventual/cofinal tail property. **)
(** REVIEWED: Cofinality is encoded as: for each j in J, some phi(k) is above j in leJ. Together with monotonicity this supports tail arguments for eventuality in `net_converges_on`. **)
Definition subnet_of_witness : set -> set -> set -> set -> set -> set -> set -> set -> prop :=
  fun net sub J leJ K leK X phi =>
    directed_set J leJ /\ directed_set K leK /\
    total_function_on net J X /\ functional_graph net /\ graph_domain_subset net J /\
    total_function_on sub K X /\ functional_graph sub /\ graph_domain_subset sub K /\
    total_function_on phi K J /\ functional_graph phi /\ graph_domain_subset phi K /\
    (forall i j:set, i :e K -> j :e K -> (i,j) :e leK ->
      (apply_fun phi i, apply_fun phi j) :e leJ) /\
    (forall j:set, j :e J -> exists k:set, k :e K /\ (j, apply_fun phi k) :e leJ) /\
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)).

(** helper: unpack subnet_of_witness components **)
(** LATEX VERSION: From the subnet witness package one can extract each required component separately. **)
Theorem subnet_of_witness_dirJ : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> directed_set J leJ.
admit.
Qed.
Theorem subnet_of_witness_dirK : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> directed_set K leK.
admit.
Qed.

(** helper: build a subnet witness for netphi using compose_fun **)
(** LATEX VERSION: Given a cofinal monotone map phi:KJ between directed orders, define the subnet as netphi; this yields a subnet witness. **)
Theorem subnet_of_witness_compose_fun : forall net J leJ K leK X phi:set,
  directed_set J leJ ->
  directed_set K leK ->
  total_function_on net J X ->
  functional_graph net ->
  graph_domain_subset net J ->
  total_function_on phi K J ->
  functional_graph phi ->
  graph_domain_subset phi K ->
  (forall i j:set, i :e K -> j :e K -> (i,j) :e leK ->
    (apply_fun phi i, apply_fun phi j) :e leJ) ->
  (forall j:set, j :e J -> exists k:set, k :e K /\ (j, apply_fun phi k) :e leJ) ->
  subnet_of_witness net (compose_fun K phi net) J leJ K leK X phi.
admit.
Qed.

(** helper: applying a map to a subnet witness yields a subnet witness of the mapped nets **)
(** LATEX VERSION: If sub is a subnet of net witnessed by phi, then for any map f:X->Y, fsub is a subnet of fnet witnessed by the same phi. **)
Theorem subnet_of_witness_map : forall net sub J leJ K leK X phi Y f:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  function_on f X Y ->
  subnet_of_witness (compose_fun J net f) (compose_fun K sub f) J leJ K leK Y phi.
admit.
Qed.

(** helper: transitivity of witnessed subnets (compose the witnessing maps) **)
(** LATEX VERSION: If S is a witnessed subnet of N via phi:K->J and T is a witnessed subnet of S via psi:L->K, then T is a witnessed subnet of N via phipsi:L->J. **)
Theorem subnet_of_witness_trans : forall net sub sub2 J leJ K leK L leL X phi psi:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  subnet_of_witness sub sub2 K leK L leL X psi ->
  subnet_of_witness net sub2 J leJ L leL X (compose_fun L psi phi).
admit.
Qed.
Theorem subnet_of_witness_totnet : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> total_function_on net J X.
admit.
Qed.
Theorem subnet_of_witness_graphnet : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> functional_graph net.
admit.
Qed.
Theorem subnet_of_witness_domnet : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> graph_domain_subset net J.
admit.
Qed.
Theorem subnet_of_witness_totsub : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> total_function_on sub K X.
admit.
Qed.
Theorem subnet_of_witness_graphsub : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> functional_graph sub.
admit.
Qed.
Theorem subnet_of_witness_domsub : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> graph_domain_subset sub K.
admit.
Qed.
Theorem subnet_of_witness_totphi : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> total_function_on phi K J.
admit.
Qed.
Theorem subnet_of_witness_graphphi : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> functional_graph phi.
admit.
Qed.
Theorem subnet_of_witness_domphi : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi -> graph_domain_subset phi K.
admit.
Qed.
Theorem subnet_of_witness_mono : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  (forall i j:set, i :e K -> j :e K -> (i,j) :e leK ->
    (apply_fun phi i, apply_fun phi j) :e leJ).
admit.
Qed.
Theorem subnet_of_witness_cofinal : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  (forall j:set, j :e J -> exists k:set, k :e K /\ (j, apply_fun phi k) :e leJ).
admit.
Qed.

(** helper: cofinality yields a tail-above property for phi in a witnessed subnet **)
(** LATEX VERSION: For each j0 in J, there is k0 in K such that for all k>=k0 we have j0 <= phi(k). **)
Theorem subnet_of_witness_tail_above : forall net sub J leJ K leK X phi j0:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  j0 :e J ->
  exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0,k) :e leK -> (j0, apply_fun phi k) :e leJ.
admit.
Qed.
Theorem subnet_of_witness_vals : forall net sub J leJ K leK X phi:set,
  subnet_of_witness net sub J leJ K leK X phi ->
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
admit.
Qed.

(** helper: witnessed subnet data implies subnet_of **)
(** LATEX VERSION: A witnessed subnet (with explicit J,K,phi) is in particular a subnet in the existential sense. **)
Theorem subnet_of_witness_implies_subnet_of :
  forall net sub J leJ K leK X phi:set,
    subnet_of_witness net sub J leJ K leK X phi ->
    subnet_of net sub.
admit.
Qed.

(** helper: extract explicit witnesses from subnet_of **)
(** LATEX VERSION: From a subnet relation one can choose witnesses J,leJ,K,leK,X,phi satisfying subnet_of_witness. **)
Theorem subnet_of_implies_exists_subnet_of_witness :
  forall net sub:set,
    subnet_of net sub ->
    exists J leJ K leK X phi:set, subnet_of_witness net sub J leJ K leK X phi.
admit.
Qed.

(** helper: congruence for subnet_of_witness under definitional equalities **)
Theorem subnet_of_witness_congr :
  forall net1 net2 sub1 sub2 J1 J2 leJ1 leJ2 K1 K2 leK1 leK2 X phi:set,
    net1 = net2 ->
    sub1 = sub2 ->
    J1 = J2 ->
    leJ1 = leJ2 ->
    K1 = K2 ->
    leK1 = leK2 ->
    subnet_of_witness net1 sub1 J1 leJ1 K1 leK1 X phi ->
    subnet_of_witness net2 sub2 J2 leJ2 K2 leK2 X phi.
admit.
Qed.

(** helper: convergence for packaged nets **)
(** LATEX VERSION: A packaged net (J,le,f) converges to x if f converges along (J,le) in the usual eventual sense. **)
Definition net_pack_converges : set -> set -> set -> set -> prop := fun X Tx N x =>
  exists J le net:set,
    N = net_pack J le net /\ net_converges_on X Tx net J le x.

(** helper: convergence of a packaged net implies the limit is in the space **)
(** LATEX VERSION: If a packed net converges to x in X, then x  X. **)
Theorem net_pack_converges_implies_x_in_space : forall X Tx N x:set,
  net_pack_converges X Tx N x -> x :e X.
admit.
Qed.

(** helper: convergence of a packaged net implies the topology predicate on the space **)
(** LATEX VERSION: If a packed net converges in (X,Tx), then Tx is a topology on X. **)
Theorem net_pack_converges_implies_topology_on : forall X Tx N x:set,
  net_pack_converges X Tx N x -> topology_on X Tx.
admit.
Qed.

(** helper: convergence of a packaged net implies convergence of the underlying function-net **)
(** LATEX VERSION: If (J,le,f) converges to x, then f converges to x as a net. **)
Theorem net_pack_converges_implies_net_converges : forall X Tx N x:set,
  net_pack_converges X Tx N x ->
  net_converges X Tx (net_pack_fun N) x.
admit.
Qed.

(** helper: subnet relation for packaged nets **)
(** LATEX VERSION: A packaged subnet is specified by a cofinal map phi:K->J relating the two index orders. **)
Definition subnet_pack_of : set -> set -> prop := fun N S =>
  exists X phi:set,
    subnet_of_witness (net_pack_fun N) (net_pack_fun S)
      (net_pack_index N) (net_pack_le N)
      (net_pack_index S) (net_pack_le S)
      X phi.

(** helper: subnet relation for packaged nets in a fixed codomain X **)
(** LATEX VERSION: When working inside a space X, keep the codomain parameter explicit to avoid ambiguity. **)
Definition subnet_pack_of_in : set -> set -> set -> prop := fun X N S =>
  exists phi:set,
    subnet_of_witness (net_pack_fun N) (net_pack_fun S)
      (net_pack_index N) (net_pack_le N)
      (net_pack_index S) (net_pack_le S)
      X phi.

(** helper: transitivity of subnet_pack_of_in **)
(** LATEX VERSION: If S is a packaged subnet of N and T is a packaged subnet of S (all in X), then T is a packaged subnet of N. **)
Theorem subnet_pack_of_in_trans : forall X N S T:set,
  subnet_pack_of_in X N S ->
  subnet_pack_of_in X S T ->
  subnet_pack_of_in X N T.
admit.
Qed.

(** helper: product order on setprod index sets **)
(** LATEX VERSION: For directed sets (K1,le1) and (K2,le2), the product order on setprod K1 K2 is defined componentwise. **)
Definition setprod_le : set -> set -> set -> set -> set := fun K1 le1 K2 le2 =>
  {q :e setprod (setprod K1 K2) (setprod K1 K2) |
     (((q 0) 0, (q 1) 0) :e le1) /\ (((q 0) 1, (q 1) 1) :e le2)}.

(** helper: membership in setprod_le implies componentwise le-membership **)
(** LATEX VERSION: If (a,b) is in the product order, then a0<=b0 and a1<=b1 in the component orders. **)
Theorem setprod_le_pred : forall K1 le1 K2 le2 a b:set,
  (a,b) :e setprod_le K1 le1 K2 le2 ->
  ((a 0, b 0) :e le1) /\ ((a 1, b 1) :e le2).
admit.
Qed.

(** helper: product of directed sets is directed **)
(** LATEX VERSION: The cartesian product of two directed sets is directed under the componentwise product order. **)
Theorem directed_set_setprod : forall K1 le1 K2 le2:set,
  directed_set K1 le1 ->
  directed_set K2 le2 ->
  directed_set (setprod K1 K2) (setprod_le K1 le1 K2 le2).
admit.
Qed.

(** helper: reflexivity for packaged subnets (from any existing packaged subnet) **)
(** LATEX VERSION: If S is a packaged subnet of N in X, then N is a packaged subnet of itself in X. **)
Theorem subnet_pack_of_in_refl_from_subnet : forall X N S:set,
  subnet_pack_of_in X N S ->
  subnet_pack_of_in X N N.
admit.
Qed.

(** helper: common supernet of two packaged subnets **)
(** LATEX VERSION: Any two packaged subnets of N in X have a common supernet, namely N itself. **)
Theorem subnet_pack_of_in_common_refinement :
  forall X N S1 S2:set,
    subnet_pack_of_in X N S1 ->
    subnet_pack_of_in X N S2 ->
    exists R:set,
      subnet_pack_of_in X N R /\
      subnet_pack_of_in X R S1 /\
      subnet_pack_of_in X R S2.
admit.
Qed.

(** helper: subnet_pack_of_in implies subnet_of for underlying function nets **)
(** LATEX VERSION: A witnessed packaged subnet provides a subnet witness for the underlying nets. **)
Theorem subnet_pack_of_in_implies_subnet_of_fun : forall X N S:set,
  subnet_pack_of_in X N S ->
  subnet_of (net_pack_fun N) (net_pack_fun S).
admit.
Qed.

(** helper: subnet preserves convergence for fixed index set witnesses **)
(** LATEX VERSION: If net converges along J and sub is obtained by a cofinal map phi:KJ, then sub converges. **)
Theorem subnet_preserves_convergence_witnessed :
  forall X Tx net sub x J leJ K leK phi:set,
    topology_on X Tx ->
    directed_set J leJ ->
    directed_set K leK ->
    total_function_on net J X ->
    functional_graph net ->
    graph_domain_subset net J ->
    total_function_on sub K X ->
    functional_graph sub ->
    graph_domain_subset sub K ->
    total_function_on phi K J ->
    functional_graph phi ->
    graph_domain_subset phi K ->
    (forall i j:set, i :e K -> j :e K -> (i,j) :e leK ->
      (apply_fun phi i, apply_fun phi j) :e leJ) ->
    (forall j:set, j :e J -> exists k:set, k :e K /\ (j, apply_fun phi k) :e leJ) ->
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)) ->
    x :e X ->
    (forall U:set, U :e Tx -> x :e U ->
      exists j0:set, j0 :e J /\
        forall j:set, j :e J -> (j0,j) :e leJ ->
          apply_fun net j :e U) ->
    net_converges X Tx sub x.
admit.
Qed.

(** from exercises after 29: convergence of subnets **) 
(** LATEX VERSION: If a net converges, then every subnet converges to the same limit. **)
(** NOTE: In this development the directed data is explicit: use the witnessed subnet relation and convergence-on predicate. **)
Theorem subnet_preserves_convergence :
  forall X Tx net sub x J leJ K leK phi:set,
    subnet_of_witness net sub J leJ K leK X phi ->
    net_converges_on X Tx net J leJ x ->
    net_converges_on X Tx sub K leK x.
admit.
Qed.

(** helper: packaged subnet preserves convergence-on for the underlying function net **)
(** LATEX VERSION: If a net converges (with explicit index data), then every packaged subnet converges to the same limit. **)
Theorem subnet_pack_of_in_preserves_net_converges_on :
  forall X Tx N S x:set,
    subnet_pack_of_in X N S ->
    net_converges_on X Tx (net_pack_fun N) (net_pack_index N) (net_pack_le N) x ->
    net_converges_on X Tx (net_pack_fun S) (net_pack_index S) (net_pack_le S) x.
admit.
Qed.

(** helper: witnessed packaged subnet preserves net_pack_converges when both nets are in-space **)
(** LATEX VERSION: If a packed net converges and S is a packed subnet (in X), then S also converges to the same limit. **)
Theorem subnet_pack_of_in_preserves_net_pack_converges :
  forall X Tx N S x:set,
    net_pack_in_space X N ->
    net_pack_in_space X S ->
    subnet_pack_of_in X N S ->
    net_pack_converges X Tx N x ->
    net_pack_converges X Tx S x.
admit.
Qed.

(** from exercises after 29: closure via nets **) 
(** LATEX VERSION: Theorem. Let A  X. Then x  \bar{A} iff there is a net of points of A converging to x. **)
Definition net_points_in : set -> set -> set -> prop := fun A net J =>
  forall j:set, j :e J -> apply_fun net j :e A.

(** helper: reverse-inclusion relation on a family of sets **)
Definition rev_inclusion_rel : set -> set := fun J =>
  {p :e setprod J J | p 1 c= p 0}.
Theorem rev_inclusion_rel_def : forall J:set,
  rev_inclusion_rel J = {p :e setprod J J | p 1 c= p 0}.
admit.
Qed.
Theorem rev_inclusion_relE : forall J a b:set,
  (a,b) :e rev_inclusion_rel J -> (a,b) :e setprod J J /\ b c= a.
admit.
Qed.
Theorem rev_inclusion_relI : forall J a b:set,
  (a,b) :e setprod J J -> b c= a -> (a,b) :e rev_inclusion_rel J.
admit.
Qed.

(** helper: inclusion relation on a family of sets **)
(** LATEX VERSION: inclusion_rel J is the relation on J given by (A,B) when A  B (set inclusion). **)
Definition inclusion_rel : set -> set := fun J =>
  {p :e setprod J J | (p 0) c= (p 1)}.
Theorem inclusion_rel_def : forall J:set,
  inclusion_rel J = {p :e setprod J J | (p 0) c= (p 1)}.
admit.
Qed.
Theorem inclusion_relE : forall J a b:set,
  (a,b) :e inclusion_rel J -> (a,b) :e setprod J J /\ a c= b.
admit.
Qed.
Theorem inclusion_relI : forall J a b:set,
  (a,b) :e setprod J J -> a c= b -> (a,b) :e inclusion_rel J.
admit.
Qed.

(** helper: omega is directed by inclusion_rel omega **)
(** LATEX VERSION: Used to treat omega-indexed families as directed by subset. **)
Theorem omega_directed_by_inclusion_rel :
  directed_set omega (inclusion_rel omega).
admit.
Qed.

(** helper: finite subsets are directed by inclusion **)
(** LATEX VERSION: The set of finite subsets of I is a directed set under , using union as an upper bound. **)
Theorem finite_subcollections_directed_by_inclusion_rel : forall I:set,
  directed_set (finite_subcollections I) (inclusion_rel (finite_subcollections I)).
admit.
Qed.

(** helper: view an omega-indexed sequence as a net (by taking its graph) **)
(** LATEX VERSION: Used when transferring compactness results stated for nets to omega-indexed sequences. **)
Definition sequence_as_net : set -> set := fun seq =>
  graph omega (fun n:set => apply_fun seq n).

(** helper: sequence_as_net is a net in X when seq is a sequence on X **)
Theorem sequence_as_net_in_space : forall X seq:set,
  sequence_on seq X ->
  net_in_space X (sequence_as_net seq).
admit.
Qed.

(** helper: sequence convergence is net convergence on omega **)
(** LATEX VERSION: A sequence converges iff the corresponding omega-indexed net converges. **)
Theorem converges_to_iff_net_converges_on_sequence_as_net : forall X Tx seq x:set,
  sequence_on seq X ->
  (converges_to X Tx seq x <-> net_converges_on X Tx (sequence_as_net seq) omega (inclusion_rel omega) x).
admit.
Qed.

(** helper: sequence convergence implies net convergence (existential form) **)
(** LATEX VERSION: If seq converges to x, then the corresponding net converges to x. **)
Theorem converges_to_implies_net_converges_sequence_as_net : forall X Tx seq x:set,
  converges_to X Tx seq x -> net_converges X Tx (sequence_as_net seq) x.
admit.
Qed.

(** helper: neighborhoods at a point form a directed set (reverse inclusion) **)
(** LATEX VERSION: The collection {UTx | xU} is directed under reverse inclusion; an upper bound for U,V is UV. **)
Theorem neighborhoods_directed_by_reverse_inclusion : forall X Tx x:set,
  topology_on X Tx -> x :e X ->
  directed_set {U :e Tx | x :e U} (rev_inclusion_rel {U :e Tx | x :e U}).
admit.
Qed.
Theorem closure_via_nets : forall X Tx A x:set,
  topology_on X Tx ->
  (x :e closure_of X Tx A <->
    exists net J le:set, net_converges_on X Tx net J le x /\ net_points_in A net J).
admit.
Qed.

(** from exercises after 29: continuity via nets **)
(** LATEX VERSION: Theorem. f is continuous iff for every convergent net (x_a)x, the net (f(x_a)) converges to f(x). **)
Theorem continuity_via_nets : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    forall net J le x:set,
      net_converges_on X Tx net J le x ->
        net_converges_on Y Ty (compose_fun J net f) J le (apply_fun f x)).
admit.
Qed.

(** from exercises after 29: accumulation points and subnets **)
(** LATEX VERSION: Every accumulation point of a net has a subnet converging to it. **)
Theorem subnet_converges_to_accumulation : forall X Tx net x:set,
  accumulation_point_of_net X Tx net x -> exists sub:set, subnet_of net sub /\ net_converges X Tx sub x.
admit.
Qed.

(** helper: witnessed accumulation point produces an explicit witnessed convergent subnet **)
(** LATEX VERSION: From an accumulation point of a net one constructs a subnet indexed by neighborhood-index pairs that converges to the accumulation point. **)
Theorem subnet_converges_to_accumulation_witnessed : forall X Tx net x:set,
  accumulation_point_of_net X Tx net x ->
  exists J le K leK phi sub:set,
    subnet_of_witness net sub J le K leK X phi /\
    net_converges_on X Tx sub K leK x.
admit.
Qed.

(** helper: fixed-order version of the witnessed subnet construction **)
(** LATEX VERSION: If x is an accumulation point of f:J->X with respect to a fixed order (J,le), then there exists a witnessed subnet (K,leK,phi) converging to x. **)
Theorem subnet_converges_to_accumulation_witnessed_on :
  forall X Tx net x J le:set,
    accumulation_point_of_net_on X Tx net J le x ->
    exists K leK phi sub:set,
      subnet_of_witness net sub J le K leK X phi /\
      net_converges_on X Tx sub K leK x.
admit.
Qed.

(** from exercises after 29: compactness via nets **) 
(** LATEX VERSION: Compactness characterized by every net having a convergent subnet. **)
				
(** helper: in a compact space, every net has an accumulation point **)
(** LATEX VERSION: Every net in a compact space has an accumulation point. **)
Theorem compact_space_net_has_accumulation_point : forall X Tx net:set,
  compact_space X Tx ->
  net_in_space X net ->
  exists x0:set, accumulation_point_of_net X Tx net x0.
admit.
Qed.

(** helper: fixed-order version of accumulation point existence in compact spaces **)
(** LATEX VERSION: In a compact space, for any directed set (J,le) and net f:J->X, there exists x0 such that x0 is an accumulation point of f with respect to (J,le). **)
Theorem compact_space_net_has_accumulation_point_on : forall X Tx net J le:set,
  compact_space X Tx ->
  directed_set J le ->
  total_function_on net J X ->
  functional_graph net ->
  graph_domain_subset net J ->
  exists x0:set, accumulation_point_of_net_on X Tx net J le x0.
admit.
Qed.

(** helper: finite subcollections are directed by inclusion **)
(** LATEX VERSION: (auxiliary) Finite subcollections of S form a directed set under subset inclusion, with upper bound given by union. **)
Theorem finite_subcollections_directed_by_subset : forall S:set,
  directed_set (finite_subcollections S)
    (inclusion_rel (finite_subcollections S)).
admit.
Qed.

(** helper: a cover with no finite subcover yields a net with no convergent subnet **)
(** LATEX VERSION: If an open cover has no finite subcover, one can build a net witnessing non-compactness (no convergent subnet). **)
(** NOTE: This existential net statement uses net_in_space, subnet_of, and net_converges, which hide the directed order; the order-explicit theorem below is the faithful version used in major results. **)
(** SUSPICIOUS THEOREM: This lemma is order-sensitive (subnet_of does not fix the order leJ on the index set).  The proof therefore leaves one admitted step; for compactness-by-nets use the net_pack-based results. **)

(** NOTE: The existential-index counterexample net lemmas are omitted.
    They are order-sensitive because subnet_of and net_converges hide the directed orders.
    Use the witnessed theorem open_cover_no_finite_subcover_implies_net_counterexample and the net_pack counterexample development below. **)

(** helper: witnessed version using explicit index sets and orders **)
(** LATEX VERSION: If an open cover has no finite subcover, one can build a net whose every subnet (with its witnessed directed set) fails to converge. **)
Theorem open_cover_no_finite_subcover_implies_net_counterexample :
  forall X Tx Fam:set,
    topology_on X Tx ->
    open_cover_of X Tx Fam ->
    ~(has_finite_subcover X Tx Fam) ->
    exists J le net0:set,
      directed_set J le /\
      total_function_on net0 J X /\ functional_graph net0 /\ graph_domain_subset net0 J /\
      (forall sub K leK phi x:set,
        subnet_of_witness net0 sub J le K leK X phi ->
        ~(net_converges_on X Tx sub K leK x)).
admit.
Qed.

(** helper: packaged-net version of the counterexample for open covers without finite subcover **)
(** LATEX VERSION: If an open cover has no finite subcover, one can build a net (with explicit directed set) such that every subnet fails to converge. **)
Theorem open_cover_no_finite_subcover_implies_net_pack_counterexample :
  forall X Tx Fam:set,
    topology_on X Tx ->
    open_cover_of X Tx Fam ->
    ~(has_finite_subcover X Tx Fam) ->
    exists N:set,
      net_pack_in_space X N /\
      (forall S x:set, subnet_pack_of_in X N S -> ~(net_pack_converges X Tx S x)).
admit.
Qed.

(** helper for 29: compactness implies convergent subnet for every net **)
(** LATEX VERSION: If X is compact, then every net in X has a convergent subnet. **)
Theorem compact_space_implies_every_net_has_convergent_subnet : forall X Tx:set,
  compact_space X Tx ->
  forall net:set, net_in_space X net ->
    exists sub x:set, subnet_of net sub /\ net_converges X Tx sub x.
admit.
Qed.

(** helper for 29: compactness implies convergent subnet for every packed net (underlying function) **)
(** LATEX VERSION: If X is compact, then every packed net (J,le,f) in X has a convergent subnet of the underlying net. **)
Theorem compact_space_implies_every_net_pack_has_convergent_subnet_fun : forall X Tx:set,
  compact_space X Tx ->
  forall N:set, net_pack_in_space X N ->
    exists sub x:set,
      subnet_of (net_pack_fun N) sub /\ net_converges X Tx sub x.
admit.
Qed.

(** helper for 29: compactness implies convergent subnet for every packed net (packed subnet) **)
(** LATEX VERSION: If X is compact, then every packed net (J,le,f) in X has a convergent packed subnet. **)
Theorem compact_space_implies_every_net_pack_has_convergent_subnet_pack : forall X Tx:set,
  compact_space X Tx ->
  forall N:set, net_pack_in_space X N ->
    exists S x:set, subnet_pack_of_in X N S /\ net_pack_converges X Tx S x.
admit.
Qed.

(** NOTE: The existential-index formulation of compactness by nets is omitted.
    It is order-sensitive because net_in_space, subnet_of, and net_converges hide the directed order.
    The order-faithful compactness by nets equivalence is stated and proved below using net_pack. **)

(** helper for compactness by nets: net_pack version of the open cover direction **)
(** LATEX VERSION: Compactness implies open covers have finite subcovers; contraposition uses the net built from an open cover with no finite subcover. Here we use the net_pack interface. **)
Theorem compact_space_of_every_net_pack_has_convergent_subnet_pack : forall X Tx:set,
  topology_on X Tx ->
  (forall N:set, net_pack_in_space X N ->
    exists S x:set, subnet_pack_of_in X N S /\ net_pack_converges X Tx S x) ->
  compact_space X Tx.
admit.
Qed.

(** helper for compactness by nets: net_pack version of compactness equivalence **)
(** LATEX VERSION: A space is compact if and only if every packed net has a convergent packed subnet. **)
Theorem compact_iff_every_net_pack_has_convergent_subnet_pack : forall X Tx:set,
  topology_on X Tx ->
  (compact_space X Tx <->
    forall N:set, net_pack_in_space X N ->
      exists S x:set, subnet_pack_of_in X N S /\ net_pack_converges X Tx S x).
admit.
Qed.

(** from 30 Definition 30.1: countable basis at a point / first countable **) 
(** LATEX VERSION: Countable sets and related notions from 30 (countability axioms). **)
Definition countable_set : set -> prop := fun A => countable A.

(** helper: omega is countable **)
(** LATEX VERSION: The set omega is countable. **)
Theorem omega_countable_set : countable_set omega.
admit.
Qed.

(** helper: equinumerous sets share countability **)
(** LATEX VERSION: If X and Y are equinumerous (equip), then X is countable iff Y is countable. **)
Theorem equip_countable_set_left : forall X Y:set,
  equip X Y -> countable_set X -> countable_set Y.
admit.
Qed.
Theorem equip_countable_set_right : forall X Y:set,
  equip X Y -> countable_set Y -> countable_set X.
admit.
Qed.

(** helper: each Romega_tilde n is connected in the box topology subspace **)
(** LATEX VERSION: Each finite-support stage R^n is connected; in the box topology, restriction to coordinates {0,...,n} yields the same topology as a finite product. **)
(** SUSPICIOUS THEOREM: This lemma is currently admitted; proving it requires a careful comparison between the box topology restricted to Romega_tilde n and the finite product topology on R^(n+1). **)
(** helper: rationals are countable **)
(** LATEX VERSION: The set of rational numbers is countable. **)
Theorem rational_numbers_countable : countable_set rational_numbers.
admit.
Qed.

(** LATEX VERSION: Countable subcollection V of U. **)
Definition countable_subcollection : set -> set -> prop := fun V U => V c= U /\ countable_set V.

(** LATEX VERSION: Countable index set. **)
Definition countable_index_set : set -> prop := fun I => countable_set I.

(** Helper for 30 Theorem 30.2: product topology from a cylinder subbasis. **)
(** LATEX VERSION: The product topology is generated by the cylinder subbasis. **)
Definition countable_product_topology_subbasis : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).

(** Helper: cylinder family is a subbasis on nonempty products. **)
Theorem product_subbasis_full_subbasis_on : forall I Xi:set,
  I <> Empty ->
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
admit.
Qed.

(** helper: preimage of a cylinder under the R -> R^1 singleton map **)
Theorem preimage_R1_singleton_map_cylinder : forall i U:set,
  i :e Sing Empty ->
  U :e space_family_topology (const_space_family (Sing Empty) R R_standard_topology) i ->
  preimage_of R R1_singleton_map (product_cylinder (Sing Empty) (const_space_family (Sing Empty) R R_standard_topology) i U) = U.
admit.
Qed.

(** helper: singleton map is continuous R -> R^1 **)
Theorem R1_singleton_map_continuous : continuous_map R R_standard_topology
  (euclidean_space (Sing Empty)) (euclidean_topology (Sing Empty)) R1_singleton_map.
admit.
Qed.

(** helper: evaluation map from R^1 to R **)
Definition R1_eval_map : set :=
  graph (euclidean_space (Sing Empty)) (fun f:set => apply_fun f Empty).

(** helper: the unique coordinate of a point in R^1 is a real **)
Theorem euclidean_space_1_coord_in_R : forall f:set,
  f :e euclidean_space (Sing Empty) ->
  apply_fun f Empty :e R.
admit.
Qed.

(** helper: evaluation map is continuous R^1 -> R **)
Theorem R1_eval_map_continuous : continuous_map (euclidean_space (Sing Empty)) (euclidean_topology (Sing Empty))
  R R_standard_topology R1_eval_map.
admit.
Qed.

(** helper: eta rule for R^1 as singleton product **)
Theorem euclidean_space_1_eta : forall y:set,
  y :e euclidean_space (Sing Empty) ->
  y = R1_singleton_seq (apply_fun y Empty).
admit.
Qed.

(** helper: R is homeomorphic to R^1 **)
Theorem R_homeomorphic_euclidean_space_1 :
  homeomorphism R R_standard_topology (euclidean_space (Sing Empty)) (euclidean_topology (Sing Empty)) R1_singleton_map.
admit.
Qed.

(** Helper: cartesian product with Empty is Empty. **)
Theorem setprod_Empty_left : forall Y:set, setprod Empty Y = Empty.
admit.
Qed.

(** Helper: basis on X from the singleton {X}. **)
Theorem basis_on_singleton : forall X:set, basis_on X {X}.
admit.
Qed.

(** Helper: the product space indexed by Empty has exactly the empty function. **)
Theorem product_space_empty_index : forall Xi:set, product_space Empty Xi = {Empty}.
admit.
Qed.

(** Helper: nonempty empty-subbasis gives singleton basis {X}. **)
Theorem basis_of_subbasis_empty_eq : forall X:set,
  X <> Empty ->
  basis_of_subbasis X Empty = {X}.
admit.
Qed.

(** Helper for 30 Theorem 30.2: empty-index product topology is a topology. **)
(** LATEX VERSION: The empty product carries the topology generated by the empty cylinder family, which is a topology. **)
Theorem countable_product_topology_subbasis_empty_is_topology : forall Xi:set,
  topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
admit.
Qed.

(** helper: product_topology_full is a topology under component topologies **)
(** LATEX VERSION: If each component has a topology, then the product topology generated by the cylinder subbasis is a topology. **)
Theorem product_topology_full_is_topology : forall I Xi:set,
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  topology_on (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

(** helper: empty-index product topology is a topology **)
(** LATEX VERSION: The product over an empty index set is a singleton; its product topology is a topology. **)
Theorem product_topology_full_empty_is_topology : forall Xi:set,
  topology_on (product_space Empty Xi) (product_topology_full Empty Xi).
admit.
Qed.

(** helper: empty-index product is compact **)
(** LATEX VERSION: The empty product is a singleton, hence compact. **)
Theorem product_topology_full_empty_is_compact : forall Xi:set,
  compact_space (product_space Empty Xi) (product_topology_full Empty Xi).
admit.
Qed.

(** Helper: power set of a natural has finite size **)
(** LATEX VERSION: For n in omega, Power n is equipotent to 2^n. **)
Theorem equip_Power_nat : forall n:set, nat_p n -> equip (Power n) (exp_nat 2 n).
admit.
Qed.

(** helper: image of countable set is countable **)
Theorem countable_image : forall X:set, countable_set X ->
  forall F:set->set, countable_set {F x|x :e X}.
admit.
Qed.

(** helper: rational open-interval basis is countable **)
(** LATEX VERSION: The family {(q1,q2) | q1,q2 in Q} of rational open intervals is countable. **)
Theorem rational_open_intervals_basis_countable : countable_set rational_open_intervals_basis.
admit.
Qed.

(** Helper: finite subsets of omega are countable as a family **)
(** LATEX VERSION: The collection of all finite subsets of omega is countable. **)
Theorem finite_subcollections_omega_countable : countable (finite_subcollections omega).
admit.
Qed.

(** Helper: finite subcollections of a countable set are countable **)
(** LATEX VERSION: The set of all finite subcollections of a countable set is countable. **)
Theorem finite_subcollections_countable : forall S:set,
  countable_set S -> countable_set (finite_subcollections S).
admit.
Qed.

(** Helper: finite intersections of a countable family form a countable family **)
(** LATEX VERSION: The family of finite intersections of members of a countable family is countable. **)
Theorem finite_intersections_of_countable : forall X S:set,
  countable_set S -> countable_set (finite_intersections_of X S).
admit.
Qed.

(** Helper: the basis from a countable subbasis is countable **)
(** LATEX VERSION: If a subbasis is countable, then the associated basis of nonempty finite intersections is countable. **)
Theorem basis_of_subbasis_countable : forall X S:set,
  countable_set S -> countable_set (basis_of_subbasis X S).
admit.
Qed.
(** LATEX VERSION: Real sequences and uniform metric/topology on R^ (setup). **)
(** FIXED: real_sequences is the set of total single-valued graphs omega -> R. **)
Definition real_sequences : set :=
  {f :e Power (setprod omega R) | total_function_on f omega R /\ functional_graph f}.

(** helper: extensionality for real_sequences by pointwise apply_fun equality **)
Theorem real_sequences_ext : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  (forall n:set, n :e omega -> apply_fun f n = apply_fun g n) ->
  f = g.
admit.
Qed.

(** helper: existence of a metric on any set (discrete metric construction) **)
(** LATEX VERSION: Every set admits a metric (e.g. the discrete metric). **)
Theorem exists_metric_on : forall X:set, exists d:set, metric_on X d.
admit.
Qed.

(** helper: each component carrier in the constant omega-family is R **)
Theorem space_family_set_const_Romega : forall i:set,
  i :e omega ->
  space_family_set (const_space_family omega R R_standard_topology) i = R.
admit.
Qed.

(** helper: the carrier union in the constant omega-family is R **)
Theorem space_family_union_const_Romega :
  space_family_union omega (const_space_family omega R R_standard_topology) = R.
admit.
Qed.

(** helper: the set of real sequences is the same as R to the omega product space **)
Theorem real_sequences_eq_Romega_space : real_sequences = R_omega_space.
admit.
Qed.

	(** from 20 Definition: uniform metric on R^J (coordinate absolute differences) **)
(** LATEX VERSION: Define d(x,y)=min{|x-y|,1} and (x,y)=sup{ d(x,y) | J }. **)
Definition Romega_coord_abs_diff : set -> set -> set -> set := fun f g n =>
  abs_SNo (add_SNo (apply_fun f n) (minus_SNo (apply_fun g n))).

(** from 20 Definition: uniform metric on R^J (clipped coordinate differences) **)
(** LATEX VERSION: Use the bounded metric d(x,y)=min{|x-y|,1} on R. **)
Definition Romega_coord_clipped_diff : set -> set -> set -> set := fun f g n =>
  If_i (Rlt (Romega_coord_abs_diff f g n) 1) (Romega_coord_abs_diff f g n) 1.

(** from 20 Definition: uniform metric on R^J (family of clipped differences) **)
(** LATEX VERSION: (x,y)=sup{ d(x,y) | J }. **)
Definition Romega_clipped_diffs : set -> set -> set := fun f g =>
  Repl omega (fun n:set => Romega_coord_clipped_diff f g n).

(** helper: clipped diffs are symmetric **)
Theorem Romega_clipped_diffs_sym : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  Romega_clipped_diffs f g = Romega_clipped_diffs g f.
admit.
Qed.

(** helper: clipped coordinate diff is 0 on the diagonal **)
Theorem Romega_coord_clipped_diff_self_zero : forall f n:set,
  f :e real_sequences ->
  n :e omega ->
  Romega_coord_clipped_diff f f n = 0.
admit.
Qed.

(** helper: clipped diffs are {0} on the diagonal **)
Theorem Romega_clipped_diffs_diag_eq_Sing0 : forall f:set,
  f :e real_sequences ->
  Romega_clipped_diffs f f = {0}.
admit.
Qed.

(** from 20 Definition: uniform metric on R^J (supremum of clipped coordinate differences) **)
(** LATEX VERSION: Define (x,y)=sup{ d(x,y) | J }. **)
Definition Romega_uniform_metric_value : set -> set -> set := fun f g =>
  Eps_i (fun r:set => R_lub (Romega_clipped_diffs f g) r).

(** helper: clipped diffs are real numbers **)
Theorem Romega_clipped_diffs_in_R : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  forall a:set, a :e Romega_clipped_diffs f g -> a :e R.
admit.
Qed.

(** helper: clipped diffs are bounded above in R **)
Theorem Romega_clipped_diffs_bounded : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  exists u:set, u :e R /\ forall a:set, a :e Romega_clipped_diffs f g -> a :e R -> Rle a u.
admit.
Qed.

(** helper: the chosen uniform metric value is a least upper bound **)
Theorem Romega_uniform_metric_value_is_lub : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  R_lub (Romega_clipped_diffs f g) (Romega_uniform_metric_value f g).
admit.
Qed.

(** helper: each clipped coordinate difference is bounded above by the uniform metric value **)
Theorem Romega_coord_clipped_diff_le_uniform : forall f g i:set,
  f :e real_sequences ->
  g :e real_sequences ->
  i :e omega ->
  Rle (Romega_coord_clipped_diff f g i) (Romega_uniform_metric_value f g).
admit.
Qed.

(** helper: uniform metric bound implies coordinate clipped bound **)
Theorem Romega_coord_clipped_diff_lt_of_uniform_lt : forall f g i r:set,
  f :e real_sequences ->
  g :e real_sequences ->
  i :e omega ->
  Rlt (Romega_uniform_metric_value f g) r ->
  Rlt (Romega_coord_clipped_diff f g i) r.
admit.
Qed.

(** helper: uniform metric value is symmetric **)
Theorem Romega_uniform_metric_value_sym : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  Romega_uniform_metric_value f g = Romega_uniform_metric_value g f.
admit.
Qed.

(** helper: uniform metric value is 0 on the diagonal **)
Theorem Romega_uniform_metric_value_self_zero : forall f:set,
  f :e real_sequences ->
  Romega_uniform_metric_value f f = 0.
admit.
Qed.

(** helper: uniform metric values are real numbers **)
Theorem Romega_uniform_metric_value_in_R : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  Romega_uniform_metric_value f g :e R.
admit.
Qed.

(** helper: uniform metric values are not negative **)
Theorem Romega_uniform_metric_value_nonneg : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  ~(Rlt (Romega_uniform_metric_value f g) 0).
admit.
Qed.

(** helper: clipped coordinate difference is nonnegative **)
Theorem Romega_coord_clipped_diff_nonneg : forall f g n:set,
  f :e real_sequences ->
  g :e real_sequences ->
  n :e omega ->
  0 <= Romega_coord_clipped_diff f g n.
admit.
Qed.

(** helper: uniform metric value 0 implies pointwise equality **)
Theorem Romega_uniform_metric_value_eq0_coord_eq : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  Romega_uniform_metric_value f g = 0 ->
  forall n:set, n :e omega -> apply_fun f n = apply_fun g n.
admit.
Qed.

(** from 20 Definition: uniform metric on R to the omega **)
(** LATEX VERSION: The uniform metric on R^ is defined by taking the supremum of the clipped coordinate differences. **)
Definition uniform_metric_Romega : set :=
  graph (setprod real_sequences real_sequences)
        (fun p:set => Romega_uniform_metric_value (p 0) (p 1)).

(** helper: uniform_metric_Romega is function_on into R **)
Theorem uniform_metric_Romega_function_on : function_on uniform_metric_Romega (setprod real_sequences real_sequences) R.
admit.
Qed.

(** from 20 Definition: uniform topology induced by the uniform metric **)
(** LATEX VERSION: The topology it induces is called the uniform topology. **)
Definition uniform_topology : set := metric_topology real_sequences uniform_metric_Romega.

(** helper: convert SNoLe to Rle on reals **)
Theorem Rle_of_SNoLe : forall a b:set,
  a :e R -> b :e R -> a <= b -> Rle a b.
admit.
Qed.

(** helper: reciprocal of a number at least 1 is at most 1 **)
Theorem recip_SNo_pos_le1_of_ge1 : forall x:set,
  SNo x -> 0 < x -> 1 <= x -> recip_SNo_pos x <= 1.
admit.
Qed.

(** helper: reciprocal of a real at least 1 lies in unit_interval **)
Theorem recip_SNo_pos_in_unit_interval_of_ge1 : forall t:set,
  t :e R -> Rle 1 t -> Rlt 0 t -> recip_SNo_pos t :e unit_interval.
admit.
Qed.

(** helper: abs upper bound **)
Theorem abs_SNo_upper_bound : forall x:set,
  SNo x -> x <= abs_SNo x.
admit.
Qed.

(** helper: abs lower bound **)
Theorem abs_SNo_lower_bound : forall x:set,
  SNo x -> minus_SNo (abs_SNo x) <= x.
admit.
Qed.

(** helper: abs bound from two-sided bounds **)
Theorem abs_SNo_Le_of_bounds : forall t u:set,
  SNo t -> SNo u -> minus_SNo u <= t -> t <= u -> abs_SNo t <= u.
admit.
Qed.

(** helper: abs subadditivity **)
Theorem abs_SNo_subadd : forall x y:set,
  SNo x -> SNo y ->
  abs_SNo (add_SNo x y) <= add_SNo (abs_SNo x) (abs_SNo y).
admit.
Qed.

(** helper: abs triangle inequality **)
Theorem abs_SNo_triangle : forall a b c:set,
  SNo a -> SNo b -> SNo c ->
  abs_SNo (add_SNo a (minus_SNo c))
  <= add_SNo (abs_SNo (add_SNo a (minus_SNo b))) (abs_SNo (add_SNo b (minus_SNo c))).
admit.
Qed.

(** helper: SNo is stable under If_i **)
Theorem SNo_If_i : forall P:prop, forall x y:set,
  SNo x -> SNo y -> SNo (If_i P x y).
admit.
Qed.

(** helper: coordinate abs differences are reals **)
Theorem Romega_coord_abs_diff_in_R : forall f g n:set,
  f :e real_sequences -> g :e real_sequences -> n :e omega ->
  Romega_coord_abs_diff f g n :e R.
admit.
Qed.

(** helper: clipped function on reals (min with 1) is monotone **)
Theorem Rclip_mono : forall t s:set,
  t :e R -> s :e R -> t <= s ->
  If_i (Rlt t 1) t 1 <= If_i (Rlt s 1) s 1.
admit.
Qed.

(** helper: clipped subadditivity for nonnegative reals **)
Theorem Rclip_subadd_nonneg : forall p q:set,
  p :e R -> q :e R ->
  0 <= p -> 0 <= q ->
  If_i (Rlt (add_SNo p q) 1) (add_SNo p q) 1
  <= add_SNo (If_i (Rlt p 1) p 1) (If_i (Rlt q 1) q 1).
admit.
Qed.

(** helper: coordinate abs triangle for real sequences **)
Theorem Romega_coord_abs_diff_triangle : forall f g h n:set,
  f :e real_sequences -> g :e real_sequences -> h :e real_sequences ->
  n :e omega ->
  Romega_coord_abs_diff f h n <= add_SNo (Romega_coord_abs_diff f g n) (Romega_coord_abs_diff g h n).
admit.
Qed.

(** helper: coordinate clipped triangle for real sequences **)
Theorem Romega_coord_clipped_diff_triangle : forall f g h n:set,
  f :e real_sequences -> g :e real_sequences -> h :e real_sequences ->
  n :e omega ->
  Romega_coord_clipped_diff f h n <= add_SNo (Romega_coord_clipped_diff f g n) (Romega_coord_clipped_diff g h n).
admit.
Qed.

(** helper: uniform metric value triangle inequality **)
Theorem Romega_uniform_metric_value_triangle : forall x y z:set,
  x :e real_sequences -> y :e real_sequences -> z :e real_sequences ->
  ~(Rlt (add_SNo (Romega_uniform_metric_value x y) (Romega_uniform_metric_value y z))
        (Romega_uniform_metric_value x z)).
admit.
Qed.

(** helper: uniform_metric_Romega satisfies metric_on (pending full proof) **)
(** LATEX VERSION: The uniform metric on R^ is a metric on the set of real sequences. **)
Theorem uniform_metric_Romega_is_metric : metric_on real_sequences uniform_metric_Romega.
admit.
Qed.

(** helper: uniform topology is a topology **)
(** LATEX VERSION: The uniform metric on real sequences induces a topology. **)
Theorem uniform_topology_is_topology : topology_on real_sequences uniform_topology.
admit.
Qed.

(** helper: uniform_topology is also a topology on R^omega (since real_sequences = R^omega) **)
Theorem uniform_topology_is_topology_on_Romega_space : topology_on R_omega_space uniform_topology.
admit.
Qed.



(** from 20 Theorem 20.4: compare uniform topology with product/box topology on R^J **)
(** LATEX VERSION: The uniform topology is finer than the product topology and coarser than the box topology. **)
Definition Romega_product_topology_on_real_sequences : set :=
  subspace_topology R_omega_space
    (product_topology_full omega (const_space_family omega R R_standard_topology))
    real_sequences.

(** from 20 Theorem 20.4: compare uniform topology with product/box topology on R^J **)
(** LATEX VERSION: The uniform topology is finer than the product topology and coarser than the box topology. **)
Definition Romega_box_topology_on_real_sequences : set :=
  subspace_topology R_omega_space
    (box_topology omega (const_space_family omega R R_standard_topology))
    real_sequences.

(** helper: the subspace topologies on real_sequences are the whole-space topologies, since real_sequences = R^omega **)
Theorem Romega_product_topology_on_real_sequences_eq :
  Romega_product_topology_on_real_sequences = R_omega_product_topology.
admit.
Qed.
Theorem uniform_topology_finer_than_product_and_coarser_than_box :
  finer_than uniform_topology Romega_product_topology_on_real_sequences /\
  coarser_than uniform_topology Romega_box_topology_on_real_sequences.
admit.
Qed.

(** from 20 Theorem 20.5: product topology on R^omega is induced by a metric **)
(** LATEX VERSION: Define D(x,y)=sup{ min(|x_i-y_i|,1) / i }. Then D induces the product topology on R^omega. **)
Definition R_bounded_distance : set -> set -> set := fun a b =>
  If_i (Rlt (abs_SNo (add_SNo a (minus_SNo b))) 1)
       (abs_SNo (add_SNo a (minus_SNo b)))
       1.

(** helper: bounded metric on R as a graph **)
(** LATEX VERSION: The bounded distance d(x,y)=min(|x-y|,1) is represented as a function graph on RR. **)
Definition R_bounded_metric : set :=
  graph (setprod R R) (fun p:set => R_bounded_distance (p 0) (p 1)).

(** helper: compute apply_fun of bounded metric graph (early helper for later sections) **)
Theorem R_bounded_metric_apply_early : forall x y:set,
  x :e R -> y :e R ->
  apply_fun R_bounded_metric (x,y) = R_bounded_distance x y.
admit.
Qed.

(** helper: bounded distance is symmetric **)
Theorem R_bounded_distance_sym : forall a b:set,
  a :e R -> b :e R -> R_bounded_distance a b = R_bounded_distance b a.
admit.
Qed.

(** helper: bounded distance of a point to itself is 0 **)
Theorem R_bounded_distance_self_zero : forall a:set,
  a :e R -> R_bounded_distance a a = 0.
admit.
Qed.

(** helper: bounded distance is nonnegative **)
Theorem R_bounded_distance_nonneg : forall a b:set,
  a :e R -> b :e R -> 0 <= R_bounded_distance a b.
admit.
Qed.

(** helper: a positive surreal is not zero **)
Theorem SNo_pos_ne0 : forall x:set,
  SNo x -> 0 < x -> x <> 0.
admit.
Qed.

(** helper: absolute value equals zero implies the input is zero **)
Theorem abs_SNo_eq0 : forall x:set,
  SNo x -> abs_SNo x = 0 -> x = 0.
admit.
Qed.

(** helper: bounded distance equals zero implies equality **)
Theorem R_bounded_distance_eq0 : forall a b:set,
  a :e R -> b :e R -> R_bounded_distance a b = 0 -> a = b.
admit.
Qed.

(** helper: bounded distance is always <= 1 **)
Theorem R_bounded_distance_le_1 : forall a b:set,
  a :e R -> b :e R -> Rle (R_bounded_distance a b) 1.
admit.
Qed.

(** helper: abs of a real is real **)
Theorem abs_SNo_in_R : forall x:set, x :e R -> abs_SNo x :e R.
admit.
Qed.

(** helper: R is not bounded in the Abs sense **)
Theorem R_not_bounded_subset_of_reals : ~ bounded_subset_of_reals R.
admit.
Qed.

(** from 27: R is not compact in the standard topology **)
(** LATEX VERSION: The real line with the usual topology is not compact. **)
Theorem R_standard_topology_not_compact : ~ compact_space R R_standard_topology.
admit.
Qed.

(** helper: bounded distance is a real number **)
Theorem R_bounded_distance_in_R : forall a b:set,
  a :e R -> b :e R -> R_bounded_distance a b :e R.
admit.
Qed.

(** helper: bounded distance satisfies triangle inequality (SNoLe form) **)
Theorem R_bounded_distance_triangle_Le : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  R_bounded_distance a c <= add_SNo (R_bounded_distance a b) (R_bounded_distance b c).
admit.
Qed.

(** from 20 Theorem 20.5: the D metric on R^ (scaled bounded coordinate differences) **)
(** LATEX VERSION: Define D(x,y)=sup{ d(x_i,y_i)/i }. **)
Definition Romega_D_scaled_diffs : set -> set -> set := fun x y =>
  Repl omega
       (fun i:set => mul_SNo (R_bounded_distance (apply_fun x i) (apply_fun y i)) (inv_nat (ordsucc i))).

(** helper: scaled diffs are symmetric **)
Theorem Romega_D_scaled_diffs_sym : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  Romega_D_scaled_diffs x y = Romega_D_scaled_diffs y x.
admit.
Qed.

(** helper: diagonal scaled diffs are all 0 **)
Theorem Romega_D_scaled_diffs_diag_subset0 : forall x:set,
  x :e R_omega_space ->
  Romega_D_scaled_diffs x x c= {0}.
admit.
Qed.

(** helper: diagonal scaled diffs are exactly {0} **)
Theorem Romega_D_scaled_diffs_diag_eq_Sing0 : forall x:set,
  x :e R_omega_space ->
  Romega_D_scaled_diffs x x = {0}.
admit.
Qed.

(** from 20 Theorem 20.5: D(x,y) is the supremum of the scaled bounded coordinate differences **)
(** LATEX VERSION: D(x,y)=sup{ d(x_i,y_i)/i }. **)
Definition Romega_D_metric_value : set -> set -> set := fun x y =>
  Eps_i (fun r:set => R_lub (Romega_D_scaled_diffs x y) r).

(** helper: reciprocal of a natural is <= 1 **)
Theorem inv_nat_Rle_1 : forall n:set, n :e omega :\: {0} -> Rle (inv_nat n) 1.
admit.
Qed.

(** helper: scaled diffs are real numbers **)
Theorem Romega_D_scaled_diffs_in_R : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  forall a:set, a :e Romega_D_scaled_diffs x y -> a :e R.
admit.
Qed.

(** helper: scaled diffs are bounded above in R **)
Theorem Romega_D_scaled_diffs_bounded : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  exists u:set, u :e R /\ forall a:set, a :e Romega_D_scaled_diffs x y -> a :e R -> Rle a u.
admit.
Qed.

(** helper: the chosen D value is a least upper bound **)
Theorem Romega_D_metric_value_is_lub : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  R_lub (Romega_D_scaled_diffs x y) (Romega_D_metric_value x y).
admit.
Qed.

(** helper: D metric value is symmetric **)
Theorem Romega_D_metric_value_sym : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  Romega_D_metric_value x y = Romega_D_metric_value y x.
admit.
Qed.

(** helper: D metric value is 0 on the diagonal **)
Theorem Romega_D_metric_value_self_zero : forall x:set,
  x :e R_omega_space ->
  Romega_D_metric_value x x = 0.
admit.
Qed.

(** helper: D metric values are real numbers **)
Theorem Romega_D_metric_value_in_R : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  Romega_D_metric_value x y :e R.
admit.
Qed.

(** helper: D metric values are not negative **)
Theorem Romega_D_metric_value_nonneg : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  ~(Rlt (Romega_D_metric_value x y) 0).
admit.
Qed.

(** helper: D metric value 0 implies coordinate agreement (for positive indices) **)
Theorem Romega_D_metric_value_eq0_coord_eq : forall x y:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  Romega_D_metric_value x y = 0 ->
  forall i:set, i :e omega -> apply_fun x i = apply_fun y i.
admit.
Qed.

(** helper: D metric value is an upper bound for each scaled coordinate distance **)
Theorem Romega_D_metric_value_ub_scaled : forall x y i:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  i :e omega ->
  Rle (mul_SNo (R_bounded_distance (apply_fun x i) (apply_fun y i)) (inv_nat (ordsucc i)))
      (Romega_D_metric_value x y).
admit.
Qed.

(** helper: if the D metric value is < r, then each scaled coordinate term is < r **)
Theorem Romega_D_metric_value_lt_implies_scaled_lt : forall x y i r:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  i :e omega ->
  Rlt (Romega_D_metric_value x y) r ->
  Rlt (mul_SNo (R_bounded_distance (apply_fun x i) (apply_fun y i)) (inv_nat (ordsucc i))) r.
admit.
Qed.

(** helper: bounded distance < r with r < 1 implies abs(a-b) < r **)
Theorem R_bounded_distance_lt_lt1_imp_abs_lt : forall a b r:set,
  a :e R ->
  b :e R ->
  r :e R ->
  Rlt r 1 ->
  Rlt (R_bounded_distance a b) r ->
  abs_SNo (add_SNo a (minus_SNo b)) < r.
admit.
Qed.

(** helper: abs(a-b) < r with r < 1 gives bounded distance < r **)
Theorem abs_lt_lt1_imp_R_bounded_distance_lt : forall a b r:set,
  a :e R ->
  b :e R ->
  r :e R ->
  Rlt r 1 ->
  abs_SNo (add_SNo a (minus_SNo b)) < r ->
  Rlt (R_bounded_distance a b) r.
admit.
Qed.

(** helper: D metric bound gives coordinate abs difference bound for a fixed index **)
Theorem Romega_D_metric_coord_abs_lt : forall x y i delta:set,
  x :e R_omega_space ->
  y :e R_omega_space ->
  i :e omega ->
  delta :e R ->
  Rlt 0 delta ->
  Rlt delta 1 ->
  Rlt (Romega_D_metric_value x y) (mul_SNo delta (inv_nat (ordsucc i))) ->
  abs_SNo (add_SNo (apply_fun x i) (minus_SNo (apply_fun y i))) < delta.
admit.
Qed.

(** helper: division by n equals inv_nat n when numerator is 1 **)
Theorem div_SNo_1_eq_inv_nat : forall n:set,
  SNo n -> div_SNo 1 n = inv_nat n.
admit.
Qed.

(** helper: inv_nat 1 = 1 **)
Theorem inv_nat_1_eq_1 : inv_nat 1 = 1.
admit.
Qed.

(** helper: for i<j in omega, inv_nat (i+1) is larger than inv_nat (j+1) **)
Theorem inv_nat_ordsucc_antitone : forall i j:set,
  i :e omega -> j :e omega -> i :e j ->
  Rlt (inv_nat (ordsucc j)) (inv_nat (ordsucc i)).
admit.
Qed.

(** helper: inv_nat 2 is strictly below 1 **)
Theorem inv_nat_2_lt_1 : Rlt (inv_nat 2) 1.
admit.
Qed.

(** helper: given r>0, some inv_nat (n+1) is below r **)
Theorem exists_inv_nat_ordsucc_lt : forall r:set,
  r :e R -> Rlt 0 r ->
  exists N:set, N :e omega /\ Rlt (inv_nat (ordsucc N)) r.
admit.
Qed.

(** helper: D metric value satisfies triangle inequality **)
Theorem Romega_D_metric_value_triangle : forall x y z:set,
  x :e R_omega_space -> y :e R_omega_space -> z :e R_omega_space ->
  ~(Rlt (add_SNo (Romega_D_metric_value x y) (Romega_D_metric_value y z))
        (Romega_D_metric_value x z)).
admit.
Qed.

(** from 20 Theorem 20.5: the D metric graph on R^  R^ **)
(** LATEX VERSION: Then D is a metric that induces the product topology on R^. **)
Definition Romega_D_metric : set :=
  graph (setprod R_omega_space R_omega_space)
        (fun p:set => Romega_D_metric_value (p 0) (p 1)).

(** helper: D metric is function_on into R **)
Theorem Romega_D_metric_function_on :
  function_on Romega_D_metric (setprod R_omega_space R_omega_space) R.
admit.
Qed.

(** from 20 Theorem 20.5: the product topology on R^ is induced by the D metric **)
(** LATEX VERSION: Then D is a metric that induces the product topology on R^. **)
Definition Romega_D_metric_topology : set := metric_topology R_omega_space Romega_D_metric.

(** helper: open balls in the D metric are open in the product topology **)
(** LATEX VERSION: For the D metric on R to the omega, every open ball is open in the product topology. **)
Theorem Romega_D_metric_open_ball_in_product_topology : forall x r:set,
  metric_on R_omega_space Romega_D_metric ->
  x :e R_omega_space -> r :e R -> Rlt 0 r ->
  open_ball R_omega_space Romega_D_metric x r :e R_omega_product_topology.
admit.
Qed.

(** helper: cylinder subbasis sets are open in the D metric topology **)
(** LATEX VERSION: For the D metric, each cylinder set fixing one coordinate to be in an open interval is D-metric-open. **)
Theorem Romega_product_cylinder_in_D_metric_topology : forall i U:set,
  metric_on R_omega_space Romega_D_metric ->
  i :e omega -> U :e R_standard_topology ->
  product_cylinder omega (const_space_family omega R R_standard_topology) i U :e Romega_D_metric_topology.
admit.
Qed.
Theorem Romega_D_metric_induces_product_topology :
  metric_on R_omega_space Romega_D_metric /\
  Romega_D_metric_topology = R_omega_product_topology.
admit.
Qed.



(** LATEX VERSION: Open cover and Lindelf space definitions. **)
Definition open_cover : set -> set -> set -> prop :=
  fun X Tx U => (forall u:set, u :e U -> u :e Tx) /\ covers X U.

(** helper: members of an open_cover are open **)
(** LATEX VERSION: If U is an open cover, then every member u of U is open. **)
Theorem open_cover_members_open : forall X Tx U u:set,
  open_cover X Tx U -> u :e U -> u :e Tx.
admit.
Qed.

(** helper: open_cover yields the cover predicate **)
(** LATEX VERSION: If U is an open cover, then U covers X. **)
Theorem open_cover_implies_covers : forall X Tx U:set,
  open_cover X Tx U -> covers X U.
admit.
Qed.

(** helper: open_cover_of implies open_cover **)
(** LATEX VERSION: An open cover in the sense open_cover_of is also an open_cover. **)
Theorem open_cover_of_implies_open_cover : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> open_cover X Tx Fam.
admit.
Qed.

(** helper: open cover members are subsets of X **)
(** LATEX VERSION: If U is an open cover of X in Tx, then U  P(X). **)
Theorem open_cover_family_sub : forall X Tx U:set,
  topology_on X Tx ->
  open_cover X Tx U ->
  U c= Power X.
admit.
Qed.

(** from 26 Lemma: compact spaces are Lindelof **)
(** LATEX VERSION: An open cover in the sense open_cover induces an open_cover_of. **)
Theorem open_cover_implies_open_cover_of : forall X Tx Fam:set,
  topology_on X Tx ->
  open_cover X Tx Fam ->
  open_cover_of X Tx Fam.
admit.
Qed.

(** from 26 Definition: Lindelof space **)
(** LATEX VERSION: A space is Lindelof if every open cover has a countable subcover. **)
Definition Lindelof_space : set -> set -> prop :=
  fun X Tx => topology_on X Tx /\ forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.

(** helper: countable spaces are Lindelof **)
(** LATEX VERSION: If X is countable, then every open cover has a countable subcover. **)
Theorem countable_space_implies_Lindelof_space : forall X Tx:set,
  topology_on X Tx ->
  countable X ->
  Lindelof_space X Tx.
admit.
Qed.

(** from 26 Lemma: compact spaces are Lindelof **)
(** LATEX VERSION: A compact space is Lindelof; every open cover admits a countable subcover. **)
Theorem compact_space_implies_Lindelof_space : forall X Tx:set,
  compact_space X Tx -> Lindelof_space X Tx.
admit.
Qed.
(** LATEX VERSION: Sorgenfrey line and its lower limit topology. **)
Definition Sorgenfrey_line : set := R.
Definition Sorgenfrey_topology : set := R_lower_limit_topology.

(** helper: the Sorgenfrey (lower limit) topology on R is Hausdorff **)
(** LATEX VERSION: The Sorgenfrey line is Hausdorff; distinct points can be separated by half-open intervals. **)
Theorem R_lower_limit_topology_Hausdorff : Hausdorff_space R R_lower_limit_topology.
admit.
Qed.

(** helper: Sorgenfrey_line is Hausdorff **)
(** LATEX VERSION: The Sorgenfrey line (R_l) is Hausdorff. **)
Theorem Sorgenfrey_line_Hausdorff : Hausdorff_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.


(** LATEX VERSION: Countable basis at x (Definition 30.1). **)
(** FIXED: countable_basis_at uses a countable local basis B c= Tx at x, not a global basis_on X B; avoids collapsing first countable into second countable. **)
Definition countable_basis_at : set -> set -> set -> prop := fun X Tx x =>
  topology_on X Tx /\ x :e X /\
  exists B:set, B c= Tx /\ countable_set B /\
    (forall b:set, b :e B -> x :e b) /\
    (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U).

(** from 30 Definition 30.1: first-countable space **) 
(** LATEX VERSION: First countable means each point has a countable neighborhood basis. **)
Definition first_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> countable_basis_at X Tx x.

(** helper: monotonicity of metric open balls in the radius **)
Theorem open_ball_radius_mono : forall X d x r1 r2:set,
  Rlt r1 r2 -> open_ball X d x r1 c= open_ball X d x r2.
admit.
Qed.

(** helper: metric topology is first countable **)
Theorem metric_topology_first_countable : forall X d:set,
  metric_on X d -> first_countable_space X (metric_topology X d).
admit.
Qed.

(** helper: uniform topology is first countable **)
Theorem uniform_topology_first_countable : first_countable_space real_sequences uniform_topology.
admit.
Qed.

(** helper: countable local basis at a point in a nonempty countable product of first-countable spaces **)
(** LATEX VERSION: The usual product argument produces a countable neighborhood basis at a point. **)
Theorem product_countable_basis_at_point_if_components_first_countable : forall I Xi f:set,
  countable_index_set I ->
  I <> Empty ->
  (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
  f :e product_space I Xi ->
  countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
admit.
Qed.

(** helper: any convergent sequence yields closure membership **) 
(** LATEX VERSION: If a sequence in A converges to x, then x is in the closure of A (no countability needed). **)
Theorem convergent_sequence_implies_closure : forall X Tx A x:set,
  topology_on X Tx ->
  A c= X ->
  (exists seq:set, sequence_in seq A /\ converges_to X Tx seq x) ->
  x :e closure_of X Tx A.
admit.
Qed.

(** helper: equip preserves finiteness **) 
(** LATEX VERSION: If X is equip to Y and Y is finite, then X is finite. **)
Theorem equip_finite_transfer : forall X Y:set,
  equip X Y -> finite Y -> finite X.
admit.
Qed.

(** helper: injection gives equip with its image **)
(** LATEX VERSION: An injection f:XY is a bijection from X onto its image f[X]. **)
Theorem inj_equip_image : forall X Y:set, forall f:set->set,
  inj X Y f -> equip X {f x|x :e X}.
admit.
Qed.

(** helper: injection into a finite ordinal implies finiteness **) 
(** LATEX VERSION: If X injects into a finite set, then X is finite. **)
Theorem inj_into_finite_nat : forall X n:set, forall f:set->set,
  nat_p n -> inj X n f -> finite X.
admit.
Qed.

(** from 30 Theorem 30.1(a): sequences and closure in first-countable spaces **) 
(** LATEX VERSION: If X is first countable, then x is in cl(A) iff there exists a sequence in A converging to x. **)
Theorem first_countable_sequences_detect_closure : forall X Tx A x:set,
  first_countable_space X Tx ->
  A c= X ->
  (x :e closure_of X Tx A <->
    exists seq:set, sequence_in seq A /\ converges_to X Tx seq x).
admit.
Qed.

(** from 30 Theorem 30.1(b): sequences and continuity in first-countable spaces **)
(** LATEX VERSION: Sequential criterion for continuity in first-countable spaces. **)
(** FIXED: Correct convergence target and image limit: if x_n converges to x then f(x_n) converges to f(x). **)
Theorem first_countable_sequences_detect_continuity : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f ->
    forall x seq:set, sequence_on seq X -> converges_to X Tx seq x -> converges_to Y Ty (map_sequence f seq) (apply_fun f x)).
admit.
Qed.

(** from 30 Definition: second-countable space **) 
(** LATEX VERSION: Second countable means existence of a countable basis for the topology. **)
Definition second_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.

(** helper: second countable implies first countable **)
Theorem second_countable_implies_first_countable : forall X Tx:set,
  second_countable_space X Tx -> first_countable_space X Tx.
admit.
Qed.

(** helper: R is second countable in the standard topology **)
(** LATEX VERSION: The real line with its standard topology has a countable basis. **)
Theorem R_standard_topology_second_countable : second_countable_space R R_standard_topology.
admit.
Qed.

(** from 30 Example 1: R^n has countable basis **) 
(** LATEX VERSION: Euclidean spaces have a countable basis, hence are second countable. **)
Theorem euclidean_spaces_second_countable : forall n:set,
  n :e omega ->
  second_countable_space (euclidean_space n) (euclidean_topology n).
admit.
Qed.

(** from 30 Example 2: uniform topology on R^omega not second countable **) 
(** LATEX VERSION: The uniform topology on the space of real sequences is first countable but not second countable. **)
Definition discrete_subspace : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\
  (forall a:set, a :e A -> exists U:set, U :e Tx /\ U :/\: A = {a}).

(** from 30 Example 2: second countable implies discrete subspaces countable **) 
(** LATEX VERSION: In a second-countable space, every discrete subspace is countable. **)
Theorem second_countable_discrete_subspace_countable : forall X Tx A:set,
  second_countable_space X Tx ->
  discrete_subspace X Tx A ->
  countable_set A.
admit.
Qed.

(** from 30 Example 2: the subspace of binary sequences **) 
(** LATEX VERSION: Let AR^ be the set of all sequences of 0s and 1s; it is uncountable. **)
Definition binary_sequences_Romega : set :=
  {f :e real_sequences | forall n:set, n :e omega -> apply_fun f n :e {0,1}}.

(** from 30 Example 2: uncountability of the binary sequences subset **) 
(** LATEX VERSION: The set of binary sequences is uncountable because Power omega injects into it via characteristic functions. **)
Theorem binary_sequences_Romega_uncountable : ~ countable_set binary_sequences_Romega.
admit.
Qed.

(** from 30 Example 2: discreteness of binary sequences in the uniform topology **) 
(** LATEX VERSION: In the uniform metric, any two distinct binary sequences have distance 1, hence the subspace is discrete. **)
(** helper: unpack real_sequences membership **)
Theorem real_sequences_in_Power_setprod : forall f:set,
  f :e real_sequences -> f :e Power (setprod omega R).
admit.
Qed.
Theorem real_sequences_total : forall f:set,
  f :e real_sequences -> total_function_on f omega R.
admit.
Qed.
Theorem real_sequences_functional : forall f:set,
  f :e real_sequences -> functional_graph f.
admit.
Qed.

(** helper: distinct sequences differ at some coordinate **)
Theorem real_sequences_neq_exists_coord : forall f g:set,
  f :e real_sequences ->
  g :e real_sequences ->
  f <> g ->
  exists n:set, n :e omega /\ apply_fun f n <> apply_fun g n.
admit.
Qed.

(** helper: R_eq_of_not_Rlt, Rle_antisym, R_lub_unique moved earlier **)

(** helper: distance 1 between distinct binary sequences (intended property of the uniform metric) **)
(** LATEX VERSION: For ab in {0,1}^, one has \\bar\\rho(a,b)=1. **)
Theorem uniform_metric_Romega_binary_dist_1 : forall f g:set,
  f :e binary_sequences_Romega ->
  g :e binary_sequences_Romega ->
  f <> g ->
  apply_fun uniform_metric_Romega (f,g) = 1.
admit.
Qed.
Theorem binary_sequences_Romega_discrete_in_uniform_topology :
  discrete_subspace real_sequences uniform_topology binary_sequences_Romega.
admit.
Qed.
Theorem Romega_uniform_first_not_second_countable :
  first_countable_space real_sequences uniform_topology /\
  ~ second_countable_space real_sequences uniform_topology.
admit.
Qed.

(** from 30 Theorem 30.2: countability axioms preserved by subspaces and countable products **)
(** LATEX VERSION: First/second countability are inherited by subspaces and countable products (Theorem 30.2). **)
(** FIXED: Product clauses quantify i only over i:e I (not all sets). **) 
Theorem countability_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall A:set, A c= X -> first_countable_space X Tx -> first_countable_space A (subspace_topology X Tx A)) /\
  (forall A:set, A c= X -> second_countable_space X Tx -> second_countable_space A (subspace_topology X Tx A)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)).
admit.
Qed.

(** from 30 Definition: dense subset **) 
(** LATEX VERSION: A is dense in X if its closure equals X. **)
Definition dense_in : set -> set -> set -> prop := fun A X Tx => closure_of X Tx A = X.

(** Helper: density is preserved by supersets **)
(** LATEX VERSION: If A is dense in X and A  B  X, then B is dense in X. **)
Theorem dense_in_superset : forall A B X Tx:set,
  topology_on X Tx ->
  A c= B -> B c= X ->
  dense_in A X Tx ->
  dense_in B X Tx.
admit.
Qed.

(** from 30 Theorem 30.3(a): countable basis implies Lindelf **) 
(** LATEX VERSION: A second-countable space is Lindelf (every open cover has countable subcover). **)
Theorem countable_basis_implies_Lindelof : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.
admit.
Qed.

(** helper: second countable spaces are Lindelof spaces **)
Theorem second_countable_implies_Lindelof_space : forall X Tx:set,
  second_countable_space X Tx -> Lindelof_space X Tx.
admit.
Qed.

(** from 30 Theorem 30.3(b): countable basis yields countable dense subset **) 
(** LATEX VERSION: Second-countable spaces are separable (have countable dense subset). **)
Theorem countable_basis_implies_separable : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  exists D:set, countable_set D /\ dense_in D X Tx.
admit.
Qed.

(** from 30 Example 3: Sorgenfrey line countability properties **) 
(** LATEX VERSION: Sorgenfrey line is first countable, separable, Lindelf, but not second countable. **)
(** helper: Sorgenfrey line is first countable (countable local basis [x,x+eps_n)) **)
Theorem Sorgenfrey_line_first_countable :
  first_countable_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** helper: rational numbers are dense in the Sorgenfrey line **)
Theorem Sorgenfrey_line_rationals_dense :
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** helper: disjoint nonempty open families are countable in a space with countable dense subset **)
(** LATEX VERSION: In a space with a countable dense subset D, any pairwise disjoint family of nonempty open sets is countable. **)
Theorem disjoint_open_family_countable_of_dense : forall X Tx D Fam:set,
  topology_on X Tx ->
  dense_in D X Tx ->
  countable_set D ->
  Fam c= Tx ->
  (forall U:set, U :e Fam -> U <> Empty) ->
  pairwise_disjoint Fam ->
  countable_set Fam.
admit.
Qed.

(** helper: Sorgenfrey line is not second countable **)
Theorem Sorgenfrey_line_not_second_countable :
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** helper: Sorgenfrey line is Lindelf **)
(** LATEX VERSION: The Sorgenfrey line is Lindelf. **)
Theorem Sorgenfrey_line_Lindelof : Lindelof_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.
Theorem Sorgenfrey_line_countability :
  first_countable_space Sorgenfrey_line Sorgenfrey_topology /\
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology /\
  Lindelof_space Sorgenfrey_line Sorgenfrey_topology /\
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** placeholders for later refinement of product/separation constructions **) 
(** LATEX VERSION: Sorgenfrey plane topology = product of two Sorgenfrey lines. **)
Definition Sorgenfrey_plane_topology : set :=
  product_topology Sorgenfrey_line Sorgenfrey_topology Sorgenfrey_line Sorgenfrey_topology.

(** LATEX VERSION: D = set of points in R_l^2 with rational coordinates. **)
Definition Sorgenfrey_plane_rational_points : set :=
  setprod rational_numbers rational_numbers.

(** helper: D is countable **)
Theorem Sorgenfrey_plane_rational_points_countable :
  countable_set Sorgenfrey_plane_rational_points.
admit.
Qed.

(** helper: D is dense in the Sorgenfrey plane **)
Theorem Sorgenfrey_plane_rational_points_dense :
  dense_in Sorgenfrey_plane_rational_points
           (setprod Sorgenfrey_line Sorgenfrey_line)
           Sorgenfrey_plane_topology.
admit.
Qed.
(** LATEX VERSION: One-point sets closed predicate (T1-like helper). **)
Definition one_point_sets_closed : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> closed_in X Tx {x}.

(** helper: metric spaces satisfy one_point_sets_closed in the metric topology **)
(** LATEX VERSION: In a metric space, singletons are closed (metric spaces are T1). **)
Theorem metric_topology_one_point_sets_closed : forall X d:set,
  metric_on X d ->
  one_point_sets_closed X (metric_topology X d).
admit.
Qed.

(** helper: Hausdorff spaces satisfy one_point_sets_closed **)
(** LATEX VERSION: In a Hausdorff space, every singleton is closed (Hausdorff implies T1). **)
Theorem Hausdorff_one_point_sets_closed : forall X Tx:set,
  Hausdorff_space X Tx ->
  one_point_sets_closed X Tx.
admit.
Qed.

(** from 31 Definition: regular and normal spaces **)
(** LATEX VERSION: Regular space: points and closed sets can be separated by disjoint open sets. **)
Definition regular_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.

(** LATEX VERSION: Normal space: disjoint closed sets can be separated by disjoint opens. **)
Definition normal_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.

(** helper: normal spaces carry a topology **)
Theorem normal_space_topology_on : forall X Tx:set,
  normal_space X Tx ->
  topology_on X Tx.
admit.
Qed.

(** helper: regular spaces carry a topology **)
Theorem regular_space_topology_on : forall X Tx:set,
  regular_space X Tx ->
  topology_on X Tx.
admit.
Qed.

(** helper: in a regular space, shrink an open neighborhood with closure inside **)
(** LATEX VERSION: If x is in an open set U, then there exists an open V with x in V and cl(V) contained in U. **)
Theorem regular_space_open_nbhd_closure_sub : forall X Tx U x:set,
  regular_space X Tx ->
  U :e Tx ->
  x :e U ->
  exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
admit.
Qed.

(** Helper: discrete topology is normal **)
Theorem discrete_normal_space : forall X:set,
  normal_space X (discrete_topology X).
admit.
Qed.

(** from 31: regular implies Hausdorff, normal implies regular **)
(** LATEX VERSION: It is clear that a regular space is Hausdorff, and that a normal space is regular. **)
Theorem regular_space_implies_Hausdorff : forall X Tx:set,
  regular_space X Tx -> Hausdorff_space X Tx.
admit.
Qed.
Theorem normal_space_implies_regular : forall X Tx:set,
  normal_space X Tx -> regular_space X Tx.
admit.
Qed.

(** LATEX VERSION: Families of Hausdorff/regular/completely regular spaces (helpers). **)
Definition Hausdorff_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> Hausdorff_space (product_component Xi i) (product_component_topology Xi i).
Definition regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> regular_space (product_component Xi i) (product_component_topology Xi i).
(** LATEX VERSION: Uncountable set helper. **)
Definition uncountable_set : set -> prop := fun X => ~ countable_set X.

(** helper: uncountable sets are nonempty **)
Theorem uncountable_set_ne_Empty : forall X:set, uncountable_set X -> X <> Empty.
admit.
Qed.
(** LATEX VERSION: In an ordinal, every countable subset has an upper bound. **)
Definition countable_subsets_bounded : set -> prop := fun X =>
  forall A:set, A c= X -> countable_set A ->
    exists b:set, b :e X /\ forall a:set, a :e A -> a :e b.
(** NOTE: The definition `well_ordered_set` is placed earlier in the topology section to avoid forward-reference issues. **)
 
(** NOTE: well_ordered_set_is_ordinal is placed earlier to avoid forward references. **)

(** helper: membership implies order_rel on well_ordered_set carriers **)
Theorem mem_implies_order_rel_well_ordered : forall X a b:set,
  well_ordered_set X -> a :e b -> order_rel X a b.
admit.
Qed.

(** helper: order_rel implies membership on well_ordered_set carriers **)
Theorem order_rel_well_ordered_implies_mem : forall X a b:set,
  well_ordered_set X -> order_rel X a b -> a :e b.
admit.
Qed.

(** helper: on well ordered carriers, open_ray_lower X 1 is {0} when 1 is in X **)
(** LATEX VERSION: For an ordinal carrier X with membership order, the initial segment below 1 is the singleton {0}. **)
Theorem open_ray_lower_well_ordered_1_eq_singleton0 : forall X:set,
  well_ordered_set X ->
  1 :e X ->
  open_ray_lower X 1 = {0}.
admit.
Qed.

(** helper: open_ray_lower is open in the order topology **)
(** LATEX VERSION: Any basic ray is open in the order topology. **)
Theorem open_ray_lower_in_order_topology : forall X b:set,
  b :e X ->
  open_ray_lower X b :e order_topology X.
admit.
Qed.

(** helper: open_ray_upper is open in the order topology **)
(** LATEX VERSION: Any basic ray is open in the order topology. **)
Theorem open_ray_upper_in_order_topology : forall X a:set,
  a :e X ->
  open_ray_upper X a :e order_topology X.
admit.
Qed.

(** helper for later continuity proofs: open rays are open in the standard topology on R **)
(** LATEX VERSION: Rays (-,b) and (a,) are open in the order/standard topology on . **)
Theorem open_ray_upper_in_R_standard_topology : forall a:set,
  a :e R -> open_ray_upper R a :e R_standard_topology.
admit.
Qed.

(** helper: lower rays are open in the standard topology on R **)
(** LATEX VERSION: Rays (-,b) are open in the order/standard topology on . **)
Theorem open_ray_lower_in_R_standard_topology : forall b:set,
  b :e R -> open_ray_lower R b :e R_standard_topology.
admit.
Qed.

(** helper: product of two open rays is open in R^2 standard topology **)
(** LATEX VERSION: The set (-infty,q) x (q,infty) is open in the product topology on R^2. **)
Theorem open_ray_rectangle_in_R2_standard_topology : forall q:set,
  q :e R ->
  rectangle_set (open_ray_lower R q) (open_ray_upper R q) :e R2_standard_topology.
admit.
Qed.

(** helper: {(x,y) in R^2 | x < y} is open in the standard topology on R^2 **)
(** LATEX VERSION: The strict order relation is an open subset of R^2 in the product topology. **)
Theorem R2_strict_lt_open : {p :e EuclidPlane| Rlt (p 0) (p 1)} :e R2_standard_topology.
admit.
Qed.

(** helper: product of an upper and lower open ray is open in R^2 standard topology **)
(** LATEX VERSION: The set (q,infty) x (-infty,q) is open in the product topology on R^2. **)
Theorem open_ray_rectangle_swapped_in_R2_standard_topology : forall q:set,
  q :e R ->
  rectangle_set (open_ray_upper R q) (open_ray_lower R q) :e R2_standard_topology.
admit.
Qed.

(** helper: {(x,y) in R^2 | y < x} is open in the standard topology on R^2 **)
(** LATEX VERSION: The reverse strict order relation is an open subset of R^2 in the product topology. **)
Theorem R2_strict_gt_open : {p :e EuclidPlane| Rlt (p 1) (p 0)} :e R2_standard_topology.
admit.
Qed.

(** helper for later continuity proofs: strict inequality preimages are open **)
(** LATEX VERSION: If g,h : X ->  are continuous, then {x | g(x) < h(x)} is open. **)
Theorem continuous_Rlt_preimage_open : forall X Tx g h:set,
  continuous_map X Tx R R_standard_topology g ->
  continuous_map X Tx R R_standard_topology h ->
  {x :e X | Rlt (apply_fun g x) (apply_fun h x)} :e Tx.
admit.
Qed.

(** helper for later continuity proofs: strict reverse inequality preimages are open **)
(** LATEX VERSION: If g,h : X ->  are continuous, then {x | h(x) < g(x)} is open. **)
Theorem continuous_Rlt_preimage_open_swapped : forall X Tx g h:set,
  continuous_map X Tx R R_standard_topology g ->
  continuous_map X Tx R R_standard_topology h ->
  {x :e X | Rlt (apply_fun h x) (apply_fun g x)} :e Tx.
admit.
Qed.

(** helper for later continuity proofs: non-strict inequality preimages are closed **)
(** LATEX VERSION: If g,h : X ->  are continuous, then {x | g(x)  h(x)} is closed. **)
Theorem continuous_Rle_preimage_closed : forall X Tx g h:set,
  continuous_map X Tx R R_standard_topology g ->
  continuous_map X Tx R R_standard_topology h ->
  closed_in X Tx {x :e X | Rle (apply_fun g x) (apply_fun h x)}.
admit.
Qed.

(** helper: {0} is open in order topology of a well ordered carrier containing 1 **)
(** LATEX VERSION: For a well ordered carrier X with 1 in X, the singleton {0} is a basic neighborhood of 0. **)
Theorem singleton0_open_in_order_topology_well_ordered : forall X:set,
  well_ordered_set X ->
  1 :e X ->
  {0} :e order_topology X.
admit.
Qed.

(** helper: {0} is open in order topology of a nonempty well ordered carrier **)
(** LATEX VERSION: In an ordinal order topology, {0} is open (either X=1 or 1X and (0,1) is the basic neighborhood). **)
Theorem singleton0_open_in_order_topology_well_ordered_nonempty : forall X:set,
  well_ordered_set X ->
  simply_ordered_set X ->
  0 :e X ->
  {0} :e order_topology X.
admit.
Qed.

(** LATEX VERSION: Completely regular family helper. **)
(** moved below after completely_regular_space is defined **)
(** LATEX VERSION: A family {f_a}_{a in J} separates points from closed sets: for each x0 and neighborhood U of x0, some f_a is positive at x0 and vanishes off U. **)
Definition separating_family_of_functions : set -> set -> set -> set -> prop :=
  fun X Tx F J =>
    topology_on X Tx /\
    total_function_on F J (function_space X R) /\
    (forall j:set, j :e J -> continuous_map X Tx R R_standard_topology (apply_fun F j)) /\
    (forall x0:set, x0 :e X ->
       forall U:set, U :e Tx -> x0 :e U ->
         exists j:set, j :e J /\
           Rlt 0 (apply_fun (apply_fun F j) x0) /\
           forall x:set, x :e X :\: U -> apply_fun (apply_fun F j) x = 0).

(** helper: under T1, separating family yields point separation **)
Theorem separating_family_of_functions_separates_points : forall X Tx F J x y:set,
  topology_on X Tx ->
  one_point_sets_closed X Tx ->
  separating_family_of_functions X Tx F J ->
  x :e X -> y :e X -> x <> y ->
  exists j:set, j :e J /\ apply_fun (apply_fun F j) x <> apply_fun (apply_fun F j) y.
admit.
Qed.

(** helper: diagonal map induced by an indexed family of functions **)
(** LATEX VERSION: Given a family of functions (f_j)_{jJ} on X, the diagonal map sends x to the function j  f_j(x). **)
Definition diagonal_map : set -> set -> set -> set := fun X F J =>
  graph X (fun x:set => graph J (fun j:set => apply_fun (apply_fun F j) x)).

(** helper: evaluate a diagonal map at a coordinate **)
Theorem diagonal_map_coord_apply : forall X F J x i:set,
  x :e X -> i :e J ->
  apply_fun (apply_fun (diagonal_map X F J) x) i = apply_fun (apply_fun F i) x.
admit.
Qed.
(** LATEX VERSION: Embedding predicate. **)
(** FIXED: embedding_of requires f:X->Y is continuous, and is a homeomorphism onto its image with the subspace topology. **) 
Definition embedding_of : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty f =>
  continuous_map X Tx Y Ty f /\
  homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f.

(** Helper: extract continuous_map from embedding_of **)
Theorem embedding_of_continuous : forall X Tx Y Ty f:set,
  embedding_of X Tx Y Ty f -> continuous_map X Tx Y Ty f.
admit.
Qed.

(** Helper: extract homeomorphism onto image from embedding_of **)
Theorem embedding_of_homeomorphism : forall X Tx Y Ty f:set,
  embedding_of X Tx Y Ty f ->
  homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f.
admit.
Qed.

(** helper: neighborhood refinement gives a homeomorphism onto the image **)
Theorem embedding_of_from_local_refinement : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  (forall x U:set, x :e X -> U :e Tx -> x :e U ->
     exists V:set, V :e Ty /\ apply_fun f x :e V /\ preimage_of X f V c= U) ->
  (forall x y:set, x :e X -> y :e X -> apply_fun f x = apply_fun f y -> x = y) ->
  embedding_of X Tx Y Ty f.
admit.
Qed.
(** LATEX VERSION: Power and unit-interval cubes helpers; metrizability predicate. **)
(** LATEX VERSION: Notation R^J for the product of copies of R with the standard topology. **)
Definition power_real : set -> set := fun J =>
  product_space J (const_space_family J R R_standard_topology).
(** LATEX VERSION: Notation [0,1]^J for the product of copies of [0,1] (subspace topology). **)
Definition unit_interval_power : set -> set := fun J =>
  product_space J (const_space_family J unit_interval unit_interval_topology).

(** from 40 Theorem 40.3: uniform metric on R^J (setup) **)
(** LATEX VERSION: On R^J define rho(x,y)=sup{|x_a-y_a|}; we use clipped coordinate differences to ensure boundedness. **)
Definition power_real_coord_abs_diff : set -> set -> set -> set := fun f g j =>
  abs_SNo (add_SNo (apply_fun f j) (minus_SNo (apply_fun g j))).

(** from 40 Theorem 40.3: uniform metric on R^J (clipped diffs) **)
(** LATEX VERSION: Use dbar(x,y)=min{|x-y|,1} coordinatewise. **)
Definition power_real_coord_clipped_diff : set -> set -> set -> set := fun f g j =>
  If_i (Rlt (power_real_coord_abs_diff f g j) 1) (power_real_coord_abs_diff f g j) 1.

(** from 40 Theorem 40.3: uniform metric on R^J (family of clipped diffs) **)
(** LATEX VERSION: The set of clipped coordinate diffs indexed by J. **)
Definition power_real_clipped_diffs : set -> set -> set -> set := fun J f g =>
  Repl J (fun j:set => power_real_coord_clipped_diff f g j).

(** from 40 Theorem 40.3: uniform metric on R^J (value as lub) **)
(** LATEX VERSION: rho(x,y)=sup{ dbar(x_a,y_a) | a in J }. **)
Definition power_real_uniform_metric_value : set -> set -> set -> set := fun J f g =>
  If_i (J = Empty)
       0
       (Eps_i (fun r:set => R_lub (power_real_clipped_diffs J f g) r)).

(** from 40 Theorem 40.3: uniform metric on R^J (metric graph) **)
(** LATEX VERSION: View rho as a metric graph on R^J=power_real J. **)
Definition uniform_metric_power_real : set -> set := fun J =>
  graph (setprod (power_real J) (power_real J))
        (fun p:set => power_real_uniform_metric_value J (p 0) (p 1)).

(** from 40 Theorem 40.3: uniform topology on R^J induced by rho **)
(** LATEX VERSION: The topology induced by the uniform metric on R^J. **)
Definition uniform_topology_power_real : set -> set := fun J =>
  metric_topology (power_real J) (uniform_metric_power_real J).

(** helper for 40 Theorem 40.3: coordinate clipped diff is the bounded distance **)
Theorem power_real_coord_clipped_diff_eq_R_bounded_distance : forall J f g j:set,
  j :e J ->
  f :e power_real J ->
  g :e power_real J ->
  power_real_coord_clipped_diff f g j = R_bounded_distance (apply_fun f j) (apply_fun g j).
admit.
Qed.

(** helper for 40 Theorem 40.3: coordinates of power_real are real numbers **)
Theorem power_real_coord_in_R : forall J f j:set,
  j :e J ->
  f :e power_real J ->
  apply_fun f j :e R.
admit.
Qed.

(** helper for 40 Theorem 40.3: extensionality in power_real by coordinates **)
Theorem power_real_ext : forall J f g:set,
  f :e power_real J ->
  g :e power_real J ->
  (forall j:set, j :e J -> apply_fun f j = apply_fun g j) ->
  f = g.
admit.
Qed.

(** helper for 40 Theorem 40.3: clipped diffs are real numbers **)
Theorem power_real_clipped_diffs_in_R : forall J f g a:set,
  f :e power_real J ->
  g :e power_real J ->
  a :e power_real_clipped_diffs J f g ->
  a :e R.
admit.
Qed.

(** helper for 40 Theorem 40.3: coordinate clipped diff is <= 1 **)
Theorem power_real_coord_clipped_diff_le_1 : forall J f g j:set,
  j :e J ->
  f :e power_real J ->
  g :e power_real J ->
  Rle (power_real_coord_clipped_diff f g j) 1.
admit.
Qed.

(** helper for 40 Theorem 40.3: clipped diffs are nonempty when J is nonempty **)
Theorem power_real_clipped_diffs_nonempty : forall J f g:set,
  J <> Empty ->
  f :e power_real J ->
  g :e power_real J ->
  exists a0:set, a0 :e power_real_clipped_diffs J f g.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric value satisfies R_lub when J is nonempty **)
Theorem power_real_uniform_metric_value_is_lub : forall J f g:set,
  J <> Empty ->
  f :e power_real J ->
  g :e power_real J ->
  R_lub (power_real_clipped_diffs J f g) (power_real_uniform_metric_value J f g).
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric values are real numbers **)
Theorem power_real_uniform_metric_value_in_R : forall J f g:set,
  f :e power_real J ->
  g :e power_real J ->
  power_real_uniform_metric_value J f g :e R.
admit.
Qed.

(** helper for 40 Theorem 40.3: apply_fun of uniform_metric_power_real **)
Theorem uniform_metric_power_real_apply : forall J x y:set,
  x :e power_real J ->
  y :e power_real J ->
  apply_fun (uniform_metric_power_real J) (x,y) = power_real_uniform_metric_value J x y.
admit.
Qed.

(** helper for 40 Theorem 40.3: clipped diffs are symmetric **)
Theorem power_real_clipped_diffs_sym : forall J f g:set,
  f :e power_real J ->
  g :e power_real J ->
  power_real_clipped_diffs J f g = power_real_clipped_diffs J g f.
admit.
Qed.

(** helper for 40 Theorem 40.3: diagonal clipped diffs are {0} when J is nonempty **)
Theorem power_real_clipped_diffs_diag_eq_Sing0 : forall J f:set,
  J <> Empty ->
  f :e power_real J ->
  power_real_clipped_diffs J f f = {0}.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric value is symmetric **)
Theorem power_real_uniform_metric_value_sym : forall J f g:set,
  f :e power_real J ->
  g :e power_real J ->
  power_real_uniform_metric_value J f g = power_real_uniform_metric_value J g f.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric value is 0 on the diagonal **)
Theorem power_real_uniform_metric_value_self_zero : forall J f:set,
  f :e power_real J ->
  power_real_uniform_metric_value J f f = 0.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform_metric_power_real is function_on into R **)
Theorem uniform_metric_power_real_function_on : forall J:set,
  function_on (uniform_metric_power_real J) (setprod (power_real J) (power_real J)) R.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric value is not negative **)
Theorem power_real_uniform_metric_value_nonneg : forall J f g:set,
  f :e power_real J ->
  g :e power_real J ->
  ~(Rlt (power_real_uniform_metric_value J f g) 0).
admit.
Qed.

(** helper for 40 Theorem 40.3: distance 0 implies coordinate equality when J is nonempty **)
Theorem power_real_uniform_metric_value_eq0_coord_eq : forall J x y j:set,
  J <> Empty ->
  x :e power_real J ->
  y :e power_real J ->
  j :e J ->
  power_real_uniform_metric_value J x y = 0 ->
  apply_fun x j = apply_fun y j.
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric value satisfies the triangle inequality **)
Theorem power_real_uniform_metric_value_triangle : forall J x y z:set,
  x :e power_real J -> y :e power_real J -> z :e power_real J ->
  ~(Rlt (add_SNo (power_real_uniform_metric_value J x y) (power_real_uniform_metric_value J y z))
        (power_real_uniform_metric_value J x z)).
admit.
Qed.

(** helper for 40 Theorem 40.3: uniform metric is a metric on R^J **)
(** LATEX VERSION: The sup metric rho on R^J satisfies the metric axioms (after clipping by 1). **)
Theorem uniform_metric_power_real_is_metric_on : forall J:set,
  metric_on (power_real J) (uniform_metric_power_real J).
admit.
Qed.

(** helper for 34 Corollary 34.3: a normalizing map R -> [0,1] **)
(** LATEX VERSION: A continuous map psi:R-> [0,1] with psi(0)=0 and psi(1)=1 can be used to turn R-valued separators into [0,1]-valued ones. **)
Definition one_minus_fun : set :=
  graph R (fun t:set => add_SNo 1 (minus_SNo t)).
Theorem one_minus_fun_value_in_R : forall t:set,
  t :e R -> apply_fun one_minus_fun t :e R.
admit.
Qed.
Theorem one_minus_fun_0 : apply_fun one_minus_fun 0 = 1.
admit.
Qed.
Theorem one_minus_fun_1 : apply_fun one_minus_fun 1 = 0.
admit.
Qed.
Theorem one_minus_fun_continuous :
  continuous_map R R_standard_topology R R_standard_topology one_minus_fun.
admit.
Qed.

(** helper: negation map on R **)
(** LATEX VERSION: The negation map is the function t  -t on . **)
Definition neg_fun : set :=
  graph R (fun t:set => minus_SNo t).
Theorem neg_fun_value_in_R : forall t:set,
  t :e R -> apply_fun neg_fun t :e R.
admit.
Qed.

(** helper: neg_fun is an element of function_space R R **)
(** LATEX VERSION: Negation is a function . **)
Theorem neg_fun_in_function_space : neg_fun :e function_space R R.
admit.
Qed.
Theorem neg_fun_apply : forall t:set, t :e R ->
  apply_fun neg_fun t = minus_SNo t.
admit.
Qed.

(** helper: double negation on R, local name **)
Theorem minus_SNo_minus_SNo_R : forall t:set, t :e R -> minus_SNo (minus_SNo t) = t.
admit.
Qed.
Theorem neg_fun_flip_upper : forall a t:set,
  a :e R -> t :e R ->
  (Rlt a (minus_SNo t) <-> Rlt t (minus_SNo a)).
admit.
Qed.
Theorem neg_fun_flip_lower : forall t b:set,
  t :e R -> b :e R ->
  (Rlt (minus_SNo t) b <-> Rlt (minus_SNo b) t).
admit.
Qed.
Theorem preimage_neg_fun_open_ray_upper : forall a:set,
  a :e R ->
  preimage_of R neg_fun (open_ray_upper R a) = open_ray_lower R (minus_SNo a).
admit.
Qed.
Theorem preimage_neg_fun_open_ray_lower : forall b:set,
  b :e R ->
  preimage_of R neg_fun (open_ray_lower R b) = open_ray_upper R (minus_SNo b).
admit.
Qed.
Theorem neg_fun_continuous :
  continuous_map R R_standard_topology R R_standard_topology neg_fun.
admit.
Qed.

(** helper: addition map on RR **)
(** LATEX VERSION: The addition map is the function (x,y)  x+y on . **)
Definition add_fun_R : set :=
  graph (setprod R R) (fun p:set => add_SNo (p 0) (p 1)).

(** helper: multiplication map on RR **)
(** LATEX VERSION: The multiplication map is the function (x,y)  xy on . **)
Definition mul_fun_R : set :=
  graph (setprod R R) (fun p:set => mul_SNo (p 0) (p 1)).

(** helper: multiplication by a fixed constant on R **)
(** LATEX VERSION: For fixed c, the map t  tc on . **)
Definition mul_const_fun : set -> set := fun c =>
  graph R (fun t:set => mul_SNo t c).
Theorem add_fun_R_value_in_R : forall p:set,
  p :e setprod R R -> apply_fun add_fun_R p :e R.
admit.
Qed.

(** helper: add_fun_R is an element of function_space (RR) R **)
(** LATEX VERSION: Addition is a function (RR)R. **)
Theorem add_fun_R_in_function_space : add_fun_R :e function_space (setprod R R) R.
admit.
Qed.

(** helper: mul_fun_R is an element of function_space (RR) R **)
(** LATEX VERSION: Multiplication is a function (RR)R. **)
Theorem mul_fun_R_in_function_space : mul_fun_R :e function_space (setprod R R) R.
admit.
Qed.
Theorem add_fun_R_apply : forall p:set,
  p :e setprod R R -> apply_fun add_fun_R p = add_SNo (p 0) (p 1).
admit.
Qed.
Theorem preimage_add_fun_R_open_ray_upper_in_product_topology : forall a:set,
  a :e R ->
  preimage_of (setprod R R) add_fun_R (open_ray_upper R a) :e
    (product_topology R R_standard_topology R R_standard_topology).
admit.
Qed.
Theorem preimage_add_fun_R_open_ray_lower_in_product_topology : forall b:set,
  b :e R ->
  preimage_of (setprod R R) add_fun_R (open_ray_lower R b) :e
    (product_topology R R_standard_topology R R_standard_topology).
admit.
Qed.
Theorem add_fun_R_continuous :
  continuous_map (setprod R R) (product_topology R R_standard_topology R R_standard_topology)
    R R_standard_topology add_fun_R.
admit.
Qed.

(** helper: normalization map into the unit interval **)
(** LATEX VERSION: normalize01_fun(t) = t^2 / (t^2 + (t-1)^2), a standard continuous function taking values in [0,1]. **)
Definition normalize01_fun : set :=
  graph R (fun t:set =>
    div_SNo (mul_SNo t t)
      (add_SNo (mul_SNo t t)
        (mul_SNo (add_SNo t (minus_SNo 1)) (add_SNo t (minus_SNo 1))))).
Theorem normalize01_fun_value_in_R : forall t:set,
  t :e R -> apply_fun normalize01_fun t :e R.
admit.
Qed.

(** moved earlier: used by normalize01_fun_preimage_open_ray lemmas **)
Theorem normalize01_fun_range_in_unit_interval : forall t:set,
  t :e R -> apply_fun normalize01_fun t :e unit_interval.
admit.
Qed.

(** helper: rewrite membership in open rays as Rlt inequalities for normalize01_fun images **)
(** LATEX VERSION: In the order topology on R, upper and lower open rays correspond to strict inequalities. **)
Theorem normalize01_fun_img_in_open_ray_upper_iff : forall a t:set,
  a :e R -> t :e R ->
  (apply_fun normalize01_fun t :e open_ray_upper R a <-> Rlt a (apply_fun normalize01_fun t)).
admit.
Qed.
Theorem normalize01_fun_img_in_open_ray_lower_iff : forall b t:set,
  b :e R -> t :e R ->
  (apply_fun normalize01_fun t :e open_ray_lower R b <-> Rlt (apply_fun normalize01_fun t) b).
admit.
Qed.

(** helper for normalize01_fun: the denominator t^2 + (t-1)^2 is strictly positive **)
(** LATEX VERSION: For all real t, t^2+(t-1)^2 > 0. **)
Theorem normalize01_fun_den_pos : forall t:set,
  t :e R ->
  0 < add_SNo (mul_SNo t t)
        (mul_SNo (add_SNo t (minus_SNo 1)) (add_SNo t (minus_SNo 1))).
admit.
Qed.

(** helper for normalize01_fun: strict positivity away from 0 **)
(** LATEX VERSION: If t  0, then t^2/(t^2+(t-1)^2) > 0. **)
Theorem normalize01_fun_pos_of_neq0 : forall t:set,
  t :e R -> t <> 0 -> Rlt 0 (apply_fun normalize01_fun t).
admit.
Qed.

(** helper for normalize01_fun: strict inequality to 1 away from 1 **)
(** LATEX VERSION: If t  1, then t^2/(t^2+(t-1)^2) < 1. **)
Theorem normalize01_fun_lt1_of_neq1 : forall t:set,
  t :e R -> t <> 1 -> Rlt (apply_fun normalize01_fun t) 1.
admit.
Qed.

(** helper for normalize01_fun: value at 0 **)
Theorem normalize01_fun_0 : apply_fun normalize01_fun 0 = 0.
admit.
Qed.

(** helper for normalize01_fun: value at 1 **)
Theorem normalize01_fun_1 : apply_fun normalize01_fun 1 = 1.
admit.
Qed.

(** helper for normalize01_fun: rewrite inequalities against the defining quotient **)
Theorem normalize01_fun_gt_iff_mul_den_lt_num : forall a t:set,
  a :e R -> t :e R ->
  0 < a -> a < 1 ->
  (a < apply_fun normalize01_fun t <->
    mul_SNo a
      (add_SNo (mul_SNo t t)
        (mul_SNo (add_SNo t (minus_SNo 1)) (add_SNo t (minus_SNo 1))))
    < (mul_SNo t t)).
admit.
Qed.

(** helper for normalize01_fun: rewrite strict upper bounds against the defining quotient **)
Theorem normalize01_fun_lt_iff_num_lt_mul_den : forall b t:set,
  b :e R -> t :e R ->
  0 < b ->
  (apply_fun normalize01_fun t < b <->
    (mul_SNo t t) <
      mul_SNo b
        (add_SNo (mul_SNo t t)
          (mul_SNo (add_SNo t (minus_SNo 1)) (add_SNo t (minus_SNo 1))))).
admit.
Qed.
Theorem open_ball_R_bounded_metric_abs_early : forall x r y:set,
  x :e R -> r :e R -> Rlt 0 r -> Rlt r 1 ->
  (y :e open_ball R R_bounded_metric x r <->
   (y :e R /\ Rlt (R_bounded_distance x y) r)).
admit.
Qed.
Theorem open_ball_R_bounded_metric_absdiff_lt : forall x r y:set,
  x :e R -> r :e R -> Rlt 0 r -> Rlt r 1 ->
  y :e open_ball R R_bounded_metric x r ->
  abs_SNo (add_SNo x (minus_SNo y)) < r.
admit.
Qed.

(** helper: bounded metric balls of radius greater than 1 are all of R (early) **)
(** LATEX VERSION: If 1<r then B(c,r)=R for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_eq_R_if_1_lt_early : forall c r:set,
  c :e R -> r :e R -> Rlt 1 r ->
  open_ball R R_bounded_metric c r = R.
admit.
Qed.

(** helper: bounded metric balls with radius < 1 are open intervals (early) **)
(** LATEX VERSION: If 0<r<1 then B(c,r) = (c-r, c+r) for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_eq_open_interval_early : forall c r:set,
  c :e R -> r :e R -> Rlt 0 r -> Rlt r 1 ->
  open_ball R R_bounded_metric c r = open_interval (add_SNo c (minus_SNo r)) (add_SNo c r).
admit.
Qed.

(** helper: bounded metric ball of radius 1 is an open interval (early) **)
(** LATEX VERSION: B(c,1) = (c-1, c+1) for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_r1_eq_open_interval_early : forall c:set,
  c :e R ->
  open_ball R R_bounded_metric c 1 = open_interval (add_SNo c (minus_SNo 1)) (add_SNo c 1).
admit.
Qed.

(** helper: bounded-metric open balls are standard-open in R (early) **)
(** LATEX VERSION: Each bounded-metric open ball is open in the standard topology on R. **)
Theorem open_ball_R_bounded_metric_in_R_standard_topology_early : forall c r:set,
  c :e R -> r :e R -> Rlt 0 r ->
  open_ball R R_bounded_metric c r :e R_standard_topology.
admit.
Qed.

(** moved below since it uses R_bounded_metric_is_metric_on_early **)

(** helper: bounded metric is a metric (early stub for 35) **)
(** LATEX VERSION: The bounded metric on R satisfies the metric axioms. **)
Theorem R_bounded_metric_is_metric_on_early : metric_on R R_bounded_metric.
admit.
Qed.
Theorem mul_const_fun_apply : forall c t:set,
  c :e R -> t :e R ->
  apply_fun (mul_const_fun c) t = mul_SNo t c.
admit.
Qed.
Theorem mul_const_fun_in_function_space : forall c:set,
  c :e R -> mul_const_fun c :e function_space R R.
admit.
Qed.
Theorem mul_const_fun_value_in_R : forall c t:set,
  c :e R -> t :e R ->
  apply_fun (mul_const_fun c) t :e R.
admit.
Qed.
Theorem preimage_mul_const_open_ray_upper : forall c a:set,
  c :e R -> 0 < c -> a :e R ->
  preimage_of R (mul_const_fun c) (open_ray_upper R a) = open_ray_upper R (div_SNo a c).
admit.
Qed.

(** preimage of a lower ray under multiplication by positive c **)
Theorem preimage_mul_const_open_ray_lower : forall c b:set,
  c :e R -> 0 < c -> b :e R ->
  preimage_of R (mul_const_fun c) (open_ray_lower R b) = open_ray_lower R (div_SNo b c).
admit.
Qed.
Theorem mul_const_fun_continuous_pos : forall c:set,
  c :e R -> 0 < c ->
  continuous_map R R_standard_topology R R_standard_topology (mul_const_fun c).
admit.
Qed.

(** helper: multiplication by an arbitrary real constant is continuous in the standard topology **)
(** LATEX VERSION: Multiplication by a constant is continuous, by reducing the negative case to the positive case using negation, and the zero case to a constant map. **)
Theorem mul_const_fun_continuous : forall c:set,
  c :e R ->
  continuous_map R R_standard_topology R R_standard_topology (mul_const_fun c).
admit.
Qed.
Theorem add_two_continuous_R : forall X Tx g h:set,
  topology_on X Tx ->
  continuous_map X Tx R R_standard_topology g ->
  continuous_map X Tx R R_standard_topology h ->
  continuous_map X Tx R R_standard_topology (compose_fun X (pair_map X g h) add_fun_R).
admit.
Qed.
Theorem mul_fun_R_value_in_R : forall p:set, p :e setprod R R -> apply_fun mul_fun_R p :e R.
admit.
Qed.

(** helper for 35: multiplication map application **)
Theorem mul_fun_R_apply : forall p:set,
  p :e setprod R R -> apply_fun mul_fun_R p = mul_SNo (p 0) (p 1).
admit.
Qed.

(** helper for section 35 abs and multiplication **)
Theorem abs_SNo_mul_nonneg_left : forall x y:set,
  SNo x -> SNo y -> 0 <= x ->
  abs_SNo (mul_SNo x y) = mul_SNo x (abs_SNo y).
admit.
Qed.
Theorem abs_SNo_mul_eq : forall x y:set,
  SNo x -> SNo y ->
  abs_SNo (mul_SNo x y) = mul_SNo (abs_SNo x) (abs_SNo y).
admit.
Qed.

(** helper for 35: preimage of upper ray under multiplication on R **)
Theorem preimage_mul_fun_R_open_ray_upper_in_product_topology : forall a:set,
  a :e R ->
  preimage_of (setprod R R) mul_fun_R (open_ray_upper R a) :e
    (product_topology R R_standard_topology R R_standard_topology).
admit.
Qed.

(** helper for 35: preimage of lower ray under multiplication on R **)
Theorem preimage_mul_fun_R_open_ray_lower_in_product_topology : forall b:set,
  b :e R ->
  preimage_of (setprod R R) mul_fun_R (open_ray_lower R b) :e
    (product_topology R R_standard_topology R R_standard_topology).
admit.
Qed.

(** helper for 35: continuity of multiplication on RR **)
Theorem mul_fun_R_continuous :
  continuous_map (setprod R R) (product_topology R R_standard_topology R R_standard_topology)
    R R_standard_topology mul_fun_R.
admit.
Qed.

(** helper for 35: pointwise product of two continuous R-valued maps is continuous **)
Theorem mul_two_continuous_R : forall X Tx g h:set,
  topology_on X Tx ->
  continuous_map X Tx R R_standard_topology g ->
  continuous_map X Tx R R_standard_topology h ->
  continuous_map X Tx R R_standard_topology (compose_fun X (pair_map X g h) mul_fun_R).
admit.
Qed.

(** helper for 35 Step II: add_fun_R after pair_map evaluates pointwise **)
Theorem add_of_pair_map_apply : forall A f g a:set,
  a :e A ->
  apply_fun f a :e R ->
  apply_fun g a :e R ->
  apply_fun (compose_fun A (pair_map A f g) add_fun_R) a = add_SNo (apply_fun f a) (apply_fun g a).
admit.
Qed.
Theorem mul_of_pair_map_apply : forall A f g a:set,
  a :e A ->
  apply_fun f a :e R ->
  apply_fun g a :e R ->
  apply_fun (compose_fun A (pair_map A f g) mul_fun_R) a = mul_SNo (apply_fun f a) (apply_fun g a).
admit.
Qed.
(** helper for normalize01_fun_continuous: preimage of an upper open ray **)
(** LATEX VERSION: Preimage of a basic open ray under the function t^2/(t^2+(t-1)^2) is open in the standard topology on R. **)
(** SUSPICIOUS THEOREM: This mid lemma is admitted; proving it directly requires an openness argument for a quadratic inequality (hence continuity of multiplication in the order topology on R).  Until this is proved, normalize01_fun_continuous remains recursively admitted. **)
(** NOTE: A direct proof can proceed by rewriting normalize01_fun(t) > a (with 0<=a<1) to a strict quadratic inequality in t using the fact that the denominator is always positive, then expressing the resulting set as a union of basic open rays/intervals; alternatively, one can first develop continuity of multiplication on R and then use continuity of polynomials. **)
(** ABY: try_aby at line 117436 column 1 FAIL (vampire failed) **)
Theorem normalize01_fun_preimage_open_ray_upper_mid : forall a:set,
  a :e R -> ~(Rlt a 0) -> Rlt a 1 ->
  preimage_of R normalize01_fun (open_ray_upper R a) :e R_standard_topology.
admit.
Qed.
Theorem normalize01_fun_preimage_open_ray_upper : forall a:set,
  a :e R -> preimage_of R normalize01_fun (open_ray_upper R a) :e R_standard_topology.
admit.
Qed.

(** helper for normalize01_fun_continuous: preimage of a lower open ray **)
(** LATEX VERSION: Preimage of a basic open ray under the function t^2/(t^2+(t-1)^2) is open in the standard topology on R. **)
(** SUSPICIOUS THEOREM: This mid lemma is admitted; proving it directly requires an openness argument for a quadratic inequality (hence continuity of multiplication in the order topology on R).  Until this is proved, normalize01_fun_continuous remains recursively admitted. **)
(** ABY: try_aby at line 117526 column 1 FAIL (vampire failed) **)
Theorem normalize01_fun_preimage_open_ray_lower_mid : forall b:set,
  b :e R -> ~(Rlt 1 b) -> Rlt 0 b ->
  preimage_of R normalize01_fun (open_ray_lower R b) :e R_standard_topology.
admit.
Qed.
Theorem normalize01_fun_preimage_open_ray_lower : forall b:set,
  b :e R -> preimage_of R normalize01_fun (open_ray_lower R b) :e R_standard_topology.
admit.
Qed.
Theorem normalize01_fun_continuous :
  continuous_map R R_standard_topology R R_standard_topology normalize01_fun.
admit.
Qed.
Theorem normalize01_fun_continuous_to_unit_interval :
  continuous_map R R_standard_topology unit_interval unit_interval_topology normalize01_fun.
admit.
Qed.

(** helper: graphs into R^J as points of power_real J **)
Theorem graph_to_R_in_power_real : forall J:set, forall g:set->set,
  (forall j:set, j :e J -> g j :e R) ->
  graph J g :e power_real J.
admit.
Qed.

(** helper: diagonal_map is a function X -> R^J when F:J->(X->R) is total **)
Theorem diagonal_map_function_on_power_real : forall X F J:set,
  total_function_on F J (function_space X R) ->
  function_on (diagonal_map X F J) X (power_real J).
admit.
Qed.

(** helper: graphs into [0,1]^J as points of unit_interval_power J **)
Theorem graph_to_unit_interval_in_unit_interval_power : forall J:set, forall g:set->set,
  (forall j:set, j :e J -> g j :e unit_interval) ->
  graph J g :e unit_interval_power J.
admit.
Qed.

(** helper: diagonal_map is a function X -> [0,1]^J when F:J->(X->[0,1]) is total **)
Theorem diagonal_map_function_on_unit_interval_power : forall X F J:set,
  total_function_on F J (function_space X unit_interval) ->
  function_on (diagonal_map X F J) X (unit_interval_power J).
admit.
Qed.

(** helper: continuity of the diagonal map into a unit_interval cube for nonempty index sets **)
Theorem diagonal_map_continuous_unit_interval_power : forall X Tx F J:set,
  topology_on X Tx ->
  J <> Empty ->
  total_function_on F J (function_space X unit_interval) ->
  (forall j:set, j :e J -> continuous_map X Tx unit_interval unit_interval_topology (apply_fun F j)) ->
  continuous_map X Tx (unit_interval_power J)
    (product_topology_full J (const_space_family J unit_interval unit_interval_topology))
    (diagonal_map X F J).
admit.
Qed.

(** helper: -power of R equals the previously defined R^ product space **)
(** LATEX VERSION: Identify ^ with the earlier `R_omega_space` definition. **)
Theorem power_real_omega_eq_Romega_space : power_real omega = R_omega_space.
admit.
Qed.

(** helper: -power of [0,1] as a product space **)
(** LATEX VERSION: Identify [0,1]^ with the corresponding product space. **)
Theorem unit_interval_power_omega_def :
  unit_interval_power omega = product_space omega (const_space_family omega unit_interval unit_interval_topology).
admit.
Qed.
Definition metrizable : set -> set -> prop := fun X Tx =>
  exists d:set, metric_on X d /\ metric_topology X d = Tx.

(** helper: R^omega in the product topology is metrizable (via the D metric) **)
(** LATEX VERSION: The standard D metric induces the product topology on R^omega, hence R^omega is metrizable. **)
Theorem Romega_product_topology_metrizable :
  metrizable R_omega_space R_omega_product_topology.
admit.
Qed.

(** from 30 Example 4: product of Lindelf spaces need not be Lindelf **) 
(** LATEX VERSION: The product of two Lindelf Sorgenfrey lines (the Sorgenfrey plane) is not Lindelf. **)
(** from 30 Example 4: define L subset of the Sorgenfrey plane **)
(** LATEX VERSION: L = { x  (-x) | x  R_l }. **)
Definition Sorgenfrey_plane_L : set :=
  {(x, minus_SNo x)|x :e Sorgenfrey_line}.

(** from 30 Example 4: special basis rectangles **)
(** LATEX VERSION: Basis elements of the form [a,b)  [-a,d). **)
Definition Sorgenfrey_plane_special_rectangle : set -> set -> set -> set :=
  fun a b d => rectangle_set (halfopen_interval_left a b) (halfopen_interval_left (minus_SNo a) d).

(** helper: special rectangles are open in the Sorgenfrey plane **)
Theorem Sorgenfrey_plane_special_rectangle_open : forall a b d:set,
  a :e R -> b :e R -> d :e R ->
  Sorgenfrey_plane_special_rectangle a b d :e Sorgenfrey_plane_topology.
admit.
Qed.

(** helper: L is uncountable **)
Theorem Sorgenfrey_plane_L_uncountable : ~ countable_set Sorgenfrey_plane_L.
admit.
Qed.

(** helper: if (x,-x) lies in [a,b)[-a,d), then x=a **)
Theorem Sorgenfrey_plane_special_rectangle_L_point : forall a b d x:set,
  a :e R -> b :e R -> d :e R -> x :e R ->
  (x, minus_SNo x) :e Sorgenfrey_plane_special_rectangle a b d ->
  x = a.
admit.
Qed.

(** helper: extensionality for 2-tuples **)
Theorem tuple_2_ext : forall a b c d:set,
  a = c -> b = d -> (a,b) = (c,d).
admit.
Qed.

(** from 30 Example 4: L is closed in the Sorgenfrey plane **)
(** LATEX VERSION: L is closed in the Sorgenfrey plane. **)
Theorem Sorgenfrey_plane_L_closed :
  closed_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology Sorgenfrey_plane_L.
admit.
Qed.

(** from 30 Example 4: Sorgenfrey plane not Lindelof **)
(** LATEX VERSION: The Sorgenfrey plane is not Lindelf. **)
Theorem Sorgenfrey_plane_not_Lindelof :
  ~ Lindelof_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** from 30 Example 5: subspace of Lindelf space need not be Lindelf **) 
(** LATEX VERSION: A subspace of a Lindelf space can fail to be Lindelf (ordered square strip example). **)
(** Helper: the ordered square is Lindelf **)
(** LATEX VERSION: The ordered square is Lindelf (standard result for this example). **)
(** NOTE: This is a standard but nontrivial example proof; we keep the proof attempt as a sketch but axiomatize the statement to avoid recursive-admit noise. **)
Axiom ordered_square_Lindelof : Lindelof_space ordered_square ordered_square_topology.
Theorem ordered_square_Lindelof_sketch : Lindelof_space ordered_square ordered_square_topology.
admit.
Qed.

(** Helper: the open strip subspace is not Lindelf **)
(** LATEX VERSION: The vertical strip subspace in the ordered square fails to be Lindelf. **)
(** NOTE: Same status as above. **)
Axiom ordered_square_open_strip_not_Lindelof :
  ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
Theorem ordered_square_open_strip_not_Lindelof_sketch :
  ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
admit.
Qed.
Theorem ordered_square_subspace_not_Lindelof :
  Lindelof_space ordered_square ordered_square_topology /\
  ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
admit.
Qed.

(** from 31 Lemma 31.1: closure-neighborhood reformulations of regular/normal **) 
(** LATEX VERSION: Lemma 31.1: characterizations of regular/normal via closures and neighborhoods (assuming T1). **)
Theorem regular_normal_via_closure : forall X Tx:set,
  topology_on X Tx ->
  (one_point_sets_closed X Tx -> (regular_space X Tx <->
     forall x U:set, x :e X -> U :e Tx -> x :e U -> exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U)) /\
  (one_point_sets_closed X Tx -> (normal_space X Tx <->
     forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U -> exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U)).
admit.
Qed.

	(** Helper: regular spaces admit closure-shrinking neighborhoods (used in product regularity proofs). **)
Theorem regular_space_shrink_neighborhood : forall X Tx x U:set,
		  regular_space X Tx ->
		  x :e X ->
		  U :e Tx ->
		  x :e U ->
		  exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
admit.
Qed.

		(** Helper: normal spaces admit closure-shrinking open neighborhoods of closed subsets. **)
		(** LATEX VERSION: If X is normal and A is closed with A  U (U open), then there exists open V with A  V and closure(V)  U. **)
Theorem normal_space_shrink_closed : forall X Tx A U:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  U :e Tx ->
  A c= U ->
  exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
admit.
Qed.

(** helper: shrink a closed set using a 2-open cover, keeping the remainder inside the second open set **)
Theorem normal_space_shrink_closed_cover2 : forall X Tx A U V:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  U :e Tx ->
  V :e Tx ->
  A c= U :\/: V ->
  exists U0:set,
    U0 :e Tx /\
    (A :\: V) c= U0 /\
    closure_of X Tx U0 c= U /\
    (A :\: U0) c= V.
admit.
Qed.

(** Helper: product of regular spaces is regular (binary product topology). **)
(** LATEX VERSION: The product of regular spaces is regular (Theorem 31.2, product clause). **)
Theorem product_topology_regular : forall X Tx Y Ty:set,
  regular_space X Tx -> regular_space Y Ty ->
  regular_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

	(** Helper for products used in 31. **)
	(** Helper: distinct points in a product differ in some coordinate. **)
Theorem product_space_points_differ_coord : forall I Xi x1 x2:set,
	  x1 :e product_space I Xi ->
  x2 :e product_space I Xi ->
  x1 <> x2 ->
  exists i:set, i :e I /\ apply_fun x1 i <> apply_fun x2 i.
admit.
Qed.

(** Helper: closure of a cylinder stays inside the cylinder of the coordinate closure. **)
Theorem closure_of_product_cylinder_sub : forall I Xi i V U:set,
  I <> Empty ->
  (forall j:set, j :e I -> topology_on (space_family_set Xi j) (space_family_topology Xi j)) ->
  i :e I ->
  V :e space_family_topology Xi i ->
  U :e space_family_topology Xi i ->
  closure_of (space_family_set Xi i) (space_family_topology Xi i) V c= U ->
  closure_of (product_space I Xi) (product_topology_full I Xi) (product_cylinder I Xi i V)
    c= product_cylinder I Xi i U.
admit.
Qed.

(** from 31 Theorem 31.2 (products): Hausdorff part **) 
(** LATEX VERSION: Hausdorff/regular properties preserved under subspaces and products (with factorwise assumptions). **)
Theorem product_topology_full_Hausdorff_axiom : forall I Xi:set,
  Hausdorff_spaces_family I Xi ->
  Hausdorff_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

(** from 31 Theorem 31.2 (products): regular part **) 
(** LATEX VERSION: Hausdorff/regular properties preserved under subspaces and products (with factorwise assumptions). **)
Theorem product_topology_full_regular_axiom : forall I Xi:set,
  regular_spaces_family I Xi ->
  regular_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.
Theorem separation_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> Hausdorff_space X Tx -> Hausdorff_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
  (forall Y:set, Y c= X -> regular_space X Tx -> regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
admit.
Qed.

(** from 31 Example 1 setup: R_K space **) 
(** LATEX VERSION: Let R_K denote the real line equipped later with the K-topology. **)
Definition R_K : set := R.

(** from 31 Example 1: R_K Hausdorff but not regular **) 
(** LATEX VERSION: The K-topology on  is Hausdorff but not regular. **)
(** Helper for RK_not_regular_axiom: an open neighborhood of a point of K_set meets the complement of K_set inside any ambient open interval. **)
(** SUSPICIOUS THEOREM: This is true because open intervals contain points other than the finitely many K_set points between endpoints; a full proof needs explicit control of K_set spacing (via inv_nat monotonicity) and density of reals/rationals. **)
Theorem K_set_point_has_nonK_neighbor_in_intersection :
  forall a b c d y:set,
    a :e R -> b :e R -> c :e R -> d :e R ->
    y :e K_set ->
    y :e open_interval a b ->
    y :e open_interval c d ->
    exists z:set, z :e (open_interval a b :/\: open_interval c d) /\ z /:e K_set.
admit.
Qed.
Theorem RK_not_regular_axiom : ~ regular_space R_K R_K_topology.
admit.
Qed.
Theorem RK_Hausdorff_not_regular :
  Hausdorff_space R_K R_K_topology /\ ~ regular_space R_K R_K_topology.
admit.
Qed.

(** from 31 Example 2: Sorgenfrey line normal **) 
(** LATEX VERSION: The Sorgenfrey line is normal. **)
  (** helper: the Sorgenfrey line is regular **)
  (** LATEX VERSION: The Sorgenfrey line is regular (points and closed sets separated by disjoint half open intervals). **)
Theorem Sorgenfrey_line_regular : regular_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** NOTE: Theorem `Sorgenfrey_line_normal` is proved later, after 32.4 infrastructure becomes available. **)

(** from 31 Exercise 9: Sorgenfrey plane rational/irrational diagonal non-separation **)
(** LATEX VERSION: In _, let A = {x  (-x) | x rational}, B = {x  (-x) | x irrational}. No open sets separate A and B. **)
(** NOTE: Moved here so it can be used in 31 Example 3 (`Sorgenfrey_plane_not_normal`). **)
(** Diagonal sets in the Sorgenfrey plane used in this exercise. **)
Definition Sorgenfrey_plane_diag_rational : set :=
  {(x, minus_SNo x) | x :e rational_numbers}.
Definition Sorgenfrey_plane_diag_irrational : set :=
  {(x, minus_SNo x) | x :e (Sorgenfrey_line :\: rational_numbers)}.

(** helper: rational and irrational diagonals are disjoint **)
Theorem Sorgenfrey_plane_diag_disjoint :
  Sorgenfrey_plane_diag_rational :/\: Sorgenfrey_plane_diag_irrational = Empty.
admit.
Qed.

(** Diagonal sets are closed in the Sorgenfrey plane (needed for non-normality). **)
Theorem Sorgenfrey_plane_diag_rational_closed :
  closed_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology Sorgenfrey_plane_diag_rational.
admit.
Qed.
Theorem Sorgenfrey_plane_diag_irrational_closed :
  closed_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology Sorgenfrey_plane_diag_irrational.
admit.
Qed.

(** from 31 Example 3 (part): L has the discrete topology as a subspace of the Sorgenfrey plane **)
(** LATEX VERSION: L = {x(-x)} is a closed discrete subspace of R_l^2. **)
Theorem Sorgenfrey_plane_L_subspace_discrete :
  subspace_topology (setprod Sorgenfrey_line Sorgenfrey_line)
                    Sorgenfrey_plane_topology
                    Sorgenfrey_plane_L
  = discrete_topology Sorgenfrey_plane_L.
admit.
Qed.

(** helper: injections lift to power sets via images **)
Theorem inj_Power_image : forall A B:set, forall f:set->set,
  inj A B f ->
  inj (Power A) (Power B) (fun S:set => {f x|x :e S}).
admit.
Qed.
Theorem ex31_9_Sorgenfrey_plane_no_separation :
  ~ (exists U V:set,
      open_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology U /\
      open_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology V /\
      Sorgenfrey_plane_diag_rational c= U /\
      Sorgenfrey_plane_diag_irrational c= V /\
      U :/\: V = Empty).
admit.
Qed.

(** from 31 Example 3: Sorgenfrey plane not normal **) 
(** LATEX VERSION: The Sorgenfrey plane is regular but not normal. **)
Theorem Sorgenfrey_plane_not_normal :
  regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** helper: if a set injects into omega, then the preimage of a finite initial segment is finite **)
(** LATEX VERSION: A subset of a finite set is finite; hence for an injection f:A, the set of a with f(a)n is finite. **)
Theorem inj_omega_preimage_ordsucc_finite : forall A n:set, forall f:set->set,
  nat_p n ->
  inj A omega f ->
  finite {a :e A | f a :e ordsucc n}.
admit.
Qed.

(** helper: union of the empty family is empty **)
(** LATEX VERSION: Union of the empty family of sets is empty. **)
Theorem Union_Empty_eq : Union Empty = Empty.
admit.
Qed.

(** helper: Union(F  {y}) = Union(F)  y **)
(** LATEX VERSION: Union distributes over adjoining a singleton to the index family. **)
Theorem Union_binunion_singleton_eq : forall F y:set,
  Union (F :\/: {y}) = (Union F) :\/: y.
admit.
Qed.

(** helper: finite unions of closed sets are closed **)
(** LATEX VERSION: A finite union of closed sets is closed. **)
Theorem finite_union_closed_in : forall X Tx F:set,
  topology_on X Tx ->
  finite F ->
  (forall C:set, C :e F -> closed_in X Tx C) ->
  closed_in X Tx (Union F).
admit.
Qed.

(** from 32 Theorem 32.1: regular space with countable basis is normal **) 
(** LATEX VERSION: Regular + second countable  normal (Theorem 32.1). **)
Theorem regular_countable_basis_normal : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> normal_space X Tx.
admit.
Qed.

	(** helper for 32: right-closed order interval **)
	(** LATEX VERSION: The half-open interval (x,y] is the set of z with x<zy (in an ordered set). **)
	Definition order_interval_right_closed : set -> set -> set -> set := fun X x y =>
	  {z :e X | order_rel X x z /\ (z = y \/ order_rel X z y)}.

	(** helper: (x,y] equals (x, succ(y)) in well-ordered carriers, hence is open **)
Theorem order_interval_right_closed_open : forall X x y:set,
		  well_ordered_set X ->
		  simply_ordered_set X ->
		  x :e X ->
		  y :e X ->
		  order_rel X x y ->
		  order_interval_right_closed X x y :e order_topology X.
admit.
Qed.

			(** helper for 32 Thm 32.4: basis neighborhoods contain some (x,a] when a is not 0 **)
			(** LATEX VERSION: A basis element about a contains an interval (x,a] for some x<a, provided a is not the least element. **)
Theorem order_topology_basis_contains_right_closed_interval : forall X b a:set,
			  well_ordered_set X ->
			  simply_ordered_set X ->
			  a :e X ->
			  ~(a = 0) ->
			  b :e order_topology_basis X ->
			  a :e b ->
			  exists x :e X, order_rel X x a /\ order_interval_right_closed X x a c= b.
admit.
Qed.
			
			(** helper for 32 Thm 32.4: open neighborhoods contain basis elements **)
			(** LATEX VERSION: If U is open in the order topology and yU, then y lies in some basis element bU. **)
Theorem order_topology_local_basis_elem : forall X U y:set,
		  simply_ordered_set X ->
		  U :e order_topology X ->
		  y :e U ->
		  exists b :e order_topology_basis X, y :e b /\ b c= U.
admit.
Qed.

		(** from 32 Theorem 32.4: well-ordered sets are normal in order topology **) 
		(** LATEX VERSION: Well-ordered sets with the order topology are normal. **)
			(** ORDER NOTE: Placed before the special cases since Megalodon disallows forward references. **)
			(** Helper: remaining main case for Thm 32.4 when 0 is in neither closed set **)
			(** LATEX VERSION: Separate A and B by choosing local right-closed neighborhoods (x,a] inside UB and then assembling disjoint open unions. **)
Theorem well_ordered_sets_normal_case_nonzero : forall X A B UB VA:set,
				  well_ordered_set X ->
				  simply_ordered_set X ->
				  topology_on X (order_topology X) ->
				  closed_in X (order_topology X) A ->
				  closed_in X (order_topology X) B ->
				  A :/\: B = Empty ->
				  A <> Empty ->
				  B <> Empty ->
				  UB :e order_topology X ->
				  B = X :\: UB ->
				  VA :e order_topology X ->
				  A = X :\: VA ->
				  ~(0 :e A) ->
				  ~(0 :e B) ->
				  exists U V:set, U :e order_topology X /\ V :e order_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
admit.
Qed.
		(** Helper: special case for Thm 32.4 when 0 belongs to A **)
		(** LATEX VERSION: If 0 is in one closed set, separate it off using a clopen singleton neighborhood. **)
Theorem well_ordered_sets_normal_case_0_in_A : forall X A B:set,
				  well_ordered_set X ->
				  simply_ordered_set X ->
				  closed_in X (order_topology X) A ->
				  closed_in X (order_topology X) B ->
				  A :/\: B = Empty ->
				  A <> Empty ->
				  B <> Empty ->
				  0 :e A ->
				  exists U V:set, U :e order_topology X /\ V :e order_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
admit.
Qed.

		(** Helper: special case for Thm 32.4 when 0 belongs to B **)
		(** LATEX VERSION: Symmetric to the 0-in-A case. **)
Theorem well_ordered_sets_normal_case_0_in_B : forall X A B:set,
				  well_ordered_set X ->
				  simply_ordered_set X ->
				  closed_in X (order_topology X) A ->
				  closed_in X (order_topology X) B ->
				  A :/\: B = Empty ->
				  A <> Empty ->
				  B <> Empty ->
				  0 :e B ->
				  exists U V:set, U :e order_topology X /\ V :e order_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
admit.
Qed.
Theorem well_ordered_sets_normal : forall X:set,
		  well_ordered_set X ->
	  simply_ordered_set X ->
	  normal_space X (order_topology X).
admit.
Qed.
(** helper: sup of negated distances from a point to a set **)
(** LATEX VERSION: For a metric d, consider the set { -d(x,a) | aA } and take its least upper bound in . **)
Definition metric_sup_neg_dists : set -> set -> set -> set -> set := fun X d x A =>
  Eps_i (fun l:set => R_lub (metric_neg_dists X d x A) l).

(** helper: nonempty set of negated distances has a least upper bound **)
Theorem metric_sup_neg_dists_is_lub : forall X d x A:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  A <> Empty ->
  R_lub (metric_neg_dists X d x A) (metric_sup_neg_dists X d x A).
admit.
Qed.

(** helper: distance from point to set, defined as inf via negated sup **)
(** LATEX VERSION: The distance from x to A is inf{ d(x,a) | aA }, implemented here as minus of the sup of negated distances. **)
Definition metric_dist_to_set : set -> set -> set -> set -> set := fun X d x A =>
  minus_SNo (metric_sup_neg_dists X d x A).

(** helper: metric_dist_to_set is real when the set is nonempty **)
Theorem metric_dist_to_set_in_R : forall X d x A:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  A <> Empty ->
  metric_dist_to_set X d x A :e R.
admit.
Qed.

(** helper: distance to a set is zero for points in the set **)
Theorem metric_dist_to_set_eq_0_if_mem : forall X d x A:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  x :e A ->
  metric_dist_to_set X d x A = 0.
admit.
Qed.

(** helper: double negation on real numbers **)
Theorem minus_SNo_minus_SNo_real : forall t:set, t :e R -> minus_SNo (minus_SNo t) = t.
admit.
Qed.

(** helper: distance to set is bounded by distance to a member **)
Theorem metric_dist_to_set_le_dist : forall X d x A a:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  A <> Empty ->
  a :e A ->
  Rle (metric_dist_to_set X d x A) (apply_fun d (x,a)).
admit.
Qed.

(** helper: approximate a minimizer for distance to a nonempty set **)
Theorem metric_dist_to_set_approx : forall X d x A eps:set,
  metric_on X d ->
  x :e X ->
  A c= X ->
  A <> Empty ->
  eps :e R -> Rlt 0 eps ->
  exists a:set, a :e A /\ a :e X /\
    Rlt (apply_fun d (x,a)) (add_SNo (metric_dist_to_set X d x A) eps).
admit.
Qed.

(** helper: distance to a set is 1-Lipschitz in a metric space **)
Theorem metric_dist_to_set_Lipschitz : forall X d x y A:set,
  metric_on X d ->
  x :e X -> y :e X ->
  A c= X -> A <> Empty ->
  Rle (metric_dist_to_set X d y A)
      (add_SNo (metric_dist_to_set X d x A) (apply_fun d (x,y))).
admit.
Qed.

(** helper: point outside a closed set has positive distance to the set in metric topology **)
Theorem metric_dist_to_closed_set_pos_if_not_mem : forall X d B x:set,
  metric_on X d ->
  closed_in X (metric_topology X d) B ->
  x :e X ->
  x /:e B ->
  B <> Empty ->
  Rlt 0 (metric_dist_to_set X d x B).
admit.
Qed.

(** from 32 Theorem 32.2: metrizable spaces are normal **) 
(** LATEX VERSION: Every metrizable space is normal. **)
Theorem metrizable_spaces_normal : forall X d:set,
  metric_on X d -> normal_space X (metric_topology X d).
admit.
Qed.

(** from 32 Theorem 32.3: compact Hausdorff spaces are normal **) 
(** LATEX VERSION: Compact Hausdorff  normal (Theorem 32.3). **)
Theorem compact_Hausdorff_normal : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
admit.
Qed.

(** from 32 Example 1: uncountable product of R not normal **) 
(** LATEX VERSION: An uncountable product of  with product topology need not be normal. **)
Axiom uncountable_product_R_not_normal : forall J:set,
	  uncountable_set J ->
	  ~ normal_space (product_space J (const_space_family J R R_standard_topology))
	                 (product_topology_full J (const_space_family J R R_standard_topology)).

(** from 32 Example 2: SOmega x SbarOmega not normal **)
(** LATEX VERSION: Product S_S_ gives a non-normal example. **)
(** FIXED: Use abstract placeholders matching topology.tex: S_Omega is an uncountable well-ordered set and Sbar_Omega is S_Omega with one new point adjoined. **)
(** NOTE: We model the point Omega by adjoining S_Omega itself; by In_irref we have S_Omega /:e S_Omega, so this really adds a new element. **)
Axiom exists_uncountable_well_ordered_set : exists X:set,
  well_ordered_set X /\ uncountable_set X /\ countable_subsets_bounded X.

(** helper: extract an uncountable ordinal from an uncountable well-orderable set **)
(** LATEX VERSION: Any uncountable well-ordered set has order type given by an uncountable ordinal. **)
Theorem exists_uncountable_ordinal : exists alpha:set, ordinal alpha /\ uncountable_set alpha.
admit.
Qed.

(** Choose S_Omega as an uncountable ordinal (hence well-ordered by membership). **)
(** LATEX VERSION: Fix an uncountable well-ordered set S_Omega (often taken as an uncountable ordinal). **)
Definition S_Omega : set := Eps_i (fun X:set => well_ordered_set X /\ uncountable_set X /\ countable_subsets_bounded X).
Theorem S_Omega_well_ordered_uncountable : well_ordered_set S_Omega /\ uncountable_set S_Omega.
admit.
Qed.

(** helper: S_Omega is not a real number **)
(** LATEX VERSION: The uncountable ordinal S_ is not an element of . **)
Theorem S_Omega_notin_R : S_Omega /:e R.
admit.
Qed.

(** helper: countable subsets of S_Omega are bounded in the membership order **)
(** LATEX VERSION: In S_, every countable subset has an upper bound in S_. **)
Theorem S_Omega_countable_subsets_bounded : countable_subsets_bounded S_Omega.
admit.
Qed.

(** helper: any omega-indexed family in S_Omega has an upper bound in S_Omega **)
(** LATEX VERSION: Any countable subset of S_ is bounded above in S_; in particular, any sequence has an upper bound. **)
Theorem S_Omega_omega_family_has_upper_bound : forall seq:set,
  function_on seq omega S_Omega ->
  exists b:set, b :e S_Omega /\ forall n:set, n :e omega -> apply_fun seq n :e b.
admit.
Qed.
Theorem S_Omega_ordinal_uncountable : ordinal S_Omega /\ uncountable_set S_Omega.
admit.
Qed.
(** LATEX VERSION: Define Sbar_Omega by adjoining one new point to S_Omega (successor of the ordinal). **)
Definition Sbar_Omega : set := SetAdjoin S_Omega S_Omega.
(** helper: Sbar_Omega is the ordinal successor of S_Omega **)
(** LATEX VERSION: \\bar S_\\Omega is obtained by adjoining one new point above all points of S_\\Omega; for an ordinal, this is the successor ordinal. **)
Theorem Sbar_Omega_eq_ordsucc : Sbar_Omega = ordsucc S_Omega.
admit.
Qed.

(** helper: Sbar_Omega is an ordinal (hence a simply ordered set under membership) **)
(** LATEX VERSION: If S_\\Omega is an ordinal, then its successor is also an ordinal. **)
Theorem Sbar_Omega_ordinal : ordinal Sbar_Omega.
admit.
Qed.

(** helper: Sbar_Omega is within the simply_ordered_set scope **)
(** LATEX VERSION: Ordinals are simply ordered by membership. **)
Theorem simply_ordered_set_Sbar_Omega : simply_ordered_set Sbar_Omega.
admit.
Qed.
(** helper: S_Omega is a subset of Sbar_Omega **)
Theorem S_Omega_Subq_Sbar_Omega : S_Omega c= Sbar_Omega.
admit.
Qed.

(** helper: the adjoined point Omega (represented by S_Omega) is in Sbar_Omega **)
Theorem S_Omega_in_Sbar_Omega : S_Omega :e Sbar_Omega.
admit.
Qed.

(** helper: Sbar_Omega is uncountable **)
(** LATEX VERSION: S_ is uncountable since it contains an uncountable subset S_. **)
Theorem Sbar_Omega_uncountable : uncountable_set Sbar_Omega.
admit.
Qed.

(** helper: Sbar_Omega is not equal to R **)
(** LATEX VERSION: S_   since S_  S_ but S_  . **)
Theorem Sbar_Omega_neq_R : Sbar_Omega <> R.
admit.
Qed.

(** helper: Sbar_Omega is not equal to rational_numbers **)
(** LATEX VERSION: S_   since S_ is uncountable. **)
Theorem Sbar_Omega_neq_rational_numbers : Sbar_Omega <> rational_numbers.
admit.
Qed.

(** helper: Sbar_Omega is not equal to setprod 2 omega **)
(** LATEX VERSION: S_  2 since 2 is countable while S_ is uncountable. **)
Theorem Sbar_Omega_neq_setprod_2_omega : Sbar_Omega <> setprod 2 omega.
admit.
Qed.

(** helper: Sbar_Omega is not equal to RR **)
(** LATEX VERSION: S_   (used only to fit the `well_ordered_set` packaging). **)
(** helper: {1} is an element of  (as the pair (0,1)) **)
(** LATEX VERSION: (0,1)   and (0,1) = {1}. **)
Theorem Sing1_in_setprod_R_R : {1} :e setprod R R.
admit.
Qed.

(** helper:  is not an ordinal (it contains {1}, which is not ordinal) **)
(** LATEX VERSION:  is not well-ordered by  as an ordinal would be. **)
Theorem not_ordinal_setprod_R_R : ~ ordinal (setprod R R).
admit.
Qed.
Theorem Sbar_Omega_neq_setprod_R_R : Sbar_Omega <> setprod R R.
admit.
Qed.

(** helper: Sbar_Omega satisfies the packaged `well_ordered_set` predicate **)
(** LATEX VERSION: S_ is an ordinal (hence well-ordered by ) and is distinct from the special-case carriers used in `order_rel`. **)
Theorem Sbar_Omega_well_ordered_set : well_ordered_set Sbar_Omega.
admit.
Qed.

(** helper: S_Omega satisfies the packaged `well_ordered_set` predicate **)
(** LATEX VERSION: S_ is an uncountable well-ordered set (modeled as an ordinal distinct from special carriers). **)
Theorem S_Omega_well_ordered_set : well_ordered_set S_Omega.
admit.
Qed.

(** helper: S_Omega is a simply ordered set (ordinal case) **)
(** LATEX VERSION: Any ordinal is simply ordered by membership. **)
Theorem simply_ordered_set_S_Omega : simply_ordered_set S_Omega.
admit.
Qed.

(** helper: S_Omega is transitive (as an ordinal) **)
(** LATEX VERSION: Every ordinal is a transitive set. **)
Theorem S_Omega_TransSet : TransSet S_Omega.
admit.
Qed.

(** helper: S_Omega is convex in Sbar_Omega (both under membership order) **)
(** LATEX VERSION: If a<b are in S_, then every point between them in \\bar S_ lies in S_. **)
Theorem convex_in_Sbar_Omega_S_Omega : convex_in Sbar_Omega S_Omega.
admit.
Qed.

(** helper: order-interval subsets of S_Omega do not depend on whether order_rel is computed in S_Omega or Sbar_Omega **)
(** LATEX VERSION: On ordinals, the order relation is membership, so inherited and intrinsic intervals coincide. **)
Theorem SOmega_interval_eq_inherited : forall a b:set,
  a :e S_Omega -> b :e S_Omega ->
  {x :e S_Omega | order_rel S_Omega a x /\ order_rel S_Omega x b}
  =
  {x :e S_Omega | order_rel Sbar_Omega a x /\ order_rel Sbar_Omega x b}.
admit.
Qed.

(** helper: left rays on S_Omega are the same whether computed in S_Omega or inherited from Sbar_Omega **)
(** LATEX VERSION: For ordinals, {x | x<b} is absolute between S_ and \\bar S_ when bS_. **)
Theorem SOmega_left_ray_eq_inherited : forall b:set,
  b :e S_Omega ->
  {x :e S_Omega | order_rel S_Omega x b}
  =
  {x :e S_Omega | order_rel Sbar_Omega x b}.
admit.
Qed.

(** helper: right rays on S_Omega are the same whether computed in S_Omega or inherited from Sbar_Omega **)
(** LATEX VERSION: For ordinals, {x | a<x} is absolute between S_ and \\bar S_ when aS_. **)
Theorem SOmega_right_ray_eq_inherited : forall a:set,
  a :e S_Omega ->
  {x :e S_Omega | order_rel S_Omega a x}
  =
  {x :e S_Omega | order_rel Sbar_Omega a x}.
admit.
Qed.

(** helper: the inherited order topology basis on S_Omega from Sbar_Omega equals the intrinsic order topology basis on S_Omega **)
(** LATEX VERSION: For ordinals, the order relation is membership, so the inherited interval and ray basis on S_ matches the intrinsic basis. **)
Theorem SOmega_order_topology_basis_inherited_eq :
  order_topology_basis_inherited Sbar_Omega S_Omega = order_topology_basis S_Omega.
admit.
Qed.

(** LATEX VERSION: Both spaces are given the order topology. **)
Definition SOmega_topology : set := order_topology S_Omega.
Definition SbarOmega_topology : set := order_topology Sbar_Omega.

(** helper: SOmega_topology is the subspace topology inherited from SbarOmega_topology **)
(** LATEX VERSION: Since S_ is convex in \\bar S_, the order topology on S_ equals the subspace topology inherited from \\bar S_. **)
Theorem SOmega_topology_eq_subspace_SbarOmega :
  SOmega_topology = subspace_topology Sbar_Omega SbarOmega_topology S_Omega.
admit.
Qed.

(** from 33 Example 1 cont.: normality of the factors S_ and S_ **)
(** LATEX VERSION: Both S_ and S_ are normal spaces in their order topologies. **)
Theorem SOmega_SbarOmega_factors_normal :
  normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology.
admit.
Qed.

(** from 33 Example 1 cont.: Tychonoff plank non-normality **)
(** LATEX VERSION: The product S_  S_ with the product of the order topologies is not normal (Tychonoff plank). **)
Theorem SOmega_SbarOmega_product_not_normal :
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
admit.
Qed.
Theorem SOmega_SbarOmega_not_normal :
  normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
admit.
Qed.

(** from 33 Theorem 33.1 (Urysohn lemma): continuous function separating closed sets in normal space **)
(** LATEX VERSION: Urysohn lemma: In a normal space, disjoint closed sets can be separated by continuous f: X[a,b]. **)
(** FIXED: Urysohn_lemma includes separation conditions f|A = a and f|B = b, not merely existence of some continuous f. **) 
Definition closed_interval : set -> set -> set := fun a b =>
  {x :e R | ~(Rlt x a) /\ ~(Rlt b x)}.

(** Helper: topology on [a,b] is the subspace topology inherited from the standard topology on R **)
(** LATEX VERSION: The interval [a,b] carries the subspace topology inherited from the standard topology on R. **)
Definition closed_interval_topology : set -> set -> set := fun a b =>
  subspace_topology R R_standard_topology (closed_interval a b).

(** helper: closed_interval is a subset of R **)
Theorem closed_interval_sub_R : forall a b:set, closed_interval a b c= R.
admit.
Qed.

(** helper: membership in closed_interval gives the endpoint inequalities **)
Theorem closed_interval_bounds : forall a b x:set,
  a :e R -> b :e R ->
  x :e closed_interval a b ->
  Rle a x /\ Rle x b.
admit.
Qed.

(** helper: build membership in closed_interval from endpoint inequalities **)
Theorem closed_intervalI_of_Rle : forall a b x:set,
  a :e R -> b :e R -> x :e R ->
  Rle a x -> Rle x b ->
  x :e closed_interval a b.
admit.
Qed.

(** helper: if x is not in [a,b] then x<a or b<x **)
Theorem closed_interval_not_mem_cases : forall a b x:set,
  a :e R -> b :e R -> x :e R ->
  x /:e closed_interval a b ->
  Rlt x a \/ Rlt b x.
admit.
Qed.

(** helper: closed_interval_topology is a topology on closed_interval **)
Theorem closed_interval_topology_on : forall a b:set,
  topology_on (closed_interval a b) (closed_interval_topology a b).
admit.
Qed.

(** helper: endpoints lie in closed_interval when a<=b **)
Theorem left_endpoint_in_closed_interval : forall a b:set,
  Rle a b -> a :e closed_interval a b.
admit.
Qed.
Theorem right_endpoint_in_closed_interval : forall a b:set,
  Rle a b -> b :e closed_interval a b.
admit.
Qed.

(** helper: degenerate closed_interval has only the endpoint **)
Theorem closed_interval_degenerate : forall a y:set,
  a :e R -> y :e closed_interval a a -> y = a.
admit.
Qed.

(** helper: closed_interval is closed in the standard topology on R **)
Theorem closed_interval_closed_in_R_standard_topology : forall a b:set,
  a :e R -> b :e R -> closed_in R R_standard_topology (closed_interval a b).
admit.
Qed.

(** helper: a closed interval is closed in any closed_interval subspace topology by intersection **)
Theorem closed_interval_closed_in_closed_interval_topology : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  closed_in (closed_interval a b) (closed_interval_topology a b) ((closed_interval c d) :/\: (closed_interval a b)).
admit.
Qed.

(** helper for 33 Urysohn lemma: extend a nested family by one point **)
(** LATEX VERSION: Given finitely many indices with nested closures, insert a new index r by shrinking between the lower-closure union and upper open intersection. **)
Theorem normal_extend_nested_open_family_by_point :
  forall X Tx:set, normal_space X Tx ->
  forall F:set, finite F -> F c= R ->
  forall Uof:set->set,
    (forall p:set, p :e F -> Uof p :e Tx) ->
    (forall p q:set, p :e F -> q :e F -> Rlt p q -> closure_of X Tx (Uof p) c= Uof q) ->
  forall r:set, r :e R ->
    exists Ur:set, Ur :e Tx /\
      (forall p:set, p :e F -> Rlt p r -> closure_of X Tx (Uof p) c= Ur) /\
      (forall q:set, q :e F -> Rlt r q -> closure_of X Tx Ur c= Uof q).
admit.
Qed.
Theorem Urysohn_lemma : forall X Tx A B a b:set,
  Rle a b ->
  normal_space X Tx -> closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
  exists f:set, continuous_map X Tx (closed_interval a b) (closed_interval_topology a b) f /\
    (forall x:set, x :e A -> apply_fun f x = a) /\
    (forall x:set, x :e B -> apply_fun f x = b).
admit.
Qed.

(** from 33 Definition: completely regular space **) 
(** LATEX VERSION: Completely regular (Tikhonov) spaces admit continuous [0,1]-valued functions separating point and closed set. **)
Definition completely_regular_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  (one_point_sets_closed X Tx /\
   forall x:set, x :e X ->
     forall F:set, closed_in X Tx F -> x /:e F ->
       exists f:set,
         continuous_map X Tx R R_standard_topology f /\
         apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1).

(** helper for 34 Corollary 34.3: open-set version of complete regularity **)
(** LATEX VERSION: If xU is open, there exists continuous g with g(x)=1 and g=0 on X\\U. **)
Theorem completely_regular_space_open_separator : forall X Tx x U:set,
  completely_regular_space X Tx ->
  x :e X -> U :e Tx -> x :e U ->
  exists g:set,
    continuous_map X Tx R R_standard_topology g /\
    apply_fun g x = 1 /\
    forall y:set, y :e X :\: U -> apply_fun g y = 0.
admit.
Qed.

(** helper for cube constructions: open-set separator with unit_interval range **)
Theorem completely_regular_space_open_separator_unit_interval : forall X Tx x U:set,
  completely_regular_space X Tx ->
  x :e X -> U :e Tx -> x :e U ->
  exists h:set,
    continuous_map X Tx unit_interval unit_interval_topology h /\
    apply_fun h x = 1 /\
    forall y:set, y :e X :\: U -> apply_fun h y = 0.
admit.
Qed.

(** helper: open-set separator as an element of function_space X unit_interval **)
Theorem completely_regular_space_open_separator_unit_interval_in_function_space : forall X Tx x U:set,
  completely_regular_space X Tx ->
  x :e X -> U :e Tx -> x :e U ->
  exists h:set,
    h :e function_space X unit_interval /\
    continuous_map X Tx unit_interval unit_interval_topology h /\
    apply_fun h x = 1 /\
    forall y:set, y :e X :\: U -> apply_fun h y = 0.
admit.
Qed.

(** helper for 34 Corollary 34.3: point separation by complete regularity **)
(** LATEX VERSION: In a completely regular space, for x!=y there exists continuous f with f(x)=0 and f(y)=1. **)
Theorem completely_regular_space_separates_points : forall X Tx x y:set,
  completely_regular_space X Tx ->
  x :e X -> y :e X -> x <> y ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    apply_fun f x = 0 /\ apply_fun f y = 1.
admit.
Qed.

(** helper: extract topology_on from completely_regular_space **)
(** LATEX VERSION: Any completely regular space carries a topology. **)
Theorem completely_regular_space_topology_on : forall X Tx:set,
  completely_regular_space X Tx -> topology_on X Tx.
admit.
Qed.

(** helper: extract one_point_sets_closed from completely_regular_space **)
(** LATEX VERSION: Completely regular implies T1. **)
Theorem completely_regular_space_one_point_sets_closed : forall X Tx:set,
  completely_regular_space X Tx -> one_point_sets_closed X Tx.
admit.
Qed.

(** helper: extract the separation map property from completely_regular_space **)
(** LATEX VERSION: Completely regular provides continuous functions separating points from closed sets. **)
Theorem completely_regular_space_separation : forall X Tx x F:set,
  completely_regular_space X Tx ->
  x :e X ->
  closed_in X Tx F ->
  x /:e F ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
admit.
Qed.

(** helper: completely regular implies regular **)
(** LATEX VERSION: Completely regular (T1) implies regular. **)
Theorem completely_regular_space_implies_regular : forall X Tx:set,
  completely_regular_space X Tx -> regular_space X Tx.
admit.
Qed.

(** helper: completely regular implies Hausdorff **)
Theorem completely_regular_space_implies_Hausdorff : forall X Tx:set,
  completely_regular_space X Tx -> Hausdorff_space X Tx.
admit.
Qed.

(** LATEX VERSION: Completely regular family helper. **)
Definition completely_regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I ->
    completely_regular_space (product_component Xi i) (product_component_topology Xi i).

(** Helper: any function is continuous from a discrete domain **)
Theorem continuous_from_discrete : forall X Y Ty f:set,
  topology_on Y Ty ->
  function_on f X Y ->
  continuous_map X (discrete_topology X) Y Ty f.
admit.
Qed.

(** Helper: congruence for tuple coordinates **)
Theorem tuple_2_0_congr : forall a b c d:set, (a,b) = (c,d) -> a = c.
admit.
Qed.
Theorem tuple_2_1_congr : forall a b c d:set, (a,b) = (c,d) -> b = d.
admit.
Qed.

(** Helper: projections from membership in const_fun graphs **)
Theorem const_fun_pair_first : forall A x a y:set, (a,y) :e const_fun A x -> a :e A.
admit.
Qed.
Theorem const_fun_pair_second : forall A x a y:set, (a,y) :e const_fun A x -> y = x.
admit.
Qed.

(** Helper: discrete topology is completely regular **)
Theorem discrete_completely_regular_space : forall X:set,
  completely_regular_space X (discrete_topology X).
admit.
Qed.

(** Helper: discrete topology is Hausdorff **)
Theorem discrete_Hausdorff_space : forall X:set,
  Hausdorff_space X (discrete_topology X).
admit.
Qed.

(** from 33 Definition: Tychonoff space **) 
(** LATEX VERSION: Tychonoff = completely regular and Hausdorff. **)
Definition Tychonoff_space : set -> set -> prop := fun X Tx =>
  completely_regular_space X Tx /\ Hausdorff_space X Tx.

(** Helper: local basis element from generated_topology_from_subbasis **)
(** LATEX VERSION: If U is open in the topology generated from a subbasis, then every point of U lies in some nonempty finite intersection of subbasis elements contained in U. **)
Theorem generated_topology_from_subbasis_local_basis : forall X S U x:set,
  U :e generated_topology_from_subbasis X S ->
  x :e U ->
  exists b:set, b :e basis_of_subbasis X S /\ x :e b /\ b c= U.
admit.
Qed.

(** Helper: unfold a basis_of_subbasis member into a finite subcollection intersection **)
(** LATEX VERSION: Every basis element is a nonempty finite intersection of subbasis elements. **)
Theorem basis_of_subbasisE : forall X S b:set,
  b :e basis_of_subbasis X S ->
  exists F:set, F :e finite_subcollections S /\ b = intersection_of_family X F /\ b <> Empty.
admit.
Qed.

(** Helper: subbasis elements are open in the topology generated from that subbasis **)
(** LATEX VERSION: Each subbasis element belongs to the generated topology. **)
Theorem generated_topology_from_subbasis_contains_subbasis_elem : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s :e generated_topology_from_subbasis X S.
admit.
Qed.

(** helper: product topology of subspaces equals subspace topology of the product **)
(** LATEX VERSION: The product topology on subspaces agrees with the subspace topology of the product. **)
Theorem product_topology_full_subspace_topology : forall I Xi Xi0:set,
  I <> Empty ->
  (forall i:set, i :e I -> space_family_set Xi0 i c= space_family_set Xi i) ->
  (forall i:set, i :e I ->
    space_family_topology Xi0 i =
      subspace_topology (space_family_set Xi i) (space_family_topology Xi i) (space_family_set Xi0 i)) ->
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  subspace_topology (product_space I Xi) (product_topology_full I Xi) (product_space I Xi0) =
  product_topology_full I Xi0.
admit.
Qed.

(** helper: product component of a graph of pairs **)
(** LATEX VERSION: If Xi is given by i |-> (A i, B i), then the i-th product_component is A i and product_component_topology is B i. **)
Theorem product_component_graph_pair : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  product_component (graph I (fun j:set => (A j, B j))) i = A i.
admit.
Qed.
Theorem product_component_topology_graph_pair : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  product_component_topology (graph I (fun j:set => (A j, B j))) i = B i.
admit.
Qed.

(** helper: compactness of a component of a graph of pairs **)
Theorem compact_space_product_component_graph_pair : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  compact_space (A i) (B i) ->
  compact_space (product_component (graph I (fun j:set => (A j, B j))) i)
    (product_component_topology (graph I (fun j:set => (A j, B j))) i).
admit.
Qed.

(** helper: compactness of a component in unfolded apply_fun form **)
Theorem compact_space_apply_fun_graph_pair_0_1 : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  compact_space (A i) (B i) ->
  compact_space ((apply_fun (graph I (fun j:set => (A j, B j))) i) 0)
    ((apply_fun (graph I (fun j:set => (A j, B j))) i) 1).
admit.
Qed.

(** helper: space_family_set of a graph of pairs **)
Theorem space_family_set_graph_pair : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  space_family_set (graph I (fun j:set => (A j, B j))) i = A i.
admit.
Qed.

(** helper: space_family_topology of a graph of pairs **)
Theorem space_family_topology_graph_pair : forall I:set, forall A B:set->set, forall i:set,
  i :e I ->
  space_family_topology (graph I (fun j:set => (A j, B j))) i = B i.
admit.
Qed.

(** Helper: evaluation map at coordinate i on a product_space **)
(** LATEX VERSION: The evaluation map ev_i: X_j -> X_i is given by ev_i(f)=f(i). **)
Definition product_eval_map : set -> set -> set -> set := fun I Xi i =>
  graph (product_space I Xi) (fun f:set => apply_fun f i).

(** Helper: evaluation is continuous in the product_topology_full **)
(** LATEX VERSION: For product topology generated by cylinders, each evaluation map is continuous. **)
Theorem product_eval_map_continuous : forall I Xi i:set,
  (forall j:set, j :e I -> topology_on (space_family_set Xi j) (space_family_topology Xi j)) ->
  i :e I ->
  continuous_map (product_space I Xi) (product_topology_full I Xi)
    (space_family_set Xi i) (space_family_topology Xi i) (product_eval_map I Xi i).
admit.
Qed.

(** Helper: closure of a cylinder is contained in the preimage of the coordinate closure. **)
(** LATEX VERSION: cl(pi_i^{-1}(V)) is contained in pi_i^{-1}(cl(V)) for continuous pi_i. **)
Theorem closure_of_product_cylinder_sub_preimage_closure : forall I Xi i V:set,
  I <> Empty ->
  (forall j:set, j :e I -> topology_on (space_family_set Xi j) (space_family_topology Xi j)) ->
  i :e I ->
  V :e space_family_topology Xi i ->
  closure_of (product_space I Xi) (product_topology_full I Xi) (product_cylinder I Xi i V)
    c= preimage_of (product_space I Xi) (product_eval_map I Xi i)
         (closure_of (space_family_set Xi i) (space_family_topology Xi i) V).
admit.
Qed.

(** helper: membership in the closure of a cylinder yields membership in the coordinate closure **)
Theorem closure_of_product_cylinder_coord_in_closure : forall I Xi i V g:set,
  I <> Empty ->
  (forall j:set, j :e I -> topology_on (space_family_set Xi j) (space_family_topology Xi j)) ->
  i :e I ->
  V :e space_family_topology Xi i ->
  g :e closure_of (product_space I Xi) (product_topology_full I Xi) (product_cylinder I Xi i V) ->
  apply_fun g i :e closure_of (space_family_set Xi i) (space_family_topology Xi i) V.
admit.
Qed.

(** helper for 37: convergence in the product implies convergence of each coordinate projection **)
(** LATEX VERSION: If a net converges in the product topology, then for each i the composed net with the projection/evaluation map converges in X_i. **)
Theorem net_converges_on_product_topology_full_implies_coord_converges :
  forall I Xi net J le x i:set,
    (forall j:set, j :e I -> topology_on (space_family_set Xi j) (space_family_topology Xi j)) ->
    i :e I ->
    net_converges_on (product_space I Xi) (product_topology_full I Xi) net J le x ->
    net_converges_on (space_family_set Xi i) (space_family_topology Xi i)
      (compose_fun J net (product_eval_map I Xi i)) J le (apply_fun x i).
admit.
Qed.

(** Helper: finite-subcollection subbasis neighborhood inside an open set **)
(** LATEX VERSION: In a topology generated by a subbasis, every open neighborhood contains a finite intersection of subbasis elements containing the point. **)
Theorem generated_topology_from_subbasis_finite_neighborhood : forall X S U x:set,
  subbasis_on X S ->
  U :e generated_topology_from_subbasis X S ->
  x :e U ->
  exists F:set, F :e finite_subcollections S /\
    x :e intersection_of_family X F /\ intersection_of_family X F c= U.
admit.
Qed.

(** helper: net convergence in a subbasis-generated topology from subbasis-eventuality **)
(** LATEX VERSION: In a topology generated by a subbasis S, it suffices for a net to be eventually in every subbasis neighborhood of x (and then use finite intersections). **)
Theorem net_converges_on_generated_topology_from_subbasis_of_subeventual :
  forall X S net J le x:set,
    subbasis_on X S ->
    directed_set J le ->
    total_function_on net J X ->
    functional_graph net ->
    graph_domain_subset net J ->
    x :e X ->
    (forall s:set, s :e S -> x :e s ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0,i) :e le -> apply_fun net i :e s) ->
    net_converges_on X (generated_topology_from_subbasis X S) net J le x.
admit.
Qed.

(** Helper: unpack a product subbasis element as a cylinder **)
(** LATEX VERSION: Every element of the product subbasis has the form pi_i^{-1}(U_i). **)
Theorem product_subbasis_fullE : forall I Xi s:set,
  s :e product_subbasis_full I Xi ->
  exists i:set, i :e I /\ exists U:set, U :e space_family_topology Xi i /\ s = product_cylinder I Xi i U.
admit.
Qed.

(** helper for 37: coordinatewise net convergence implies convergence in product_topology_full **)
(** LATEX VERSION: A net in X_i converges to x in the product topology iff each coordinate projection converges to x(i). **)
Theorem net_converges_on_product_topology_full_of_all_coord_converge :
  forall I Xi net J le x:set,
    I <> Empty ->
    (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
    directed_set J le ->
    total_function_on net J (product_space I Xi) ->
    functional_graph net ->
    graph_domain_subset net J ->
    x :e product_space I Xi ->
    (forall i:set, i :e I ->
      net_converges_on (space_family_set Xi i) (space_family_topology Xi i)
        (compose_fun J net (product_eval_map I Xi i)) J le (apply_fun x i)) ->
    net_converges_on (product_space I Xi) (product_topology_full I Xi) net J le x.
admit.
Qed.

(** helper for 37: product convergence iff coordinate convergence (net version) **)
(** LATEX VERSION: A net in X_i converges to x in the product topology iff each coordinate projection converges to x(i). **)
Theorem net_converges_on_product_topology_full_iff_all_coord_converge :
  forall I Xi net J le x:set,
    I <> Empty ->
    (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
    directed_set J le ->
    total_function_on net J (product_space I Xi) ->
    functional_graph net ->
    graph_domain_subset net J ->
    x :e product_space I Xi ->
    (net_converges_on (product_space I Xi) (product_topology_full I Xi) net J le x <->
      forall i:set, i :e I ->
        net_converges_on (space_family_set Xi i) (space_family_topology Xi i)
          (compose_fun J net (product_eval_map I Xi i)) J le (apply_fun x i)).
admit.
Qed.

(** Helper: combine two continuous 0-1 separators **)
(** LATEX VERSION: If f and g are continuous, then a continuous max-like combination can be used to propagate 0 at a point and 1 on the union of the 1-sets. **)
Theorem continuous_combine_or_01 : forall X Tx f g x0:set,
  topology_on X Tx ->
  continuous_map X Tx R R_standard_topology f ->
  continuous_map X Tx R R_standard_topology g ->
  x0 :e X ->
  apply_fun f x0 = 0 ->
  apply_fun g x0 = 0 ->
  exists h:set,
    continuous_map X Tx R R_standard_topology h /\
    apply_fun h x0 = 0 /\
    forall y:set, y :e X -> (apply_fun f y = 1 \/ apply_fun g y = 1) -> apply_fun h y = 1.
admit.
Qed.

(** Helper: finite cylinder family yields a separating continuous function on the product **)
(** LATEX VERSION: A finite family of coordinate-separating continuous functions can be combined into one separating continuous function on the product. **)
Theorem product_finite_subbasis_intersection_separator : forall I Xi F x:set,
  I <> Empty ->
  completely_regular_spaces_family I Xi ->
  F :e finite_subcollections (product_subbasis_full I Xi) ->
  x :e intersection_of_family (product_space I Xi) F ->
  exists f:set,
    continuous_map (product_space I Xi) (product_topology_full I Xi) R R_standard_topology f /\
    apply_fun f x = 0 /\
    forall y:set, y :e product_space I Xi ->
      (exists s:set, s :e F /\ y /:e s) -> apply_fun f y = 1.
admit.
Qed.

(** from 33 Theorem 33.2: subspaces/products of completely regular spaces **) 
(** LATEX VERSION: Subspaces and products of completely regular spaces remain completely regular. **)
Theorem completely_regular_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> completely_regular_space X Tx -> completely_regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, completely_regular_spaces_family I Xi -> completely_regular_space (product_space I Xi) (product_topology_full I Xi)).
admit.
Qed.

(** Helper: continuous preimage of a closed set is closed **)
(** LATEX VERSION: If f is continuous and C is closed, then f^{-1}(C) is closed. **)
Theorem continuous_map_preimage_closed : forall X Tx Y Ty f C:set,
  continuous_map X Tx Y Ty f ->
  closed_in Y Ty C ->
  closed_in X Tx (preimage_of X f C).
admit.
Qed.

(** Helper: completely regularity is preserved under homeomorphism **)
(** LATEX VERSION: If X and Y are homeomorphic and Y is completely regular, then X is completely regular. **)
Theorem homeomorphism_preserves_completely_regular : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  completely_regular_space Y Ty ->
  completely_regular_space X Tx.
admit.
Qed.

(** Helper: Hausdorff is preserved under homeomorphism **)
(** LATEX VERSION: If X and Y are homeomorphic and Y is Hausdorff, then X is Hausdorff. **)
Theorem homeomorphism_preserves_Hausdorff : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  Hausdorff_space Y Ty ->
  Hausdorff_space X Tx.
admit.
Qed.

(** Helper: metric spaces are completely regular **)
(** LATEX VERSION: Every metrizable space is completely regular, by applying Urysohn lemma to {x} and a closed F. **)
Theorem metric_spaces_completely_regular : forall X d:set,
  metric_on X d -> completely_regular_space X (metric_topology X d).
admit.
Qed.

(** Helper: the real line is completely regular in the standard topology **)
(** LATEX VERSION: R is metrizable, hence completely regular. **)
(** Note: This theorem is placed later, after the bounded metric on R and the proof that it induces the standard topology. **)

(** Helper: the unit interval is completely regular **)
(** LATEX VERSION: The unit interval [0,1] with the subspace topology from R is completely regular. **)
Theorem unit_interval_completely_regular :
  completely_regular_space unit_interval unit_interval_topology.
admit.
Qed.

(** Helper: normal spaces are completely regular **)
(** LATEX VERSION: If X is normal and T1 then Urysohn lemma separates a point and a closed set by a continuous function into [0,1]. **)
Theorem normal_space_implies_completely_regular : forall X Tx:set,
  normal_space X Tx ->
  completely_regular_space X Tx.
admit.
Qed.

(** Helper: completely regular binary product in product_topology **)
(** LATEX VERSION: Product of two completely regular spaces is completely regular. **)
Theorem continuous_map_to_generated_topology : forall X Tx Y B f:set,
  topology_on X Tx ->
  basis_on Y B ->
  function_on f X Y ->
  (forall b:set, b :e B -> preimage_of X f b :e Tx) ->
  continuous_map X Tx Y (generated_topology Y B) f.
admit.
Qed.
Theorem completely_regular_product_topology : forall X Tx Y Ty:set,
  completely_regular_space X Tx ->
  completely_regular_space Y Ty ->
  completely_regular_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.

(** helper for 33 Example 1: Sorgenfrey line is completely regular **)
(** LATEX VERSION: The Sorgenfrey line is completely regular. **)
Theorem Sorgenfrey_line_completely_regular :
  completely_regular_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** from 33 Example 1: products giving completely regular but not normal spaces **) 
(** LATEX VERSION: Sorgenfrey plane is completely regular but not normal. **)
Theorem Sorgenfrey_plane_completely_regular_not_normal :
  completely_regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** from 33 Example 1 cont.: SOmega x SbarOmega completely regular not normal **)
(** LATEX VERSION: Another example of completely regular but non-normal product. **)
(** FIXED: Use product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology on S_Omega  Sbar_Omega (not a mismatched topology on a function space). **) 
Theorem SOmega_SbarOmega_completely_regular_not_normal :
  completely_regular_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology) /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
admit.
Qed.

(** from 34 Theorem 34.1: Urysohn metrization theorem **) 
(** LATEX VERSION: Regular second-countable spaces are metrizable (Urysohn). **)
Theorem Urysohn_metrization_theorem : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> exists d:set, metric_on X d /\ metric_topology X d = Tx.
admit.
Qed.

(** from 34 Theorem 34.2: Imbedding via separating family of functions **) 
(** LATEX VERSION: Embedding into product of reals via separating family of continuous functions. **)
Theorem embedding_via_functions : forall X Tx:set,
  topology_on X Tx -> one_point_sets_closed X Tx ->
  forall F J:set, separating_family_of_functions X Tx F J ->
    exists Fmap:set, embedding_of X Tx (power_real J) (product_topology_full J (const_space_family J R R_standard_topology)) Fmap.
admit.
Qed.

(** from 34 Corollary 34.3: completely regular iff embeds in [0,1]^J **) 
(** LATEX VERSION: Completely regular iff embeds into a Tychonoff cube [0,1]^J. **)
Theorem completely_regular_iff_embeds_in_cube : forall X Tx:set,
  (completely_regular_space X Tx <->
    exists J:set, exists Fmap:set, embedding_of X Tx (unit_interval_power J) (product_topology_full J (const_space_family J unit_interval (subspace_topology R R_standard_topology unit_interval))) Fmap).
admit.
Qed.

(** helper moved earlier: metric Cauchy/completeness primitives are needed by uniform-limit infrastructure used in 35 **)
(** helper: Cauchy sequence in a metric space **)
(** LATEX VERSION: Cauchy sequence definition (metric). **)
(** FIXED: cauchy_sequence requires sequence_on seq X and uses N c= m and N c= n (eventuality) plus eps :e R and Rlt 0 eps; metric is applied as apply_fun d (seq(m), seq(n)). **)
Definition cauchy_sequence : set -> set -> set -> prop := fun X d seq =>
  metric_on X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.

(** Helper: cauchy_sequence plus totality of the metric graph on XX **)
(** from 43 Definition: Cauchy sequence in a metric space **)
(** LATEX VERSION: A sequence x_n is Cauchy if for every >0 there exists N such that d(x_m,x_n)< for m,n>N. **)
Definition cauchy_sequence_total : set -> set -> set -> prop := fun X d seq =>
  metric_on_total X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.
Theorem cauchy_sequence_total_imp : forall X d seq:set,
  cauchy_sequence_total X d seq -> cauchy_sequence X d seq.
admit.
Qed.

(** from 43 Definition: complete metric space **)
(** LATEX VERSION: Completeness: every Cauchy sequence converges. **)
(** FIXED: complete_metric_space quantifies over seq with sequence_on seq X, matching cauchy_sequence. **)
Definition complete_metric_space : set -> set -> prop := fun X d =>
  metric_on X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.

(** Helper: complete_metric_space plus totality of the metric graph on XX **)
(** from 43 Definition: complete metric space (total metric graph variant) **)
(** LATEX VERSION: A metric space is complete if every Cauchy sequence converges. **)
Definition complete_metric_space_total : set -> set -> prop := fun X d =>
  metric_on_total X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence_total X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.

(** helper: continuity at a point into a topological space **)
(** LATEX VERSION: f is continuous at x if every neighborhood of f(x) contains the image of some neighborhood of x. **)
Definition continuous_at_map : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f x =>
    function_on f X Y /\ x :e X /\
    forall V:set, V :e Ty -> apply_fun f x :e V ->
      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.

(** helper: pointwise convergence of a sequence of maps into a metric space **)
(** LATEX VERSION: f_n converges pointwise to f if for each x and each epsilon, eventually d(f_n(x),f(x))<epsilon. **)
Definition pointwise_limit_metric : set -> set -> set -> set -> set -> prop :=
  fun X Y d fn f =>
    forall x:set, x :e X ->
      forall eps:set, eps :e R -> Rlt 0 eps ->
        exists N:set, N :e omega /\
          forall n:set, n :e omega -> N c= n ->
            Rlt (apply_fun d (apply_fun (apply_fun fn n) x, apply_fun f x)) eps.

(** helper: uniform convergence of a sequence of maps into a metric space **)
(** LATEX VERSION: f_n converges uniformly to f if for each eps>0 there exists N such that d(f_n(x),f(x))<eps for all n>=N and all x in X. **)
Definition uniform_limit_metric : set -> set -> set -> set -> set -> prop :=
  fun X Y d fn f =>
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          forall x:set, x :e X ->
            Rlt (apply_fun d (apply_fun (apply_fun fn n) x, apply_fun f x)) eps.

(** helper: uniform convergence implies pointwise convergence **)
(** LATEX VERSION: If f_n converges uniformly to f then f_n converges pointwise to f. **)
Theorem uniform_limit_metric_imp_pointwise_limit_metric : forall X Y d fn f:set,
  uniform_limit_metric X Y d fn f ->
  pointwise_limit_metric X Y d fn f.
admit.
Qed.

(** helper: a limit of a sequence in A lies in closure_of A **)
(** LATEX VERSION: If x_n converges to x and all x_n lie in A, then x lies in cl(A). **)
Theorem converges_to_imp_in_closure_of_terms : forall X Tx A seq x:set,
  converges_to X Tx seq x ->
  (forall n:set, n :e omega -> apply_fun seq n :e A) ->
  x :e closure_of X Tx A.
admit.
Qed.

(** helper: a limit of a sequence eventually in A lies in closure_of A **)
(** LATEX VERSION: If x_n converges to x and x_n  A for all sufficiently large n, then x  cl(A). **)
Theorem converges_to_imp_in_closure_of_eventually_terms : forall X Tx A seq x N:set,
  converges_to X Tx seq x ->
  N :e omega ->
  (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e A) ->
  x :e closure_of X Tx A.
admit.
Qed.

(** helper: closed sets contain limits of sequences **)
(** LATEX VERSION: If A is closed and x_n in A converges to x then x is in A. **)
Theorem converges_to_closed_in_contains_limit : forall X Tx A seq x:set,
  topology_on X Tx -> A c= X ->
  closed_in X Tx A ->
  converges_to X Tx seq x ->
  (forall n:set, n :e omega -> apply_fun seq n :e A) ->
  x :e A.
admit.
Qed.

(** helper: uniform convergence gives metric convergence at each point **)
(** LATEX VERSION: If f_n converges uniformly to f, then for each x the sequence n |-> f_n(x) converges to f(x) in the metric sense. **)
Theorem uniform_limit_metric_imp_sequence_converges_metric_at_point : forall X Y d fn f x:set,
  metric_on Y d ->
  function_on fn omega (function_space X Y) ->
  function_on f X Y ->
  x :e X ->
  uniform_limit_metric X Y d fn f ->
  sequence_converges_metric Y d (graph omega (fun n:set => apply_fun (apply_fun fn n) x)) (apply_fun f x).
admit.
Qed.

(** helper: metric topology neighborhoods contain a centered ball **)
(** LATEX VERSION: In a metric topology, every open neighborhood of x contains an open ball centered at x. **)
Theorem metric_topology_neighborhood_contains_ball : forall X d x U:set,
  metric_on X d ->
  x :e X ->
  U :e metric_topology X d ->
  x :e U ->
  exists r:set, r :e R /\ (Rlt 0 r /\ open_ball X d x r c= U).
admit.
Qed.

(** helper: metric neighborhood contains a smaller ball bounded by a given positive radius **)
(** LATEX VERSION: Given a neighborhood U of x and a positive a, we can find a ball centered at x contained in U with radius < a. **)
Theorem metric_topology_neighborhood_contains_ball_bounded : forall X d x U a:set,
  metric_on X d ->
  x :e X ->
  U :e metric_topology X d ->
  x :e U ->
  a :e R ->
  Rlt 0 a ->
  exists r:set, r :e R /\ Rlt 0 r /\ open_ball X d x r c= U /\ Rlt r a.
admit.
Qed.

(** helper: metric epsilon convergence implies topological convergence in metric topology **)
(** LATEX VERSION: If x_n converges to x in the metric sense, then it converges to x in the metric topology. **)
Theorem sequence_converges_metric_imp_converges_to_metric_topology : forall X d seq x:set,
  sequence_converges_metric X d seq x ->
  converges_to X (metric_topology X d) seq x.
admit.
Qed.

(** helper: topological convergence in metric topology implies metric epsilon convergence **)
(** LATEX VERSION: If x_n converges to x in the metric topology, then d(x_n,x) -> 0. **)
Theorem converges_to_metric_topology_imp_sequence_converges_metric : forall X d seq x:set,
  metric_on X d ->
  converges_to X (metric_topology X d) seq x ->
  sequence_converges_metric X d seq x.
admit.
Qed.

(** helper: uniform convergence implies pointwise convergence in the metric topology **)
(** LATEX VERSION: If f_n converges uniformly to f then for each x the sequence f_n(x) converges to f(x) in the metric topology. **)
Theorem uniform_limit_metric_imp_converges_to_metric_topology_at_point : forall X Y d fn f x:set,
  metric_on Y d ->
  function_on fn omega (function_space X Y) ->
  function_on f X Y ->
  x :e X ->
  uniform_limit_metric X Y d fn f ->
  converges_to Y (metric_topology Y d)
    (graph omega (fun n:set => apply_fun (apply_fun fn n) x))
    (apply_fun f x).
admit.
Qed.

(** helper: uniform Cauchy property for a sequence of maps into a metric space **)
(** LATEX VERSION: (f_n) is uniformly Cauchy if for each eps>0 there exists N such that d(f_m(x),f_n(x))<eps for all m,n>=N and all x in X. **)
Definition uniform_cauchy_metric : set -> set -> set -> set -> prop :=
  fun X Y d fn =>
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
          forall x:set, x :e X ->
            Rlt (apply_fun d (apply_fun (apply_fun fn m) x, apply_fun (apply_fun fn n) x)) eps.

(** helper: existence of a uniform limit in a complete metric space (stub) **)
(** LATEX VERSION: If (f_n) is uniformly Cauchy into a complete metric space, then there exists f with f_n converging uniformly to f. **)
Theorem uniform_cauchy_metric_complete_imp_uniform_limit_stub : forall X Y d fn:set,
  complete_metric_space Y d ->
  function_on fn omega (function_space X Y) ->
  uniform_cauchy_metric X Y d fn ->
  exists f:set, function_on f X Y /\ uniform_limit_metric X Y d fn f.
admit.
Qed.

(** helper: uniform limit of continuous maps into a metric space is continuous **)
(** LATEX VERSION: If f_n:X->Y are continuous and converge uniformly to f into metric Y, then f is continuous. **)
Theorem uniform_limit_of_continuous_to_metric_is_continuous : forall X Tx Y d fn f:set,
  topology_on X Tx ->
  metric_on Y d ->
  function_on fn omega (function_space X Y) ->
  function_on f X Y ->
  (forall n:set, n :e omega -> continuous_map X Tx Y (metric_topology Y d) (apply_fun fn n)) ->
  uniform_limit_metric X Y d fn f ->
  continuous_map X Tx Y (metric_topology Y d) f.
admit.
Qed.

(** helper: membership in bounded metric ball implies bounded distance inequality **)
(** LATEX VERSION: If 0<r<1 then y is in the bounded-metric ball B(x,r) iff y is real and dbar(x,y)<r. **)

(** helper: bounded-metric ball implies abs(x-y) < r **)

(** helper: standard open intervals are open in the bounded metric topology (early) **)
(** LATEX VERSION: Every open interval (a,b) is open in the bounded-metric topology on R. **)
Theorem open_interval_in_metric_topology_R_bounded_metric_early : forall a b:set,
  a :e R -> b :e R ->
  open_interval a b :e metric_topology R R_bounded_metric.
admit.
Qed.

(** helper: bounded metric induces the standard topology on R (early stub for 35) **)
(** LATEX VERSION: The bounded metric on R induces the standard topology. **)
Theorem metric_topology_R_bounded_metric_eq_R_standard_topology_early :
  metric_topology R R_bounded_metric = R_standard_topology.
admit.
Qed.

(** helper: bounded-metric Cauchy gives abs-tail estimates for eps<1 (early) **)
(** LATEX VERSION: If seq is Cauchy in dbar and 0<eps<1 then eventually |seq m-seq n| < eps. **)
Theorem cauchy_R_bounded_metric_abs_tail_early : forall seq eps:set,
  cauchy_sequence R R_bounded_metric seq ->
  eps :e R -> Rlt 0 eps -> Rlt eps 1 ->
  exists N:set, N :e omega /\
    forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
      abs_SNo (add_SNo (apply_fun seq m) (minus_SNo (apply_fun seq n))) < eps.
admit.
Qed.

(** helper: abs-Cauchy sequences on R converge in the standard topology (early) **)
(** LATEX VERSION: Every Cauchy sequence in R with respect to |x-y| converges in the standard topology. **)
Theorem abs_Cauchy_sequence_converges_R_standard_topology_early : forall seq:set,
  sequence_on seq R ->
  (forall eps:set, eps :e R /\ Rlt 0 eps ->
     exists N:set, N :e omega /\
       forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
         abs_SNo (add_SNo (apply_fun seq m) (minus_SNo (apply_fun seq n))) < eps) ->
  exists x:set, converges_to R R_standard_topology seq x.
admit.
Qed.

(** helper: bounded metric on R is complete (early stub for 35) **)
(** LATEX VERSION: The real line with the bounded metric is complete. **)
Theorem R_bounded_metric_complete_early : complete_metric_space R R_bounded_metric.
admit.
Qed.

(** helper: uniform limit of continuous maps to R is continuous in the standard topology **)
(** LATEX VERSION: If f_n:X->R are continuous (usual topology) and converge uniformly in the bounded metric, then the limit is continuous. **)
Theorem uniform_limit_of_continuous_to_R_standard_topology : forall X Tx fn f:set,
  topology_on X Tx ->
  function_on fn omega (function_space X R) ->
  function_on f X R ->
  (forall n:set, n :e omega -> continuous_map X Tx R R_standard_topology (apply_fun fn n)) ->
  uniform_limit_metric X R R_bounded_metric fn f ->
  continuous_map X Tx R R_standard_topology f.
admit.
Qed.

(** helper: uniformly Cauchy continuous maps to R have a continuous uniform limit **)
(** LATEX VERSION: In a complete metric codomain, a uniformly Cauchy sequence of continuous functions has a continuous uniform limit. **)
Theorem uniform_cauchy_continuous_to_R_has_continuous_limit : forall X Tx fn:set,
  topology_on X Tx ->
  function_on fn omega (function_space X R) ->
  (forall n:set, n :e omega -> continuous_map X Tx R R_standard_topology (apply_fun fn n)) ->
  uniform_cauchy_metric X R R_bounded_metric fn ->
  exists f:set,
    function_on f X R /\
    uniform_limit_metric X R R_bounded_metric fn f /\
    continuous_map X Tx R R_standard_topology f.
admit.
Qed.

(** from 35 Theorem 35.1: Tietze extension theorem **)
(** LATEX VERSION: Tietze extension theorem for normal spaces and intervals. **)
(** helper for 35: 1/3 and 2/3 in R **)
Definition one_third : set := inv_nat 3.
Definition two_thirds : set := add_SNo one_third one_third.
Theorem one_third_in_R : one_third :e R.
admit.
Qed.
Theorem two_thirds_in_R : two_thirds :e R.
admit.
Qed.
	
	(** helper for 35: positivity of one_third and two_thirds **)
Theorem one_third_pos : 0 < one_third.
admit.
Qed.
Theorem two_thirds_pos : 0 < two_thirds.
admit.
Qed.
Theorem two_thirds_ne0 : two_thirds <> 0.
admit.
Qed.
		
		(** helper for 35: division by a fixed constant on R **)
		(** LATEX VERSION: For fixed c, the map t  t/c on . **)
		Definition div_const_fun : set -> set := fun c =>
		  graph R (fun t:set => div_SNo t c).
Theorem div_const_fun_apply : forall c t:set,
		  c :e R -> t :e R ->
		  apply_fun (div_const_fun c) t = div_SNo t c.
admit.
Qed.

		(** helper for 35: apply_fun of compose_fun with div_const_fun **)
Theorem compose_div_const_fun_apply : forall A f c x:set,
		  x :e A -> c :e R -> apply_fun f x :e R ->
		  apply_fun (compose_fun A f (div_const_fun c)) x = div_SNo (apply_fun f x) c.
admit.
Qed.

		(** helper: div_const_fun c is an element of function_space R R **)
		(** LATEX VERSION: For fixed c, the map tt/c is a function . **)
Theorem div_const_fun_in_function_space : forall c:set,
		  c :e R -> div_const_fun c :e function_space R R.
admit.
Qed.
Theorem div_const_fun_value_in_R : forall c t:set,
	  c :e R -> t :e R ->
	  apply_fun (div_const_fun c) t :e R.
admit.
Qed.
	
	(** preimage of an upper ray under division by positive c **)
Theorem preimage_div_const_open_ray_upper : forall c a:set,
	  c :e R -> 0 < c -> a :e R ->
	  preimage_of R (div_const_fun c) (open_ray_upper R a) = open_ray_upper R (mul_SNo a c).
admit.
Qed.
	
	(** preimage of a lower ray under division by positive c **)
Theorem preimage_div_const_open_ray_lower : forall c b:set,
	  c :e R -> 0 < c -> b :e R ->
	  preimage_of R (div_const_fun c) (open_ray_lower R b) = open_ray_lower R (mul_SNo b c).
admit.
Qed.
Theorem div_const_fun_continuous_pos : forall c:set,
  c :e R -> 0 < c ->
  continuous_map R R_standard_topology R R_standard_topology (div_const_fun c).
admit.
Qed.

(** helper for 35: division by a negative denominator **)
Theorem div_SNo_minus_den : forall x y:set,
  x :e R -> y :e R -> y <> 0 ->
  div_SNo x (minus_SNo y) = minus_SNo (div_SNo x y).
admit.
Qed.

(** helper: division by an arbitrary nonzero real constant is continuous in the standard topology **)
(** LATEX VERSION: Division by a constant is continuous, by reducing the negative case to the positive case using negation. **)
Theorem div_const_fun_continuous : forall c:set,
  c :e R -> c <> 0 ->
  continuous_map R R_standard_topology R R_standard_topology (div_const_fun c).
admit.
Qed.

(** helper for 35: multiplication by a fixed constant on R **)
(** LATEX VERSION: For fixed c, the map t  tc on . **)
(** mul_const_fun is defined earlier in the file. **)


(** helper for 35 Step II: scaling from [-den,den] to [-1,1] for den>0 **)
Theorem div_SNo_closed_interval_scale : forall den y:set,
  den :e R -> 0 < den ->
  y :e closed_interval (minus_SNo den) den ->
  div_SNo y den :e closed_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper: mul_const_fun c is an element of function_space R R **)
(** LATEX VERSION: For fixed c, the map ttc is a function . **)


(** preimage of an upper ray under multiplication by positive c **)

(** helper for 35: scaling a continuous map by a positive constant is continuous **)
Theorem scale_continuous_mul_const_pos : forall X Tx g c:set,
  topology_on X Tx ->
  continuous_map X Tx R R_standard_topology g ->
  c :e R -> 0 < c ->
  continuous_map X Tx R R_standard_topology (compose_fun X g (mul_const_fun c)).
admit.
Qed.

(** helper for 35: adding two continuous R-valued maps is continuous **)

(** helper for 35: multiplication map on RR **)
(** LATEX VERSION: The multiplication map RRR is continuous in the standard topology. **)
(** from 24 Example: punctured euclidean space path components via horizontal slices **)
(** LATEX VERSION: Any two points on a horizontal line y=y0 with y00 can be joined by a path staying in R{0}. **)
(** NOTE: A direct proof here needs continuity of affine maps on R and their pairing into RR. The current file develops the needed arithmetic continuity infrastructure later, so this item is deferred. **)
Theorem punctured_horizontal_slice_path_component : forall x0 x1 y0:set,
  y0 :e R -> y0 <> 0 -> x0 :e R -> x1 :e R ->
  (x0,y0) :e path_component_of (EuclidPlane :\: {(0,0)})
    (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)}))
    (x1,y0).
admit.
Qed.

(** from 24 Example: punctured euclidean space path components via vertical slices **)
(** LATEX VERSION: Any two points on a vertical line x=x0 with x00 can be joined by a path staying in R{0}. **)
(** NOTE: This is symmetric to punctured_horizontal_slice_path_component. **)
Theorem punctured_vertical_slice_path_component : forall x0 y0 y1:set,
  x0 :e R -> x0 <> 0 -> y0 :e R -> y1 :e R ->
  (x0,y0) :e path_component_of (EuclidPlane :\: {(0,0)})
    (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)}))
    (x0,y1).
admit.
Qed.

(** from 24 Example: punctured euclidean space is path connected (placeholder) **)
(** LATEX VERSION: The plane with the origin removed is path connected. **)
(** FIXED: Origin is the ordered pair (0,0) so the removed set is {(0,0)}. **)
(** MOVED: This item uses path_component_of and its path concatenation lemma. **)
Theorem punctured_space_path_connected :
  path_connected_space (EuclidPlane :\: {(0,0)})
    (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)})).
admit.
Qed.
 
(** helper for 35: multiplication map on RR **)
(** LATEX VERSION: The multiplication map is the function (x,y)  xy on . **)
(** mul_fun_R is defined earlier in the file. **)

(** helper for 35: multiplication map values lie in R **)


(** helper for 35: -2/3 expressed as -1/3 + -1/3 **)
Theorem minus_two_thirds_eq : minus_SNo two_thirds = add_SNo (minus_SNo one_third) (minus_SNo one_third).
admit.
Qed.

(** helper for 35: one_third and two_thirds as divisions by 3 **)
Theorem one_third_eq_div_1_3 : one_third = div_SNo 1 3.
admit.
Qed.
Theorem two_thirds_eq_div_2_3 : two_thirds = div_SNo 2 3.
admit.
Qed.

(** helper for 35: 1 divided by 2 equals eps_ 1 **)
Theorem div_SNo_1_2_eq_eps_1 : div_SNo 1 2 = eps_ 1.
admit.
Qed.

(** helper: add_nat 4 4 equals 8 **)
Theorem add_nat_4_4_eq_8 : add_nat 4 4 = 8.
admit.
Qed.

(** helper: mul_nat 4 2 equals 8 **)
Theorem mul_nat_4_2_eq_8 : mul_nat 4 2 = 8.
admit.
Qed.

(** helper: 4 times 2 is strictly below 9 in SNo order **)
Theorem mul_SNo_4_2_lt_9 : mul_SNo 4 2 < 9.
admit.
Qed.

(** helper: add_nat 3 3 equals 6 **)
Theorem add_nat_3_3_eq_6 : add_nat 3 3 = 6.
admit.
Qed.

(** helper: add_nat 3 6 equals 9 **)
Theorem add_nat_3_6_eq_9 : add_nat 3 6 = 9.
admit.
Qed.

(** helper: mul_nat 2 2 equals 4 **)
Theorem mul_nat_2_2_eq_4 : mul_nat 2 2 = 4.
admit.
Qed.

(** helper: mul_nat 3 3 equals 9 **)
Theorem mul_nat_3_3_eq_9 : mul_nat 3 3 = 9.
admit.
Qed.

(** helper: mul_SNo 2 2 equals 4 **)
Theorem mul_SNo_2_2_eq_4 : mul_SNo 2 2 = 4.
admit.
Qed.

(** helper: mul_SNo 3 3 equals 9 **)
Theorem mul_SNo_3_3_eq_9 : mul_SNo 3 3 = 9.
admit.
Qed.

(** helper for 35: square of two_thirds is below eps_ 1 **)
Theorem two_thirds_sq_lt_eps_1 : mul_SNo two_thirds two_thirds < eps_ 1.
admit.
Qed.
Theorem add_one_third_two_thirds_eq_1 : add_SNo one_third two_thirds = 1.
admit.
Qed.

(** helper for 35: 2/3 < 1 **)
Theorem Rlt_two_thirds_1 : Rlt two_thirds 1.
admit.
Qed.

(** helper for 35: 1/3 < 2/3 **)
Theorem one_third_lt_two_thirds : one_third < two_thirds.
admit.
Qed.

(** helper for 35: 1/3 < 1 **)
Theorem one_third_lt_1_SNo : one_third < 1.
admit.
Qed.

(** helper for 35: Rlt one_third 1 **)
Theorem Rlt_one_third_1 : Rlt one_third 1.
admit.
Qed.

(** helper for 35: -1 < -1/3 **)
Theorem minus_1_lt_minus_one_third_SNo : (minus_SNo 1) < (minus_SNo one_third).
admit.
Qed.

(** helper for 35: Rlt (minus 1) (minus one_third) **)
Theorem Rlt_minus1_minus_one_third : Rlt (minus_SNo 1) (minus_SNo one_third).
admit.
Qed.

(** helper for 35: I0 subset I **)
Theorem closed_interval_minus_one_third_one_third_sub_closed_interval_minus1_1 :
  closed_interval (minus_SNo one_third) one_third c= closed_interval (minus_SNo 1) 1.
admit.
Qed.
Theorem two_thirds_eq_1_minus_one_third : two_thirds = add_SNo 1 (minus_SNo one_third).
admit.
Qed.
Theorem minus_two_thirds_eq_minus1_plus_one_third : minus_SNo two_thirds = add_SNo (minus_SNo 1) one_third.
admit.
Qed.
Theorem add_minus1_two_thirds_eq_minus_one_third : add_SNo (minus_SNo 1) two_thirds = minus_SNo one_third.
admit.
Qed.
Theorem add_1_minus_two_thirds_eq_one_third : add_SNo 1 (minus_SNo two_thirds) = one_third.
admit.
Qed.
Theorem Rle_0_two_thirds : Rle 0 two_thirds.
admit.
Qed.
Theorem Rle_minus_two_thirds_0 : Rle (minus_SNo two_thirds) 0.
admit.
Qed.

(** helper for 35: order relation -one_third <= one_third **)
Theorem Rlt_minus_one_third_one_third : Rlt (minus_SNo one_third) one_third.
admit.
Qed.
Theorem Rle_minus_one_third_one_third : Rle (minus_SNo one_third) one_third.
admit.
Qed.

(** helper: monotonicity of add_SNo in Rle form (left argument) **)
Theorem Rle_add_SNo_1 : forall x y z:set,
  x :e R -> y :e R -> z :e R ->
  Rle x y -> Rle (add_SNo x z) (add_SNo y z).
admit.
Qed.

(** helper for 35 Step II: interval expansion by a 1/3-sized correction term **)
(** LATEX VERSION: If y is in [-1+c, 1-c] and z is in [-c/3, c/3] with c>0, then y+z lies in [-1+(2/3)c, 1-(2/3)c]. **)
Theorem add_SNo_interval_expand_by_third_stub : forall c y z:set,
  c :e R -> 0 < c ->
  y :e closed_interval (add_SNo (minus_SNo 1) c) (add_SNo 1 (minus_SNo c)) ->
  z :e closed_interval (minus_SNo (mul_SNo c one_third)) (mul_SNo c one_third) ->
  add_SNo y z :e closed_interval (add_SNo (minus_SNo 1) (mul_SNo c two_thirds))
                                (add_SNo 1 (minus_SNo (mul_SNo c two_thirds))).
admit.
Qed.

(** helper: negation reverses Rle **)
Theorem Rle_minus_contra : forall x y:set,
  Rle x y -> Rle (minus_SNo y) (minus_SNo x).
admit.
Qed.

(** helper for 35: -1 < -2/3 **)
Theorem Rlt_minus1_minus_two_thirds : Rlt (minus_SNo 1) (minus_SNo two_thirds).
admit.
Qed.

(** helper for 35: [-2/3,2/3] is contained in (-1,1) **)
Theorem closed_interval_minus_two_thirds_two_thirds_Subq_open_interval_minus1_1 :
  closed_interval (minus_SNo two_thirds) two_thirds c= open_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper for 35: scaling [-1,1] by two_thirds lands in [-2/3,2/3] **)
Theorem mul_two_thirds_closed_interval_minus1_1 : forall t:set,
  t :e closed_interval (minus_SNo 1) 1 ->
  mul_SNo t two_thirds :e closed_interval (minus_SNo two_thirds) two_thirds.
admit.
Qed.

(** helper for 35: scaling [-1,1] by a nonnegative real c lands in [-c,c] **)
(** LATEX VERSION: If t  [-1,1] and c  0, then ct  [-c,c]. **)
Theorem mul_nonneg_closed_interval_minus1_1 : forall t c:set,
  t :e closed_interval (minus_SNo 1) 1 ->
  c :e R ->
  0 <= c ->
  mul_SNo t c :e closed_interval (minus_SNo c) c.
admit.
Qed.

(** helper for 35: dividing [-2/3,2/3] by two_thirds lands in [-1,1] **)
Theorem div_two_thirds_closed_interval_minus_two_thirds_two_thirds : forall t:set,
  t :e closed_interval (minus_SNo two_thirds) two_thirds ->
  div_SNo t two_thirds :e closed_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper for 35 Step I: the subinterval pieces are closed in [-1,1] (as a subspace) **)
Theorem Tietze_I1_closed_in_I : 
  closed_in (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1)
    ((closed_interval (minus_SNo 1) (minus_SNo one_third)) :/\: (closed_interval (minus_SNo 1) 1)).
admit.
Qed.
Theorem Tietze_I3_closed_in_I :
  closed_in (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1)
    ((closed_interval one_third 1) :/\: (closed_interval (minus_SNo 1) 1)).
admit.
Qed.

(** helper for 35 Step I: preimages of the subinterval pieces are closed in X **)
Theorem Tietze_stepI_BC_closed_in_X : forall X Tx A f:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A)
    (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) f ->
  closed_in X Tx (preimage_of A f ((closed_interval (minus_SNo 1) (minus_SNo one_third)) :/\: (closed_interval (minus_SNo 1) 1)))
  /\
  closed_in X Tx (preimage_of A f ((closed_interval one_third 1) :/\: (closed_interval (minus_SNo 1) 1))).
admit.
Qed.

(** helper for 35 Step I: the two Step I subinterval pieces are disjoint **)
Theorem Tietze_I1_I3_disjoint :
  ((closed_interval (minus_SNo 1) (minus_SNo one_third)) :/\: (closed_interval (minus_SNo 1) 1))
    :/\:
  ((closed_interval one_third 1) :/\: (closed_interval (minus_SNo 1) 1))
    = Empty.
admit.
Qed.

(** helper for 35 Step I: apply Urysohn lemma to the B,C preimages **)
Theorem Tietze_stepI_g_exists : forall X Tx A f:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A)
    (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) f ->
  exists g:set,
    continuous_map X Tx (closed_interval (minus_SNo one_third) one_third) (closed_interval_topology (minus_SNo one_third) one_third) g /\
    (forall x:set, x :e preimage_of A f ((closed_interval (minus_SNo 1) (minus_SNo one_third)) :/\: (closed_interval (minus_SNo 1) 1)) ->
      apply_fun g x = minus_SNo one_third) /\
    (forall x:set, x :e preimage_of A f ((closed_interval one_third 1) :/\: (closed_interval (minus_SNo 1) 1)) ->
      apply_fun g x = one_third).
admit.
Qed.

	(** helper for 35 Step II: add_fun_R after pair_map with negated second component **)
Theorem add_of_pair_map_neg_apply : forall A f g a:set,
		  a :e A ->
		  apply_fun f a :e R ->
		  apply_fun g a :e R ->
		  apply_fun (compose_fun A (pair_map A f (compose_fun A g neg_fun)) add_fun_R) a =
		    add_SNo (apply_fun f a) (minus_SNo (apply_fun g a)).
admit.
Qed.

		(** helper for 35 Step II: algebraic cancellation identity **)
Theorem Tietze_stepII_algebra_tail : forall gx rx ux c:set,
		  SNo gx -> SNo rx -> SNo ux -> SNo c ->
		  add_SNo (add_SNo gx (mul_SNo ux c))
		    (mul_SNo (add_SNo rx (minus_SNo ux)) c)
		  = add_SNo gx (mul_SNo rx c).
admit.
Qed.
	
		(** helper for 35: -1 < 0 in R **)
Theorem Rlt_minus1_0 : Rlt (minus_SNo 1) 0.
admit.
Qed.

(** helper for 35: 0 is in [-1,1] **)
Theorem zero_in_closed_interval_minus1_1 : 0 :e closed_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper for 35 Step II: real-valued extension with range in [-1,1] **)
(** LATEX VERSION: Step 2 (core): extend f:A(-1,1) by an infinite series of Urysohn functions; here packaged as existence of a continuous gR:XR agreeing with f on A and mapping X into [-1,1]. **)
(** helper for 35 Step II: nonempty closed subset case, real-valued extension **)
(** LATEX VERSION: Step II (nonempty A): construct a real-valued continuous extension gR:X->R agreeing with f on A and bounded in [-1,1]. **)
Theorem Tietze_stepII_real_extension_nonempty : forall X Tx A f:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  A <> Empty ->
  continuous_map A (subspace_topology X Tx A)
    (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) f ->
  exists gR:set,
    continuous_map X Tx R R_standard_topology gR /\
    (forall x:set, x :e A -> apply_fun gR x = apply_fun f x) /\
    (forall x:set, x :e X -> apply_fun gR x :e closed_interval (minus_SNo 1) 1).
admit.
Qed.
Theorem Tietze_stepII_real_extension : forall X Tx A f:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A)
    (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) f ->
  exists gR:set,
    continuous_map X Tx R R_standard_topology gR /\
    (forall x:set, x :e A -> apply_fun gR x = apply_fun f x) /\
    (forall x:set, x :e X -> apply_fun gR x :e closed_interval (minus_SNo 1) 1).
admit.
Qed.

(** helper for 35: Tietze extension theorem for the range [-1,1] (Step I-II skeleton) **)
Theorem Tietze_extension_minus1_1 : forall X Tx A f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A)
    (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) f ->
  exists g:set,
    continuous_map X Tx (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** helper for 35: existence of an affine homeomorphism between a nondegenerate closed interval and [-1,1] **)
(** LATEX VERSION: For a<b there is an affine homeomorphism between [a,b] and [-1,1], with both directions continuous. **)
Theorem closed_interval_affine_equiv_minus1_1 : forall a b:set,
  Rle a b -> ~(a = b) ->
  exists h:set, exists hinv:set,
    continuous_map (closed_interval a b) (closed_interval_topology a b)
      (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1) h /\
    (continuous_map (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1)
      (closed_interval a b) (closed_interval_topology a b) hinv /\
     ((forall t:set, t :e closed_interval a b -> apply_fun hinv (apply_fun h t) = t) /\
      (forall s:set, s :e closed_interval (minus_SNo 1) 1 -> apply_fun h (apply_fun hinv s) = s))).
admit.
Qed.

(** helper: compactness of the closed interval [-1,1] **)
(** LATEX VERSION: The interval [-1,1] is compact, by transferring compactness from [0,1] along an affine equivalence. **)
Theorem closed_interval_minus1_1_compact :
  compact_space (closed_interval (minus_SNo 1) 1) (closed_interval_topology (minus_SNo 1) 1).
admit.
Qed.

(** helper: compactness of closed intervals in R **)
(** LATEX VERSION: Every closed interval [a,b] is compact in the subspace topology inherited from the standard topology on R. **)
Theorem closed_interval_compact : forall a b:set,
  Rle a b ->
  compact_space (closed_interval a b) (closed_interval_topology a b).
admit.
Qed.
Theorem Tietze_extension_interval : forall X Tx A a b f:set,
  Rle a b ->
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) (closed_interval a b) (closed_interval_topology a b) f ->
  exists g:set, continuous_map X Tx (closed_interval a b) (closed_interval_topology a b) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** helper: inclusion of a subspace is continuous (local lemma for later sections) **)
(** LATEX VERSION: If A  X then the inclusion map A  X is continuous for the subspace topology. **)
Theorem subspace_inclusion_continuous : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A}.
admit.
Qed.

(** helper for 35: interval-valued Tietze gives a real-valued extension when the range is already bounded **)
(** LATEX VERSION: If f maps into [a,b], then extending f to [a,b] and composing with the inclusion yields a real-valued extension. **)
Theorem Tietze_extension_real_bounded_interval : forall X Tx A a b f:set,
  Rle a b ->
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) R R_standard_topology f ->
  (forall x:set, x :e A -> apply_fun f x :e closed_interval a b) ->
  exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** helper for 35: open interval valued extension (needed for composing with the inverse bounded transform) **)
(** LATEX VERSION: Extend a continuous f:A->(-1,1) to a continuous g:X->(-1,1) in a normal space. **)
Theorem Tietze_extension_open_interval : forall X Tx A f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A)
    (open_interval (minus_SNo 1) 1)
    (subspace_topology R R_standard_topology (open_interval (minus_SNo 1) 1))
    f ->
  exists g:set,
    continuous_map X Tx
      (open_interval (minus_SNo 1) 1)
      (subspace_topology R R_standard_topology (open_interval (minus_SNo 1) 1))
      g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** helper for 35: bounded transform phi **)
(** LATEX VERSION: Define phi(t)=t/(1+|t|), a continuous map (-1,1). **)
Definition bounded_transform_phi : set :=
  graph R (fun t:set => div_SNo t (add_SNo 1 (abs_SNo t))).

(** helper for 35: bounded transform maps reals to reals **)
Theorem bounded_transform_phi_value_in_R : forall t:set,
  t :e R -> apply_fun bounded_transform_phi t :e R.
admit.
Qed.

(** helper for 35: bounded transform range is within the closed interval [-1,1] **)
Theorem bounded_transform_phi_range_in_closed_interval_minus1_1 : forall t:set,
  t :e R ->
  apply_fun bounded_transform_phi t :e closed_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper for 35: strict range is within the open interval (-1,1) **)
Theorem bounded_transform_phi_strict_bounds : forall t:set,
  t :e R ->
  Rlt (minus_SNo 1) (apply_fun bounded_transform_phi t) /\
  Rlt (apply_fun bounded_transform_phi t) 1.
admit.
Qed.

(** helper for 35: inverse bounded transform psi **)
(** LATEX VERSION: Define psi(s)=s/(1-|s|), inverse to phi on (-1,1). **)
Definition bounded_transform_psi : set :=
  graph R (fun s:set => div_SNo s (add_SNo 1 (minus_SNo (abs_SNo s)))).

(** helper for 35: abs distributes over division by positive denominator **)
Theorem abs_div_SNo_pos : forall x y:set,
  SNo x -> SNo y -> 0 < y ->
  abs_SNo (div_SNo x y) = div_SNo (abs_SNo x) y.
admit.
Qed.

(** helper for 35: nonneg numerator over positive denominator is nonneg **)
Theorem div_SNo_nonneg_pos_nonneg : forall x y:set,
  SNo x -> SNo y -> 0 <= x -> 0 < y -> 0 <= div_SNo x y.
admit.
Qed.

(** helper for 35: division by a nonzero denominator distributes over unary minus on numerator **)
Theorem div_SNo_minus_num : forall x y:set,
  SNo x -> SNo y -> y <> 0 -> div_SNo (minus_SNo x) y = minus_SNo (div_SNo x y).
admit.
Qed.

(** helper for 35: absolute value is less than 1 on the open interval (-1,1) **)
Theorem abs_lt_one_of_open_interval : forall s:set,
  s :e open_interval (minus_SNo 1) 1 -> abs_SNo s < 1.
admit.
Qed.

(** helper for 35: open interval (-1,1) is closed under unary minus **)
Theorem neg_closed_open_interval_minus1_1 : forall s:set,
  s :e open_interval (minus_SNo 1) 1 -> (minus_SNo s) :e open_interval (minus_SNo 1) 1.
admit.
Qed.

(** helper for 35: bounded transform phi is odd **)
Theorem bounded_transform_phi_odd : forall t:set,
  t :e R -> apply_fun bounded_transform_phi (minus_SNo t) = minus_SNo (apply_fun bounded_transform_phi t).
admit.
Qed.

(** helper for 35: bounded transform psi is odd on the open interval (-1,1) **)
Theorem bounded_transform_psi_odd_open_interval : forall s:set,
  s :e open_interval (minus_SNo 1) 1 ->
  apply_fun bounded_transform_psi (minus_SNo s) = minus_SNo (apply_fun bounded_transform_psi s).
admit.
Qed.

(** helper for 35: preimage of an upper open ray under psi on the open interval **)
Theorem bounded_transform_psi_preimage_open_ray_upper : forall a:set,
  a :e R ->
  preimage_of (open_interval (minus_SNo 1) 1)
              bounded_transform_psi
              (open_ray_upper R a)
  :e subspace_topology R R_standard_topology (open_interval (minus_SNo 1) 1).
admit.
Qed.

(** helper for 35: preimage of a lower open ray under psi on the open interval **)
Theorem bounded_transform_psi_preimage_open_ray_lower : forall b:set,
  b :e R ->
  preimage_of (open_interval (minus_SNo 1) 1)
              bounded_transform_psi
              (open_ray_lower R b)
  :e subspace_topology R R_standard_topology (open_interval (minus_SNo 1) 1).
admit.
Qed.

(** helper for 35: psi cancels phi on R (intended inverse identity) **)
Theorem bounded_transform_psi_phi_cancel : forall t:set,
  t :e R ->
  apply_fun bounded_transform_psi (apply_fun bounded_transform_phi t) = t.
admit.
Qed.

(** helper for 35: continuity of psi on the open interval (-1,1) **)
Theorem bounded_transform_psi_continuous_open_interval :
  continuous_map (open_interval (minus_SNo 1) 1)
                 (subspace_topology R R_standard_topology (open_interval (minus_SNo 1) 1))
                 R R_standard_topology
                 bounded_transform_psi.
admit.
Qed.

(** helper for 35: positivity reflects through bounded transform **)
Theorem bounded_transform_phi_Rlt0_implies_Rlt0 : forall t:set,
  t :e R -> Rlt 0 (apply_fun bounded_transform_phi t) -> Rlt 0 t.
admit.
Qed.

(** helper for 35: negativity reflects through bounded transform **)
Theorem bounded_transform_phi_Rlt0_implies_Rlt0_neg : forall t:set,
  t :e R -> Rlt (apply_fun bounded_transform_phi t) 0 -> Rlt t 0.
admit.
Qed.

(** helper for 35: preimage of an upper open ray, strict middle case **)
Theorem bounded_transform_phi_preimage_open_ray_upper_neg_case_eq : forall a:set,
  a :e R -> Rlt a 0 -> Rlt (minus_SNo 1) a ->
  preimage_of R bounded_transform_phi (open_ray_upper R a) =
  open_ray_upper R (div_SNo a (add_SNo 1 a)).
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_upper_pos_case_eq : forall a:set,
  a :e R -> Rlt 0 a -> Rlt a 1 ->
  preimage_of R bounded_transform_phi (open_ray_upper R a) =
  open_ray_upper R (div_SNo a (add_SNo 1 (minus_SNo a))).
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_upper_zero_eq :
  preimage_of R bounded_transform_phi (open_ray_upper R 0) = open_ray_upper R 0.
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_upper_strict_mid : forall a:set,
  a :e R -> Rlt (minus_SNo 1) a -> Rlt a 1 ->
  preimage_of R bounded_transform_phi (open_ray_upper R a) :e R_standard_topology.
admit.
Qed.

(** helper for 35: preimage of an upper open ray, middle case **)
Theorem bounded_transform_phi_preimage_open_ray_upper_mid : forall a:set,
  a :e R -> ~(Rlt a (minus_SNo 1)) -> Rlt a 1 ->
  preimage_of R bounded_transform_phi (open_ray_upper R a) :e R_standard_topology.
admit.
Qed.

(** helper for 35: preimage of an upper open ray **)
Theorem bounded_transform_phi_preimage_open_ray_upper : forall a:set,
  a :e R -> preimage_of R bounded_transform_phi (open_ray_upper R a) :e R_standard_topology.
admit.
Qed.

(** helper for 35: preimage of a lower open ray, middle case **)
Theorem bounded_transform_phi_preimage_open_ray_lower_neg_case_eq : forall b:set,
  b :e R -> Rlt b 0 -> Rlt (minus_SNo 1) b ->
  preimage_of R bounded_transform_phi (open_ray_lower R b) =
  open_ray_lower R (div_SNo b (add_SNo 1 b)).
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_lower_pos_case_eq : forall b:set,
  b :e R -> Rlt 0 b -> Rlt b 1 ->
  preimage_of R bounded_transform_phi (open_ray_lower R b) =
  open_ray_lower R (div_SNo b (add_SNo 1 (minus_SNo b))).
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_lower_zero_eq :
  preimage_of R bounded_transform_phi (open_ray_lower R 0) = open_ray_lower R 0.
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_lower_strict_mid : forall b:set,
  b :e R -> Rlt (minus_SNo 1) b -> Rlt b 1 ->
  preimage_of R bounded_transform_phi (open_ray_lower R b) :e R_standard_topology.
admit.
Qed.
Theorem bounded_transform_phi_preimage_open_ray_lower_mid : forall b:set,
  b :e R -> ~(Rlt 1 b) -> Rlt (minus_SNo 1) b ->
  preimage_of R bounded_transform_phi (open_ray_lower R b) :e R_standard_topology.
admit.
Qed.

(** helper for 35: preimage of a lower open ray **)
Theorem bounded_transform_phi_preimage_open_ray_lower : forall b:set,
  b :e R -> preimage_of R bounded_transform_phi (open_ray_lower R b) :e R_standard_topology.
admit.
Qed.

(** helper for 35: bounded transform is continuous in the standard topology on R **)
Theorem bounded_transform_phi_continuous :
  continuous_map R R_standard_topology R R_standard_topology bounded_transform_phi.
admit.
Qed.

(** helper for 35: reciprocal is continuous on the positive reals, via bounded transforms **)
(** LATEX VERSION: The map t -> 1/t is continuous on (0, infinity). **)
Theorem recip_pos_continuous_via_bounded_transforms :
  continuous_map (open_ray_upper R 0)
                 (subspace_topology R R_standard_topology (open_ray_upper R 0))
                 R R_standard_topology
                 (compose_fun (open_ray_upper R 0)
                   (compose_fun R bounded_transform_phi one_minus_fun)
                   bounded_transform_psi).
admit.
Qed.

(** helper for 41: the bounded-transform reciprocal equals the Dedekind-cut reciprocal on positive reals **)
(** LATEX VERSION: For t>0, psi(1-phi(t)) = 1/t. **)
Theorem recip_pos_value_eq_recip_SNo_pos : forall t:set,
  t :e open_ray_upper R 0 ->
  apply_fun (compose_fun (open_ray_upper R 0)
              (compose_fun R bounded_transform_phi one_minus_fun)
              bounded_transform_psi) t = recip_SNo_pos t.
admit.
Qed.

(** helper for 41: composing a positive continuous real function with reciprocal preserves continuity **)
(** LATEX VERSION: If f is continuous and f(x)>0, then x -> 1/f(x) is continuous. **)
Theorem reciprocal_of_positive_continuous_map :
  forall X Tx f:set,
    topology_on X Tx ->
    continuous_map X Tx R R_standard_topology f ->
    (forall x:set, x :e X -> Rlt 0 (apply_fun f x)) ->
    continuous_map X Tx R R_standard_topology
      (compose_fun X f
        (compose_fun (open_ray_upper R 0)
          (compose_fun R bounded_transform_phi one_minus_fun)
          bounded_transform_psi)).
admit.
Qed.
Theorem Tietze_extension_real : forall X Tx A f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) R R_standard_topology f ->
  exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** from 36 Definition: m-manifold **) 
(** LATEX VERSION: An m-manifold is Hausdorff and second countable (dimension suppressed here). **)
(** LATEX VERSION: An m-manifold is a Hausdorff space with a countable basis such that each point has a neighborhood homeomorphic with an open subset of R^m. **)
Definition m_manifold : set -> set -> set -> prop := fun X Tx m =>
  Hausdorff_space X Tx /\
  second_countable_space X Tx /\
  m :e omega /\
  forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      exists V:set, V :e (euclidean_topology m) /\
        exists f:set,
          homeomorphism U (subspace_topology X Tx U)
                       V (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.

(** from 36 Definition: support of a function **)
(** LATEX VERSION: If phi:XR, support(phi) is the closure of {xX | phi(x)0}. **)
Definition support_of : set -> set -> set -> set := fun X Tx phi =>
  closure_of X Tx {x :e X | apply_fun phi x <> 0}.

(** helper: support is a subset of the ambient space **)
Theorem support_of_sub_X : forall X Tx phi:set,
  topology_on X Tx ->
  support_of X Tx phi c= X.
admit.
Qed.

(** helper: support is closed **)
Theorem support_of_closed_in : forall X Tx phi:set,
  topology_on X Tx ->
  closed_in X Tx (support_of X Tx phi).
admit.
Qed.

(** helper: if phi(x) is nonzero then x lies in the support **)
(** LATEX VERSION: If phi(x) != 0 then x is in supp(phi). **)
Theorem support_of_contains_nonzero : forall X Tx phi x:set,
  topology_on X Tx ->
  x :e X ->
  apply_fun phi x <> 0 ->
  x :e support_of X Tx phi.
admit.
Qed.

(** helper: if an open neighborhood misses the support then the function is zero there **)
(** LATEX VERSION: If x lies in an open set N disjoint from supp(phi), then phi(x)=0. **)
Theorem support_of_disjoint_open_implies_value_zero : forall X Tx phi N x:set,
  topology_on X Tx ->
  N :e Tx ->
  x :e N ->
  support_of X Tx phi :/\: N = Empty ->
  apply_fun phi x = 0.
admit.
Qed.

(** helper: support of a pointwise product is contained in the support of the left factor **)
(** LATEX VERSION: If h(x)=f(x) times g(x), then supp(h) is contained in supp(f). **)
Theorem support_of_mul_two_Subq_support_left : forall X Tx f g:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> apply_fun f x :e R) ->
  (forall x:set, x :e X -> apply_fun g x :e R) ->
  support_of X Tx (compose_fun X (pair_map X f g) mul_fun_R) c= support_of X Tx f.
admit.
Qed.

(** helper: support of a pointwise product is contained in the support of the right factor **)
(** LATEX VERSION: If h(x)=f(x) times g(x), then supp(h) is contained in supp(g). **)
Theorem support_of_mul_two_Subq_support_right : forall X Tx f g:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> apply_fun f x :e R) ->
  (forall x:set, x :e X -> apply_fun g x :e R) ->
  support_of X Tx (compose_fun X (pair_map X f g) mul_fun_R) c= support_of X Tx g.
admit.
Qed.

(** helper: open set meeting the closure meets the set **)
(** LATEX VERSION: If N is open and N meets cl(A), then N meets A. **)
Theorem open_intersects_closure_implies_intersects : forall X Tx A N:set,
  topology_on X Tx ->
  N :e Tx ->
  N :/\: closure_of X Tx A <> Empty ->
  N :/\: A <> Empty.
admit.
Qed.

(** helper: support is contained in the closure of any set containing the nonzero locus **)
(** LATEX VERSION: If f vanishes outside U, then supp(f)  cl(U). **)
Theorem support_of_sub_closure_of : forall X Tx phi U:set,
  topology_on X Tx ->
  U c= X ->
  (forall x:set, x :e X -> apply_fun phi x <> 0 -> x :e U) ->
  support_of X Tx phi c= closure_of X Tx U.
admit.
Qed.

(** helper: Urysohn bump function for a closed subset inside an open set **)
(** LATEX VERSION: If A is closed and A  V (V open) in a normal space, then there is a continuous f:X[0,1] with f=1 on A and f=0 on X\\V. **)
Theorem Urysohn_bump_closed_in_open : forall X Tx A V:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  V :e Tx ->
  A c= V ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 1) /\
    (forall x:set, x :e (X :\: V) -> apply_fun f x = 0) /\
    (forall x:set, x :e X -> apply_fun f x :e unit_interval).
admit.
Qed.

(** helper: support control for a function that vanishes outside an open set **)
(** LATEX VERSION: If f=0 on X\\V and V is open, then supp(f)  cl(V). **)
Theorem support_of_zero_outside_open_sub_closure : forall X Tx f V:set,
  topology_on X Tx ->
  V :e Tx ->
  (forall x:set, x :e (X :\: V) -> apply_fun f x = 0) ->
  support_of X Tx f c= closure_of X Tx V.
admit.
Qed.

(** helper: support of Urysohn bump is contained in closure(V) **)
(** LATEX VERSION: For the Urysohn bump with f=0 on X\\V, supp(f)  cl(V). **)
Theorem Urysohn_bump_support_sub_closure : forall X Tx A V:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  V :e Tx ->
  A c= V ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 1) /\
    (forall x:set, x :e (X :\: V) -> apply_fun f x = 0) /\
    (forall x:set, x :e X -> apply_fun f x :e unit_interval) /\
    support_of X Tx f c= closure_of X Tx V.
admit.
Qed.

(** from 36 Definition: partition of unity dominated by a cover **) 
(** LATEX VERSION: For an indexed open cover {U_i}, a family of continuous functions phi_i:X[0,1] is a partition of unity dominated by {U_i} if: (1) support(phi_i)U_i, (2) the supports are locally finite (automatic in the finite case), and (3) sum phi_i(x)=1 for all x. **)
Definition partition_of_unity_dominated : set -> set -> set -> prop := fun X Tx U =>
  topology_on X Tx /\ open_cover X Tx U /\
  exists P:set,
    P c= function_space X R /\
	    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
	    (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
	    (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
	    (forall x:set, x :e X ->
	      exists N:set, N :e Tx /\ x :e N /\
	        exists F0:set, finite F0 /\ F0 c= P /\
	          forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) /\
	    (forall x:set, x :e X ->
	      exists F:set, finite F /\ F c= P /\
	        (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
	        exists n:set, n :e omega /\
          exists e:set, bijection n F e /\
            exists p:set,
              function_on p (ordsucc n) R /\
              apply_fun p Empty = 0 /\
              (forall k:set, k :e n ->
                apply_fun p (ordsucc k) =
                  add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)) /\
              apply_fun p n = 1).

(** helper: predicate for the partition-of-unity function family itself **)
(** LATEX VERSION: The family P of functions satisfies continuity, [0,1]-valuedness, domination by U via supports, local finiteness of supports, and pointwise finite summation to 1. **)
Definition partition_of_unity_family : set -> set -> set -> set -> prop := fun X Tx U P =>
  P c= function_space X R /\
	  (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
	  (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
	  (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
	  (forall x:set, x :e X ->
	    exists N:set, N :e Tx /\ x :e N /\
	      exists F0:set, finite F0 /\ F0 c= P /\
	        forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) /\
	  (forall x:set, x :e X ->
	    exists F:set, finite F /\ F c= P /\
	      (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
	      exists n:set, n :e omega /\
        exists e:set, bijection n F e /\
          exists p:set,
            function_on p (ordsucc n) R /\
            apply_fun p Empty = 0 /\
            (forall k:set, k :e n ->
              apply_fun p (ordsucc k) =
                add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)) /\
            apply_fun p n = 1).

(** helper: extract P subset of function_space from partition_of_unity_family **)
Theorem partition_of_unity_family_sub_function_space : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  P c= function_space X R.
admit.
Qed.

(** helper: extract continuity of members from partition_of_unity_family **)
Theorem partition_of_unity_family_continuous : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f.
admit.
Qed.

(** helper: extract unit_interval range from partition_of_unity_family **)
Theorem partition_of_unity_family_unit_interval : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval.
admit.
Qed.

(** helper: extract support domination by U from partition_of_unity_family **)
Theorem partition_of_unity_family_support_dominated : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u.
admit.
Qed.

(** helper: extract local finiteness of supports from partition_of_unity_family **)
Theorem partition_of_unity_family_supports_locally_finite : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists F0:set, finite F0 /\ F0 c= P /\
        forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0.
admit.
Qed.

(** helper: local finiteness of supports implies pointwise finiteness of nonzero values **)
(** LATEX VERSION: If only finitely many supports meet some neighborhood of x, then only finitely many functions are nonzero at x. **)
Theorem pointwise_finite_from_local_support_finite : forall X Tx P x N F0:set,
  topology_on X Tx ->
  x :e X ->
  N :e Tx ->
  x :e N ->
  finite F0 ->
  F0 c= P ->
  (forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) ->
  (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F0).
admit.
Qed.

(** helper: if a support does not meet an open set then the function is zero on that open set **)
(** LATEX VERSION: If N is open and N is disjoint from supp(f), then f vanishes on N. **)
Theorem support_disjoint_open_implies_zero_on_open : forall X Tx f N:set,
  topology_on X Tx ->
  N :e Tx ->
  support_of X Tx f :/\: N = Empty ->
  forall x:set, x :e N -> apply_fun f x = 0.
admit.
Qed.

(** helper for 41: if only finitely many supports meet an open set then every other function is zero on that open set **)
(** LATEX VERSION: If a neighborhood N meets the support of a function only when that function lies in a fixed finite family F0, then any function outside F0 vanishes on N. **)
Theorem local_support_finite_outside_F0_zero_on_open : forall X Tx P N F0 f:set,
  topology_on X Tx ->
  N :e Tx ->
  F0 c= P ->
  (forall g:set, g :e P -> support_of X Tx g :/\: N <> Empty -> g :e F0) ->
  f :e P ->
  ~(f :e F0) ->
  forall x:set, x :e N -> apply_fun f x = 0.
admit.
Qed.

(** helper: if nonzero points of g are among those of f then supp(g) is contained in supp(f) **)
(** LATEX VERSION: If {x | g(x) != 0} is contained in {x | f(x) != 0}, then supp(g) is contained in supp(f). **)
Theorem support_of_monotone_nonzero : forall X Tx f g:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> apply_fun g x <> 0 -> apply_fun f x <> 0) ->
  support_of X Tx g c= support_of X Tx f.
admit.
Qed.

(** helper: local finiteness of supports gives pointwise finiteness on the whole neighborhood **)
(** LATEX VERSION: If only finitely many supports meet N, then at every y in N only finitely many functions are nonzero. **)
Theorem pointwise_finite_on_neighborhood_from_local_support_finite :
  forall X Tx P N F0:set,
    topology_on X Tx ->
    N :e Tx ->
    finite F0 ->
    F0 c= P ->
    (forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) ->
    forall y:set, y :e N ->
      forall f:set, f :e P -> apply_fun f y <> 0 -> f :e F0.
admit.
Qed.

(** helper: continuity of an enumerated finite sum of continuous real maps **)
(** LATEX VERSION: A finite sum of continuous real-valued maps is continuous. **)
Theorem enumerated_finite_sum_continuous : forall X Tx F n e:set,
  topology_on X Tx ->
  n :e omega ->
  bijection n F e ->
  (forall f:set, f :e F -> continuous_map X Tx R R_standard_topology f) ->
  continuous_map X Tx R R_standard_topology
    (graph X (fun x:set =>
      nat_primrec 0
        (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
        n)).
admit.
Qed.

(** helper: pulling out a constant factor from an enumerated finite sum **)
(** LATEX VERSION: For a finite sum s(x)=sum_k a_k(x) and a constant r, we have s(x) times r = sum_k (a_k(x) times r). **)
Theorem nat_primrec_add_mul_const_right : forall X n e x r:set,
  n :e omega ->
  x :e X ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e R) ->
  r :e R ->
  mul_SNo
    (nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n)
    r
  =
  nat_primrec 0 (fun k acc:set => add_SNo acc (mul_SNo (apply_fun (apply_fun e k) x) r)) n.
admit.
Qed.

(** helper: normalizing a finite sum by its reciprocal gives 1 **)
(** LATEX VERSION: If s = sum_k a_k and s>0, then sum_k (a_k times (1/s)) = 1. **)
Theorem nat_primrec_sum_times_recip_pos_eq_1 : forall X n e x:set,
  n :e omega ->
  x :e X ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e R) ->
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n :e R ->
  Rlt 0 (nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n) ->
  nat_primrec 0
    (fun k acc:set =>
      add_SNo acc
        (mul_SNo (apply_fun (apply_fun e k) x)
                 (recip_SNo_pos
                   (nat_primrec 0 (fun j b:set => add_SNo b (apply_fun (apply_fun e j) x)) n))))
    n
  = 1.
admit.
Qed.

(** helper: if x is nonnegative, then y is below x plus y **)
(** LATEX VERSION: If 0<=x then y <= x+y. **)
Theorem Rle_increase_by_nonneg_left : forall x y:set,
  x :e R ->
  y :e R ->
  Rle 0 x ->
  Rle y (add_SNo x y).
admit.
Qed.

(** helper: finite sums of pointwise nonnegative terms are nonnegative **)
(** LATEX VERSION: If all terms are >=0 then their finite sum is >=0. **)
Theorem nat_primrec_sum_Rle0_of_Rle0_terms : forall X n e x:set,
  n :e omega ->
  x :e X ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e R) ->
  (forall k:set, k :e n -> Rle 0 (apply_fun (apply_fun e k) x)) ->
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n :e R /\
  Rle 0 (nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n).
admit.
Qed.

(** helper: each successor step increases a nonnegative-term sum **)
(** LATEX VERSION: If a_k >= 0 then partial_sum(k) <= partial_sum(k+1). **)
Theorem nat_primrec_sum_Rle_succ_of_Rle0_term : forall X n e x k:set,
  n :e omega ->
  k :e n ->
  x :e X ->
  (forall j:set, j :e n -> apply_fun (apply_fun e j) x :e R) ->
  (forall j:set, j :e n -> Rle 0 (apply_fun (apply_fun e j) x)) ->
  nat_primrec 0 (fun j acc:set => add_SNo acc (apply_fun (apply_fun e j) x)) k :e R ->
  Rle
    (nat_primrec 0 (fun j acc:set => add_SNo acc (apply_fun (apply_fun e j) x)) k)
    (nat_primrec 0 (fun j acc:set => add_SNo acc (apply_fun (apply_fun e j) x)) (ordsucc k)).
admit.
Qed.

(** helper: extract pointwise finite summation from partition_of_unity_family **)
Theorem partition_of_unity_family_pointwise_finite_sum : forall X Tx U P:set,
  partition_of_unity_family X Tx U P ->
  forall x:set, x :e X ->
    exists F:set, finite F /\ F c= P /\
      (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
      exists n:set, n :e omega /\
        exists e:set, bijection n F e /\
          exists p:set,
            function_on p (ordsucc n) R /\
            apply_fun p Empty = 0 /\
            (forall k:set, k :e n ->
              apply_fun p (ordsucc k) =
                add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)) /\
            apply_fun p n = 1.
admit.
Qed.

(** helper for 41.7: finite nat_primrec sums of continuous maps are continuous (on the whole domain) **)
(** LATEX VERSION: A finite sum of continuous real-valued functions is continuous. **)
Theorem nat_primrec_sum_continuous_map : forall X Tx n F e:set,
  topology_on X Tx ->
  n :e omega ->
  bijection n F e ->
  (forall f:set, f :e F -> continuous_map X Tx R R_standard_topology f) ->
  continuous_map X Tx R R_standard_topology
    (graph X (fun x:set =>
      nat_primrec 0
        (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
        n)).
admit.
Qed.

(** helper: finite set admits a bijection from some n:e omega (graph form) **)
(** NOTE: This is a small bridge between the pre-topology definitions finite/equip/bij and the later graph-form bijection predicate. **)
Theorem finite_ex_bijection_from_omega : forall F:set,
  finite F -> exists n e:set, n :e omega /\ bijection n F e.
admit.
Qed.

(** helper: locally finite supports imply pointwise finite summation witnesses (without sum equal to 1) **)
(** LATEX VERSION: If a family of continuous functions has locally finite supports, then at each point only finitely many terms are nonzero, so a finite-sum recursion witness exists. **)
Theorem locally_finite_supports_pointwise_sum_witness : forall X Tx P:set,
  topology_on X Tx ->
  P c= function_space X R ->
  (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) ->
  (forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists F0:set, finite F0 /\ F0 c= P /\
        forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) ->
  forall x:set, x :e X ->
    exists F:set, finite F /\ F c= P /\
      (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
      exists n:set, n :e omega /\
        exists e:set, bijection n F e /\
          exists p:set,
            function_on p (ordsucc n) R /\
            apply_fun p Empty = 0 /\
            (forall k:set, k :e n ->
              apply_fun p (ordsucc k) =
                add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)).
admit.
Qed.

(** helper: extract the family predicate from partition_of_unity_dominated **)
(** LATEX VERSION: If a cover admits a partition of unity, then there exists a family P satisfying the partition-of-unity family conditions. **)
Theorem partition_of_unity_dominated_ex_family_pred : forall X Tx U:set,
  partition_of_unity_dominated X Tx U ->
  exists P:set, partition_of_unity_family X Tx U P.
admit.
Qed.

(** helper: extract topology_on and open_cover together from partition_of_unity_dominated **)
(** LATEX VERSION: A partition of unity dominated by U presupposes that Tx is a topology on X and that U is an open cover. **)
Theorem partition_of_unity_dominated_topology_open_cover : forall X Tx U:set,
  partition_of_unity_dominated X Tx U -> topology_on X Tx /\ open_cover X Tx U.
admit.
Qed.

(** helper: extract topology_on from partition_of_unity_dominated **)
Theorem partition_of_unity_dominated_topology : forall X Tx U:set,
  partition_of_unity_dominated X Tx U -> topology_on X Tx.
admit.
Qed.

(** helper: extract open_cover from partition_of_unity_dominated **)
Theorem partition_of_unity_dominated_open_cover : forall X Tx U:set,
  partition_of_unity_dominated X Tx U -> open_cover X Tx U.
admit.
Qed.

(** helper: extract existence of the partition family P **)
Theorem partition_of_unity_dominated_ex_family : forall X Tx U:set,
  partition_of_unity_dominated X Tx U ->
  exists P:set,
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
    (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
    (forall x:set, x :e X ->
      exists N:set, N :e Tx /\ x :e N /\
        exists F0:set, finite F0 /\ F0 c= P /\
          forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0) /\
    (forall x:set, x :e X ->
      exists F:set, finite F /\ F c= P /\
        (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
        exists n:set, n :e omega /\
          exists e:set, bijection n F e /\
            exists p:set,
              function_on p (ordsucc n) R /\
              apply_fun p Empty = 0 /\
              (forall k:set, k :e n ->
                apply_fun p (ordsucc k) =
                  add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)) /\
              apply_fun p n = 1).
admit.
Qed.

(** helper: partition_of_unity_dominated implies the cover is a family of subsets of X **)
(** LATEX VERSION: If U admits a partition of unity on X, then U is a family of subsets of X. **)
Theorem partition_of_unity_dominated_cover_sub_Power : forall X Tx U:set,
  partition_of_unity_dominated X Tx U -> U c= Power X.
admit.
Qed.

(** helper: partition_of_unity_dominated implies U covers X **)
(** LATEX VERSION: A partition of unity subordinate to U implies U covers X. **)
Theorem partition_of_unity_dominated_covers : forall X Tx U:set,
  partition_of_unity_dominated X Tx U -> covers X U.
admit.
Qed.

(** helper: pointwise congruence for nat_primrec finite sums **)
(** LATEX VERSION: If two enumerations agree pointwise on all indices, then the induced finite sum agrees. **)
Theorem nat_primrec_sum_congr_on : forall X n e1 e2 x:set,
  nat_p n ->
  x :e X ->
  (forall k:set, k :e n -> apply_fun e1 k = apply_fun e2 k) ->
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e1 k) x)) n =
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e2 k) x)) n.
admit.
Qed.

(** helper: swap the top two indices in ordsucc (ordsucc m) **)
Definition swap_last_two : set -> set -> set := fun e m =>
  graph (ordsucc (ordsucc m))
        (fun i:set =>
           if i = m then apply_fun e (ordsucc m)
           else if i = ordsucc m then apply_fun e m
           else apply_fun e i).

(** helper: unfold apply_fun for swap_last_two **)
Theorem swap_last_two_apply : forall e m i:set, i :e ordsucc (ordsucc m) ->
  apply_fun (swap_last_two e m) i =
    if i = m then apply_fun e (ordsucc m)
    else if i = ordsucc m then apply_fun e m
    else apply_fun e i.
admit.
Qed.

(** helper: swap_last_two value at m **)
Theorem swap_last_two_at_m : forall e m:set, nat_p m ->
  apply_fun (swap_last_two e m) m = apply_fun e (ordsucc m).
admit.
Qed.

(** helper: swap_last_two value at ordsucc m **)
Theorem swap_last_two_at_sm : forall e m:set, nat_p m ->
  apply_fun (swap_last_two e m) (ordsucc m) = apply_fun e m.
admit.
Qed.

(** helper: function_on is preserved by swap_last_two **)
Theorem function_on_swap_last_two : forall F e m:set,
  nat_p m ->
  function_on e (ordsucc (ordsucc m)) F ->
  function_on (swap_last_two e m) (ordsucc (ordsucc m)) F.
admit.
Qed.

(** helper: bijection is preserved by swap_last_two **)
Theorem bijection_swap_last_two : forall F e m:set,
  nat_p m ->
  bijection (ordsucc (ordsucc m)) F e ->
  bijection (ordsucc (ordsucc m)) F (swap_last_two e m).
admit.
Qed.

(** helper: swapping the last two summands does not change a finite nat_primrec sum **)
(** LATEX VERSION: Finite sums of reals are invariant under swapping adjacent summands at the end. **)
Theorem nat_primrec_sum_swap_last_two_unit_interval : forall X m e x:set,
  m :e omega ->
  x :e X ->
  (forall k:set, k :e ordsucc (ordsucc m) -> apply_fun (apply_fun e k) x :e unit_interval) ->
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun (swap_last_two e m) k) x))
    (ordsucc (ordsucc m))
  =
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
    (ordsucc (ordsucc m)).
admit.
Qed.

(** helper: if the last summand is zero then the successor sum collapses **)
(** LATEX VERSION: Adding 0 as the last term does not change a finite sum. **)
Theorem nat_primrec_sum_S_drop_zero_unit_interval : forall X n e x:set,
  n :e omega ->
  x :e X ->
  (forall k:set, k :e ordsucc n -> apply_fun (apply_fun e k) x :e unit_interval) ->
  apply_fun (apply_fun e n) x = 0 ->
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc n) =
  nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n.
admit.
Qed.

(** helper: if the last term is zero, drop it and keep a bijection witness for the smaller family **)
(** LATEX VERSION: If a finite family is enumerated by a bijection and the last enumerated term vanishes at x, then dropping that last element preserves the sum and yields a bijection for the remaining set. **)
Theorem nat_primrec_sum_drop_last_zero_bijection_unit_interval :
  forall X n F e x:set,
    n :e omega ->
    x :e X ->
    (forall k:set, k :e ordsucc n -> apply_fun (apply_fun e k) x :e unit_interval) ->
    apply_fun (apply_fun e n) x = 0 ->
    bijection (ordsucc n) F e ->
    bijection n (F :\: {apply_fun e n}) e /\
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc n) =
      nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n.
admit.
Qed.

(** helper: swap adjacent indices i and ordsucc i inside a fixed domain n **)
Definition swap_adjacent : set -> set -> set -> set := fun e i n =>
  graph n (fun j:set =>
    if j = i then apply_fun e (ordsucc i)
    else if j = ordsucc i then apply_fun e i
    else apply_fun e j).

(** helper: unfold apply_fun for swap_adjacent **)
Theorem swap_adjacent_apply : forall e i n j:set, j :e n ->
  apply_fun (swap_adjacent e i n) j =
    if j = i then apply_fun e (ordsucc i)
    else if j = ordsucc i then apply_fun e i
    else apply_fun e j.
admit.
Qed.

(** helper: value of swap_adjacent at ordsucc i **)
Theorem swap_adjacent_at_succ : forall e i n:set,
  ordsucc i :e n ->
  apply_fun (swap_adjacent e i n) (ordsucc i) = apply_fun e i.
admit.
Qed.

(** helper: value of swap_adjacent at i **)
Theorem swap_adjacent_at_i : forall e i n:set,
  i :e n ->
  apply_fun (swap_adjacent e i n) i = apply_fun e (ordsucc i).
admit.
Qed.

(** helper: function_on is preserved by swap_adjacent **)
Theorem function_on_swap_adjacent : forall F e i n:set,
  i :e n ->
  ordsucc i :e n ->
  function_on e n F ->
  function_on (swap_adjacent e i n) n F.
admit.
Qed.

(** helper: bijection is preserved by swap_adjacent **)
Theorem bijection_swap_adjacent : forall F e i n:set,
  i :e n ->
  ordsucc i :e n ->
  bijection n F e ->
  bijection n F (swap_adjacent e i n).
admit.
Qed.

(** helper: swapping adjacent indices does not change the total nat_primrec sum **)
(** LATEX VERSION: Finite sums are invariant under swapping two adjacent summands. **)
Theorem nat_primrec_sum_swap_adjacent_unit_interval : forall X n e i x:set,
  n :e omega ->
  i :e n ->
  ordsucc i :e n ->
  x :e X ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e unit_interval) ->
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun (swap_adjacent e i n) k) x))
    n
  =
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
    n.
admit.
Qed.

(** helper: adjacent swap preserves bijection and leaves the sum unchanged **)
(** LATEX VERSION: If e enumerates a finite family by a bijection, swapping two adjacent indices gives another bijection and does not change the finite sum. **)
Theorem nat_primrec_sum_swap_adjacent_bijection_unit_interval : forall X n F e i x:set,
  n :e omega ->
  i :e n ->
  ordsucc i :e n ->
  x :e X ->
  bijection n F e ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e unit_interval) ->
  bijection n F (swap_adjacent e i n) /\
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun (swap_adjacent e i n) k) x))
    n
  =
  nat_primrec 0
    (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
    n.
admit.
Qed.

(** helper for 41: bubble a zero-valued term one step to the right (uses adjacent swap) **)
(** LATEX VERSION: If one summand is zero at x, swapping it with the adjacent summand moves the zero one step to the right without changing the total sum. **)
Theorem nat_primrec_sum_bubble_zero_right_unit_interval : forall X n F e i x:set,
  n :e omega ->
  i :e n ->
  ordsucc i :e n ->
  x :e X ->
  bijection n F e ->
  (forall k:set, k :e n -> apply_fun (apply_fun e k) x :e unit_interval) ->
  apply_fun (apply_fun e i) x = 0 ->
  exists e':set,
    e' = swap_adjacent e i n /\
    bijection n F e' /\
    nat_primrec 0
      (fun k acc:set => add_SNo acc (apply_fun (apply_fun e' k) x))
      n
    =
    nat_primrec 0
      (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x))
      n
    /\
    apply_fun (apply_fun e' (ordsucc i)) x = 0.
admit.
Qed.

(** helper for 41: move a chosen enumerated element to the last index without changing the pointwise sum **)
(** LATEX VERSION: Given a finite sum over a bijection enumeration and a chosen element of the finite set, we may reorder the enumeration so that the chosen element appears last, without changing the sum. **)
Theorem nat_primrec_sum_bijection_move_value_to_last_unit_interval :
  forall X m F e flast x:set,
    m :e omega ->
    x :e X ->
    bijection (ordsucc m) F e ->
    flast :e F ->
    (forall f:set, f :e F -> apply_fun f x :e unit_interval) ->
    exists e':set,
      bijection (ordsucc m) F e' /\
      nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc m)
      =
      nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e' k) x)) (ordsucc m)
      /\
      apply_fun e' m = flast.
admit.
Qed.

(** helper for 41.7: if some summand equals 1 then the finite sum is at least 1 **)
(** LATEX VERSION: If one term equals 1 and all terms are in [0,1], then the finite sum is >= 1. **)
Theorem nat_primrec_sum_bijection_Rle1_if_some_term_eq1_unit_interval :
  forall X x m F e f1:set,
    m :e omega ->
    x :e X ->
    bijection (ordsucc m) F e ->
    f1 :e F ->
    (forall f:set, f :e F -> apply_fun f x :e unit_interval) ->
    apply_fun f1 x = 1 ->
    Rle 1 (nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc m)).
admit.
Qed.

(** helper for 41.7: the same hypotheses imply the finite sum is positive **)
(** LATEX VERSION: If one term equals 1 and all terms are in [0,1], then the finite sum is > 0. **)
Theorem nat_primrec_sum_bijection_Rlt0_if_some_term_eq1_unit_interval :
  forall X x m F e f1:set,
    m :e omega ->
    x :e X ->
    bijection (ordsucc m) F e ->
    f1 :e F ->
    (forall f:set, f :e F -> apply_fun f x :e unit_interval) ->
    apply_fun f1 x = 1 ->
    Rlt 0 (nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc m)).
admit.
Qed.

(** helper for 41: nat_primrec sums do not depend on the chosen bijection enumeration **)
(** LATEX VERSION: The value of a finite sum over a finite set is invariant under reordering the enumeration. **)
Theorem nat_primrec_sum_bijection_independent_unit_interval :
  forall X m F e1 e2 x:set,
    m :e omega ->
    x :e X ->
    bijection (ordsucc m) F e1 ->
    bijection (ordsucc m) F e2 ->
    (forall f:set, f :e F -> apply_fun f x :e unit_interval) ->
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e1 k) x)) (ordsucc m)
    =
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e2 k) x)) (ordsucc m).
admit.
Qed.

(** helper for 41: drop a chosen zero-valued summand from a bijection enumeration **)
(** LATEX VERSION: If one summand evaluates to 0 at x, it can be removed from the finite sum without changing the value. **)
Theorem nat_primrec_sum_bijection_drop_zero_element_unit_interval :
  forall X m F e f0 x:set,
    m :e omega ->
    x :e X ->
    bijection (ordsucc m) F e ->
    f0 :e F ->
    (forall f:set, f :e F -> apply_fun f x :e unit_interval) ->
    apply_fun f0 x = 0 ->
    exists e':set,
      bijection m (F :\: {f0}) e' /\
      nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) (ordsucc m)
      =
      nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e' k) x)) m.
admit.
Qed.

(** helper: equinumerous naturals are equal **)
(** LATEX VERSION: Finite ordinals are uniquely determined by cardinality: if n,m in omega are equipotent then n=m. **)
Theorem equip_omega_eq : forall n m:set,
  n :e omega -> m :e omega -> equip n m -> n = m.
admit.
Qed.

(** helper for 41: adding finitely-many zero-valued summands does not change a nat_primrec finite sum **)
(** LATEX VERSION: If all functions outside a finite subfamily vanish at x, then the pointwise finite sum depends only on that subfamily (up to bijection). **)
Theorem nat_primrec_sum_bijection_zero_outside_unit_interval :
  forall X x n0 F0 e0 n F e:set,
    x :e X ->
    n0 :e omega ->
    finite F ->
    F0 c= F ->
    (exists f:set, f :e F0) ->
    (forall f:set, f :e F0 -> apply_fun f x :e unit_interval) ->
    (forall f:set, f :e F -> ~(f :e F0) -> apply_fun f x = 0) ->
    bijection n0 F0 e0 ->
    n :e omega ->
    bijection n F e ->
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e0 k) x)) n0
    =
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e k) x)) n.
admit.
Qed.

(** helper for 41.7: two finite control families give the same pointwise sum (unit interval case) **)
(** LATEX VERSION: If outside each of two finite subfamilies the terms vanish at x, then both finite sums agree. **)
Theorem nat_primrec_sum_bijection_equal_of_two_control_sets_unit_interval :
  forall X x n0 F0 e0 n1 F1 e1 n F e:set,
    x :e X ->
    n0 :e omega ->
    n1 :e omega ->
    n :e omega ->
    finite F ->
    F0 c= F ->
    F1 c= F ->
    (exists f:set, f :e F0) ->
    (exists f:set, f :e F1) ->
    (forall f:set, f :e F0 -> apply_fun f x :e unit_interval) ->
    (forall f:set, f :e F1 -> apply_fun f x :e unit_interval) ->
    (forall f:set, f :e F -> ~(f :e F0) -> apply_fun f x = 0) ->
    (forall f:set, f :e F -> ~(f :e F1) -> apply_fun f x = 0) ->
    bijection n0 F0 e0 ->
    bijection n1 F1 e1 ->
    bijection n F e ->
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e0 k) x)) n0
    =
    nat_primrec 0 (fun k acc:set => add_SNo acc (apply_fun (apply_fun e1 k) x)) n1.
admit.
Qed.

(** helper: extract the local finiteness of supports from partition_of_unity_dominated **)
(** LATEX VERSION: A partition of unity is locally finite in the sense that each point has a neighborhood meeting only finitely many supports. **)
Theorem partition_of_unity_dominated_supports_locally_finite : forall X Tx U:set,
  partition_of_unity_dominated X Tx U ->
  exists P:set,
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
    (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
    (forall x:set, x :e X ->
      exists N:set, N :e Tx /\ x :e N /\
        exists F0:set, finite F0 /\ F0 c= P /\
          forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0).
admit.
Qed.

(** helper: extract the pointwise finite summation clause from partition_of_unity_dominated **)
(** LATEX VERSION: For each x in X, only finitely many functions of the partition are nonzero at x, and their sum equals 1. **)
Theorem partition_of_unity_dominated_pointwise_finite_sum : forall X Tx U:set,
  partition_of_unity_dominated X Tx U ->
  exists P:set,
    forall x:set, x :e X ->
      exists F:set, finite F /\ F c= P /\
        (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
        exists n:set, n :e omega /\
          exists e:set, bijection n F e /\
            exists p:set,
              function_on p (ordsucc n) R /\
              apply_fun p Empty = 0 /\
              (forall k:set, k :e n ->
                apply_fun p (ordsucc k) =
                  add_SNo (apply_fun p k) (apply_fun (apply_fun e k) x)) /\
              apply_fun p n = 1.
admit.
Qed.

(** from 39 Definition: locally finite family **)
(** LATEX VERSION: A family F of subsets of X is locally finite if every x  X has a neighborhood meeting only finitely many members of F. **)
(** MOVED: This definition is used by the 36 partition-of-unity statements, so it is placed here to avoid forward references. **)
Definition locally_finite_family : set -> set -> set -> prop := fun X Tx F =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists S:set, finite S /\ S c= F /\
        forall A:set, A :e F -> A :/\: N <> Empty -> A :e S.

(** helper: extract topology_on from locally_finite_family **)
Theorem locally_finite_family_topology : forall X Tx F:set,
  locally_finite_family X Tx F -> topology_on X Tx.
admit.
Qed.

(** helper: extract the neighborhood-finite part from locally_finite_family **)
Theorem locally_finite_family_property : forall X Tx F:set,
  locally_finite_family X Tx F ->
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists S:set, finite S /\ S c= F /\
        forall A:set, A :e F -> A :/\: N <> Empty -> A :e S.
admit.
Qed.

(** helper: locally finite open covers yield a neighborhood contained in a finite subunion **)
(** LATEX VERSION: If W is a locally finite open cover and xX, there is an open neighborhood N of x and a finite subfamily SW with NUnion S. **)
Theorem locally_finite_open_cover_neighborhood_finite_subunion : forall X Tx W x:set,
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  x :e X ->
  exists N S:set, N :e Tx /\ x :e N /\ finite S /\ S c= W /\ N c= Union S.
admit.
Qed.

(** helper: in a locally finite open cover, only finitely many members have closures containing a given point **)
(** LATEX VERSION: For a locally finite open cover W and xX, there is a finite subfamily SW such that if xcl(w) then wS. **)
Theorem locally_finite_open_cover_closure_point_finite : forall X Tx W x:set,
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  x :e X ->
  exists S:set, finite S /\ S c= W /\
    forall w:set, w :e W -> x :e closure_of X Tx w -> w :e S.
admit.
Qed.

(** helper: subfamily of a locally finite family is locally finite **)
Theorem locally_finite_subfamily : forall X Tx F G:set,
  locally_finite_family X Tx F ->
  G c= F ->
  locally_finite_family X Tx G.
admit.
Qed.

(** helper: locally finite family is preserved by taking one subset per member (Repl image) **)
(** LATEX VERSION: If W is locally finite and f(w)  w for all wW, then {f(w) | wW} is locally finite. **)
Theorem locally_finite_family_Repl_subsets : forall X Tx W:set, forall f:set->set,
  locally_finite_family X Tx W ->
  (forall w:set, w :e W -> f w c= w) ->
  locally_finite_family X Tx {f w|w :e W}.
admit.
Qed.

(** helper: locally finite families give a finite controlling subfamily at each point **)
(** LATEX VERSION: If F is locally finite, then each x lies in only finitely many members of F (existential finite witness form). **)
Theorem locally_finite_family_point_finite_ex : forall X Tx F:set,
  locally_finite_family X Tx F ->
  forall x:set, x :e X ->
    exists S:set, finite S /\ S c= F /\
      forall A:set, A :e F -> x :e A -> A :e S.
admit.
Qed.

(** helper: finite families are locally finite **)
(** LATEX VERSION: Any finite family of subsets is locally finite (choose neighborhood N=X and S=F). **)
Theorem finite_family_locally_finite : forall X Tx F:set,
  topology_on X Tx -> finite F -> F c= Power X ->
  locally_finite_family X Tx F.
admit.
Qed.

(** helper: finite open_cover implies locally finite family **)
(** LATEX VERSION: Finite open covers are locally finite. **)
Theorem finite_open_cover_locally_finite : forall X Tx U:set,
  topology_on X Tx ->
  open_cover X Tx U ->
  finite U ->
  locally_finite_family X Tx U.
admit.
Qed.

(** helper: finite open_cover_of implies locally finite family **)
(** LATEX VERSION: In the packaged open_cover_of form, finiteness still implies local finiteness. **)
Theorem finite_open_cover_of_locally_finite : forall X Tx Fam:set,
  open_cover_of X Tx Fam ->
  finite Fam ->
  locally_finite_family X Tx Fam.
admit.
Qed.

(** helper: closures of a locally finite family form a locally finite family **)
(** LATEX VERSION: If a family is locally finite, then the family of its closures is locally finite as well. **)
Theorem locally_finite_family_closures : forall X Tx Fam:set,
  locally_finite_family X Tx Fam ->
  locally_finite_family X Tx {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** helper: union of a locally finite family of closed sets is closed **)
(** LATEX VERSION: If Fam is locally finite and each AFam is closed, then Union Fam is closed. **)
Theorem Union_locally_finite_closed_is_closed : forall X Tx Fam:set,
  locally_finite_family X Tx Fam ->
  (forall A:set, A :e Fam -> closed_in X Tx A) ->
  closed_in X Tx (Union Fam).
admit.
Qed.

(** helper: closures of a locally finite open cover form a locally finite closed cover **)
(** LATEX VERSION: If W is a locally finite open cover, then {cl(w) | wW} is a locally finite closed cover of X. **)
Theorem locally_finite_open_cover_closures_closed_cover : forall X Tx W:set,
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists ClW:set,
    ClW = {closure_of X Tx w|w :e W} /\
    ((forall C:set, C :e ClW -> closed_in X Tx C) /\ covers X ClW) /\
    locally_finite_family X Tx ClW /\
    (forall C:set, C :e ClW -> exists w:set, w :e W /\ C = closure_of X Tx w).
admit.
Qed.

(** helper: finite open covers can be shrunk in normal spaces **)
(** LATEX VERSION: Every finite open cover of a normal space admits an open refinement whose members have closures contained in members of the original cover. **)
Theorem normal_space_finite_open_cover_shrinking : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  finite W ->
  exists V:set,
    open_cover X Tx V /\
    finite V /\
    (forall v:set, v :e V -> exists w:set, w :e W /\ v c= w) /\
    forall v:set, v :e V -> exists w:set, w :e W /\ closure_of X Tx v c= w.
admit.
Qed.

(** helper: shrink a finite open cover of a closed subset in a normal space **)
(** LATEX VERSION: If A is closed and covered by finitely many open sets, one can refine to finitely many open sets whose closures lie in members of the cover. **)
Theorem normal_space_finite_open_cover_shrinking_closed : forall X Tx A F:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  finite F ->
  (forall w:set, w :e F -> w :e Tx) ->
  A c= Union F ->
  exists V:set,
    finite V /\
    (forall v:set, v :e V -> v :e Tx) /\
    A c= Union V /\
    forall v:set, v :e V -> exists w:set, w :e F /\ closure_of X Tx v c= w.
admit.
Qed.

(** NOTE: The well-ordering theorem is declared earlier in the topology section to avoid forward-reference issues. **)

(** helper: core open subset for a member of a locally finite open cover **)
(** LATEX VERSION: For w in a locally finite open cover W of X, the set Bw = X \\ Union{cl(w0) | w0W\\{w}} is open, contained in w, and has cl(Bw)  w. **)
Theorem locally_finite_open_cover_core_open_set : forall X Tx W w:set,
  topology_on X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  w :e W ->
  exists Bw:set, Bw :e Tx /\ Bw c= w /\ closure_of X Tx Bw c= w.
admit.
Qed.

(** helper: core family extracted from a locally finite open cover **)
(** LATEX VERSION: From a locally finite open cover W of X, one can extract a locally finite family B of open sets, each bB lying in some wW with cl(b)w (this does not assert that B covers X). **)
Theorem locally_finite_open_cover_core_family : forall X Tx W:set,
  topology_on X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists B:set,
    (forall b:set, b :e B -> b :e Tx) /\
    locally_finite_family X Tx B /\
    (forall b:set, b :e B -> exists w:set, w :e W /\ b c= w) /\
    forall b:set, b :e B -> exists w:set, w :e W /\ closure_of X Tx b c= w.
admit.
Qed.

(** helper: nonempty subset of an ordinal has a least element **)
Theorem nonempty_subset_of_ordinal_has_least : forall I S:set,
  ordinal I ->
  S c= I ->
  S <> Empty ->
  exists m:set, m :e S /\ forall s:set, s :e S -> m c= s.
admit.
Qed.

(** helper: least element of a subset is unique **)
Theorem ordinal_subset_least_unique : forall I S m1 m2:set,
  ordinal I ->
  S c= I ->
  m1 :e S ->
  (forall s:set, s :e S -> m1 c= s) ->
  m2 :e S ->
  (forall s:set, s :e S -> m2 c= s) ->
  m1 = m2.
admit.
Qed.

(** helper: a finite nonempty subset of an ordinal has a maximal element **)
Theorem finite_nonempty_subset_of_ordinal_has_max : forall I S:set,
  ordinal I ->
  finite S ->
  S c= I ->
  S <> Empty ->
  exists m:set, m :e S /\ forall s:set, s :e S -> s c= m.
admit.
Qed.

(** helper: in a point-finite cover enumerated by an ordinal, each point has a maximal index among cover members containing it **)
Theorem point_finite_cover_has_max_index : forall X W I:set, forall idx pickW:set->set,
  ordinal I ->
  covers X W ->
  (forall x:set, x :e X ->
    exists S:set, finite S /\ S c= W /\ forall A:set, A :e W -> x :e A -> A :e S) ->
  (forall w:set, w :e W -> idx w :e I) ->
  (forall i:set, i :e I -> pickW i :e W /\ idx (pickW i) = i) ->
  (forall w:set, w :e W -> pickW (idx w) = w) ->
  forall x:set, x :e X ->
    exists imax:set,
      imax :e I /\ x :e pickW imax /\ forall j:set, j :e I -> imax :e j -> x /:e pickW j.
admit.
Qed.

(** helper: shrinking of locally finite open covers in normal spaces (needed for normal-space partition of unity) **)
(** LATEX VERSION: If {W_i} is a locally finite open cover of a normal space, then it admits an open shrinking {V_i} with cl(V_i)  W_i. **)
(** BOTTLENECK: Recursive admits for `normal_locally_finite_partition_of_unity_family` and finite-cover partitions of unity go through this lemma; the 41.8 paracompact-Hausdorff chain is currently recadmit-free. Planned route: prove using a well-ordering of W and a transfinite recursion shrinking one set at a time, using normality and local finiteness to keep earlier closures under control. **)
(** Internal working version: recursion proof is now admit-free. **)
Theorem normal_locally_finite_open_cover_shrinking_rec : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists V:set,
    open_cover X Tx V /\
    locally_finite_family X Tx V /\
    (forall v:set, v :e V -> exists w:set, w :e W /\ v c= w) /\
    forall v:set, v :e V -> exists w:set, w :e W /\ closure_of X Tx v c= w.
admit.
Qed.

(** Wrapper: public name for the shrinking lemma, delegating to the internal recursion proof. **)
Theorem normal_locally_finite_open_cover_shrinking : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists V:set,
    open_cover X Tx V /\
    locally_finite_family X Tx V /\
    (forall v:set, v :e V -> exists w:set, w :e W /\ v c= w) /\
    forall v:set, v :e V -> exists w:set, w :e W /\ closure_of X Tx v c= w.
admit.
Qed.

(** from 39 Definition: refinement of a cover **)
(** LATEX VERSION: A family V refines U if every vV is contained in some uU. **)
Definition refine_of : set -> set -> prop := fun V U =>
  forall v:set, v :e V -> exists u:set, u :e U /\ v c= u.

Axiom function_space_extensional : forall X Y f g:set,
  f :e function_space X Y ->
  g :e function_space X Y ->
  (forall x:set, x :e X -> apply_fun f x = apply_fun g x) ->
  f = g.

(** helper for 41 Theorem 41.7: normalize a dominated bump cover into a partition of unity **)
(** LATEX VERSION: Starting from a locally finite family of continuous unit-interval bump functions dominated by U and pointwise hitting 1, normalize by the pointwise finite sum to obtain a partition of unity dominated by U. **)
(** BOTTLENECK: This is intended to replace the current dependency chain through normal-space locally-finite shrinking and partitions of unity. **)
Theorem locally_finite_bump_cover_normalizes_to_partition_of_unity_dominated :
  forall X Tx U V P:set,
    topology_on X Tx ->
    open_cover X Tx U ->
    open_cover X Tx V ->
    locally_finite_family X Tx V ->
    refine_of V U ->
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
    (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
    (forall x:set, x :e X -> exists f:set, f :e P /\ apply_fun f x = 1) /\
    (forall x:set, x :e X ->
      exists N:set, N :e Tx /\ x :e N /\
        exists F0:set, finite F0 /\ F0 c= P /\
          forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0)
    ->
    partition_of_unity_dominated X Tx U.
admit.
Qed.

(** helper: locally finite open covers admit a partition of unity on normal spaces (placeholder) **) 
(** LATEX VERSION: On a normal space, every locally finite open cover admits a partition of unity subordinate to it. **)
(** BOTTLENECK: This is the core missing piece in the recadmit chain for 41.7 and 41.8. Once the shrinking lemma above is proved, this should be completed by building Urysohn bump functions with locally finite supports, then normalizing via a continuous reciprocal on the positive ray (see reciprocal_of_positive_continuous_map). **)
(** Internal working version: keeps the remaining admits while the construction is refined. **)
Theorem normal_locally_finite_partition_of_unity_family_rec : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists P:set, partition_of_unity_family X Tx W P.
admit.
Qed.

(** Wrapper: public name for the locally finite partition of unity lemma. **)
Theorem normal_locally_finite_partition_of_unity_family : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  exists P:set, partition_of_unity_family X Tx W P.
admit.
Qed.

(** from 36 Theorem 36.1: existence of finite partition of unity on normal space **) 
(** LATEX VERSION: On a normal space, every finite open cover has a partition of unity subordinate to it. **)
(** helper: construction of a partition of unity family subordinate to a finite open cover **)
Theorem finite_open_cover_has_partition_of_unity_family : forall X Tx U:set,
  normal_space X Tx ->
  finite U ->
  open_cover X Tx U ->
  exists P:set, partition_of_unity_family X Tx U P.
admit.
Qed.
Theorem finite_partition_of_unity_exists : forall X Tx U:set,
  normal_space X Tx -> finite U -> open_cover X Tx U -> partition_of_unity_dominated X Tx U.
admit.
Qed.

(** from 36 Theorem: compact manifold embeds in Euclidean space **) 
(** LATEX VERSION: Any compact manifold embeds in some Euclidean space. **)
(** NOTE: This theorem is proved later, after the 50 embedding machinery, to avoid forward-reference issues. **)

(** helper for 37: coordinate projection of a packed net in a product **)
(** LATEX VERSION: If N=(J,le,f) is a packed net in _{iI} X_i, then for each iI the projected packed net
    N_i=(J,le,jf(j)(i)) is a packed net in X_i (same index/order, projected underlying net). **)
Theorem net_pack_coord_projection_in_space : forall I Xi N i:set,
  net_pack_in_space (product_space I Xi) N ->
  i :e I ->
  exists Ni:set,
    net_pack_in_space (space_family_set Xi i) Ni /\
    net_pack_index Ni = net_pack_index N /\
    net_pack_le Ni = net_pack_le N /\
    Ni =
      net_pack (net_pack_index N) (net_pack_le N)
        (graph (net_pack_index N) (fun j:set => apply_fun (apply_fun (net_pack_fun N) j) i)).
admit.
Qed.

(** from 37 Lemma 37.1: maximal finite intersection property family **)
(** LATEX VERSION: Let X be a set; let A be a collection of subsets of X having the finite intersection property. Then there is a collection D of subsets of X such that D contains A, D has the finite intersection property, and no collection of subsets of X that properly contains D has this property. **)
(** NOTE: This is the Zorn-style maximality lemma used in the TeX proof of the Tychonoff theorem. The current development does not yet connect it to `compact_space`; it is recorded here for coverage and future alignment with the TeX proof. **)
Definition finite_intersection_property : set -> set -> prop := fun X A =>
  A c= Power X /\
  forall F:set, finite F -> F c= A -> intersection_of_family X F <> Empty.

(** from 37 Lemma 37.1: maximal with respect to finite intersection property **)
(** LATEX VERSION: A collection D is maximal with respect to the finite intersection property if it has the property and no proper larger collection does. **)
Definition maximal_finite_intersection_property : set -> set -> prop := fun X D =>
  finite_intersection_property X D /\
  forall E:set, D c= E -> finite_intersection_property X E -> E c= D.
Theorem Lemma37_1_maximal_fip_extension : forall X A:set,
  finite_intersection_property X A ->
  exists D:set, A c= D /\ maximal_finite_intersection_property X D.
admit.
Qed.

(** from 37 Lemma 37.2(a): maximal FIP families are closed under finite intersections **)
(** LATEX VERSION: Any finite intersection of elements of D is an element of D. **)
Theorem Lemma37_2a_max_fip_finite_intersections_in : forall X D:set,
  maximal_finite_intersection_property X D ->
  forall F:set, finite F -> F c= D ->
    intersection_of_family X F :e D.
admit.
Qed.

(** from 37 Lemma 37.2(b): maximal FIP families contain all sets meeting every member **)
(** LATEX VERSION: If A is a subset of X that intersects every element of D, then A is an element of D. **)
Theorem Lemma37_2b_max_fip_meets_all_implies_in : forall X D A:set,
  maximal_finite_intersection_property X D ->
  A c= X ->
  (forall B:set, B :e D -> A :/\: B <> Empty) ->
  A :e D.
admit.
Qed.

(** helper for 37: compactness gives global intersection for closed FIP families **)
(** LATEX VERSION: In a compact space, any family of closed sets with the finite intersection property has nonempty intersection. **)
Theorem compact_space_closed_FIP_intersection_nonempty : forall X Tx D:set,
  compact_space X Tx ->
  (forall C:set, C :e D -> closed_in X Tx C) ->
  finite_intersection_property X D ->
  intersection_of_family X D <> Empty.
admit.
Qed.

(** helper for 37: closed-FIP characterization (direction: closed-FIP -> compact) **)
(** LATEX VERSION: A space is compact iff every family of closed sets with the finite intersection property has nonempty intersection. (This is the closed-FIP  compact direction.) **)
Theorem compact_space_of_closed_FIP_intersection_nonempty : forall X Tx:set,
  topology_on X Tx ->
  (forall D:set,
    (forall C:set, C :e D -> closed_in X Tx C) ->
    finite_intersection_property X D ->
    intersection_of_family X D <> Empty) ->
  compact_space X Tx.
admit.
Qed.

(** helper for 37: compact factor gives convergent subnet of projected packed net **)
(** LATEX VERSION: If X_i is compact and N is a packed net in _{iI} X_i, then the projected packed net N_i has a convergent packed subnet in X_i. **)
Theorem net_pack_coord_projection_has_convergent_subnet_in_compact_factor :
  forall I Xi N i:set,
    net_pack_in_space (product_space I Xi) N ->
    i :e I ->
    compact_space (product_component Xi i) (product_component_topology Xi i) ->
    exists Ni Si x:set,
      net_pack_in_space (space_family_set Xi i) Ni /\
      net_pack_index Ni = net_pack_index N /\
      net_pack_le Ni = net_pack_le N /\
      Ni =
        net_pack (net_pack_index N) (net_pack_le N)
          (graph (net_pack_index N) (fun j:set => apply_fun (apply_fun (net_pack_fun N) j) i)) /\
      subnet_pack_of_in (space_family_set Xi i) Ni Si /\
      net_pack_converges (space_family_set Xi i) (space_family_topology Xi i) Si x.
admit.
Qed.

(** helper for 37: diagonalization step for packed nets in products **)
(** LATEX VERSION: Given, for each coordinate i, a convergent packed subnet of the projected packed net, one can diagonalize to obtain a single packed subnet of the original net converging in the product topology. **)
(** NOTE: The proof of `Tychonoff_coordinate_subnets_to_common_subnet` is still admitted; if later issues arise,
    re-check that the TeX hypotheses are captured correctly (in particular, common-subnet existence may require
    stronger compatibility assumptions than pointwise existence of convergent coordinate subnets). **)
(** NOTE: We treat the diagonal/common-subnet construction as an axiom for dependency tracking; a proof sketch is kept below. **)
Axiom Tychonoff_coordinate_subnets_to_common_subnet :
  forall I Xi N x:set,
    I <> Empty ->
    net_pack_in_space (product_space I Xi) N ->
    x :e product_space I Xi ->
    (forall i:set, i :e I ->
      exists Ni Si:set,
        net_pack_in_space (space_family_set Xi i) Ni /\
        net_pack_index Ni = net_pack_index N /\
        net_pack_le Ni = net_pack_le N /\
        Ni =
          net_pack (net_pack_index N) (net_pack_le N)
            (graph (net_pack_index N) (fun j:set => apply_fun (apply_fun (net_pack_fun N) j) i)) /\
        subnet_pack_of_in (space_family_set Xi i) Ni Si /\
        net_pack_converges (space_family_set Xi i) (space_family_topology Xi i) Si (apply_fun x i)) ->
    exists J le net:set,
      subnet_pack_of_in (product_space I Xi) N (net_pack J le net) /\
      (forall i:set, i :e I ->
        net_converges_on (space_family_set Xi i) (space_family_topology Xi i)
          (compose_fun J net (product_eval_map I Xi i))
          J le (apply_fun x i)).

(** Proof sketch (not used for dependencies) **)
Theorem Tychonoff_coordinate_subnets_to_common_subnet_sketch :
  forall I Xi N x:set,
    I <> Empty ->
    net_pack_in_space (product_space I Xi) N ->
    x :e product_space I Xi ->
    (forall i:set, i :e I ->
      exists Ni Si:set,
        net_pack_in_space (space_family_set Xi i) Ni /\
        net_pack_index Ni = net_pack_index N /\
        net_pack_le Ni = net_pack_le N /\
        Ni =
          net_pack (net_pack_index N) (net_pack_le N)
            (graph (net_pack_index N) (fun j:set => apply_fun (apply_fun (net_pack_fun N) j) i)) /\
        subnet_pack_of_in (space_family_set Xi i) Ni Si /\
        net_pack_converges (space_family_set Xi i) (space_family_topology Xi i) Si (apply_fun x i)) ->
    exists J le net:set,
      subnet_pack_of_in (product_space I Xi) N (net_pack J le net) /\
      (forall i:set, i :e I ->
        net_converges_on (space_family_set Xi i) (space_family_topology Xi i)
          (compose_fun J net (product_eval_map I Xi i))
          J le (apply_fun x i)).
admit.
Qed.
Theorem Tychonoff_diagonalize_from_coordinate_subnets :
  forall I Xi N:set,
    I <> Empty ->
    net_pack_in_space (product_space I Xi) N ->
    (forall i:set, i :e I ->
      exists Ni Si x:set,
        net_pack_in_space (space_family_set Xi i) Ni /\
        net_pack_index Ni = net_pack_index N /\
        net_pack_le Ni = net_pack_le N /\
        Ni =
          net_pack (net_pack_index N) (net_pack_le N)
            (graph (net_pack_index N) (fun j:set => apply_fun (apply_fun (net_pack_fun N) j) i)) /\
        subnet_pack_of_in (space_family_set Xi i) Ni Si /\
        net_pack_converges (space_family_set Xi i) (space_family_topology Xi i) Si x) ->
    exists S x:set,
      subnet_pack_of_in (product_space I Xi) N S /\
      net_pack_converges (product_space I Xi) (product_topology_full I Xi) S x.
admit.
Qed.

(** from 37 Theorem: Tychonoff theorem **)
(** LATEX VERSION: Arbitrary product of compact spaces is compact (Tychonoff). **)
(** FIXED: Hypothesis quantifies i only over i:e I (not all sets). **) 
Theorem Tychonoff_theorem : forall I Xi:set,
  (forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i)) ->
  compact_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

(** from 38 Definition: Stone-Cech compactification and universal property **) 
(** LATEX VERSION: Stoneech compactification X as closure of the evaluation embedding into I^{C(X,I)} (existence of compact Hausdorff topology). **)
(** family of all continuous maps X -> I, used as the index set for the Tychonoff cube **)
Definition Stone_Cech_index : set -> set -> set := fun X Tx =>
  {f :e function_space X unit_interval | continuous_map X Tx unit_interval unit_interval_topology f}.

(** ambient cube I^{C(X,I)} **)
Definition Stone_Cech_ambient_family : set -> set -> set := fun X Tx =>
  const_space_family (Stone_Cech_index X Tx) unit_interval unit_interval_topology.
Definition Stone_Cech_ambient_space : set -> set -> set := fun X Tx =>
  product_space (Stone_Cech_index X Tx) (Stone_Cech_ambient_family X Tx).
Definition Stone_Cech_ambient_topology : set -> set -> set := fun X Tx =>
  product_topology_full (Stone_Cech_index X Tx) (Stone_Cech_ambient_family X Tx).

(** evaluation image of X in the cube (as a subset of the ambient product space) **)
Definition Stone_Cech_image : set -> set -> set := fun X Tx =>
  {p :e Stone_Cech_ambient_space X Tx |
    exists x:set, x :e X /\
      p = graph (Stone_Cech_index X Tx) (fun f:set => apply_fun f x)}.

(** X as the closure of the evaluation image in the ambient cube **)
Definition Stone_Cech_compactification : set -> set -> set := fun X Tx =>
  closure_of (Stone_Cech_ambient_space X Tx) (Stone_Cech_ambient_topology X Tx) (Stone_Cech_image X Tx).
Theorem Stone_Cech_universal_property : forall X Tx:set,
  Tychonoff_space X Tx ->
  exists Ty:set,
    compact_space (Stone_Cech_compactification X Tx) Ty /\
    Hausdorff_space (Stone_Cech_compactification X Tx) Ty.
admit.
Qed.

(** helper: refinement transitivity **) 
Theorem refine_trans : forall U V W:set,
  refine_of W V -> refine_of V U -> refine_of W U.
admit.
Qed.

(** helper: transfer partition-of-unity family domination along a refinement **) 
(** LATEX VERSION: If the supports are dominated by a refining cover V and V refines U, then the same family is dominated by U. **)
Theorem partition_of_unity_family_refine : forall X Tx U V P:set,
  partition_of_unity_family X Tx V P ->
  refine_of V U ->
  partition_of_unity_family X Tx U P.
admit.
Qed.

(** helper: transfer partition-of-unity domination along a refinement **) 
Theorem partition_of_unity_dominated_refine : forall X Tx U V:set,
  open_cover X Tx U ->
  partition_of_unity_dominated X Tx V ->
  refine_of V U ->
  partition_of_unity_dominated X Tx U.
admit.
Qed.
(** MOVED: locally_finite_family is defined earlier (before 36) to avoid forward references. **)

(** helper: the empty family is locally finite **)
Theorem locally_finite_family_empty : forall X Tx:set,
  topology_on X Tx ->
  locally_finite_family X Tx Empty.
admit.
Qed.

(** helper: replacement of a finite set is finite **)
Theorem finite_Repl : forall X:set, finite X -> forall F:set -> set, finite {F x|x :e X}.
admit.
Qed.

(** helper: the closure image of a locally finite family is locally finite **)
Theorem locally_finite_family_closure_image : forall X Tx Fam:set,
  locally_finite_family X Tx Fam ->
  locally_finite_family X Tx {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** helper: every finite family is locally finite **)
(** LATEX VERSION: Every finite family of subsets is locally finite. **)
Theorem finite_family_locally_finite_family : forall X Tx F:set,
  topology_on X Tx ->
  finite F ->
  locally_finite_family X Tx F.
admit.
Qed.

(** helper: finite open cover is a locally finite family **)
(** LATEX VERSION: Every finite family (in particular, every finite open cover) is locally finite. **)
Theorem finite_open_cover_locally_finite_family : forall X Tx U:set,
  topology_on X Tx ->
  open_cover X Tx U ->
  finite U ->
  locally_finite_family X Tx U.
admit.
Qed.

(** MOVED: normal_locally_finite_partition_of_unity_family is stated earlier (before 36) to avoid forward references. **)
Theorem normal_locally_finite_partition_of_unity_dominated : forall X Tx W:set,
  normal_space X Tx ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  partition_of_unity_dominated X Tx W.
admit.
Qed.

(** helper: partitions of unity along locally finite refinements (placeholder) **) 
Theorem normal_locally_finite_refinement_partition_of_unity : forall X Tx U W:set,
  normal_space X Tx ->
  open_cover X Tx U ->
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  refine_of W U ->
  partition_of_unity_dominated X Tx U.
admit.
Qed.

(** helper: locally finite open cover yields a neighborhood covered by finitely many members **)
(** LATEX VERSION: If W is a locally finite open cover, then each x has an open neighborhood N meeting only finitely many members of W, hence N is covered by finitely many members of W. **)
Theorem locally_finite_open_cover_neighborhood_finite_subcover : forall X Tx W x:set,
  open_cover X Tx W ->
  locally_finite_family X Tx W ->
  x :e X ->
  exists N:set, N :e Tx /\ x :e N /\
    exists S:set, finite S /\ S c= W /\ N c= Union S /\
      forall A:set, A :e W -> A :/\: N <> Empty -> A :e S.
admit.
Qed.

(** helper: locally finite families are pointwise finite **)
(** LATEX VERSION: If F is locally finite, then for each x only finitely many members of F contain x. **)
Theorem locally_finite_family_point_finite : forall X Tx F x:set,
  locally_finite_family X Tx F ->
  x :e X ->
  finite {A :e F | x :e A}.
admit.
Qed.

(** helper: closure of a union is contained in the union of closures for locally finite families **)
Theorem closure_Union_locally_finite_subset_Union_closures : forall X Tx Fam:set,
  (forall A:set, A :e Fam -> A c= X) ->
  locally_finite_family X Tx Fam ->
  closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** helper: if a locally finite family has closures contained in an open set, then the closure of its union lies in that open set **)
(** LATEX VERSION: For a locally finite family Fam with cl(A)  U for all AFam and U open, we have cl(Union Fam)  U. **)
Theorem closure_Union_locally_finite_sub_open : forall X Tx Fam U:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  locally_finite_family X Tx Fam ->
  U :e Tx ->
  (forall A:set, A :e Fam -> closure_of X Tx A c= U) ->
  closure_of X Tx (Union Fam) c= U.
admit.
Qed.

(** from 39 Lemma 39.1(a): subcollection of locally finite is locally finite **)
(** LATEX VERSION: If A is locally finite, then any subcollection of A is locally finite. **)
Theorem lemma39_1a_subcollection_locally_finite : forall X Tx Fam Sub:set,
  locally_finite_family X Tx Fam ->
  Sub c= Fam ->
  locally_finite_family X Tx Sub.
admit.
Qed.

(** from 39 Lemma 39.1(b): closures of locally finite family are locally finite **)
(** LATEX VERSION: If A is locally finite, then the collection of closures {cl(A)} is locally finite. **)
Theorem lemma39_1b_closures_locally_finite : forall X Tx Fam:set,
  (forall A:set, A :e Fam -> A c= X) ->
  locally_finite_family X Tx Fam ->
  locally_finite_family X Tx {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** from 39 Lemma 39.1(c): closure of union equals union of closures under local finiteness **)
(** LATEX VERSION: If A is locally finite and Y=A, then cl(Y)={cl(A) | AA}. **)
Theorem lemma39_1c_closure_Union_eq_Union_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  locally_finite_family X Tx Fam ->
  closure_of X Tx (Union Fam) = Union {closure_of X Tx A|A :e Fam}.
admit.
Qed.

(** helper: point finiteness for the closure family of a locally finite family **)
(** LATEX VERSION: If a family is locally finite, then only finitely many closures contain a given point. **)
Theorem locally_finite_family_closure_point_finite_ex : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  locally_finite_family X Tx Fam ->
  forall x:set, x :e X ->
    exists S:set, finite S /\ S c= {closure_of X Tx A|A :e Fam} /\
      forall A:set, A :e Fam -> x :e closure_of X Tx A -> closure_of X Tx A :e S.
admit.
Qed.
(** from 39 Definition: locally finite collection (applied to a basis) **)
(** LATEX VERSION: A collection A is locally finite in X if every point has a neighborhood intersecting only finitely many elements of A. **)
Definition locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists B:set, basis_generates X B Tx /\ locally_finite_family X Tx B /\ (forall b:set, b :e B -> b :e Tx).
(** from 39 Definition: countably locally finite (sigma-locally finite) collection **)
(** LATEX VERSION: A collection B is countably locally finite if it is the countable union of collections B_n, each locally finite. **)
Definition sigma_locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fams:set, countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall F:set, F :e Fams -> locally_finite_family X Tx F) /\
    basis_generates X (Union Fams) Tx /\
    forall b:set, b :e Union Fams -> b :e Tx.

(** helper: unpack sigma locally finite basis data **)
Theorem sigma_locally_finite_basis_data : forall X Tx:set,
  sigma_locally_finite_basis X Tx ->
  exists Fams:set, countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall F:set, F :e Fams -> locally_finite_family X Tx F) /\
    basis_generates X (Union Fams) Tx /\
    forall b:set, b :e Union Fams -> b :e Tx.
admit.
Qed.

(** helper: basis generating Tx refines all opens of Tx **)
Theorem basis_generates_imp_basis_refines : forall X Tx B:set,
  basis_generates X B Tx ->
  basis_refines X B Tx.
admit.
Qed.

(** from 39 Lemma 39.2 (setup): well-ordering theorem **)
(** LATEX VERSION: We shall use the well-ordering theorem: every set can be well-ordered. **)
(** NOTE: This block was moved earlier to support earlier dependencies. **)

(** helper: second countable implies sigma locally finite basis (singleton decomposition) **)
Theorem second_countable_implies_sigma_locally_finite_basis : forall X Tx:set,
  second_countable_space X Tx -> sigma_locally_finite_basis X Tx.
admit.
Qed.

(** from 40 Definition: G_delta set **)
(** LATEX VERSION: A subset A of a space X is a G_delta set in X if it equals the intersection of a countable collection of open subsets of X. **)
Definition Gdelta_simple : set -> set -> set -> prop := fun X Tx A =>
  exists Fam:set, countable_set Fam /\
    Fam c= Tx /\
    A = intersection_of_family X Fam.

(** helper: union of a subfamily of a locally finite closed family is closed **)
Theorem Union_subfamily_locally_finite_closed_is_closed_early : forall X Tx Fam S:set,
  locally_finite_family X Tx Fam ->
  (forall A:set, A :e Fam -> closed_in X Tx A) ->
  S c= Fam ->
  closed_in X Tx (Union S).
admit.
Qed.

(** helper for 40 Lemma 40.1 Step 1: open set as countable union of opens with closure inside **)
(** LATEX VERSION: If W is open, then there is a countable collection {U_n} of open sets such that W =  U_n =  cl(U_n). **)
Theorem lemma40_1_step1_open_as_countable_union : forall X Tx W:set,
  regular_space X Tx ->
  sigma_locally_finite_basis X Tx ->
  W :e Tx ->
  exists Ufam:set,
    countable_set Ufam /\
    Ufam c= Tx /\
    Union Ufam = W /\
    forall U:set, U :e Ufam -> closure_of X Tx U c= W.
admit.
Qed.

(** helper for 40 Lemma 40.1 Step 3: countable separation trick **)
(** LATEX VERSION: Given countable covers {U_n},{V_n} with cl(U_n) disjoint from B and cl(V_n) disjoint from A, define U'_n and V'_n by removing finite initial closure unions to obtain disjoint open neighborhoods. **)
Theorem countable_closed_separation : forall X Tx A B Cand Dand:set,
  topology_on X Tx ->
  A c= X ->
  B c= X ->
  Cand c= Tx ->
  Dand c= Tx ->
  countable_set Cand ->
  countable_set Dand ->
  A c= Union Cand ->
  B c= Union Dand ->
  (forall c:set, c :e Cand -> closure_of X Tx c :/\: B = Empty) ->
  (forall d:set, d :e Dand -> closure_of X Tx d :/\: A = Empty) ->
  exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
admit.
Qed.

(** from 40 Lemma 40.1: regular sigma basis implies normal and closed G_delta **)
(** LATEX VERSION: Let X be a regular space with a basis B that is countably locally finite. Then X is normal, and every closed set in X is a G_delta set in X. **)
Theorem lemma40_1_regular_sigma_basis_implies_normal_and_closed_Gdelta : forall X Tx:set,
  regular_space X Tx ->
  sigma_locally_finite_basis X Tx ->
  normal_space X Tx /\ (forall C:set, closed_in X Tx C -> Gdelta_simple X Tx C).
admit.
Qed.

(** from 40 Lemma 40.2: closed G_delta yields positive function **)
(** LATEX VERSION: Let X be normal; let A be a closed G_delta set in X. Then there is a continuous function f:X->[0,1] such that f=0 on A and f>0 on X-A. **)
Theorem lemma40_2_closed_Gdelta_has_positive_function : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  Gdelta_simple X Tx A ->
  exists f:set, continuous_map X Tx unit_interval unit_interval_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e X -> x /:e A -> Rlt 0 (apply_fun f x)).
admit.
Qed.

(** helper for 40: open set admits a positive-support function **)
(** LATEX VERSION: In a normal space where every closed set is G_delta, for each open U there is continuous f:X->[0,1] with f=0 on X-U and f>0 on U. **)
Theorem open_set_has_positive_support_function : forall X Tx U:set,
  normal_space X Tx ->
  (forall C:set, closed_in X Tx C -> Gdelta_simple X Tx C) ->
  U :e Tx ->
  exists f:set, f :e function_space X R /\
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e X :\: U -> apply_fun f x = 0) /\
    (forall x:set, x :e U -> Rlt 0 (apply_fun f x)).
admit.
Qed.

(** helper for 40: open set admits a positive-support function into unit_interval **)
(** LATEX VERSION: In a normal space where every closed set is G_delta, for each open U there is continuous f:X->[0,1] with f=0 on X-U and f>0 on U. **)
Theorem open_set_has_positive_support_function_unit_interval : forall X Tx U:set,
  normal_space X Tx ->
  (forall C:set, closed_in X Tx C -> Gdelta_simple X Tx C) ->
  U :e Tx ->
  exists f0:set, continuous_map X Tx unit_interval unit_interval_topology f0 /\
    (forall x:set, x :e X :\: U -> apply_fun f0 x = 0) /\
    (forall x:set, x :e U -> Rlt 0 (apply_fun f0 x)).
admit.
Qed.

(** internal helper lemma for abs with minus zero **)
Theorem abs_SNo_add_minus_zero : forall x:set, SNo x ->
  abs_SNo (add_SNo x (minus_SNo 0)) = abs_SNo x.
admit.
Qed.

(** internal helper lemma: finite union of finite family is finite **)
Theorem finite_Union_of_finite_family : forall F:set,
  finite F ->
  (forall A:set, A :e F -> finite A) ->
  finite (Union F).
admit.
Qed.

(** from 40 Nagata-Smirnov metrization theorem **)
(** LATEX VERSION: NagataSmirnov: A regular space with a -locally-finite basis is metrizable. **)
Theorem Nagata_Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> sigma_locally_finite_basis X Tx -> metrizable X Tx.
admit.
Qed.

(** from 40 (converse direction prep): metrizable spaces have -locally-finite bases **)
(** LATEX VERSION: Every metrizable space has a -locally-finite basis (metric spaces admit a -locally-finite base). **)
(** helper: fixed-radius ball covers are open covers in metric spaces **)
(** LATEX VERSION: For each n, the family {B(x,inv_nat(ordsucc n))|xX} is an open cover of X in the metric topology. **)
Theorem metric_fixed_radius_ball_cover_open_cover : forall X d n:set,
  metric_on X d ->
  n :e omega ->
  open_cover X (metric_topology X d) {open_ball X d x (inv_nat (ordsucc n))|x :e X}.
admit.
Qed.

(** helper: fixed-radius ball covers in metric spaces admit locally finite refinements **)
(** LATEX VERSION: For each n, the cover by balls of radius inv_nat(ordsucc n) has a locally finite open refinement. **)
Axiom metric_fixed_radius_ball_cover_has_locally_finite_refinement : forall X d n:set,
	  metric_on X d ->
	  n :e omega ->
	  exists V:set,
	    open_cover X (metric_topology X d) V /\
	    locally_finite_family X (metric_topology X d) V /\
	    refine_of V {open_ball X d x (inv_nat (ordsucc n))|x :e X}.
Theorem metric_space_sigma_locally_finite_basis : forall X d:set,
  metric_on X d -> sigma_locally_finite_basis X (metric_topology X d).
admit.
Qed.

(** from 40 Theorem 40.3: Nagata-Smirnov metrization theorem (iff form) **)
(** LATEX VERSION: A space X is metrizable if and only if X is regular and has a basis that is countably locally finite. **)
(** MOVED: Placed after the forward direction theorem `Nagata_Smirnov_metrization` to avoid forward references in Megalodon. **)
Theorem Nagata_Smirnov_metrization_theorem : forall X Tx:set,
  metrizable X Tx <-> (regular_space X Tx /\ sigma_locally_finite_basis X Tx).
admit.
Qed.

(** helper: locally finite basis implies sigma-locally finite basis (singleton family) **)
Theorem locally_finite_basis_imp_sigma_locally_finite_basis : forall X Tx:set,
  locally_finite_basis X Tx -> sigma_locally_finite_basis X Tx.
admit.
Qed.

(** from 41 Definition: paracompact space **) 
(** LATEX VERSION: Paracompact = every open cover has a locally finite open refinement. **)
Definition paracompact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set, open_cover X Tx U ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.

(** from 41 Theorem: existence of locally finite refinements **) 
(** LATEX VERSION: Any paracompact space admits a locally finite open refinement of every open cover. **)
Theorem locally_finite_refinement : forall X Tx U:set,
  paracompact_space X Tx -> open_cover X Tx U -> exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V.
admit.
Qed.

(** helper: paracompact Hausdorff implies regular **)
(** LATEX VERSION: Standard separation upgrade using locally finite refinement of the Hausdorff point-separators. **)
Theorem paracompact_Hausdorff_regular : forall X Tx:set,
  paracompact_space X Tx -> Hausdorff_space X Tx -> regular_space X Tx.
admit.
Qed.

(** from 41 Theorem: paracompact Hausdorff implies normal **) 
(** LATEX VERSION: Paracompact Hausdorff spaces are normal. **)
Theorem paracompact_Hausdorff_normal : forall X Tx:set,
  paracompact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
admit.
Qed.

(** from 41 Theorem 41.2: closed subspace of a paracompact space is paracompact **)
(** LATEX VERSION: Every closed subspace of a paracompact space is paracompact. **)
Theorem closed_subspace_paracompact : forall X Tx Y:set,
  paracompact_space X Tx ->
  closed_in X Tx Y ->
  paracompact_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** from 41 Lemma 41.3 (Michael): countably locally finite refinements and locally finite refinements **)
(** LATEX VERSION: In a regular space, the following are equivalent: open cover has (1) open countably locally finite refinement, (2) locally finite refinement, (3) locally finite closed refinement, (4) locally finite open refinement. **)
Definition sigma_locally_finite_family : set -> set -> set -> prop := fun X Tx F =>
  topology_on X Tx /\
  exists Fams:set,
    countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall G:set, G :e Fams -> locally_finite_family X Tx G) /\
    F = Union Fams.

(** helper: singleton family is locally finite **)
Theorem locally_finite_family_singleton : forall X Tx A:set,
  topology_on X Tx ->
  locally_finite_family X Tx {A}.
admit.
Qed.

(** helper: locally finite family is sigma-locally-finite (singleton decomposition) **)
Theorem locally_finite_family_imp_sigma_locally_finite_family : forall X Tx F:set,
  topology_on X Tx ->
  F c= Power X ->
  locally_finite_family X Tx F ->
  sigma_locally_finite_family X Tx F.
admit.
Qed.

(** helper: countable open cover is sigma-locally-finite **)
Theorem countable_open_cover_sigma_locally_finite_family : forall X Tx U:set,
  topology_on X Tx ->
  open_cover X Tx U ->
  countable_set U ->
  sigma_locally_finite_family X Tx U.
admit.
Qed.

(** helper: closed cover (collection of closed subsets covering X) **)
(** LATEX VERSION: A closed cover of X is a family of closed sets whose union covers X. **)
Definition closed_cover : set -> set -> set -> prop := fun X Tx C =>
  (forall c:set, c :e C -> closed_in X Tx c) /\ covers X C.

(** from 41 Lemma 41.3: Michael conditions **)
(** LATEX VERSION: Several equivalent formulations of paracompactness, expressing existence of locally finite or sigma locally finite refinements of open covers. **)
Definition Michael_cond41_3_1 : set -> set -> prop := fun X Tx =>
  forall U:set, open_cover X Tx U ->
    exists V:set, open_cover X Tx V /\ sigma_locally_finite_family X Tx V /\ refine_of V U.

(** LATEX VERSION: Variant: every open cover admits a locally finite refinement that still covers X. **)
Definition Michael_cond41_3_2 : set -> set -> prop := fun X Tx =>
  forall U:set, open_cover X Tx U ->
    exists V:set, covers X V /\ locally_finite_family X Tx V /\ refine_of V U.

(** LATEX VERSION: Variant: every open cover admits a locally finite closed refinement. **)
Definition Michael_cond41_3_3 : set -> set -> prop := fun X Tx =>
  forall U:set, open_cover X Tx U ->
    exists V:set, closed_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.

(** LATEX VERSION: Variant: every open cover admits a locally finite open refinement. **)
Definition Michael_cond41_3_4 : set -> set -> prop := fun X Tx =>
  forall U:set, open_cover X Tx U ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.

(** helper: Michael Lemma 41.3 step (1) to (2): from countably locally finite open cover to locally finite refinement **)
(** LATEX VERSION: Given an open cover B =  B_n where each B_n is locally finite, define S_n(U)=U-_{i<n}V_i and C=C_n; then C is a locally finite refinement covering X. **)
Theorem sigma_locally_finite_open_cover_imp_locally_finite_refinement :
  forall X Tx V:set,
    regular_space X Tx ->
    open_cover X Tx V ->
    sigma_locally_finite_family X Tx V ->
    exists C:set, covers X C /\ locally_finite_family X Tx C /\ refine_of C V.
admit.
Qed.

(** helper: Michael Lemma 41.3 step (2) to (3) **)
(** LATEX VERSION: Given open cover A, let B be open sets U with closure(U) subset A; use (2) to refine B by a locally finite C and take D={closure(C)}. **)
Theorem Michael_lemma_41_3_closed_cover_from_locally_finite_refinement :
  forall X Tx A:set,
    regular_space X Tx ->
    open_cover X Tx A ->
    Michael_cond41_3_2 X Tx ->
    exists D:set, closed_cover X Tx D /\ locally_finite_family X Tx D /\ refine_of D A.
admit.
Qed.

(** helper: union of a subfamily of a locally finite closed family is closed **)
Theorem Union_subfamily_locally_finite_closed_is_closed : forall X Tx Fam S:set,
  locally_finite_family X Tx Fam ->
  (forall A:set, A :e Fam -> closed_in X Tx A) ->
  S c= Fam ->
  closed_in X Tx (Union S).
admit.
Qed.

(** helper: union of a finite family of finite sets is finite **)
(** helper: Michael Lemma 41.3 step (3) to (4) **)
(** LATEX VERSION: Expand a locally finite closed refinement using an auxiliary locally finite closed cover, obtaining a locally finite open refinement. **)
Theorem Michael_lemma_41_3_closed_refinement_to_open_refinement :
  forall X Tx A:set,
    regular_space X Tx ->
    open_cover X Tx A ->
    Michael_cond41_3_3 X Tx ->
    exists D:set, open_cover X Tx D /\ locally_finite_family X Tx D /\ refine_of D A.
admit.
Qed.
Theorem Michael_lemma_41_3 : forall X Tx:set,
  regular_space X Tx ->
  (Michael_cond41_3_1 X Tx -> Michael_cond41_3_2 X Tx) /\
  (Michael_cond41_3_2 X Tx -> Michael_cond41_3_3 X Tx) /\
  (Michael_cond41_3_3 X Tx -> Michael_cond41_3_4 X Tx) /\
  (Michael_cond41_3_4 X Tx -> Michael_cond41_3_1 X Tx).
admit.
Qed.

(** from 41 Theorem 41.4: metrizable implies paracompact **)
(** LATEX VERSION: Every metrizable space is paracompact. **)
(** helper: metric spaces are paracompact (used to discharge the metrizable case) **)
(** LATEX VERSION: Every metric space is paracompact. **)
(** helper: metric open covers admit locally finite refinements **)
(** helper: an open cover member contains a centered ball **)
(** LATEX VERSION: In a metric space, if U is open and x is in U, then some ball around x is contained in U. **)
Theorem metric_open_cover_point_ball_submember : forall X d U x:set,
  metric_on X d ->
  open_cover X (metric_topology X d) U ->
  x :e X ->
  exists u:set, u :e U /\
    exists r:set, r :e R /\ (Rlt 0 r /\ open_ball X d x r c= u).
admit.
Qed.

(** helper: an open cover member contains a standard eps ball **)
(** LATEX VERSION: If U is an open cover in a metric topology and x is in X, then some member u of U contains a standard ball B(x,eps_N). **)
Theorem metric_open_cover_point_eps_ball_submember : forall X d U x:set,
  metric_on X d ->
  open_cover X (metric_topology X d) U ->
  x :e X ->
  exists u:set, u :e U /\
    exists N:set, N :e omega /\ open_ball X d x (eps_ N) c= u.
admit.
Qed.

(** helper: refine an open cover by centered open balls **)
(** LATEX VERSION: Any open cover in a metric topology admits a refinement by centered open balls. **)
Theorem metric_open_cover_refine_by_balls : forall X d U:set,
  metric_on X d ->
  open_cover X (metric_topology X d) U ->
  exists B:set,
    open_cover X (metric_topology X d) B /\
    (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) /\
    refine_of B U.
admit.
Qed.

(** helper: metric spaces are regular **)
(** LATEX VERSION: Every metric space is completely regular, hence regular. **)
Theorem metric_spaces_regular : forall X d:set,
  metric_on X d -> regular_space X (metric_topology X d).
admit.
Qed.

(** helper: from a ball cover, get a standard eps_N ball inside some member **)
(** LATEX VERSION: If B is a cover by open balls, then each x has a standard epsilon-ball neighborhood contained in some b:e B. **)
Theorem metric_ball_cover_point_eps_submember : forall X d B x:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists c :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d c r) ->
  x :e X ->
  exists b:set, b :e B /\ x :e b /\ exists N:set, N :e omega /\ open_ball X d x (eps_ N) c= b.
admit.
Qed.

(** helper: refine a ball cover by standard eps balls (no finiteness claims) **)
(** LATEX VERSION: From a cover by open balls, choose for each x an eps_N ball inside some cover element; this yields an open refinement by standard balls. **)
Theorem metric_ball_open_cover_refine_by_eps_balls : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists c :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d c r) ->
  exists V:set,
    open_cover X (metric_topology X d) V /\
    refine_of V B /\
    (forall v:set, v :e V -> exists x:set, x :e X /\ exists N:set, N :e omega /\ v = open_ball X d x (eps_ N)).
admit.
Qed.

(** helper: small balls around eps_n-separated centers form a locally finite family **)
(** LATEX VERSION: If S is eps_n-separated, then the family {B(x,eps_{n+2})|xS} is locally finite in the metric topology. **)
Theorem eps_separated_imp_eps_succ_succ_ball_locally_finite : forall X d S n:set,
  metric_on X d ->
  n :e omega ->
  eps_separated_set X d S n ->
  locally_finite_family X (metric_topology X d)
    {open_ball X d x (eps_ (ordsucc (ordsucc n)))|x :e S}.
admit.
Qed.

(** helper: center families for sigma locally finite refinement of an eps-ball cover (pending, deprecated) **)
(** LATEX VERSION: Selection of center sets (nets) used in the standard sigma-locally-finite refinement argument in metric spaces. **)
Axiom metric_eps_centers_for_sigma_ball_refinement_old : forall X d V0:set,
  metric_on X d ->
  open_cover X (metric_topology X d) V0 ->
  exists Centers:set->set,
    (forall n:set, n :e omega ->
      eps_separated_set X d (Centers n) n /\
      (forall c:set, c :e Centers n ->
        exists v0:set, v0 :e V0 /\ open_ball X d c (eps_ (ordsucc (ordsucc n))) c= v0)) /\
  (forall x:set, x :e X ->
    exists n:set, n :e omega /\
      exists c:set, c :e Centers n /\ x :e open_ball X d c (eps_ (ordsucc (ordsucc n)))).

(** Proof sketch (not used for dependencies) **)
Theorem metric_eps_centers_for_sigma_ball_refinement_old_sketch : forall X d V0:set,
  metric_on X d ->
  open_cover X (metric_topology X d) V0 ->
  exists Centers:set->set,
    (forall n:set, n :e omega ->
      eps_separated_set X d (Centers n) n /\
      (forall c:set, c :e Centers n ->
        exists v0:set, v0 :e V0 /\ open_ball X d c (eps_ (ordsucc (ordsucc n))) c= v0)) /\
  (forall x:set, x :e X ->
    exists n:set, n :e omega /\
      exists c:set, c :e Centers n /\ x :e open_ball X d c (eps_ (ordsucc (ordsucc n)))).
admit.
Qed.

(** helper: sigma locally finite refinement construction core for ball covers in metric spaces (pending, deprecated) **)
(** LATEX VERSION: Standard selection argument producing a sigma locally finite open ball refinement of a ball cover. **)
Theorem metric_ball_open_cover_has_sigma_locally_finite_refinement_core_old : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) ->
  exists Fams:set,
    countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall G:set, G :e Fams -> locally_finite_family X (metric_topology X d) G) /\
    exists V:set, V = Union Fams /\ open_cover X (metric_topology X d) V /\ refine_of V B.
admit.
Qed.

(** helper: sigma locally finite refinement core for ball covers in metric spaces, via TeX Lemma 39.2 well-ordering construction **)
(** LATEX VERSION: Use a well-ordering of the cover, define S_n(U) = {x | B(x,eps_n)  U}, T_n(U)=S_n(U)_{V<U}V, and E_n(U)=_{xT_n(U)}B(x,eps_{n+2}); then {E_n(U)} is locally finite for each n and _n_U E_n(U) covers X and refines the cover. **)
Theorem metric_ball_open_cover_has_sigma_locally_finite_refinement_core_wo : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) ->
  exists Fams:set,
    countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall G:set, G :e Fams -> locally_finite_family X (metric_topology X d) G) /\
    exists V:set, V = Union Fams /\ open_cover X (metric_topology X d) V /\ refine_of V B.
admit.
Qed.

(** helper: sigma locally finite refinement construction core for ball covers in metric spaces **)
(** LATEX VERSION: Standard selection argument producing a sigma locally finite open ball refinement of a ball cover. **)
(** NOTE: This is the preferred core; the earlier `..._core_old` is kept only for historical context. **)
Theorem metric_ball_open_cover_has_sigma_locally_finite_refinement_core : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) ->
  exists Fams:set,
    countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall G:set, G :e Fams -> locally_finite_family X (metric_topology X d) G) /\
    exists V:set, V = Union Fams /\ open_cover X (metric_topology X d) V /\ refine_of V B.
admit.
Qed.

(** helper: sigma locally finite refinement for ball covers in metric spaces **)
(** LATEX VERSION: Standard selection argument producing a sigma locally finite open ball refinement of a ball cover. **)
Theorem metric_ball_open_cover_has_sigma_locally_finite_refinement : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) ->
  exists V:set,
    open_cover X (metric_topology X d) V /\
    sigma_locally_finite_family X (metric_topology X d) V /\
    refine_of V B.
admit.
Qed.

(** helper: locally finite refinement for ball covers in metric spaces (pending) **)
(** LATEX VERSION: Standard metric selection argument turning a ball cover into a locally finite ball refinement. **)
Theorem metric_ball_open_cover_has_locally_finite_refinement : forall X d B:set,
  metric_on X d ->
  open_cover X (metric_topology X d) B ->
  (forall b:set, b :e B -> exists x :e X, exists r :e R, Rlt 0 r /\ b = open_ball X d x r) ->
  exists V:set,
    open_cover X (metric_topology X d) V /\
    locally_finite_family X (metric_topology X d) V /\
    refine_of V B.
admit.
Qed.
Theorem metric_open_cover_has_locally_finite_refinement :
  forall X d U:set,
    metric_on X d ->
    open_cover X (metric_topology X d) U ->
    exists V:set,
      open_cover X (metric_topology X d) V /\
      locally_finite_family X (metric_topology X d) V /\
      refine_of V U.
admit.
Qed.

(** from 39 Lemma 39.2: metric open cover has countably locally finite refinement **)
(** LATEX VERSION: Let X be a metrizable space. If A is an open covering of X, then there is an open covering E of X refining A that is countably locally finite. **)
(** MOVED: Proved here via the stronger metric locally finite refinement theorem (41). **)
Theorem metric_open_cover_has_sigma_locally_finite_refinement :
  forall X d U:set,
    metric_on X d ->
    open_cover X (metric_topology X d) U ->
    exists V:set,
      open_cover X (metric_topology X d) V /\
      sigma_locally_finite_family X (metric_topology X d) V /\
      refine_of V U.
admit.
Qed.
Theorem metric_paracompact : forall X d:set,
  metric_on X d ->
  paracompact_space X (metric_topology X d).
admit.
Qed.
Theorem metrizable_paracompact : forall X Tx:set,
  metrizable X Tx -> paracompact_space X Tx.
admit.
Qed.

(** from 41 Theorem 41.5: regular Lindelof implies paracompact **)
(** LATEX VERSION: Every regular Lindelof space is paracompact. **)
Theorem regular_Lindelof_paracompact : forall X Tx:set,
  regular_space X Tx -> Lindelof_space X Tx -> paracompact_space X Tx.
admit.
Qed.

(** from 41 Example 4: product of two paracompact spaces need not be paracompact **)
(** LATEX VERSION: R_lower_limit is paracompact, but R_lower_limit x R_lower_limit is not paracompact since it is Hausdorff but not normal. **)
Theorem Sorgenfrey_plane_not_paracompact :
  ~ paracompact_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** from 41 Example 5: R^omega is paracompact in product and uniform topologies **)
(** LATEX VERSION: R^omega is paracompact in the product and uniform topologies since it is metrizable; box topology case is unknown. **)
Theorem Romega_paracompact_product_topology :
  paracompact_space (product_space omega (const_space_family omega R R_standard_topology))
                    (product_topology_full omega (const_space_family omega R R_standard_topology)).
admit.
Qed.

(** from 41 Example 5 (uniform topology): R^omega is paracompact in the uniform topology **)
(** LATEX VERSION: R^omega is paracompact in the uniform topology since it is metrizable. **)
Theorem Romega_paracompact_uniform_topology :
  paracompact_space real_sequences uniform_topology.
admit.
Qed.

(** from 41 Example 6: uncountable product of R is not paracompact **)
(** LATEX VERSION: If J is uncountable then R^J is not paracompact since it is Hausdorff but not normal. **)
Theorem uncountable_product_R_not_paracompact : forall J:set,
  uncountable_set J ->
  ~ paracompact_space (product_space J (const_space_family J R R_standard_topology))
                      (product_topology_full J (const_space_family J R R_standard_topology)).
admit.
Qed.

(** from 41 Lemma 41.6 (shrinking lemma): locally finite open shrinking of an open cover **)
(** LATEX VERSION: If X is paracompact Hausdorff and U is an indexed open cover, there exists a locally finite open cover V with closure(V) contained in U. **)
Theorem shrinking_lemma_41_6 : forall X Tx U:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  open_cover X Tx U ->
  exists V:set,
    open_cover X Tx V /\
    locally_finite_family X Tx V /\
    refine_of V U /\
    forall v:set, v :e V -> exists u:set, u :e U /\ closure_of X Tx v c= u.
admit.
Qed.

(** helper for 41: apply the shrinking lemma twice **)
(** LATEX VERSION: Apply Lemma 41.6 to U, then again to the resulting locally finite cover. **)
Theorem shrinking_lemma_41_6_twice : forall X Tx U:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  open_cover X Tx U ->
  exists V W:set,
    open_cover X Tx V /\
    locally_finite_family X Tx V /\
    refine_of V U /\
    (forall v:set, v :e V -> exists u:set, u :e U /\ closure_of X Tx v c= u) /\
    open_cover X Tx W /\
    locally_finite_family X Tx W /\
    refine_of W V /\
    (forall w:set, w :e W -> exists v:set, v :e V /\ closure_of X Tx w c= v).
admit.
Qed.

(** helper for 41 Theorem 41.7: dominated bump cover from a paracompact Hausdorff refinement **)
(** LATEX VERSION: From a paracompact Hausdorff open cover U, build a locally finite open refinement V and a family of continuous unit-interval bumps {f_v} dominated by U, with pointwise existence of a bump equal to 1 and local finiteness of supports. **)
Theorem paracompact_Hausdorff_bump_cover_dominated : forall X Tx U:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  open_cover X Tx U ->
  exists V P:set,
    open_cover X Tx V /\
    locally_finite_family X Tx V /\
    refine_of V U /\
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall f x:set, f :e P -> x :e X -> apply_fun f x :e unit_interval) /\
    (forall f:set, f :e P -> exists u:set, u :e U /\ support_of X Tx f c= u) /\
    (forall x:set, x :e X -> exists f:set, f :e P /\ apply_fun f x = 1) /\
    (forall x:set, x :e X ->
      exists N:set, N :e Tx /\ x :e N /\
        exists F0:set, finite F0 /\ F0 c= P /\
          forall f:set, f :e P -> support_of X Tx f :/\: N <> Empty -> f :e F0).
admit.
Qed.

(** helper: extensional equality for elements of function_space **)
(** This bridges the weak set-theoretic encoding of functions (via apply_fun/Eps_i) with extensional equality. **)

(** from 41 Theorem 41.7: partition of unity dominated by an open cover **)
(** LATEX VERSION: For a paracompact Hausdorff space X and an indexed open cover U, there exists a partition of unity on X dominated by U. **)
Theorem paracompact_Hausdorff_partition_of_unity : forall X Tx U:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  open_cover X Tx U ->
  partition_of_unity_dominated X Tx U.
admit.
Qed.
(** from 41 Theorem 41.8: positive continuous function bounded on a locally finite collection **)
(** LATEX VERSION: If C is locally finite and eps assigns a positive number to each C, there is continuous f>0 with f(x) <= eps(C) for x in C. **)
(** helper: main construction (kept separate so the top theorem body has no admits) **)
Theorem paracompact_Hausdorff_locally_finite_bounded_function_aux : forall X Tx C eps:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  locally_finite_family X Tx C ->
  C c= Power X ->
  (forall c:set, c :e C -> apply_fun eps c :e R /\ Rlt 0 (apply_fun eps c)) ->
  normal_space X Tx ->
  topology_on X Tx ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e X -> Rlt 0 (apply_fun f x)) /\
    (forall c x:set, c :e C -> x :e c -> Rle (apply_fun f x) (apply_fun eps c)).
admit.
Qed.
Theorem paracompact_Hausdorff_locally_finite_bounded_function : forall X Tx C eps:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  locally_finite_family X Tx C ->
  C c= Power X ->
  (forall c:set, c :e C -> apply_fun eps c :e R /\ Rlt 0 (apply_fun eps c)) ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e X -> Rlt 0 (apply_fun f x)) /\
    (forall c x:set, c :e C -> x :e c -> Rle (apply_fun f x) (apply_fun eps c)).
admit.
Qed.

(** from 42 Smirnov metrization theorem **) 
(** LATEX VERSION: Smirnov metrization: regular spaces with a locally finite basis are metrizable. **)
Theorem Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> locally_finite_basis X Tx -> metrizable X Tx.
admit.
Qed.

(** NOTE: cauchy_sequence / complete_metric_space moved earlier (before 35) to avoid forward-reference issues. **)
(** FIXED: discrete_metric is defined as a graph on XX with value 0 on the diagonal and 1 off the diagonal. **) 
(** from 20 Metric topology: auxiliary definition of the discrete metric **)
(** LATEX VERSION: The discrete metric satisfies d(x,y)=0 if x=y and d(x,y)=1 otherwise. **)
Definition discrete_metric : set -> set := fun X =>
  graph (setprod X X) (fun p:set => If_i (p 0 = p 1) 0 1).

(** helper: compute apply_fun of the discrete metric graph **)
Theorem discrete_metric_apply : forall X x y:set,
  x :e X -> y :e X ->
  apply_fun (discrete_metric X) (x,y) = If_i (x = y) 0 1.
admit.
Qed.

(** helper: the discrete metric is a metric_on **)
Theorem discrete_metric_is_metric_on : forall X:set,
  metric_on X (discrete_metric X).
admit.
Qed.

(** helper: open ball of radius 1 in the discrete metric is the singleton **)
Theorem open_ball_discrete_radius1_eq_singleton : forall X x:set,
  x :e X ->
  open_ball X (discrete_metric X) x 1 = {x}.
admit.
Qed.

(** helper: discrete metric spaces are complete **)
Theorem discrete_metric_complete : forall X:set,
  complete_metric_space X (discrete_metric X).
admit.
Qed.
(** helper: auxiliary metric on euclidean_space n **) 
(** from 24 Euclidean space: auxiliary metric on euclidean_space n **)
(** LATEX VERSION: Euclidean space R^n is a metric space in its usual Euclidean metric. **)
(** SUSPICIOUS DEFINITION: The development does not currently have an explicit 2 formula for R^n, so we use the standard bounded D metric on R^omega and embed R^n into R^omega by padding with 0 outside n. This induces the usual product topology on R^n (and hence the Euclidean topology for finite n). **)
(** REVIEWED: This embedding is intended to avoid re-developing a finite-sum norm. Subsequent results should justify that the induced topology equals `R_standard_topology` on each coordinate and matches the product topology on finite n. **)
(** helper: extend a point of R^n (a function on n) to a sequence on omega by padding with 0 outside n **)
Definition euclidean_space_extend_to_Romega : set -> set -> set := fun n f =>
  graph omega (fun i:set => If_i (i :e n) (apply_fun f i) 0).
(** from 24 Euclidean space: Euclidean metric on R^n (implemented via the D metric on R^omega) **)
(** LATEX VERSION: Euclidean distance on R^n is the metric inducing the Euclidean topology. **)
Definition euclidean_metric : set -> set := fun n =>
  graph (setprod (euclidean_space n) (euclidean_space n))
    (fun p:set =>
      Romega_D_metric_value
        (euclidean_space_extend_to_Romega n (p 0))
        (euclidean_space_extend_to_Romega n (p 1))).

(** helper: coordinates of a point in euclidean_space n are real numbers **)
(** LATEX VERSION: Each coordinate projection R^n -> R is well-defined on the product space. **)
Theorem euclidean_space_coord_in_R : forall n f i:set,
  f :e euclidean_space n ->
  i :e n ->
  apply_fun f i :e R.
admit.
Qed.

(** helper: extension of a point of R^n to a sequence lies in R^omega **)
(** LATEX VERSION: Pad a point in R^n with zeros to obtain an element of R^omega. **)
Theorem euclidean_space_extend_to_Romega_in_Romega_space : forall n f:set,
  f :e euclidean_space n ->
  euclidean_space_extend_to_Romega n f :e R_omega_space.
admit.
Qed.

(** helper: compute the padded extension on an index i **)
(** LATEX VERSION: The extension agrees with the original point on indices in n and is zero otherwise. **)
Theorem euclidean_space_extend_to_Romega_apply : forall n f i:set,
  i :e omega ->
  apply_fun (euclidean_space_extend_to_Romega n f) i =
    If_i (i :e n) (apply_fun f i) 0.
admit.
Qed.

(** helper: the padding extension is injective on R^n for n in omega **)
(** LATEX VERSION: A point of R^n is determined by its coordinates, hence by its padded sequence in R^omega. **)
Theorem euclidean_space_extend_to_Romega_injective : forall n f g:set,
  n :e omega ->
  f :e euclidean_space n ->
  g :e euclidean_space n ->
  euclidean_space_extend_to_Romega n f = euclidean_space_extend_to_Romega n g ->
  f = g.
admit.
Qed.

(** helper: evaluate euclidean_metric on a pair of points **)
(** LATEX VERSION: The metric on R^n is computed by applying D to the padded sequences. **)
Theorem euclidean_metric_apply : forall n x y:set,
  x :e euclidean_space n ->
  y :e euclidean_space n ->
  apply_fun (euclidean_metric n) (x,y) =
    Romega_D_metric_value
      (euclidean_space_extend_to_Romega n x)
      (euclidean_space_extend_to_Romega n y).
admit.
Qed.

(** helper: euclidean_metric is a metric on R^n for n in omega **)
(** LATEX VERSION: For each natural n, R^n is a metric space. **)
Theorem euclidean_metric_is_metric_on : forall n:set,
  n :e omega ->
  metric_on (euclidean_space n) (euclidean_metric n).
admit.
Qed.

(** helper: bounded product metric on R^omega **) 
(** LATEX VERSION: On R^, use the bounded product metric D (defined earlier as `Romega_D_metric`). **)
Definition bounded_product_metric : set := Romega_D_metric.

(** helper: bounded_product_metric is Romega_D_metric **)
(** LATEX VERSION: The bounded product metric on ^ is exactly the D-metric. **)
Theorem bounded_product_metric_eq_Romega_D_metric : bounded_product_metric = Romega_D_metric.
admit.
Qed.

(** from 43 Lemma 43.1: Cauchy with convergent subsequence converges **) 
(** LATEX VERSION: In a metric space, a Cauchy sequence with a convergent subsequence converges to the same limit. **)
(** helper: strictly increasing index map on  (used to model subsequences) **)
(** LATEX VERSION: A subsequence is obtained by composing with a strictly increasing map f:. **)
Definition omega_strictly_increasing : set -> prop := fun f =>
  forall m n:set, m :e omega -> n :e omega -> m :e n -> apply_fun f m :e apply_fun f n.

(** helper: subsequence of a sequence seq:X **)
(** LATEX VERSION: subseq is a subsequence of seq if subseq(n)=seq(f(n)) for some strictly increasing f:. **)
Definition subsequence_of : set -> set -> prop := fun seq subseq =>
  exists f:set,
    total_function_on f omega omega /\ functional_graph f /\ graph_domain_subset f omega /\
    omega_strictly_increasing f /\
    subseq = compose_fun omega f seq.

(** helper: twofold-small epsilon for metric estimates **)
(** For any positive eps0, choose eps1 with eps1+eps1 < eps0, using dyadic eps_ N. **)
Theorem exists_twofold_small_eps : forall eps0:set,
  eps0 :e R -> Rlt 0 eps0 ->
  exists eps1:set,
    eps1 :e R /\ Rlt 0 eps1 /\
    Rlt (add_SNo eps1 eps1) eps0.
admit.
Qed.

(** helper: a strictly increasing omega index map is unbounded **)
(** If f:omega->omega is strictly increasing, then for any N there is k with N c= f(k). **)
Theorem omega_strictly_increasing_unbounded : forall f N:set,
  total_function_on f omega omega ->
  functional_graph f ->
  graph_domain_subset f omega ->
  omega_strictly_increasing f ->
  N :e omega ->
  exists k:set, k :e omega /\ N c= apply_fun f k.
admit.
Qed.
Theorem Cauchy_with_convergent_subsequence_converges : forall X d seq x:set,
  metric_on X d -> cauchy_sequence X d seq ->
  (exists subseq:set, subsequence_of seq subseq /\ converges_to X (metric_topology X d) subseq x) ->
  converges_to X (metric_topology X d) seq x.
admit.
Qed.

(** NOTE: The theorems Romega_D_metric_complete and Euclidean_space_complete are proved later after product_Romega_complete to avoid forward references. **)

(** from 43 Lemma 43.3: product convergence via projections **) 
(** LATEX VERSION: Convergence in a product metric topology iff coordinatewise convergence. **)
(** Helper: coordinate sequence of a product-valued sequence **)
Definition product_coordinate_sequence : set -> set -> set :=
  fun seq j => graph omega (fun n:set => apply_fun (apply_fun seq n) j).
Theorem product_sequence_convergence_iff_coordinates : forall X J:set,
  X = product_space J (const_space_family J R R_standard_topology) ->
  forall seq x:set,
    sequence_on seq X ->
    x :e X ->
    (converges_to X (product_topology_full J (const_space_family J R R_standard_topology)) seq x <->
     (forall j:set, j :e J ->
       converges_to (product_component (const_space_family J R R_standard_topology) j)
         (product_component_topology (const_space_family J R R_standard_topology) j)
         (product_coordinate_sequence seq j)
         (apply_fun x j))).
admit.
Qed.

(** NOTE: R_bounded_metric is defined earlier (near R_bounded_distance). **)

(** helper: compute apply_fun of the bounded metric graph **)
Theorem R_bounded_metric_apply : forall x y:set,
  x :e R -> y :e R ->
  apply_fun R_bounded_metric (x,y) = R_bounded_distance x y.
admit.
Qed.

(** helper: bounded metric on R is a metric_on **)
Theorem R_bounded_metric_is_metric_on : metric_on R R_bounded_metric.
admit.
Qed.

(** helper: bounded-metric Cauchy gives abs-tail estimates for eps<1 **)
Theorem cauchy_R_bounded_metric_abs_tail : forall seq eps:set,
  cauchy_sequence R R_bounded_metric seq ->
  eps :e R -> Rlt 0 eps -> Rlt eps 1 ->
  exists N:set, N :e omega /\
    forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
      abs_SNo (add_SNo (apply_fun seq m) (minus_SNo (apply_fun seq n))) < eps.
admit.
Qed.

(** helper: open balls for the bounded metric with radius < 1 are exactly abs-balls **)
Theorem open_ball_R_bounded_metric_abs : forall x r y:set,
  x :e R -> r :e R -> Rlt 0 r -> Rlt r 1 ->
  (y :e open_ball R R_bounded_metric x r <->
   (y :e R /\ Rlt (R_bounded_distance x y) r)).
admit.
Qed.

(** helper: bounded metric balls with radius < 1 are open intervals **)
(** LATEX VERSION: If 0<r<1 then B(c,r) = (c-r, c+r) for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_eq_open_interval : forall c r:set,
  c :e R -> r :e R -> Rlt 0 r -> Rlt r 1 ->
  open_ball R R_bounded_metric c r = open_interval (add_SNo c (minus_SNo r)) (add_SNo c r).
admit.
Qed.

(** helper: bounded metric ball of radius 1 is an open interval **)
(** LATEX VERSION: B(c,1) = (c-1, c+1) for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_r1_eq_open_interval : forall c:set,
  c :e R ->
  open_ball R R_bounded_metric c 1 = open_interval (add_SNo c (minus_SNo 1)) (add_SNo c 1).
admit.
Qed.

(** helper: bounded metric balls of radius greater than 1 are all of R **)
(** LATEX VERSION: If 1<r then B(c,r)=R for the bounded metric on R. **)
Theorem open_ball_R_bounded_metric_eq_R_if_1_lt : forall c r:set,
  c :e R -> r :e R -> Rlt 1 r ->
  open_ball R R_bounded_metric c r = R.
admit.
Qed.

(** helper: a D-Cauchy sequence in R^omega has bounded-metric Cauchy coordinate sequences **)
Theorem Romega_cauchy_imp_coord_cauchy_bounded : forall seq i:set,
  cauchy_sequence R_omega_space Romega_D_metric seq ->
  i :e omega ->
  cauchy_sequence R R_bounded_metric (product_coordinate_sequence seq i).
admit.
Qed.

(** helper: a graph omega -> R is a point of R_omega_space **)
Theorem graph_omega_to_R_in_Romega_space : forall g:set->set,
  (forall i:set, i :e omega -> g i :e R) ->
  graph omega g :e R_omega_space.
admit.
Qed.

(** helper: bounded-metric open balls are standard-open in R **)
(** LATEX VERSION: Each bounded-metric open ball is open in the standard topology on R. **)
Theorem open_ball_R_bounded_metric_in_R_standard_topology : forall c r:set,
  c :e R -> r :e R -> Rlt 0 r ->
  open_ball R R_bounded_metric c r :e R_standard_topology.
admit.
Qed.

(** helper: standard open intervals are open in the bounded metric topology **)
(** LATEX VERSION: Every open interval (a,b) is open in the bounded-metric topology on R. **)
Theorem open_interval_in_metric_topology_R_bounded_metric : forall a b:set,
  a :e R -> b :e R ->
  open_interval a b :e metric_topology R R_bounded_metric.
admit.
Qed.

(** helper: the bounded metric induces the standard topology on R **)
Theorem metric_topology_R_bounded_metric_eq_R_standard_topology :
  metric_topology R R_bounded_metric = R_standard_topology.
admit.
Qed.

(** Helper: the real line is completely regular in the standard topology **)
(** LATEX VERSION: R is metrizable, hence completely regular. **)
Theorem R_standard_topology_completely_regular :
  completely_regular_space R R_standard_topology.
admit.
Qed.

(** helper: abs-Cauchy sequences on R converge in the standard topology (completeness of R) **)
(** LATEX VERSION: Every Cauchy sequence in  (with respect to |x-y|) converges in the standard topology. **)
Theorem abs_Cauchy_sequence_converges_R_standard_topology : forall seq:set,
  sequence_on seq R ->
  (forall eps:set, eps :e R /\ Rlt 0 eps ->
     exists N:set, N :e omega /\
       forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
         abs_SNo (add_SNo (apply_fun seq m) (minus_SNo (apply_fun seq n))) < eps) ->
  exists x:set, converges_to R R_standard_topology seq x.
admit.
Qed.

(** helper: abs-Cauchy sequences on R converge in the bounded metric topology **)
(** LATEX VERSION: A Cauchy sequence in  with respect to |x-y| also converges in the bounded metric topology. **)
Theorem abs_Cauchy_sequence_converges_metric_topology_R_bounded_metric : forall seq:set,
  sequence_on seq R ->
  (forall eps:set, eps :e R /\ Rlt 0 eps ->
     exists N:set, N :e omega /\
       forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
         abs_SNo (add_SNo (apply_fun seq m) (minus_SNo (apply_fun seq n))) < eps) ->
  exists x:set, converges_to R (metric_topology R R_bounded_metric) seq x.
admit.
Qed.

(** helper: completeness of the bounded metric on R **)
(** LATEX VERSION: The real line with the bounded metric dbar(x,y)=min(|x-y|,1) is complete. **)
Theorem R_bounded_metric_complete : complete_metric_space R R_bounded_metric.
admit.
Qed.

(** from 43 Theorem 43.4: complete metric on R^omega **) 
(** LATEX VERSION: The bounded product metric makes R^ complete. **)
Theorem product_Romega_complete : complete_metric_space (power_real omega) bounded_product_metric.
admit.
Qed.

(** helper: completeness of R omega space with the D metric **)
(** LATEX VERSION: The countable product of real lines is complete with a bounded product metric. **)
(** NOTE: This lemma is used in Euclidean_space_complete; proved here by rewriting to product_Romega_complete. **)
Theorem Romega_D_metric_complete : complete_metric_space R_omega_space Romega_D_metric.
admit.
Qed.

(** from 43 Theorem 43.2: Euclidean space is complete **) 
(** LATEX VERSION: Euclidean spaces are complete metric spaces. **)
Theorem Euclidean_space_complete : forall k :e omega,
  complete_metric_space (euclidean_space k) (euclidean_metric k).
admit.
Qed.

(** from 44 Theorem: space-filling curve existence **) 
(** LATEX VERSION: Existence of a continuous surjection from [0,1] onto the unit square (Peano curve). **)
Definition unit_square : set := setprod unit_interval unit_interval.
Definition unit_square_topology : set :=
  product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
Theorem space_filling_curve : exists f:set, continuous_map unit_interval unit_interval_topology unit_square unit_square_topology f.
admit.
Qed.

(** from 45 Definition: sequential compactness **)
(** LATEX VERSION: Sequentially compact: every sequence has a convergent subsequence/limit in X. **)
(** FIXED: sequentially_compact requires existence of a convergent subsequence, not that every sequence converges. **) 
Definition sequentially_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall seq:set, sequence_on seq X ->
    exists subseq:set, exists x:set, subsequence_of seq subseq /\ converges_to X Tx subseq x.

(** from 45 Theorem: compactness in metric spaces equivalences **) 
(** LATEX VERSION: In metric spaces, compact  sequentially compact. **)
(** helper: compact metric spaces have convergent subsequences (BolzanoWeierstrass style) **)
Theorem compact_metric_sequence_has_convergent_subsequence : forall X d seq:set,
  metric_on X d ->
  compact_space X (metric_topology X d) ->
  sequence_on seq X ->
  exists subseq:set, exists x:set, subsequence_of seq subseq /\ converges_to X (metric_topology X d) subseq x.
admit.
Qed.

(** helper: sequentially compact metric spaces are compact **)
(** helper: Lebesgue number predicate for metric covers **)
(** LATEX VERSION: A Lebesgue number delta for an open cover Fam is a positive real such that every ball of radius delta is contained in some member of the cover. **)
Definition lebesgue_number_metric : set -> set -> set -> set -> prop := fun X d Fam delta =>
  delta :e R /\ Rlt 0 delta /\
  forall x:set, x :e X -> exists U:set, U :e Fam /\ open_ball X d x delta c= U.

(** helper: finite ball cover predicate for a metric space **)
(** LATEX VERSION: A finite delta-ball cover is a finite set F of centers in X such that the delta-balls around F cover X. **)
Definition finite_ball_cover_metric : set -> set -> set -> set -> prop := fun X d delta F =>
  finite F /\ F c= X /\ X c= (\/_ c :e F, open_ball X d c delta).

(** helper: lebesgue number plus finite ball cover yields a finite subcover **)
Theorem lebesgue_and_ball_cover_imply_finite_subcover : forall X d Fam delta:set,
  metric_on X d ->
  open_cover_of X (metric_topology X d) Fam ->
  lebesgue_number_metric X d Fam delta ->
  (exists F:set, finite_ball_cover_metric X d delta F) ->
  has_finite_subcover X (metric_topology X d) Fam.
admit.
Qed.

(** helper: sequential compactness yields a lebesgue number from the eps_ sequence **)
Theorem sequentially_compact_metric_has_lebesgue_number_eps : forall X d Fam:set,
  metric_on X d ->
  sequentially_compact X (metric_topology X d) ->
  open_cover_of X (metric_topology X d) Fam ->
  exists N:set, N :e omega /\ lebesgue_number_metric X d Fam (eps_ N).
admit.
Qed.

(** helper: sequential compactness yields finite ball covers for eps_ radii **)
Theorem sequentially_compact_metric_has_finite_ball_cover_eps : forall X d N:set,
  metric_on X d ->
  sequentially_compact X (metric_topology X d) ->
  N :e omega ->
  exists F:set, finite_ball_cover_metric X d (eps_ N) F.
admit.
Qed.
Theorem sequentially_compact_metric_imp_compact : forall X d:set,
  metric_on X d ->
  sequentially_compact X (metric_topology X d) ->
  compact_space X (metric_topology X d).
admit.
Qed.
Theorem compact_metric_equivalences : forall X d:set,
  metric_on X d ->
  (compact_space X (metric_topology X d) <-> sequentially_compact X (metric_topology X d)).
admit.
Qed.

(** from 46 Definition: pointwise and compact convergence topologies **) 
(** LATEX VERSION: The topology of pointwise convergence on Y^X is the product topology on _{xX} Y (evaluations are continuous). **)
(** We implement pointwise convergence on the graph-based `function_space X Y` via the evaluation subbasis. **)
(** from 46 Definition: pointwise convergence subbasis via evaluations **) 
(** LATEX VERSION: A subbasis is given by sets {f  Y^X | f(x)  U} for xX and U open in Y. **)
Definition pointwise_subbasis : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    {S :e Power (function_space X Y) |
      exists x U:set,
        x :e X /\ U :e Ty /\
        S = {f :e function_space X Y | apply_fun f x :e U}}.

(** from 46 Definition: pointwise convergence topology **) 
(** LATEX VERSION: The topology of pointwise convergence is generated by the evaluation subbasis {f | f(x)  U}. **)
Definition pointwise_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    generated_topology_from_subbasis
      (function_space X Y)
      ((pointwise_subbasis X Tx Y Ty) :\/: {function_space X Y}).

(** from 46 Notation: C(X,Y) as continuous maps **)
(** LATEX VERSION: Let C(X,Y) denote the set of continuous maps f:XY. **)
Definition continuous_function_space : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => {f :e function_space X Y | continuous_map X Tx Y Ty f}.

(** helper: pointwise convergence topology is a topology **)
(** LATEX VERSION: The pointwise convergence topology is a topology. **)
Theorem pointwise_convergence_topology_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  topology_on (function_space X Y) (pointwise_convergence_topology X Tx Y Ty).
admit.
Qed.

(** helper: evaluation is continuous in pointwise convergence topology **)
(** LATEX VERSION: For xX, the evaluation map ev_x : Y^XY is continuous in the pointwise convergence topology. **)
Theorem pointwise_eval_continuous : forall X Tx Y Ty x:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  x :e X ->
  continuous_map
    (function_space X Y) (pointwise_convergence_topology X Tx Y Ty)
    Y Ty
    (graph (function_space X Y) (fun f:set => apply_fun f x)).
admit.
Qed.

(** helper: continuous images preserve closure membership **)
(** LATEX VERSION: If f:X->Y is continuous and x is in cl(A), then f(x) is in cl(f(A)). **)
Theorem continuous_map_image_of_closure_subset_closure_of_image : forall X Tx Y Ty f A x:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  continuous_map X Tx Y Ty f ->
  A c= X ->
  x :e closure_of X Tx A ->
  apply_fun f x :e closure_of Y Ty (Repl A (fun a:set => apply_fun f a)).
admit.
Qed.

(** helper for 47 Step 1: pointwise closure implies coordinate closure **)
(** LATEX VERSION: If g is in the closure of F in the pointwise convergence topology, then g(a) is in the closure of F_a in Y. **)
Theorem pointwise_closure_implies_coordinate_in_closure_of_values : forall X Tx Y Ty F a g:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  a :e X ->
  F c= function_space X Y ->
  g :e closure_of (function_space X Y) (pointwise_convergence_topology X Tx Y Ty) F ->
  apply_fun g a :e closure_of Y Ty (Repl F (fun f0:set => apply_fun f0 a)).
admit.
Qed.

(** from 46 Definition: compact-open topology (compact convergence) **) 
(** LATEX VERSION: The compact-open topology on a function space has subbasis sets [K,U] = {f | f(K)  U} for K compact in X and U open in Y. **)
(** SUSPICIOUS DEFINITION: Because `function_space` only assumes `function_on` (via `apply_fun`), we express f(K)U as K  f^{-1}(U) using `preimage_of`, avoiding an explicit image operator. **)
(** REVIEWED: Using preimages keeps the definition within the existing function graph interface. Later continuity lemmas should rewrite f(K)U to K  f^{-1}(U) when needed. **)
Definition compact_open_subbasis : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    {S :e Power (function_space X Y) |
      exists K U:set,
        compact_space K (subspace_topology X Tx K) /\ K c= X /\
        U :e Ty /\
        S = {f :e function_space X Y | K c= preimage_of X f U}}.

(** from 46 Definition: compact convergence topology (compact-open topology) **) 
(** LATEX VERSION: The compact convergence topology is the topology generated by the compact-open subbasis. **)
Definition compact_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology_from_subbasis (function_space X Y) (compact_open_subbasis X Tx Y Ty).

(** helper: compact-open subbasis really is a subbasis (assuming Ty is a topology) **)
(** LATEX VERSION: The compact-open sets [K,U] form a subbasis for the compact-open topology on C(X,Y). **)
Theorem compact_open_subbasis_is_subbasis : forall X Tx Y Ty:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  subbasis_on (function_space X Y) (compact_open_subbasis X Tx Y Ty).
admit.
Qed.

(** helper: compact convergence topology is a topology **)
(** LATEX VERSION: The compact-open topology is a topology on C(X,Y). **)
Theorem compact_convergence_topology_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  topology_on (function_space X Y) (compact_convergence_topology X Tx Y Ty).
admit.
Qed.

(** helper: evaluation at a point is continuous for the compact-open topology **)
(** LATEX VERSION: For xX, the evaluation map ev_x : C(X,Y)Y is continuous in the compact-open topology. **)
Theorem compact_convergence_eval_continuous : forall X Tx Y Ty x:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  x :e X ->
  continuous_map
    (function_space X Y) (compact_convergence_topology X Tx Y Ty)
    Y Ty
    (graph (function_space X Y) (fun f:set => apply_fun f x)).
admit.
Qed.

(** from 46 Definition: compact-open topology on C(X,Y) (as subspace topology) **)
(** LATEX VERSION: The compact-open topology is of interest on the subspace C(X,Y) of Y^X. **)
Definition compact_open_topology_C : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    subspace_topology
      (function_space X Y) (compact_convergence_topology X Tx Y Ty)
      (continuous_function_space X Tx Y Ty).

(** helper: C(X,Y) is a subset of Y^X = function_space X Y **)
(** LATEX VERSION: C(X,Y)  Y^X. **)
Theorem continuous_function_space_sub : forall X Tx Y Ty:set,
  continuous_function_space X Tx Y Ty c= function_space X Y.
admit.
Qed.

(** helper: compact-open topology on C(X,Y) is a topology (as subspace topology) **)
(** LATEX VERSION: The compact-open topology defines a topology on C(X,Y). **)
Theorem compact_open_topology_C_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  topology_on
    (continuous_function_space X Tx Y Ty)
    (compact_open_topology_C X Tx Y Ty).
admit.
Qed.

(** from 46 Theorem 46.10: joint continuity of evaluation map **)
(** LATEX VERSION: If X is locally compact Hausdorff and C(X,Y) has the compact-open topology, then e:XC(X,Y)Y, e(x,f)=f(x), is continuous. **)
Definition compact_open_evaluation_map : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    graph
      (setprod X (continuous_function_space X Tx Y Ty))
      (fun p:set => apply_fun (p 1) (p 0)).
Theorem compact_open_evaluation_continuous : forall X Tx Y Ty:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  topology_on Y Ty ->
  continuous_map
    (setprod X (continuous_function_space X Tx Y Ty))
    (product_topology X Tx
      (continuous_function_space X Tx Y Ty) (compact_open_topology_C X Tx Y Ty))
    Y Ty
    (compact_open_evaluation_map X Tx Y Ty).
admit.
Qed.

(** helper: tube lemma with compact first factor **)
(** LATEX VERSION: If K is compact in X and N is an open neighborhood of K{y0} in XY, then there is V open in Y with y0V and KV  N. **)
Theorem tube_lemma_compact_first : forall X Tx Y Ty K:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  compact_space K (subspace_topology X Tx K) ->
  K c= X ->
  forall y0:set, y0 :e Y ->
  forall N:set, N :e product_topology X Tx Y Ty /\ setprod K {y0} c= N ->
    exists V:set, V :e Ty /\ y0 :e V /\ setprod K V c= N.
admit.
Qed.

(** from 46 Theorem 46.11: induced maps into C(X,Y) (compact-open topology) **)
(** LATEX VERSION: If f:XZY is continuous, then the induced F:ZC(X,Y) is continuous; converse if X locally compact Hausdorff. **)
Theorem compact_open_induced_map_continuous : forall X Tx Y Ty Z Tz f:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  topology_on Z Tz ->
  continuous_map
    (setprod X Z) (product_topology X Tx Z Tz)
    Y Ty
    f ->
  exists F:set,
    continuous_map
      Z Tz
      (continuous_function_space X Tx Y Ty) (compact_open_topology_C X Tx Y Ty)
      F.
admit.
Qed.

(** from 46 Definition: compact convergence topology on C(X,Y) (metric definition) **)
(** LATEX VERSION: For metric (Y,d), the compact convergence topology on C(X,Y) has basic neighborhoods B_C(f,) using uniform -control on a compact CX. **)
Definition compact_convergence_subbasis_metric : set -> set -> set -> set -> set :=
  fun X Tx Y dY =>
    {S :e Power (continuous_function_space X Tx Y (metric_topology Y dY)) |
      exists C f eps:set,
        compact_space C (subspace_topology X Tx C) /\ C c= X /\
        f :e continuous_function_space X Tx Y (metric_topology Y dY) /\
        eps :e R /\ Rlt 0 eps /\
        S = {g :e continuous_function_space X Tx Y (metric_topology Y dY) |
              forall x:set, x :e C ->
                Rlt (apply_fun dY (apply_fun g x, apply_fun f x)) eps}}.

(** from 46 Definition: compact convergence topology (generated from metric subbasis) **)
(** LATEX VERSION: The compact convergence topology is generated by the neighborhoods B_C(f,). **)
Definition compact_convergence_topology_metric_C : set -> set -> set -> set -> set :=
  fun X Tx Y dY =>
    generated_topology_from_subbasis
      (continuous_function_space X Tx Y (metric_topology Y dY))
      ((compact_convergence_subbasis_metric X Tx Y dY)
        :\/: {continuous_function_space X Tx Y (metric_topology Y dY)}).

(** helper: the metric compact convergence subbasis is a subbasis on C(X,Y) **)
Theorem compact_convergence_metric_subbasis_on : forall X Tx Y dY:set,
  topology_on X Tx ->
  metric_on Y dY ->
  subbasis_on
    (continuous_function_space X Tx Y (metric_topology Y dY))
    ((compact_convergence_subbasis_metric X Tx Y dY)
      :\/: {continuous_function_space X Tx Y (metric_topology Y dY)}).
admit.
Qed.

(** helper: compact convergence topology (metric) is a topology **)
(** LATEX VERSION: The compact convergence topology on C(X,Y) is a topology. **)
Theorem compact_convergence_topology_metric_C_is_topology : forall X Tx Y dY:set,
  topology_on X Tx ->
  metric_on Y dY ->
  topology_on
    (continuous_function_space X Tx Y (metric_topology Y dY))
    (compact_convergence_topology_metric_C X Tx Y dY).
admit.
Qed.

(** helper for 46 Theorem 46.8: compact-open subbasic sets are open in compact convergence (metric) **)
(** LATEX VERSION: If K is compact in X and U is open in Y, then [K,U]C(X,Y) is open in the compact convergence topology (metric neighborhood topology). **)
Theorem compact_open_subbasic_C_open_in_compact_convergence_metric : forall X Tx Y dY K U:set,
  topology_on X Tx ->
  metric_on Y dY ->
  compact_space K (subspace_topology X Tx K) ->
  K c= X ->
  U :e metric_topology Y dY ->
  {f :e continuous_function_space X Tx Y (metric_topology Y dY) | K c= preimage_of X f U}
    :e compact_convergence_topology_metric_C X Tx Y dY.
admit.
Qed.

(** helper for 46 Theorem 46.8: compact-open topology is contained in compact convergence (metric) **)
(** LATEX VERSION: On C(X,Y), every compact-open open set is open for the compact convergence (metric) topology. **)
Theorem compact_open_topology_C_sub_compact_convergence_metric_C : forall X Tx Y dY:set,
  topology_on X Tx ->
  metric_on Y dY ->
  compact_open_topology_C X Tx Y (metric_topology Y dY)
    c= compact_convergence_topology_metric_C X Tx Y dY.
admit.
Qed.

(** helper for 46 Theorem 46.8: compact convergence (metric) is contained in compact-open topology **)
(** LATEX VERSION: The uniform- neighborhoods on compact sets are open in the compact-open topology, by a finite-subcover argument. **)
(** helper for 46 Theorem 46.8: closure of a ball stays inside the doubled ball **)
(** LATEX VERSION: In a metric space, the closure of B(y,r) is contained in B(y,2r). **)
Theorem closure_open_ball_sub_open_ball_add_radius : forall Y d y r:set,
  metric_on Y d ->
  y :e Y ->
  r :e R ->
  Rlt 0 r ->
  closure_of Y (metric_topology Y d) (open_ball Y d y r)
    c= open_ball Y d y (add_SNo r r).
admit.
Qed.

(** helper for 46 Theorem 46.8: closure of a preimage ball maps into a doubled ball preimage **)
(** LATEX VERSION: If f is continuous and B is an open ball, then closure(f^{-1}(B)) is mapped into the doubled ball. **)
Theorem closure_preimage_open_ball_sub_preimage_open_ball_add_radius : forall X Tx Y d f y r:set,
  topology_on X Tx ->
  metric_on Y d ->
  continuous_map X Tx Y (metric_topology Y d) f ->
  y :e Y ->
  r :e R ->
  Rlt 0 r ->
  closure_of X Tx (preimage_of X f (open_ball Y d y r))
    c= preimage_of X f (open_ball Y d y (add_SNo r r)).
admit.
Qed.
Theorem compact_convergence_metric_C_sub_compact_open_topology_C : forall X Tx Y dY:set,
  topology_on X Tx ->
  metric_on Y dY ->
  compact_convergence_topology_metric_C X Tx Y dY
    c= compact_open_topology_C X Tx Y (metric_topology Y dY).
admit.
Qed.

(** from 46 Theorem 46.8: compact-open topology equals compact convergence (metric) on C(X,Y) **)
(** LATEX VERSION: For metric (Y,d), on C(X,Y) the compact-open and compact convergence topologies coincide. **)
Theorem compact_open_eq_compact_convergence_on_C : forall X Tx Y dY:set,
  topology_on X Tx ->
  metric_on Y dY ->
  compact_open_topology_C X Tx Y (metric_topology Y dY) =
  compact_convergence_topology_metric_C X Tx Y dY.
admit.
Qed.

(** from 46 Corollary 46.9: compact convergence topology does not depend on metric **)
(** LATEX VERSION: If Y is metric, the compact convergence topology on C(X,Y) depends only on the induced topology on Y. **)
Theorem compact_convergence_metric_independent_of_metric : forall X Tx Y d1 d2:set,
  topology_on X Tx ->
  metric_on Y d1 ->
  metric_on Y d2 ->
  metric_topology Y d1 = metric_topology Y d2 ->
  compact_convergence_topology_metric_C X Tx Y d1 =
  compact_convergence_topology_metric_C X Tx Y d2.
admit.
Qed.

(** helper: compact-open topology is finer than pointwise convergence topology **)
(** LATEX VERSION: The compact-open topology is finer than the topology of pointwise convergence (singletons are compact). **)
Theorem compact_convergence_finer_than_pointwise : forall X Tx Y Ty:set,
  topology_on X Tx ->
  topology_on Y Ty ->
  finer_than
    (compact_convergence_topology X Tx Y Ty)
    (pointwise_convergence_topology X Tx Y Ty).
admit.
Qed.

(** from 47 Definition: pointwise image of a family at a point **)
(** LATEX VERSION: For aX, define F_a = { f(a) | f  F }. **)
Definition Ascoli_F_at : set -> set -> set -> set -> set :=
  fun X Y a F => {apply_fun f a | f :e F}.

(** helper: unfold Ascoli_F_at as Repl **)
Theorem Ascoli_F_at_def : forall X Y a F:set,
  Ascoli_F_at X Y a F = Repl F (fun f:set => apply_fun f a).
admit.
Qed.

(** from 47 Hypothesis: pointwise compact closure of images **)
(** LATEX VERSION: For each aX, the set F_a has compact closure in Y. **)
Definition Ascoli_pointwise_compact_closure : set -> set -> set -> set -> prop :=
  fun X Y dY F =>
    forall a:set, a :e X ->
      compact_space
        (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F))
        (subspace_topology
           Y (metric_topology Y dY)
           (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F))).

(** from 47 Hypothesis: equicontinuity under a metric **)
(** LATEX VERSION: F is equicontinuous under d if x0,>0, Ux0: d(f(x),f(x0))< for xU, fF. **)
Definition equicontinuous_family : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y dY F =>
    topology_on X Tx /\ metric_on Y dY /\
    F c= continuous_function_space X Tx Y (metric_topology Y dY) /\
    forall x0:set, x0 :e X ->
      forall eps:set, eps :e R /\ Rlt 0 eps ->
        exists U:set, U :e Tx /\ x0 :e U /\
          forall f:set, f :e F ->
            forall x:set, x :e X -> x :e U ->
              Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps.

(** from 47 Definition: relative compactness in compact convergence topology **)
(** LATEX VERSION: F is relatively compact if it is contained in a compact subspace of C(X,Y) (compact convergence topology). **)
(** Here compact convergence is the metric topology `compact_convergence_topology_metric_C` from 46. **)
Definition relatively_compact_in_compact_convergence : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y dY F =>
    F c= continuous_function_space X Tx Y (metric_topology Y dY) /\
    exists H:set,
      F c= H /\
      H c= continuous_function_space X Tx Y (metric_topology Y dY) /\
      compact_space
        H
        (subspace_topology
           (continuous_function_space X Tx Y (metric_topology Y dY))
           (compact_convergence_topology_metric_C X Tx Y dY)
           H).

(** from 47 Theorem 47.1(a) Proof Step 1: pointwise closure g of F in Y^X **)
(** LATEX VERSION: Let g be the closure of F in Y^X in the product topology, i.e. the topology of pointwise convergence. **)
Definition Ascoli_g_pointwise_closure : set -> set -> set -> set -> set -> set :=
  fun X Tx Y dY F =>
    closure_of
      (function_space X Y)
      (pointwise_convergence_topology X Tx Y (metric_topology Y dY))
      F.

(** helper: g is a subset of Y^X **)
Theorem Ascoli_g_pointwise_closure_sub : forall X Tx Y dY F:set,
  topology_on (function_space X Y)
    (pointwise_convergence_topology X Tx Y (metric_topology Y dY)) ->
  Ascoli_g_pointwise_closure X Tx Y dY F c= function_space X Y.
admit.
Qed.

(** helper: g is closed in Y^X **)
Theorem Ascoli_g_pointwise_closure_closed : forall X Tx Y dY F:set,
  topology_on (function_space X Y)
    (pointwise_convergence_topology X Tx Y (metric_topology Y dY)) ->
  F c= function_space X Y ->
  closed_in
    (function_space X Y)
    (pointwise_convergence_topology X Tx Y (metric_topology Y dY))
    (Ascoli_g_pointwise_closure X Tx Y dY F).
admit.
Qed.

(** helper for 47 Step 1: each coordinate of g lies in the closure of F_a **)
(** LATEX VERSION: If g is in the pointwise closure of F in Y^X, then g(a) is in the closure of F_a for each a. **)
Theorem Ascoli_g_pointwise_closure_coord : forall X Tx Y dY F g a:set,
  topology_on X Tx ->
  metric_on Y dY ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  g :e Ascoli_g_pointwise_closure X Tx Y dY F ->
  a :e X ->
  apply_fun g a :e closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F).
admit.
Qed.

(** from 47 Theorem 47.1(a) Proof Step 2: equicontinuity bound for g **)
(** LATEX VERSION: Step 2: given x0 and eps, there is U around x0 such that d(g(x),g(x0))<eps for all g in g and all x in U. **)
Theorem Ascoli_g_pointwise_closure_equicontinuous_bound :
  forall X Tx Y dY F x0 eps:set,
    topology_on X Tx ->
    metric_on Y dY ->
    F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
    equicontinuous_family X Tx Y dY F ->
    x0 :e X ->
    eps :e R /\ Rlt 0 eps ->
    exists U:set, U :e Tx /\ x0 :e U /\
      forall g:set, g :e Ascoli_g_pointwise_closure X Tx Y dY F ->
        forall x:set, x :e X -> x :e U ->
          Rlt (apply_fun dY (apply_fun g x, apply_fun g x0)) eps.
admit.
Qed.

(** helper: relative compactness implies pointwise compact closure of images **)
Theorem relatively_compact_imp_Ascoli_pointwise_compact_closure : forall X Tx Y dY F:set,
  topology_on X Tx ->
  metric_on Y dY ->
  relatively_compact_in_compact_convergence X Tx Y dY F ->
  Ascoli_pointwise_compact_closure X Y dY F.
admit.
Qed.

(** from 47 Step 2: every element of g is continuous **)
(** LATEX VERSION: Step 2 shows each element of g is continuous (and g is equicontinuous). **)
Theorem Ascoli_g_pointwise_closure_continuous_map : forall X Tx Y dY F g:set,
  topology_on X Tx ->
  metric_on Y dY ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  equicontinuous_family X Tx Y dY F ->
  g :e Ascoli_g_pointwise_closure X Tx Y dY F ->
  continuous_map X Tx Y (metric_topology Y dY) g.
admit.
Qed.

(** from 47 Step 2: g is contained in C(X,Y) **)
(** LATEX VERSION: Step 2 implies g is a subset of C(X,Y). **)
Theorem Ascoli_g_pointwise_closure_sub_CXY : forall X Tx Y dY F g:set,
  topology_on X Tx ->
  metric_on Y dY ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  equicontinuous_family X Tx Y dY F ->
  g :e Ascoli_g_pointwise_closure X Tx Y dY F ->
  g :e continuous_function_space X Tx Y (metric_topology Y dY).
admit.
Qed.

(** helper for 47 Step 2: the whole set g is contained in C(X,Y) **)
(** LATEX VERSION: Step 2 yields g c= C(X,Y). **)
Theorem Ascoli_g_pointwise_closure_set_sub_CXY : forall X Tx Y dY F:set,
  topology_on X Tx ->
  metric_on Y dY ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  equicontinuous_family X Tx Y dY F ->
  Ascoli_g_pointwise_closure X Tx Y dY F c=
    continuous_function_space X Tx Y (metric_topology Y dY).
admit.
Qed.

(** helper: Ascoli compact coordinate family XiKa for the product of Ka **)
(** LATEX VERSION: For each a in X, let Ka be the closure of Fa in Y and consider the product of the spaces Ka. **)
Definition Ascoli_XiKa : set -> set -> set -> set -> set :=
  fun X Y Ty F =>
    graph X (fun a:set =>
      (closure_of Y Ty (Ascoli_F_at X Y a F),
       subspace_topology Y Ty (closure_of Y Ty (Ascoli_F_at X Y a F)))).

(** helper: component carrier for Ascoli_XiKa **)
Theorem Ascoli_XiKa_set : forall X Y Ty F a:set,
  a :e X ->
  space_family_set (Ascoli_XiKa X Y Ty F) a =
    closure_of Y Ty (Ascoli_F_at X Y a F).
admit.
Qed.

(** helper: component topology for Ascoli_XiKa **)
Theorem Ascoli_XiKa_topology : forall X Y Ty F a:set,
  a :e X ->
  space_family_topology (Ascoli_XiKa X Y Ty F) a =
    subspace_topology Y Ty (closure_of Y Ty (Ascoli_F_at X Y a F)).
admit.
Qed.

(** helper: compactness of the product of the compact closures Ka **)
(** LATEX VERSION: If each Ka is compact, then the product of the family Ka indexed by X is compact (Tychonoff). **)
Theorem Ascoli_XiKa_product_compact : forall X Y dY F:set,
  metric_on Y dY ->
  Ascoli_pointwise_compact_closure X Y dY F ->
  compact_space
    (product_space X (Ascoli_XiKa X Y (metric_topology Y dY) F))
    (product_topology_full X (Ascoli_XiKa X Y (metric_topology Y dY) F)).
admit.
Qed.

(** helper for 47: any net in the Ascoli product has a convergent subnet **)
(** LATEX VERSION: In a compact space, every net has a convergent subnet. **)
Theorem Ascoli_XiKa_product_every_net_pack_has_convergent_subnet_pack :
  forall X Y dY F N:set,
    metric_on Y dY ->
    Ascoli_pointwise_compact_closure X Y dY F ->
    net_pack_in_space (product_space X (Ascoli_XiKa X Y (metric_topology Y dY) F)) N ->
    exists S x:set,
      subnet_pack_of_in (product_space X (Ascoli_XiKa X Y (metric_topology Y dY) F)) N S /\
      net_pack_converges
        (product_space X (Ascoli_XiKa X Y (metric_topology Y dY) F))
        (product_topology_full X (Ascoli_XiKa X Y (metric_topology Y dY) F))
        S x.
admit.
Qed.

(** helper for 47: per-ball neighborhood extraction used in equicontinuity proof skeleton **)
Theorem compact_subspace_CXY_equicontinuous_per_ball :
  forall X Tx Y dY H x0 eps r Ty eval0 Img0 FamBalls Gballs:set,
    topology_on X Tx ->
    metric_on Y dY ->
    Ty = metric_topology Y dY ->
    locally_compact X Tx ->
    Hausdorff_space X Tx ->
    H c= continuous_function_space X Tx Y (metric_topology Y dY) ->
    compact_space
      H
      (subspace_topology
        (continuous_function_space X Tx Y (metric_topology Y dY))
        (compact_open_topology_C X Tx Y (metric_topology Y dY))
        H) ->
    eval0 = graph (function_space X Y) (fun f:set => apply_fun f x0) ->
    x0 :e X ->
    eps :e R -> Rlt 0 eps ->
    r :e R -> Rlt 0 r ->
    Rlt (add_SNo (add_SNo r r) (add_SNo r r)) eps ->
    Img0 = image_of_fun eval0 H ->
    FamBalls = {open_ball Y dY y r|y :e Img0} ->
    Gballs c= FamBalls ->
    forall b:set, b :e Gballs ->
      exists U:set,
        U :e Tx /\ x0 :e U /\
          forall f:set, f :e H ->
            apply_fun eval0 f :e closure_of Y Ty b ->
              forall x1:set, x1 :e X -> x1 :e U ->
                Rlt (apply_fun dY (apply_fun f x1, apply_fun f x0)) eps.
admit.
Qed.

(** helper: compact subset of C(X,Y) is equicontinuous (metric codomain) **)
Theorem compact_subspace_CXY_equicontinuous : forall X Tx Y dY H:set,
  topology_on X Tx ->
  metric_on Y dY ->
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  H c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  compact_space
    H
    (subspace_topology
      (continuous_function_space X Tx Y (metric_topology Y dY))
      (compact_open_topology_C X Tx Y (metric_topology Y dY))
      H) ->
  equicontinuous_family X Tx Y dY H.
admit.
Qed.

(** helper for 47: apply_fun of a graph result **)
(** LATEX VERSION: If h = graph A g and a  A, then applying the function value h(a) at b is the same as applying g(a) at b. **)
Theorem apply_fun_apply_fun_graph : forall A:set, forall g:set->set, forall a b:set,
  a :e A -> apply_fun (apply_fun (graph A g) a) b = apply_fun (g a) b.
admit.
Qed.

(** helper for 47: apply_fun respects equality **)
(** LATEX VERSION: If f=g then f(x)=g(x). **)
Theorem apply_fun_congr : forall f g x:set,
  f = g -> apply_fun f x = apply_fun g x.
admit.
Qed.

(** helper for 47: upper bound for finite subsets of a directed set **)
(** LATEX VERSION: In a directed set, any finite subset has an upper bound. **)
Theorem directed_set_finite_upper_bound : forall J le F:set,
  directed_set J le ->
  finite F ->
  F c= J ->
  exists k:set, k :e J /\ forall i:set, i :e F -> (i,k) :e le.
admit.
Qed.

(** helper for 47: remaining diagonalization plus equicontinuity upgrade (placeholder) **)
Theorem Ascoli_theorem_47_1a_diag_upgrade :
  forall X Tx Y dY F Hcand Thcand N J le net:set,
    topology_on X Tx ->
    metric_on Y dY ->
    Hcand c= continuous_function_space X Tx Y (metric_topology Y dY) ->
    Hcand = Ascoli_g_pointwise_closure X Tx Y dY F ->
    Thcand =
      subspace_topology
        (continuous_function_space X Tx Y (metric_topology Y dY))
        (compact_convergence_topology_metric_C X Tx Y dY)
        Hcand ->
    topology_on Hcand Thcand ->
    F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
    equicontinuous_family X Tx Y dY F ->
    Ascoli_pointwise_compact_closure X Y dY F ->
    N = net_pack J le net ->
    directed_set J le ->
    total_function_on net J Hcand ->
    functional_graph net ->
    graph_domain_subset net J ->
    (forall a:set, a :e X ->
      exists Ni Si x:set,
        net_pack_in_space (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F)) Ni /\
        Ni =
          net_pack J le
            (graph J (fun j:set => apply_fun (apply_fun net j) a)) /\
        subnet_pack_of_in (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F)) Ni Si /\
        net_pack_converges
          (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F))
          (subspace_topology Y (metric_topology Y dY)
             (closure_of Y (metric_topology Y dY) (Ascoli_F_at X Y a F)))
          Si x) ->
    exists S x:set, subnet_pack_of_in Hcand N S /\ net_pack_converges Hcand Thcand S x.
admit.
Qed.

(** from 47 Theorem 47.1(a): Ascoli's theorem, forward direction **)
(** LATEX VERSION: If FC(X,Y) is equicontinuous and each F_a has compact closure, then F lies in a compact subspace. **)
Theorem Ascoli_theorem_47_1a : forall X Tx Y dY F:set,
  topology_on X Tx ->
  metric_on Y dY ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  equicontinuous_family X Tx Y dY F ->
  Ascoli_pointwise_compact_closure X Y dY F ->
  relatively_compact_in_compact_convergence X Tx Y dY F.
admit.
Qed.

(** from 47 Theorem 47.1(b): Ascoli's theorem, converse direction **)
(** LATEX VERSION: Conversely, if X is locally compact Hausdorff and F is relatively compact, then F is equicontinuous and each F_a has compact closure. **)
Theorem Ascoli_theorem_47_1b : forall X Tx Y dY F:set,
  topology_on X Tx ->
  metric_on Y dY ->
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  F c= continuous_function_space X Tx Y (metric_topology Y dY) ->
  relatively_compact_in_compact_convergence X Tx Y dY F ->
  equicontinuous_family X Tx Y dY F /\ Ascoli_pointwise_compact_closure X Y dY F.
admit.
Qed.

(** helper: intersection over a family within a universe X **) 
(** LATEX VERSION: Intersection_over_family X Fam collects points lying in every member of Fam. **)
Definition intersection_over_family : set -> set -> set :=
  fun X Fam => intersection_of_family X Fam.

(** from 48 Definition: Baire space **)
(** LATEX VERSION: A Baire space is one where countable intersections of dense open sets are dense. **)
Definition Baire_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set,
    U c= Tx -> countable_set U ->
    (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) ->
    dense_in (intersection_over_family X U) X Tx.

(** from 48 Definition (closed-set form): Baire space **)
(** LATEX VERSION: X is Baire if for any countable family of closed subsets with empty interior, the union has empty interior. **)
Definition Baire_space_closed : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall Fam:set,
    countable_set Fam ->
    (forall A:set, A :e Fam -> closed_in X Tx A /\ interior_of X Tx A = Empty) ->
    interior_of X Tx (Union Fam) = Empty.

(** helper: union of complements equals complement of intersection_over_family **)
Theorem union_of_complements_eq_complement_of_intersection_over_family : forall X U:set,
  (forall u:set, u :e U -> u c= X) ->
  Union {X :\: u | u :e U} = X :\: (intersection_over_family X U).
admit.
Qed.

(** helper: intersection of complements equals complement of Union **)
Theorem intersection_of_complements_eq_complement_of_Union : forall X Fam:set,
  (forall A:set, A :e Fam -> A c= X) ->
  intersection_over_family X {X :\: A | A :e Fam} = X :\: Union Fam.
admit.
Qed.

(** from 48 Lemma 48.1 (direction): closed-set Baire implies open-set Baire **)
(** LATEX VERSION: Lemma 48.1: X is Baire iff countable intersections of dense open sets are dense. **)
Theorem Baire_space_closed_imp : forall X Tx:set,
  Baire_space_closed X Tx -> Baire_space X Tx.
admit.
Qed.

(** from 48 Lemma 48.1 (direction): open-set Baire implies closed-set Baire **)
(** LATEX VERSION: Lemma 48.1: X is Baire iff countable intersections of dense open sets are dense. **)
Theorem Baire_space_imp_closed : forall X Tx:set,
  Baire_space X Tx -> Baire_space_closed X Tx.
admit.
Qed.

(** from 48 Lemma 48.1: equivalence of closed and open formulations **)
(** LATEX VERSION: Lemma 48.1: X is Baire iff any countable intersection of dense open sets is dense. **)
Theorem Baire_space_closed_iff : forall X Tx:set,
  (Baire_space_closed X Tx <-> Baire_space X Tx).
admit.
Qed.

(** from 48 Lemma 48.1: dense G_delta characterization of Baire space **)
(** LATEX VERSION: Equivalent dense G_ characterization of Baire spaces. **)
Theorem Baire_space_dense_Gdelta : forall X Tx:set,
  Baire_space X Tx ->
  forall U:set,
    U c= Tx -> countable_set U ->
    (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) ->
    dense_in (intersection_over_family X U) X Tx.
admit.
Qed.

(** from 48 Theorem: Baire category theorem for complete metric spaces **)
(** LATEX VERSION: Complete metric spaces are Baire. **)
(** helper: closed-set Baire category core for complete metric spaces **)
(** helper: if B is not a subset of A then B contains a point outside A **)
Theorem not_subset_ex_elem : forall A B:set,
  ~(B c= A) -> exists x:set, x :e B /\ x /:e A.
admit.
Qed.

(** helper: if closure(A) is contained in B then A is contained in B **)
Theorem subset_of_set_from_closure_sub : forall X Tx A B:set,
  topology_on X Tx ->
  A c= X ->
  closure_of X Tx A c= B ->
  A c= B.
admit.
Qed.

(** helper: one Baire-step in a metric space (choose x1 in B\\A, shrink around x1, take a small ball) **)
Theorem baire_step_metric_ball : forall X d A B x:set,
  metric_on X d ->
  x :e X ->
  B :e metric_topology X d ->
  x :e B ->
  closed_in X (metric_topology X d) A ->
  interior_of X (metric_topology X d) A = Empty ->
  exists x1:set, exists V1:set, exists N1:set,
    (x1 :e B /\ x1 /:e A) /\
    (V1 :e metric_topology X d /\ x1 :e V1 /\ closure_of X (metric_topology X d) V1 c= (B :/\: (X :\: A))) /\
    (N1 :e omega /\ open_ball X d x1 (eps_ N1) c= V1).
admit.
Qed.

(** helper: same step, additionally producing the next ball and closure nesting **)
Theorem baire_step_metric_ball_closure : forall X d A B x:set,
  metric_on X d ->
  x :e X ->
  B :e metric_topology X d ->
  x :e B ->
  closed_in X (metric_topology X d) A ->
  interior_of X (metric_topology X d) A = Empty ->
  exists x1:set, exists N1:set, exists B1:set,
    (x1 :e B /\ x1 /:e A) /\
    (B1 = open_ball X d x1 (eps_ N1)) /\
    (B1 :e metric_topology X d /\ x1 :e B1 /\ closure_of X (metric_topology X d) B1 c= (B :/\: (X :\: A))).
admit.
Qed.

(** helper: one Baire-step, choosing a ball with radius bounded by a given a>0 **)
Theorem baire_step_metric_ball_bounded_closure : forall X d A B x a:set,
  metric_on X d ->
  x :e X ->
  B :e metric_topology X d ->
  x :e B ->
  closed_in X (metric_topology X d) A ->
  interior_of X (metric_topology X d) A = Empty ->
  a :e R ->
  Rlt 0 a ->
  exists x1:set, exists r1:set, exists B1:set,
    (x1 :e B /\ x1 /:e A) /\
    (r1 :e R /\ Rlt 0 r1 /\ Rlt r1 a) /\
    (B1 = open_ball X d x1 r1) /\
    (B1 :e metric_topology X d /\ x1 :e B1 /\ closure_of X (metric_topology X d) B1 c= (B :/\: (X :\: A))).
admit.
Qed.

(** helper: one Baire-step with radius bounded by eps_(ordsucc n) **)
Theorem baire_step_metric_ball_eps_bounded_closure : forall X d A B x n:set,
  metric_on X d ->
  x :e X ->
  B :e metric_topology X d ->
  x :e B ->
  closed_in X (metric_topology X d) A ->
  interior_of X (metric_topology X d) A = Empty ->
  n :e omega ->
  exists x1:set, exists r1:set, exists B1:set,
    (x1 :e B /\ x1 /:e A) /\
    (r1 :e R /\ Rlt 0 r1 /\ Rlt r1 (eps_ (ordsucc n))) /\
    (B1 = open_ball X d x1 r1) /\
    (B1 :e metric_topology X d /\ x1 :e B1 /\ closure_of X (metric_topology X d) B1 c= (B :/\: (X :\: A))).
admit.
Qed.

(** helper: Baire construction produces a point outside a countable closed family **)
(** This is used to close the main Baire_category_complete_metric_closed_core proof. **)
Theorem baire_complete_metric_avoid_closed_seq : forall X d U0 x0:set, forall An:set->set,
  complete_metric_space X d ->
  (forall n:set, n :e omega ->
    closed_in X (metric_topology X d) (An n) /\ interior_of X (metric_topology X d) (An n) = Empty) ->
  U0 :e metric_topology X d ->
  x0 :e X ->
  x0 :e U0 ->
  exists x:set, x :e U0 /\ forall n:set, n :e omega -> x /:e (An n).
admit.
Qed.
Theorem Baire_category_complete_metric_closed_core : forall X d Fam:set,
  complete_metric_space X d ->
  countable_set Fam ->
  (forall A:set, A :e Fam ->
    closed_in X (metric_topology X d) A /\ interior_of X (metric_topology X d) A = Empty) ->
  interior_of X (metric_topology X d) (Union Fam) = Empty.
admit.
Qed.
Theorem Baire_category_complete_metric_closed : forall X d:set,
  complete_metric_space X d -> Baire_space_closed X (metric_topology X d).
admit.
Qed.
Theorem Baire_category_complete_metric : forall X d:set,
  complete_metric_space X d -> Baire_space X (metric_topology X d).
admit.
Qed.

(** from 48 Theorem: compact Hausdorff spaces are Baire spaces **)
(** LATEX VERSION: Compact Hausdorff spaces are Baire. **)
(** helper: one-step Baire construction in a regular space, avoiding a closed set with empty interior **)
Theorem baire_step_regular_open_closure : forall X Tx A B x:set,
  regular_space X Tx ->
  x :e X ->
  B :e Tx ->
  x :e B ->
  closed_in X Tx A ->
  interior_of X Tx A = Empty ->
  exists x1:set, exists B1:set,
    (x1 :e B /\ x1 /:e A) /\
    (B1 :e Tx /\ x1 :e B1 /\ closure_of X Tx B1 c= (B :/\: (X :\: A))).
admit.
Qed.

(** helper: accumulation point plus eventual membership gives closure membership **)
Theorem accumulation_point_on_in_closure_of_eventually_terms : forall X Tx net J le A x i0:set,
  accumulation_point_of_net_on X Tx net J le x ->
  A c= X ->
  i0 :e J ->
  (forall i:set, i :e J -> (i0,i) :e le -> apply_fun net i :e A) ->
  x :e closure_of X Tx A.
admit.
Qed.

(** helper: Baire construction in compact Hausdorff spaces produces a point outside a countable closed family **)
Theorem baire_compact_Hausdorff_avoid_closed_seq : forall X Tx U0 x0:set, forall An:set->set,
  compact_space X Tx ->
  Hausdorff_space X Tx ->
  (forall n:set, n :e omega ->
    closed_in X Tx (An n) /\ interior_of X Tx (An n) = Empty) ->
  U0 :e Tx ->
  x0 :e X ->
  x0 :e U0 ->
  exists x:set, x :e U0 /\ forall n:set, n :e omega -> x /:e (An n).
admit.
Qed.

(** helper: closed-set Baire category core for compact Hausdorff spaces **)
Theorem Baire_category_compact_Hausdorff_closed_core : forall X Tx Fam:set,
  compact_space X Tx ->
  Hausdorff_space X Tx ->
  countable_set Fam ->
  (forall A:set, A :e Fam -> closed_in X Tx A /\ interior_of X Tx A = Empty) ->
  interior_of X Tx (Union Fam) = Empty.
admit.
Qed.
Theorem Baire_category_compact_Hausdorff_closed : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> Baire_space_closed X Tx.
admit.
Qed.
Theorem Baire_category_compact_Hausdorff : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> Baire_space X Tx.
admit.
Qed.

(** from 48 Theorem 48.2 (Baire category theorem): compact Hausdorff or complete metric implies Baire **)
(** LATEX VERSION: If X is compact Hausdorff or a complete metric space, then X is a Baire space. **)
Theorem Baire_category_theorem : forall X Tx:set,
  (compact_space X Tx /\ Hausdorff_space X Tx) \/
  (exists d:set, complete_metric_space X d /\ Tx = metric_topology X d) ->
  Baire_space X Tx.
admit.
Qed.

(** from 48 Lemma 48.4: open subspace of Baire is Baire **)
(** LATEX VERSION: Lemma 48.4: Any open subspace Y of a Baire space X is itself a Baire space. **)
Theorem Baire_open_subspace : forall X Tx Y:set,
  Baire_space X Tx ->
  open_in X Tx Y ->
  Baire_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** helper block moved earlier: continuity at a point and uniform limit infrastructure are needed for 35 **)
(** see earlier placement just before 35 after the metric completeness primitives **)
(** helper: Cauchy tail set A_N(eps) for a sequence of maps into a metric space **)
(** LATEX VERSION: A_N(eps) is the set of x such that d(f_n(x),f_m(x))  eps for all n,m  N. **)
Definition A_N_eps : set -> set -> set -> set -> set -> set -> set :=
  fun X Y d fn N eps =>
    {x :e X |
      forall n:set, n :e omega -> N c= n ->
        forall m:set, m :e omega -> N c= m ->
          Rle (apply_fun d (apply_fun (apply_fun fn n) x, apply_fun (apply_fun fn m) x)) eps }.

(** helper: monotonicity of A_N_eps in eps **)
(** LATEX VERSION: If eps1 <= eps2 then A_N(eps1) is a subset of A_N(eps2). **)
Theorem A_N_eps_monotone : forall X Y d fn N eps1 eps2:set,
  eps1 :e R -> eps2 :e R -> Rle eps1 eps2 ->
  A_N_eps X Y d fn N eps1 c= A_N_eps X Y d fn N eps2.
admit.
Qed.

(** helper: distance map is continuous in the product topology of a metric space **)
(** LATEX VERSION: The distance function d:YYR is continuous for the product of the metric topology on Y. **)
Theorem metric_distance_above_has_product_ball : forall Y d a p:set,
  metric_on_total Y d ->
  a :e R ->
  p :e preimage_of (setprod Y Y) d (open_ray_upper R a) ->
  exists r:set, r :e R /\ Rlt 0 r /\
    rectangle_set (open_ball Y d (p 0) r) (open_ball Y d (p 1) r)
      c= preimage_of (setprod Y Y) d (open_ray_upper R a).
admit.
Qed.
Theorem metric_distance_preimage_open_ray_upper : forall Y d a:set,
  metric_on_total Y d ->
  a :e R ->
  preimage_of (setprod Y Y) d (open_ray_upper R a) :e
    (product_topology Y (metric_topology Y d) Y (metric_topology Y d)).
admit.
Qed.
Theorem metric_distance_below_has_product_ball : forall Y d b p:set,
  metric_on_total Y d ->
  b :e R ->
  p :e preimage_of (setprod Y Y) d (open_ray_lower R b) ->
  exists r:set, r :e R /\ Rlt 0 r /\
    rectangle_set (open_ball Y d (p 0) r) (open_ball Y d (p 1) r)
      c= preimage_of (setprod Y Y) d (open_ray_lower R b).
admit.
Qed.
Theorem metric_distance_preimage_open_ray_lower : forall Y d b:set,
  metric_on_total Y d ->
  b :e R ->
  preimage_of (setprod Y Y) d (open_ray_lower R b) :e
    (product_topology Y (metric_topology Y d) Y (metric_topology Y d)).
admit.
Qed.
Theorem metric_distance_continuous : forall Y d:set,
  metric_on_total Y d ->
  continuous_map (setprod Y Y)
    (product_topology Y (metric_topology Y d) Y (metric_topology Y d))
    R R_standard_topology d.
admit.
Qed.

(** helper: A_N(eps) is closed under continuity hypotheses **)
(** LATEX VERSION: In Theorem 48.5, A_N(eps) is closed as an intersection of closed sets defined by d(f_n,f_m)eps. **)
Theorem A_N_eps_closed_stub : forall X Tx Y d fn N eps:set,
  topology_on X Tx ->
  metric_on_total Y d ->
  (forall n:set, n :e omega ->
    continuous_map X Tx Y (metric_topology Y d) (apply_fun fn n)) ->
  N :e omega ->
  eps :e R ->
  closed_in X Tx (A_N_eps X Y d fn N eps).
admit.
Qed.

(** helper: U(eps) as union of interiors of A_N(eps) **)
(** LATEX VERSION: U(eps) is the union over N of Int(A_N(eps)). **)
Definition U_eps : set -> set -> set -> set -> set -> set -> set :=
  fun X Tx Y d fn eps =>
    Union {interior_of X Tx (A_N_eps X Y d fn N eps) | N :e omega}.

(** helper: monotonicity of U_eps in eps **)
(** LATEX VERSION: If eps1 <= eps2 then U(eps1) is a subset of U(eps2). **)
Theorem U_eps_monotone : forall X Tx Y d fn eps1 eps2:set,
  topology_on X Tx ->
  eps1 :e R -> eps2 :e R -> Rle eps1 eps2 ->
  U_eps X Tx Y d fn eps1 c= U_eps X Tx Y d fn eps2.
admit.
Qed.

(** helper: unpack membership in U_eps into a concrete neighborhood inside A_N_eps **)
(** LATEX VERSION: If x  U(eps)= Int(A_N(eps)), then x lies in some open set U  A_N(eps). **)
Theorem U_epsE_open_subset_A_N : forall X Tx Y d fn eps x:set,
  topology_on X Tx ->
  x :e U_eps X Tx Y d fn eps ->
  exists N:set, N :e omega /\
    exists U:set, U :e Tx /\ x :e U /\ U c= A_N_eps X Y d fn N eps.
admit.
Qed.

(** helper: pointwise limit implies eventual Cauchy, hence X is covered by A_N(eps) **)
(** LATEX VERSION: In Theorem 48.5, the union of A_N(eps) equals X because f_n(x) converges for each x. **)
Theorem pointwise_limit_metric_imp_cover_A_N_eps_stub : forall X Y d fn f eps:set,
  metric_on_total Y d ->
  (forall n:set, n :e omega -> function_on (apply_fun fn n) X Y) ->
  function_on f X Y ->
  pointwise_limit_metric X Y d fn f ->
  eps :e R -> Rlt 0 eps ->
  forall x:set, x :e X -> exists N:set, N :e omega /\ x :e A_N_eps X Y d fn N eps.
admit.
Qed.

(** helper: U(eps) should be open and dense under hypotheses of Theorem 48.5 **)
(** LATEX VERSION: In the proof of Theorem 48.5, U(eps) is shown to be open and dense. **)
Theorem U_eps_open_dense_stub : forall X Tx Y d fn eps:set,
  Baire_space X Tx ->
  metric_on_total Y d ->
  (forall n:set, n :e omega ->
    continuous_map X Tx Y (metric_topology Y d) (apply_fun fn n)) ->
  (forall N:set, N :e omega -> closed_in X Tx (A_N_eps X Y d fn N eps)) ->
  (forall x:set, x :e X -> exists N:set, N :e omega /\ x :e A_N_eps X Y d fn N eps) ->
  eps :e R -> Rlt 0 eps ->
  open_in X Tx (U_eps X Tx Y d fn eps) /\ dense_in (U_eps X Tx Y d fn eps) X Tx.
admit.
Qed.

(** helper: fourfold-small epsilon for metric continuity estimates **)
(** This is used in 48.5 to split a target radius eps0 into four smaller error terms. **)
Theorem exists_fourfold_small_eps : forall eps0:set,
  eps0 :e R -> Rlt 0 eps0 ->
  exists eps1:set,
    eps1 :e R /\ Rlt 0 eps1 /\
    Rlt (add_SNo (add_SNo eps1 eps1) (add_SNo eps1 eps1)) eps0.
admit.
Qed.


(** from 48 Theorem 48.5: continuity points of pointwise limit are dense **)
(** LATEX VERSION: Theorem 48.5: If f_n:XY are continuous and f_n(x)f(x) pointwise into metric space Y, then continuity points of f form a dense subset of X when X is Baire. **)
Theorem pointwise_limit_continuity_points_dense : forall X Tx Y d fn f:set,
  metric_on_total Y d ->
  (forall n:set, n :e omega ->
    continuous_map X Tx Y (metric_topology Y d) (apply_fun fn n)) ->
  function_on f X Y ->
  pointwise_limit_metric X Y d fn f ->
  Baire_space X Tx ->
  dense_in {x :e X | continuous_at_map X Tx Y (metric_topology Y d) f x} X Tx.
admit.
Qed.

(** from 49 Definition: differentiability and nowhere-differentiable function **) 
(** LATEX VERSION: A function is differentiable at x if the difference quotient (f(x+h)-f(x))/h tends to a limit as h0 (with x+h in the domain); nowhere differentiable means differentiable at no point. **)
Definition differentiable_at : set -> set -> prop := fun f x =>
  function_on f unit_interval R /\ x :e unit_interval /\
  exists L:set, L :e R /\
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        forall h:set, h :e R ->
          ~(h = 0) ->
          Rlt 0 (Abs h) ->
          Rlt (Abs h) delta ->
          (add_SNo x h) :e unit_interval ->
          Rlt (Abs (add_SNo
                      (div_SNo (add_SNo (apply_fun f (add_SNo x h)) (minus_SNo (apply_fun f x))) h)
                      (minus_SNo L))) eps.
(** from 49 Definition: nowhere differentiable function **)
(** LATEX VERSION: A function is nowhere differentiable if it is differentiable at no point of its domain. **)
Definition nowhere_differentiable : set -> prop := fun f =>
  function_on f unit_interval R /\ forall x:set, x :e unit_interval -> ~ differentiable_at f x.

(** from 49 Definition: the function space C(I,R) and the sets U_n **)
(** LATEX VERSION: Let C be the space of continuous maps f:IR. For n2, define U_n as the set of f such that for some 0<h1/n one has _h f > n. **)
(** note: the pointwise difference-quotient predicate is formalized, but deeper analytic facts are still handled via later axioms/theorems **)
Definition I_topology : set := unit_interval_topology.
Theorem I_topology_on : topology_on unit_interval I_topology.
admit.
Qed.
(** from 49 Definition: continuous functions h:[0,1]R **)
(** LATEX VERSION: Let h:[0,1]R be a continuous function. **)
Definition continuous_real_on_I : set -> prop := fun f =>
  continuous_map unit_interval I_topology R R_standard_topology f.
(** from 49 Definition: C(I,R) as continuous functions on I=[0,1] **)
(** LATEX VERSION: Let C(I,R) denote the space of continuous maps f:IR. **)
Definition C_I_R : set := {f :e function_space unit_interval R | continuous_real_on_I f}.

(** from 49 Theorem 49.1: approximation by nowhere-differentiable functions **)
(** LATEX VERSION: Given continuous h and epsilon>0, there exists continuous g with |h(x)-g(x)|<epsilon for all x, such that g is nowhere differentiable. **)
Axiom theorem_49_1_nowhere_differentiable_approx : forall h eps:set,
	  continuous_map unit_interval I_topology R R_standard_topology h ->
	  eps :e R ->
	  Rlt 0 eps ->
	  exists g:set,
	    continuous_map unit_interval I_topology R R_standard_topology g /\
	    nowhere_differentiable g /\
	    forall x:set, x :e unit_interval ->
	      Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g x)))) eps.

(** from 49 Definition: forward difference quotient |(f(x+h)-f(x))/h| **)
(** LATEX VERSION: Consider the difference quotient (f(x+h)-f(x))/h. **)
Definition diffquot_forward_abs : set -> set -> set -> set := fun f x h =>
  Abs (div_SNo (add_SNo (apply_fun f (add_SNo x h)) (minus_SNo (apply_fun f x))) h).
(** from 49 Definition: backward difference quotient |(f(x)-f(x-h))/h| **)
(** LATEX VERSION: Consider the difference quotient (f(x)-f(x-h))/h. **)
Definition diffquot_backward_abs : set -> set -> set -> set := fun f x h =>
  Abs (div_SNo (add_SNo (apply_fun f (add_SNo x (minus_SNo h))) (minus_SNo (apply_fun f x))) (minus_SNo h)).

(** from 49 Definition: predicate _h f > n using forward/backward difference quotients **)
(** LATEX VERSION: Define _h f > n in terms of a large difference quotient for some 0<h1/n. **)
Definition Delta_gt : set -> set -> set -> set -> prop := fun f x h n =>
  (add_SNo x h :e unit_interval /\ Rlt n (diffquot_forward_abs f x h))
  \/
  (add_SNo x (minus_SNo h) :e unit_interval /\ Rlt n (diffquot_backward_abs f x h)).

(** from 49 Definition: the open sets U_n in C(I,R) (Baire category argument) **)
(** LATEX VERSION: For n2, define U_n  C(I,R) using existence of small h with _h f > n. **)
Definition U_n : set -> set := fun n =>
  {f :e C_I_R | n :e omega /\ 2 c= n /\
    exists h:set, h :e R /\ Rlt 0 h /\ Rle h (div_SNo 1 n) /\
      forall x:set, x :e unit_interval -> Delta_gt f x h n}.

(** from 49 Existence: nowhere-differentiable function **) 
(** LATEX VERSION: Existence of a continuous nowhere-differentiable function. **)
Theorem nowhere_differentiable_function_exists :
  exists f:set,
    continuous_map unit_interval I_topology R R_standard_topology f /\
    nowhere_differentiable f.
admit.
Qed.

(** helper: finite cardinality via equip to an ordinal **) 
(** LATEX VERSION: Cardinality_exact/at_most helper predicates for dimension theory. **)
Definition cardinality_exact : set -> set -> prop := fun S n =>
  ordinal n /\ equip S n.
Definition cardinality_at_most : set -> set -> prop := fun S n =>
  ordinal n /\ exists k:set, ordinal k /\ k c= n /\ equip S k.

(** helper: a subset of a finite ordinal is equip to a subordinal **)
(** LATEX VERSION: For finite ordinals n, every subset of n is equip to some mn. **)
Theorem finite_ordinal_subset_equip_subordinal : forall n S:set,
  nat_p n ->
  S c= n ->
  exists m:set, nat_p m /\ (m c= n /\ equip S m).
admit.
Qed.

(** helper: cardinality_at_most is monotone for finite bounds **)
(** LATEX VERSION: If n is finite, S1S2 and |S2|n then |S1|n. **)
Theorem cardinality_at_most_mono_subset_finite : forall S1 S2 n:set,
  n :e omega ->
  S1 c= S2 ->
  cardinality_at_most S2 n ->
  cardinality_at_most S1 n.
admit.
Qed.

(** helper: cardinality_at_most is preserved under equip (left transfer) **)
(** LATEX VERSION: If S1 and S2 are equipotent and |S2|n, then |S1|n. **)
Theorem cardinality_at_most_equip_left : forall S1 S2 n:set,
  equip S1 S2 ->
  cardinality_at_most S2 n ->
  cardinality_at_most S1 n.
admit.
Qed.

(** helper: finite image of a finite-ordinal-bounded set has the same cardinality bound **)
(** LATEX VERSION: If |S|n and n is finite, then for any f the image f[S] also satisfies |f[S]|n. **)
Theorem cardinality_at_most_image_finite : forall S n:set, forall f:set->set,
  n :e omega ->
  cardinality_at_most S (ordsucc n) ->
  cardinality_at_most {f x|x :e S} (ordsucc n).
admit.
Qed.

(** from 50 Definition: order of a collection of subsets **) 
(** LATEX VERSION: A collection A has order m+1 if some point lies in m+1 elements of A, and no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    (exists x:set, x :e X /\
      exists Fam:set, Fam c= A /\ finite Fam /\
        cardinality_exact Fam (ordsucc m) /\
        forall U:set, U :e Fam -> x :e U) /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition (derived): order at most m+1 **) 
(** LATEX VERSION: A collection A has order at most m+1 if no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_most_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition: covering dimension and finite dimensionality **)
(** LATEX VERSION: For a topological space (X,Tx), we write dim(X)  n if for every open cover A of X\n+   there exists an open cover B refining A that has order at most n+1. **)
(** Helper: refinement of covers (as families of subsets) **)
(** LATEX VERSION: B refines A if every element of B is contained in some element of A. **)
Definition refines_cover : set -> set -> prop := fun B A =>
  forall U:set, U :e B -> exists V:set, V :e A /\ U c= V.

(** helper: refinement is reflexive **)
Theorem refines_cover_ref : forall A:set, refines_cover A A.
admit.
Qed.

(** helper: refinement is transitive **)
Theorem refines_cover_tra : forall A B C:set,
  refines_cover C B -> refines_cover B A -> refines_cover C A.
admit.
Qed.

(** helper: equality substitution for membership **)
Theorem eq_subst_mem : forall x y S:set, x = y -> y :e S -> x :e S.
admit.
Qed.

(** helper: equality substitution for membership (reverse direction) **)
Theorem eq_subst_mem_rev : forall x y S:set, x = y -> x :e S -> y :e S.
admit.
Qed.

(** helper: choose an ambient open set whose intersection is a given subspace-open set **)
Definition ambient_open_of_subspace_open : set -> set -> set -> set -> set :=
  fun X Tx Y U => Eps_i (fun V:set => V :e Tx /\ U = V :/\: Y).

(** helper: specification of ambient_open_of_subspace_open **)
Theorem ambient_open_of_subspace_open_spec : forall X Tx Y U:set,
  U :e subspace_topology X Tx Y ->
  (ambient_open_of_subspace_open X Tx Y U) :e Tx /\
  U = (ambient_open_of_subspace_open X Tx Y U) :/\: Y.
admit.
Qed.

(** from 50 Definition: covering dimension **)
(** LATEX VERSION: dim(X)  n means every open cover has an open refinement of order at most n+1. **)
Definition covering_dimension : set -> set -> set -> prop := fun X Tx n =>
  topology_on X Tx /\ n :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B n.

(** helper: projections from covering_dimension package **)
Theorem covering_dimension_topology_on : forall X Tx n:set,
  covering_dimension X Tx n -> topology_on X Tx.
admit.
Qed.
Theorem covering_dimension_n_in_omega : forall X Tx n:set,
  covering_dimension X Tx n -> n :e omega.
admit.
Qed.

(** helper: covering_dimension introduction **)
Theorem covering_dimensionI : forall X Tx n:set,
  topology_on X Tx ->
  n :e omega ->
  (forall A:set, open_cover_of X Tx A ->
    exists B:set,
      open_cover_of X Tx B /\
      refines_cover B A /\
      collection_has_order_at_most_m_plus_one X B n) ->
  covering_dimension X Tx n.
admit.
Qed.
(** LATEX VERSION: X is finite dimensional if dim(X)  m for some m. **)
Definition finite_dimensional_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists m:set, m :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B m.

(** helper: finite_dimensional_space introduction **)
Theorem finite_dimensional_spaceI : forall X Tx:set,
  topology_on X Tx ->
  (exists m:set, m :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B m) ->
  finite_dimensional_space X Tx.
admit.
Qed.

(** helper: projections from finite_dimensional_space package **)
Theorem finite_dimensional_space_topology_on : forall X Tx:set,
  finite_dimensional_space X Tx -> topology_on X Tx.
admit.
Qed.
Theorem finite_dimensional_space_exists_bound : forall X Tx:set,
  finite_dimensional_space X Tx ->
  exists m:set, m :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B m.
admit.
Qed.

(** helper: covering_dimension implies finite_dimensional_space (existentially) **)
(** LATEX VERSION: If dim(X)  n for some n, then X is finite dimensional. **)
Theorem covering_dimension_implies_finite_dimensional_space : forall X Tx n:set,
  covering_dimension X Tx n -> finite_dimensional_space X Tx.
admit.
Qed.

(** helper: finite_dimensional_space yields some covering_dimension bound **)
(** LATEX VERSION: Finite dimensional means dim(X)  m for some m. **)
Theorem finite_dimensional_space_implies_exists_covering_dimension : forall X Tx:set,
  finite_dimensional_space X Tx ->
  exists m:set, covering_dimension X Tx m.
admit.
Qed.

(** helper for 50: Euclidean space has covering dimension  N **)
(** LATEX VERSION: dim(R^N) = N (in particular, dim(R^N)  N). **)
(** NOTE: Keep as an admitted theorem for now. **)
Theorem euclidean_space_covering_dimension_le : forall N:set,
  N :e omega ->
  covering_dimension (euclidean_space N) (euclidean_topology N) N.
admit.
Qed.

(** from 50 Theorem: compact m-manifold has dimension at most m **) 
(** LATEX VERSION: Compact m-manifold has covering dimension  m. **)
(** NOTE: Same status as above: admitted theorem for now (no new axioms). **)
Theorem compact_manifold_dimension_le : forall X Tx m:set,
  m_manifold X Tx m -> compact_space X Tx -> covering_dimension X Tx m.
admit.
Qed.

(** from 50 Theorem (Menger-Nbeling): compact metrizable space of dimension m embeds in R^{2m+1} **) 
(** LATEX VERSION: MengerNbeling embedding theorem (placeholder). **)
(** NOTE: This is a major theorem; keep it as an admitted theorem for now (no new axioms). **)
Theorem Menger_Nobeling_embedding : forall X Tx m:set,
  compact_space X Tx -> metrizable X Tx -> covering_dimension X Tx m ->
  exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Theorem 50.1: dimension of closed subspace bounded by ambient **) 
(** LATEX VERSION: Dimension of a closed subspace does not exceed that of the ambient space. **)
(** STATUS: Implemented and proved below as `dimension_closed_subspace_le`. **)
(** helper: cardinality_at_most is monotone under subset **)
(** LATEX VERSION: If S1  S2 and |S2|  n then |S1|  n. **)
Theorem cardinality_at_most_mono_subset : forall S1 S2 n:set,
  n :e omega ->
  S1 c= S2 ->
  cardinality_at_most S2 n ->
  cardinality_at_most S1 n.
admit.
Qed.

(** helper: order-at-most is preserved when restricting a family to a subspace by intersections **)
(** LATEX VERSION: If a family has order at most n+1 in X, then the restricted family {UY} has order at most n+1 in Y. **)
(** helper: finite cardinality bound is preserved under intersection-image **)
(** LATEX VERSION: For finite n, the image {UY | UFam} has cardinality  n whenever Fam has cardinality  n. **)
Theorem cardinality_at_most_restrict_family_to_subspace_finite : forall Fam Y n:set,
  n :e omega ->
  cardinality_at_most Fam (ordsucc n) ->
  cardinality_at_most (restrict_family_to_subspace Fam Y) (ordsucc n).
admit.
Qed.
Theorem collection_has_order_at_most_m_plus_one_restrict_to_subspace : forall X Y Fam n:set,
  n :e omega ->
  Y c= X ->
  collection_has_order_at_most_m_plus_one X Fam n ->
  collection_has_order_at_most_m_plus_one Y (restrict_family_to_subspace Fam Y) n.
admit.
Qed.
(** helper: order-at-most is monotone in the family argument **)
(** LATEX VERSION: If Fam1 is a subfamily of Fam2, then order_at_most(Fam2) implies order_at_most(Fam1). **)
Theorem collection_has_order_at_most_m_plus_one_mono_family : forall X Fam1 Fam2 n:set,
  n :e omega ->
  Fam1 c= Fam2 ->
  collection_has_order_at_most_m_plus_one X Fam2 n ->
  collection_has_order_at_most_m_plus_one X Fam1 n.
admit.
Qed.
Theorem dimension_closed_subspace_le : forall X Tx Y n:set,
  covering_dimension X Tx n -> closed_in X Tx Y ->
  covering_dimension Y (subspace_topology X Tx Y) n.
admit.
Qed.

(** from 50 Theorem 50.2: dimension of union of closed sets is max **)
(** LATEX VERSION: If X = Y  Z where Y,Z are closed in X, then dim(X)  max(dim(Y),dim(Z)) (and in fact equality holds for finite-dimensional spaces). **)
(** NOTE: Major theorem; keep it as an admitted theorem for now (no new axioms). **)
Theorem dimension_union_closed_max : forall X Tx Y Z n:set,
  topology_on X Tx ->
  Y c= X -> Z c= X ->
  closed_in X Tx Y -> closed_in X Tx Z ->
  covering_dimension Y (subspace_topology X Tx Y) n ->
  covering_dimension Z (subspace_topology X Tx Z) n ->
  covering_dimension (Y :\/: Z) (subspace_topology X Tx (Y :\/: Z)) n.
admit.
Qed.

(** from 50 Corollary 50.3: finite union of closed finite-dimensional sets **)
(** LATEX VERSION: If X is a finite union of closed subspaces each of dimension  n, then X has dimension  n. **)
(** NOTE: Major theorem; keep it as an admitted theorem for now (no new axioms). **)
Theorem dimension_finite_union_closed_max : forall X Tx Fam n:set,
  topology_on X Tx ->
  n :e omega ->
  finite Fam ->
  (forall Y:set, Y :e Fam -> Y c= X /\ closed_in X Tx Y /\ covering_dimension Y (subspace_topology X Tx Y) n) ->
  covering_dimension (Union Fam) (subspace_topology X Tx (Union Fam)) n.
admit.
Qed.

(** from 50 Example 4: compact 1-manifold has dimension 1 **)
(** LATEX VERSION: Every compact 1-manifold X has topological dimension 1. **)
Theorem compact_1_manifold_dimension_1 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx (Sing Empty) -> covering_dimension X Tx (Sing Empty).
admit.
Qed.

(** from 50 Example 5: compact 2-manifold has dimension at most 2 **)
(** LATEX VERSION: Every compact 2-manifold X has topological dimension at most 2. **)
(** NOTE: Use the numeral 2 (von Neumann ordinal) consistently with earlier uses such as two_by_nat := setprod 2 omega. **)
Definition two : set := 2.
Theorem compact_2_manifold_dimension_le_2 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx two -> covering_dimension X Tx two.
admit.
Qed.

(** from 50 Example 6: arcs and linear graphs **)
(** LATEX VERSION: An arc is a space homeomorphic to [0,1]; a linear graph is a finite union of arcs meeting at most at common endpoints. **)
Definition arc : set -> set -> prop := fun X Tx =>
  exists f:set, homeomorphism unit_interval unit_interval_topology X Tx f.

(** Helper: arc is a topological space **)
Theorem arc_is_topological_space : forall X Tx:set,
  arc X Tx -> topology_on X Tx.
admit.
Qed.

(** from 50 Example 6: end points of an arc **)
(** LATEX VERSION: The end points of an arc A are points p,q such that A-{p} and A-{q} are connected. **)
Definition end_points_of_arc : set -> set -> set -> set -> prop := fun X Tx p q =>
  arc X Tx /\
  p :e X /\ q :e X /\
  p <> q /\
  connected_space (X :\: (Sing p)) (subspace_topology X Tx (X :\: (Sing p))) /\
  connected_space (X :\: (Sing q)) (subspace_topology X Tx (X :\: (Sing q))).

(** from 50 Example 6: finite linear graph **)
(** LATEX VERSION: A finite linear graph G is Hausdorff and is the union of finitely many arcs; any two arcs meet in at most a common end point. **)
Definition linear_graph : set -> set -> prop := fun G Tg =>
  Hausdorff_space G Tg /\
  exists Arcs:set,
    finite Arcs /\
    (forall A:set, A :e Arcs ->
      A c= G /\ arc A (subspace_topology G Tg A)) /\
    G = Union Arcs /\
    (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
      exists p:set, (A :/\: B = Empty \/ A :/\: B = Sing p)).

(** from 50 Example 6: linear graphs have dimension 1 **)
(** LATEX VERSION: A linear graph G has topological dimension 1. **)
(** NOTE: Keep it as an admitted theorem for now (no new axioms). **)
Theorem linear_graph_dimension_1 : forall G Tg:set,
  linear_graph G Tg -> covering_dimension G Tg (Sing Empty).
admit.
Qed.

(** from 50 Example 7: general position in R^3 (preliminary) **)
(** LATEX VERSION: In R^3, points are in general position if no three are collinear and no four are coplanar. **)
(** helper: coordinate selectors on points in euclidean_space 3 **)
Definition R3_xcoord : set -> set := fun p => p 0.
Definition R3_ycoord : set -> set := fun p => p 1.
Definition R3_zcoord : set -> set := fun p => p 2.

(** helper: differences of coordinates **)
(** from 50 Example 7: coordinate differences in R^3 **)
(** LATEX VERSION: Use differences of coordinates to form determinants testing collinearity and coplanarity. **)
Definition R3_dx : set -> set -> set := fun p q =>
  add_SNo (R3_xcoord q) (minus_SNo (R3_xcoord p)).
(** from 50 Example 7: coordinate differences in R^3 **)
(** LATEX VERSION: Use differences of coordinates to form determinants testing collinearity and coplanarity. **)
Definition R3_dy : set -> set -> set := fun p q =>
  add_SNo (R3_ycoord q) (minus_SNo (R3_ycoord p)).
(** from 50 Example 7: coordinate differences in R^3 **)
(** LATEX VERSION: Use differences of coordinates to form determinants testing collinearity and coplanarity. **)
Definition R3_dz : set -> set -> set := fun p q =>
  add_SNo (R3_zcoord q) (minus_SNo (R3_zcoord p)).

(** helper: 2 by 2 determinant a d minus b c **)
(** from 50 Example 7: determinant criteria for collinearity/coplanarity **)
(** LATEX VERSION: Determinants of coordinate differences vanish when points are collinear or coplanar. **)
Definition det2_SNo : set -> set -> set -> set -> set := fun a b c d =>
  add_SNo (mul_SNo a d) (minus_SNo (mul_SNo b c)).

(** helper: 3 by 3 determinant for rows (a1,a2,a3), (b1,b2,b3), (c1,c2,c3) **)
(** from 50 Example 7: determinant criteria for collinearity/coplanarity **)
(** LATEX VERSION: Determinants of coordinate differences vanish when points are collinear or coplanar. **)
Definition det3_SNo : set -> set -> set -> set -> set -> set -> set -> set -> set -> set :=
  fun a1 a2 a3 b1 b2 b3 c1 c2 c3 =>
    add_SNo
      (mul_SNo a1 (det2_SNo b2 b3 c2 c3))
      (add_SNo
        (minus_SNo (mul_SNo a2 (det2_SNo b1 b3 c1 c3)))
        (mul_SNo a3 (det2_SNo b1 b2 c1 c2))).

(** from 50 Example 7: definition of collinearity in R^3 **)
(** LATEX VERSION: No three of the points are collinear. **)
Definition collinear_in_R3 : set -> set -> set -> prop := fun p q r =>
  p :e (euclidean_space 3) /\ q :e (euclidean_space 3) /\ r :e (euclidean_space 3) /\
  det2_SNo (R3_dx p q) (R3_dy p q) (R3_dx p r) (R3_dy p r) = 0 /\
  det2_SNo (R3_dx p q) (R3_dz p q) (R3_dx p r) (R3_dz p r) = 0 /\
  det2_SNo (R3_dy p q) (R3_dz p q) (R3_dy p r) (R3_dz p r) = 0.

(** from 50 Example 7: definition of coplanarity in R^3 **)
(** LATEX VERSION: No four of the points are coplanar. **)
Definition coplanar_in_R3 : set -> set -> set -> set -> prop := fun p q r s =>
  p :e (euclidean_space 3) /\ q :e (euclidean_space 3) /\ r :e (euclidean_space 3) /\ s :e (euclidean_space 3) /\
  det3_SNo
    (R3_dx p q) (R3_dy p q) (R3_dz p q)
    (R3_dx p r) (R3_dy p r) (R3_dz p r)
    (R3_dx p s) (R3_dy p s) (R3_dz p s) = 0.

(** from 50: geometrically independent (affinely independent) points in R^N **)
(** LATEX VERSION: Points {x,...,x} in R^N are geometrically independent if ax=0 and a=0 imply all a=0. **)
(** stub: actual condition needs vector space operations on R^N; we only record that S lies in some euclidean_space N **)
Definition geometrically_independent : set -> prop := fun S =>
  exists N:set, N :e omega /\ S c= euclidean_space N.

(** from 50: plane determined by geometrically independent points **)
(** LATEX VERSION: The plane P determined by geometrically independent points {x,...,x} is the set of all x = tx where t=1. **)
(** stub: needs proper formulation of affine combination in euclidean_space N **)
Definition affine_plane : set -> set := fun S =>
  Eps_i (fun P:set =>
    exists N:set, N :e omega /\ S c= euclidean_space N /\ P c= euclidean_space N).

(** from 50: k-plane in R^N **)
(** LATEX VERSION: A k-plane in R^N is the affine plane determined by k+1 geometrically independent points. **)
Definition k_plane : set -> set -> prop := fun k P =>
  k :e omega /\
  exists S:set,
    geometrically_independent S /\
    finite S /\
    (exists kp1:set, kp1 = k :\/: (Sing k) /\ equip S kp1) /\
    P = affine_plane S.

(** from 50: general position in R^N **)
(** LATEX VERSION: A set A in R^N is in general position if every subset with N+1 points is geometrically independent. **)
Definition general_position_RN : set -> set -> prop := fun N A =>
  N :e omega /\
  A c= euclidean_space N /\
  forall S:set, S c= A ->
    (forall Np1:set, Np1 = N :\/: (Sing N) ->
      (exists f:set -> set, inj S Np1 f) -> geometrically_independent S).

(** from 50 Lemma 50.4: approximation in general position **)
(** LATEX VERSION: Given finite {x,...,x} in R^N and >0, there exists {y,...,y} in general position with |x-y|< for all i. **)
(** stub: proper ordering and metric conditions need to be formulated **)
(** NOTE: Keep it as an admitted theorem for now (no new axioms). **)
Theorem finite_set_approximation_general_position : forall N:set, forall pts:set, forall delta:set,
  N :e omega ->
  finite pts ->
  pts c= euclidean_space N ->
  delta :e R ->
  exists pts':set,
    general_position_RN N pts' /\
    finite pts' /\
    equip pts pts'.
admit.
Qed.

(** from 50 Theorem 50.5: Menger-Nbeling embedding theorem **)
(** LATEX VERSION: Every compact metrizable space X of topological dimension m can be embedded in R^{2m+1}. **)
(** FIXED: Dimension parameter uses N = add_nat (mul_nat two m) (Sing Empty) to represent 2m+1, not m+1. **) 
(** NOTE: Major theorem; keep it as an admitted theorem for now (no new axioms). **)
Theorem Menger_Nobeling_embedding_full : forall X Tx m:set,
  compact_space X Tx ->
  metrizable X Tx ->
  covering_dimension X Tx m ->
  m :e omega ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Theorem: compact subspace of R^n has dimension at most n **) 
(** LATEX VERSION: Compact subspace of ^n has covering dimension  n. **)
(** NOTE: This is a major dimension theorem; for now it is reduced to the admitted ambient bound `euclidean_space_covering_dimension_le`. **)
Theorem compact_subspace_Rn_dimension_le : forall N X:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Theorem 50.6: compact subspace of R^N has dimension at most N **)
(** LATEX VERSION: Every compact subspace of R^N has topological dimension at most N. **)
Theorem compact_subspace_RN_dimension_le_N : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Corollary 50.7: compact m-manifold has dimension at most m **)
(** LATEX VERSION: Every compact m-manifold has topological dimension at most m. **)
Theorem compact_m_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx m ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Corollary 50.8: compact m-manifold embeds in R^{2m+1} **)
(** LATEX VERSION: Every compact m-manifold can be embedded in R^{2m+1}. **)
(** FIXED: Same correction as above: N = add_nat (mul_nat two m) (Sing Empty) represents 2m+1. **) 
Theorem compact_m_manifold_embeds_R2mp1 : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx m ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 36 Theorem: compact manifold embeds in Euclidean space **) 
(** LATEX VERSION: Any compact manifold embeds in some Euclidean space. **)
(** NOTE: This is a corollary of 50 Corollary 50.8 in this development. **)
Theorem compact_manifold_embeds_in_Euclidean : forall X Tx:set,
  forall m:set, m_manifold X Tx m -> compact_space X Tx ->
    exists N:set, exists e:set,
      N :e omega /\ N <> Empty /\
      embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Corollary 50.9: compact metrizable embeds in R^N iff finite dimensional **)
(** LATEX VERSION: A compact metrizable space X can be embedded in R^N for some N iff X has finite topological dimension. **)
Theorem compact_metrizable_embeds_iff_finite_dim : forall X Tx:set,
  compact_space X Tx ->
  metrizable X Tx ->
  ((exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e)
  <->
  finite_dimensional_space X Tx).
admit.
Qed.

(** from Supplementary Exercises: locally m-euclidean space **)
(** LATEX VERSION: A space X is locally m-euclidean if each point has a neighborhood homeomorphic to an open set of R^m. **)
Definition locally_m_euclidean : set -> set -> set -> prop := fun X Tx m =>
  m :e omega /\
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists U:set, exists V:set, exists f:set,
      open_in X Tx U /\
      x :e U /\
      V c= (euclidean_space m) /\
      open_in (euclidean_space m) (euclidean_topology m) V /\
      homeomorphism U (subspace_topology X Tx U) V (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.

(** from Supplementary Exercises: Locally Euclidean Spaces: locally m-euclidean implies T1 **)
(** LATEX VERSION: Such a space X automatically satisfies the T1 axiom. **)
Theorem euclidean_space_Hausdorff : forall m:set,
  Hausdorff_space (euclidean_space m) (euclidean_topology m).
admit.
Qed.

(** helper: Euclidean spaces are regular **)
(** LATEX VERSION: For any m, R^m with the product topology is regular. **)
Theorem euclidean_space_regular : forall m:set,
  regular_space (euclidean_space m) (euclidean_topology m).
admit.
Qed.

(** helper: Euclidean spaces are completely regular **)
(** LATEX VERSION: For any m, R^m with the product topology is completely regular. **)
Theorem euclidean_space_completely_regular : forall m:set,
  completely_regular_space (euclidean_space m) (euclidean_topology m).
admit.
Qed.

(** helper: Euclidean spaces are metrizable **)
(** LATEX VERSION: For n in omega, R^n is metrizable (regular + second countable  metrizable). **)
Theorem euclidean_space_metrizable : forall n:set,
  n :e omega ->
  metrizable (euclidean_space n) (euclidean_topology n).
admit.
Qed.

(** helper: m-manifold implies locally m-euclidean **)
(** LATEX VERSION: Every m-manifold is locally m-euclidean. **)
Theorem m_manifold_implies_locally_m_euclidean : forall X Tx m:set,
  m_manifold X Tx m -> locally_m_euclidean X Tx m.
admit.
Qed.

(** helper: Euclidean spaces are T1 **)
(** LATEX VERSION: Euclidean spaces satisfy the T1 axiom (finite sets are closed). **)
Theorem euclidean_space_T1 : forall m:set,
  T1_space (euclidean_space m) (euclidean_topology m).
admit.
Qed.
Theorem locally_m_euclidean_implies_T1 : forall X Tx m:set,
  locally_m_euclidean X Tx m -> T1_space X Tx.
admit.
Qed.

(** from 50 Exercise 1: discrete space has dimension 0 **)
(** LATEX VERSION: Every discrete space has topological dimension 0. **)
Theorem ex50_1_discrete_dimension_0 : forall X Tx:set,
  Tx = discrete_topology X ->
  topology_on X Tx ->
  covering_dimension X Tx Empty.
admit.
Qed.

(** from 50 Exercise 2: connected T1 space with >1 point has dimension 1 **)
(** LATEX VERSION: Any connected T space with more than one point has dimension at least 1. **)
Theorem ex50_2_connected_T1_dimension_ge_1 : forall X Tx:set,
  connected_space X Tx ->
  T1_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  covering_dimension X Tx Empty -> False.
admit.
Qed.

(** from 50 Exercise 3: topologist's sine curve has dimension 1 **)
(** LATEX VERSION: The topologist's sine curve has topological dimension 1. **)
(** from 50 Exercise 3: the topologist sine curve **)
(** LATEX VERSION: The topologist sine curve is a specific subspace of R2; we name it abstractly here. **)
(** stub: the actual geometric definition is not expanded in this file **)
Definition topologists_sine_curve : set := Eps_i (fun S:set => S c= EuclidPlane).
(** helper: topologist's sine curve lies in EuclidPlane **)
(** LATEX VERSION: By construction, the sine-curve subset is a subset of R^2. **)
Theorem topologists_sine_curve_subset_EuclidPlane : topologists_sine_curve c= EuclidPlane.
admit.
Qed.
(** from 24 Example 7: topologist's sine curve (subspace topology) **)
(** LATEX VERSION: The topologist's sine curve is the closure of {(x,sin(1/x)) | 0<x<=1} in R^2, i.e. that set together with the vertical interval 0[-1,1]. **)
Definition topologists_sine_curve_topology : set :=
  subspace_topology EuclidPlane R2_standard_topology topologists_sine_curve.
(** helper: EuclidPlane with standard product topology is a topology **)
(** LATEX VERSION: The product of two topological spaces is a topological space. **)
Theorem EuclidPlane_R2_standard_topology_on : topology_on EuclidPlane R2_standard_topology.
admit.
Qed.
(** helper: subspace topology on the sine curve is a topology **)
(** LATEX VERSION: Any subspace of a topological space is a topological space in the subspace topology. **)
Theorem topologists_sine_curve_topology_on :
  topology_on topologists_sine_curve topologists_sine_curve_topology.
admit.
Qed.
Theorem ex50_3_sine_curve_dimension_1 :
  covering_dimension topologists_sine_curve topologists_sine_curve_topology (Sing Empty).
admit.
Qed.

(** from 50 Exercise 4: specific points in general position in R **)
(** LATEX VERSION: Show that 0, , , , and (1,1,1) are in general position in R. **)
(** FIXED: Use explicit coordinate functions in the product description of euclidean_space 3. **)

(** helper: 2 is an element of 3 **)
Theorem In_2_3 : 2 :e 3.
admit.
Qed.

(** helper: all reals lie in the space-family union for R **)
Theorem real_in_space_family_union_R3 : forall y:set,
  y :e R ->
  y :e space_family_union 3 (const_space_family 3 R R_standard_topology).
admit.
Qed.

(** helper: each component set in the constant family is R **)
Theorem space_family_set_const_R3 : forall i:set,
  i :e 3 ->
  space_family_set (const_space_family 3 R R_standard_topology) i = R.
admit.
Qed.

(** helper: a coordinate function into R yields a point of euclidean_space 3 **)
Theorem graph3_in_euclidean_space3 : forall g:set->set,
  (forall i:set, g i :e R) ->
  graph 3 g :e euclidean_space 3.
admit.
Qed.

(** explicit points in R as coordinate functions **)
(** from 50 Exercise 4: specific points in general position in R **)
(** LATEX VERSION: Show that 0, e1, e2, e3, and (1,1,1) are in general position in R^3. **)
Definition ex50_R3_zero : set := graph 3 (fun _ : set => 0).
Definition ex50_R3_ones : set := graph 3 (fun _ : set => 1).
Definition ex50_R3_e1 : set := graph 3 (fun i:set => if i = 0 then 1 else 0).
Definition ex50_R3_e2 : set := graph 3 (fun i:set => if i = 1 then 1 else 0).
Definition ex50_R3_e3 : set := graph 3 (fun i:set => if i = 2 then 1 else 0).

(** membership facts for these points **)
Theorem ex50_R3_zero_in : ex50_R3_zero :e euclidean_space 3.
admit.
Qed.
Theorem ex50_R3_ones_in : ex50_R3_ones :e euclidean_space 3.
admit.
Qed.
Theorem ex50_R3_e1_in : ex50_R3_e1 :e euclidean_space 3.
admit.
Qed.
Theorem ex50_R3_e2_in : ex50_R3_e2 :e euclidean_space 3.
admit.
Qed.
Theorem ex50_R3_e3_in : ex50_R3_e3 :e euclidean_space 3.
admit.
Qed.
Theorem ex50_4_points_general_position_R3 :
  general_position_RN 3 {ex50_R3_zero, ex50_R3_e1, ex50_R3_e2, ex50_R3_e3, ex50_R3_ones}.
admit.
Qed.

(** from 50 Exercise 5: embedding theorem for m=1 maps to linear graph **)
(** LATEX VERSION: For m=1, the map g in the embedding theorem proof maps X onto a linear graph in R. **)
Theorem ex50_5_embedding_m1_linear_graph : forall X Tx:set,
  covering_dimension X Tx (Sing Empty) ->
  compact_space X Tx ->
  metrizable X Tx ->
  exists g:set,
    (forall x:set, x :e X -> apply_fun g x :e (euclidean_space 3)) /\
    linear_graph (apply_fun g X) R_standard_topology.
admit.
Qed.

(** from 50 Exercise 6: locally compact Hausdorff with countable basis embeds in R^{2m+1} **)
(** LATEX VERSION: A locally compact Hausdorff space with countable basis whose compact subspaces have dimension m is homeomorphic to a closed subspace of R^{2m+1}. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_6_locally_compact_embeds : forall X Tx m:set,
  m :e omega ->
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  second_countable_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit.
Qed.

(** from 50 Exercise 7: every m-manifold embeds in R^{2m+1} as closed subspace **)
(** LATEX VERSION: Every m-manifold can be embedded in R^{2m+1} as a closed subspace. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_7_manifold_closed_embedding : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx m ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit.
Qed.

(** from 50 Exercise 8: sigma-compact Hausdorff with compact subspaces of dimension m has dimension m **)
(** LATEX VERSION: A -compact Hausdorff space whose compact subspaces have dimension m has dimension m. **)
(** FIXED: sigma_compact uses X = Union Fam, not a filtered union; sigma-compact means a countable union of compact subspaces. **) 
Definition sigma_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fam:set,
    countable Fam /\
    (forall C:set, C :e Fam -> C c= X /\ compact_space C (subspace_topology X Tx C)) /\
    X = Union Fam.
Theorem ex50_8_sigma_compact_dimension : forall X Tx m:set,
  m :e omega ->
  sigma_compact X Tx ->
  Hausdorff_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Exercise 9: every m-manifold has dimension m **)
(** LATEX VERSION: Every m-manifold has topological dimension at most m. **)
Theorem ex50_9_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx m ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Exercise 10: closed subspace of R^N has dimension N **)
(** LATEX VERSION: Every closed subspace of R^N has topological dimension at most N. **)
Theorem ex50_10_closed_subspace_RN_dimension : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  closed_in (euclidean_space N) (euclidean_topology N) X ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Exercise 11: embedding in R^N characterization **)
(** LATEX VERSION: A space X can be embedded as a closed subspace of R^N for some N iff X is locally compact Hausdorff with countable basis and finite dimension. **)
Theorem ex50_11_embedding_characterization : forall X Tx:set,
  (exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X))
<->
(locally_compact X Tx /\ Hausdorff_space X Tx /\ second_countable_space X Tx /\ finite_dimensional_space X Tx).
admit.
Qed.

(** from Supplementary Exercises Exercise 1: locally m-euclidean implies locally compact and locally metrizable **)
(** LATEX VERSION: If X is locally m-euclidean, then X is locally compact and locally metrizable. **)
(** helper: metrizability is preserved under homeomorphism **)
(** LATEX VERSION: If X and Y are homeomorphic and Y is metrizable, then X is metrizable. **)
Theorem homeomorphism_preserves_metrizable : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  metrizable Y Ty ->
  metrizable X Tx.
admit.
Qed.

(** helper: second countability is preserved under homeomorphism **)
(** LATEX VERSION: If X and Y are homeomorphic and Y is second countable, then X is second countable. **)
Theorem homeomorphism_preserves_second_countable : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  second_countable_space Y Ty ->
  second_countable_space X Tx.
admit.
Qed.
(** helper: local metrizability **)
(** LATEX VERSION: A space is locally metrizable if each point has a neighborhood whose subspace topology is induced by some metric. **)
Definition locally_metrizable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists d:set, metric_on N d /\ subspace_topology X Tx N = metric_topology N d.

(** helper: chart neighborhoods with compact closure **)
(** LATEX VERSION: In a locally m-euclidean space, one can shrink a chart neighborhood so that its closure is compact. **)
(** SUSPICIOUS THEOREM: This requires a nontrivial Euclidean local compactness fact (existence of open neighborhoods with compact closure inside an open subset of R^m). **)
(** NOTE: A sufficient Euclidean lemma is: for m:omega, V open in euclidean_space m and y:e V,
    there exists W open in euclidean_space m with y:e W and closure_of (euclidean_space m) (euclidean_topology m) W c= V,
    and compact_space (closure_of (euclidean_space m) (euclidean_topology m) W) with the induced subspace topology. **)
(** helper: closure of a compact set in Hausdorff is compact **)
(** LATEX VERSION: In a Hausdorff space, compact subspaces are closed, hence their closure equals themselves and is compact. **)
Theorem closure_of_compact_subspace_compact : forall X Tx A:set,
  Hausdorff_space X Tx ->
  A c= X ->
  compact_space A (subspace_topology X Tx A) ->
  compact_space (closure_of X Tx A) (subspace_topology X Tx (closure_of X Tx A)).
admit.
Qed.

(** helper: if cl(B) is compact then cl(A) is compact for A c= B **)
(** LATEX VERSION: If A c= B then cl(A) c= cl(B); hence compactness of cl(B) implies compactness of cl(A). **)
Theorem compact_closure_monotone : forall X Tx A B:set,
  topology_on X Tx ->
  A c= B ->
  B c= X ->
  compact_space (closure_of X Tx B) (subspace_topology X Tx (closure_of X Tx B)) ->
  compact_space (closure_of X Tx A) (subspace_topology X Tx (closure_of X Tx A)).
admit.
Qed.

(** helper: open sets in R contain neighborhoods with compact closure **)
(** LATEX VERSION: If U is open in the standard topology on R and x in U, then there exists open W with x in W, cl(W) c= U, and cl(W) is compact. **)
Theorem R_standard_open_has_compact_closure_neighborhood : forall U x:set,
  U :e R_standard_topology ->
  x :e U ->
  exists W:set,
    W :e R_standard_topology /\ x :e W /\
    closure_of R R_standard_topology W c= U /\
    compact_space (closure_of R R_standard_topology W)
      (subspace_topology R R_standard_topology (closure_of R R_standard_topology W)).
admit.
Qed.

(** helper: standard topology on R is locally compact **)
(** LATEX VERSION: R with the standard topology is locally compact. **)
Theorem R_standard_topology_locally_compact : locally_compact R R_standard_topology.
admit.
Qed.

(** helper: locally compact and regular gives compact-closure refinements inside opens **)
(** LATEX VERSION: In a locally compact regular space, each point in an open set has an open neighborhood with compact closure contained in that open set. **)
Theorem locally_compact_regular_open_has_compact_closure_neighborhood : forall X Tx U x:set,
  locally_compact X Tx ->
  regular_space X Tx ->
  U :e Tx ->
  x :e U ->
  exists W:set,
    W :e Tx /\ x :e W /\
    closure_of X Tx W c= U /\
    compact_space (closure_of X Tx W) (subspace_topology X Tx (closure_of X Tx W)).
admit.
Qed.

(** helper: Euclidean open sets contain neighborhoods with compact closure **)
Theorem euclidean_open_has_closure_sub_neighborhood : forall m V y:set,
  m :e omega ->
  V c= (euclidean_space m) ->
  open_in (euclidean_space m) (euclidean_topology m) V ->
  y :e V ->
  exists W:set, W :e (euclidean_topology m) /\ y :e W /\
    closure_of (euclidean_space m) (euclidean_topology m) W c= V.
admit.
Qed.

(** helper: Euclidean neighborhoods with compact closure **)
(** LATEX VERSION: R^m is locally compact for finite m. **)
Theorem euclidean_space_open_has_compact_closure_neighborhood_global : forall m:set,
  m :e omega ->
  topology_on (euclidean_space m) (euclidean_topology m) /\
    forall x:set, x :e (euclidean_space m) ->
      exists U:set, U :e (euclidean_topology m) /\ x :e U /\
        compact_space (closure_of (euclidean_space m) (euclidean_topology m) U)
          (subspace_topology (euclidean_space m) (euclidean_topology m)
            (closure_of (euclidean_space m) (euclidean_topology m) U)).
admit.
Qed.

(** helper: Euclidean space is locally compact **)
Theorem euclidean_space_locally_compact : forall m:set,
  m :e omega -> locally_compact (euclidean_space m) (euclidean_topology m).
admit.
Qed.
Theorem euclidean_open_has_compact_closure_neighborhood : forall m V y:set,
  m :e omega ->
  V c= (euclidean_space m) ->
  open_in (euclidean_space m) (euclidean_topology m) V ->
  y :e V ->
  exists W:set,
    W :e (euclidean_topology m) /\ y :e W /\
    closure_of (euclidean_space m) (euclidean_topology m) W c= V /\
	    compact_space (closure_of (euclidean_space m) (euclidean_topology m) W)
	      (subspace_topology (euclidean_space m) (euclidean_topology m)
	        (closure_of (euclidean_space m) (euclidean_topology m) W)).
admit.
Qed.
Theorem chart_neighborhood_has_compact_closure : forall X Tx m U V f x:set,
  m :e omega ->
  topology_on X Tx ->
  Hausdorff_space X Tx ->
  open_in X Tx U ->
  x :e U ->
  V c= (euclidean_space m) ->
  open_in (euclidean_space m) (euclidean_topology m) V ->
  homeomorphism U (subspace_topology X Tx U) V
    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f ->
  exists U1:set, U1 :e Tx /\ x :e U1 /\
    compact_space (closure_of X Tx U1) (subspace_topology X Tx (closure_of X Tx U1)).
admit.
Qed.

(** helper: chart neighborhood yields a compact neighborhood package (for locally_compact) **)
(** LATEX VERSION: From a Euclidean chart around x, choose W with compact closure in V; pull back to an open U1 in X contained in a compact set. **)
Theorem chart_neighborhood_has_compact_neighborhood : forall X Tx m U V f x:set,
  m :e omega ->
  topology_on X Tx ->
  open_in X Tx U ->
  x :e U ->
  V c= (euclidean_space m) ->
  open_in (euclidean_space m) (euclidean_topology m) V ->
  homeomorphism U (subspace_topology X Tx U) V
    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f ->
  exists C:set,
    (C c= X /\ compact_space C (subspace_topology X Tx C)) /\
      exists U1:set, U1 :e Tx /\ x :e U1 /\ U1 c= C.
admit.
Qed.

(** helper: locally m euclidean implies locally compact **)
Theorem locally_m_euclidean_implies_locally_compact : forall X Tx m:set,
  locally_m_euclidean X Tx m -> locally_compact X Tx.
admit.
Qed.

(** helper: locally compact Hausdorff implies regular **)
(** LATEX VERSION: A locally compact Hausdorff space is regular. **)
Theorem locally_compact_Hausdorff_regular_early : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  regular_space X Tx.
admit.
Qed.

(** helper: compact + locally m-euclidean implies second countable **)
(** LATEX VERSION: A compact locally m-euclidean space has a countable basis (finite subcover by charts, each chart has countable basis). **)
Theorem compact_locally_m_euclidean_second_countable_early : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  compact_space X Tx ->
  second_countable_space X Tx.
admit.
Qed.
Theorem supp_ex_locally_euclidean_1 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  locally_compact X Tx /\ locally_metrizable_space X Tx.
admit.
Qed.

(** from Supplementary Exercises Exercise 2: implications among conditions **)
(** LATEX VERSION: For locally m-euclidean X: (i) compact Hausdorff  (ii) m-manifold  (iii) metrizable  (iv) normal  (v) Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_i_implies_ii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  compact_space X Tx ->
  Hausdorff_space X Tx ->
  m_manifold X Tx m.
admit.
Qed.
Theorem supp_ex_locally_euclidean_2_ii_implies_iii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  m_manifold X Tx m ->
  metrizable X Tx.
admit.
Qed.
Theorem supp_ex_locally_euclidean_2_iii_implies_iv : forall X Tx:set,
  metrizable X Tx ->
  normal_space X Tx.
admit.
Qed.

(** helper: normal + T1 implies Hausdorff **)
Theorem normal_T1_implies_Hausdorff : forall X Tx:set,
  normal_space X Tx -> T1_space X Tx -> Hausdorff_space X Tx.
admit.
Qed.

(** from Supplementary Exercises Exercise 2: (iv) normal  (v) Hausdorff, for locally m-euclidean X **)
(** LATEX VERSION: For locally m-euclidean X, normality implies Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_iv_implies_v : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  normal_space X Tx ->
  Hausdorff_space X Tx.
admit.
Qed.

(** from Supplementary Exercises Exercise 3: R is locally 1-euclidean satisfies (ii) not (i) **)
(** LATEX VERSION: R is locally 1-euclidean and satisfies (ii) but not (i). **)
Theorem supp_ex_locally_euclidean_3 :
  locally_m_euclidean R R_standard_topology (Sing Empty) /\
  m_manifold R R_standard_topology (Sing Empty) /\
  ~ (compact_space R R_standard_topology /\ Hausdorff_space R R_standard_topology).
admit.
Qed.

(** from Supplementary Exercises Exercise 4: RR dictionary order is locally 1-euclidean satisfies (iii) not (ii) **)
(** LATEX VERSION: RR in dictionary order topology is locally 1-euclidean and satisfies (iii) but not (ii). **)
Theorem supp_ex_locally_euclidean_4 :
  locally_m_euclidean EuclidPlane (order_topology EuclidPlane) (Sing Empty) /\
  metrizable EuclidPlane (order_topology EuclidPlane) /\
  ~ m_manifold EuclidPlane (order_topology EuclidPlane) (Sing Empty).
admit.
Qed.

(** from Supplementary Exercises Exercise 5: long line is locally 1-euclidean satisfies (iv) not (iii) **)
(** LATEX VERSION: The long line is locally 1-euclidean and satisfies (iv) but not (iii). **)
(** from Supplementary Exercises Exercise 5: long line carrier and topology **)
(** LATEX VERSION: The long line and its topology (see exercises of 24). **)
(** note: the long line is not constructed in this file; we name its carrier abstractly but ensure it is infinite **)
Definition long_line : set := Eps_i (fun L:set => infinite L).
Theorem infinite_omega : infinite omega.
admit.
Qed.
Theorem long_line_infinite : infinite long_line.
admit.
Qed.
(** from 24 Theorem/Exercise: topology on the long line **)
(** LATEX VERSION: The long line is the ordered set S_Omega[0,1) in the dictionary order with its smallest element deleted, with the order topology. **)
Definition long_line_topology : set := Eps_i (fun T:set => topology_on long_line T).
Theorem long_line_topology_on : topology_on long_line long_line_topology.
admit.
Qed.
Theorem supp_ex_locally_euclidean_5 :
  locally_m_euclidean long_line long_line_topology (Sing Empty) /\
  normal_space long_line long_line_topology /\
  ~ metrizable long_line long_line_topology.
admit.
Qed.

(** from Supplementary Exercises Exercise 7: Hausdorff iff completely regular **)
(** LATEX VERSION: For locally m-euclidean X: X is Hausdorff iff X is completely regular. **)
Theorem supp_ex_locally_euclidean_7 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (Hausdorff_space X Tx <-> completely_regular_space X Tx).
admit.
Qed.

(** from Supplementary Exercises Exercise 8: metrizable iff paracompact Hausdorff **)
(** LATEX VERSION: For locally m-euclidean X: X is metrizable iff X is paracompact Hausdorff. **)
(** helper: paracompact Hausdorff plus locally metrizable gives a sigma locally finite basis **)
(** LATEX VERSION: For paracompact Hausdorff X that is locally metrizable, there is a -locally-finite basis. **)
Theorem paracompact_Hausdorff_locally_metrizable_sigma_basis : forall X Tx:set,
  paracompact_space X Tx ->
  Hausdorff_space X Tx ->
  locally_metrizable_space X Tx ->
  sigma_locally_finite_basis X Tx.
admit.
Qed.
Theorem supp_ex_locally_euclidean_8 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (metrizable X Tx <-> (paracompact_space X Tx /\ Hausdorff_space X Tx)).
admit.
Qed.

(** from Supplementary Exercises Exercise 9: metrizable implies components are m-manifolds **)
(** LATEX VERSION: If locally m-euclidean X is metrizable, then each component of X is an m-manifold. **)
Theorem supp_ex_locally_euclidean_9 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  metrizable X Tx ->
  forall x:set, x :e X ->
    m_manifold (component_of X Tx x) (subspace_topology X Tx (component_of X Tx x)) m.
admit.
Qed.

(** helper: G_delta subset coded via countable intersection of open sets **)
(** from 30 and 48: G_delta sets **)
(** LATEX VERSION: A G_delta set is a countable intersection of open sets. **)
Definition Gdelta_in : set -> set -> set -> prop := fun X Tx A =>
  exists Fam:set, countable_set Fam /\
    (forall U :e Fam, open_in X Tx U) /\
    intersection_over_family X Fam = A.

(** helper: continuous preimage of a G_delta set is G_delta **)
(** LATEX VERSION: If f:XY is continuous and AY is G_delta, then f^{-1}(A) is G_delta in X. **)
Theorem continuous_preimage_Gdelta : forall X Tx Y Ty f A:set,
  continuous_map X Tx Y Ty f ->
  Gdelta_in Y Ty A ->
  Gdelta_in X Tx (preimage_of X f A).
admit.
Qed.

(** helper: open map - images of open sets are open **)
(** FIXED: open_map uses image_of f U for set images; apply_fun is only for elements. **) 
(** from Supplementary Exercises: topological groups and open maps **)
(** LATEX VERSION: A map is open if it carries open sets to open sets. **)
Definition open_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall U:set, U :e Tx -> image_of f U :e Ty.

(** helper: simple topological group structure **)
(** from Supplementary Exercises: Topological Groups **)
(** LATEX VERSION: A topological group is a group that is T1, such that multiplication GGG and inversion GG are continuous. **)
Definition topological_group : set -> set -> prop := fun G Tg =>
  T1_space G Tg /\
  exists mult inv e:set,
    function_on mult (setprod G G) G /\
    function_on inv G G /\
    e :e G /\
    (forall x y z:set,
      x :e G -> y :e G -> z :e G ->
      apply_fun mult (apply_fun mult (x,y), z) = apply_fun mult (x, apply_fun mult (y,z))) /\
    (forall x:set, x :e G -> apply_fun mult (e,x) = x /\ apply_fun mult (x,e) = x) /\
    (forall x:set, x :e G ->
      apply_fun mult (x, apply_fun inv x) = e /\ apply_fun mult (apply_fun inv x, x) = e) /\
    continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult /\
    continuous_map G Tg G Tg inv.

(** helper: extract T1_space from topological_group **)
Theorem topological_group_T1 : forall G Tg:set, topological_group G Tg -> T1_space G Tg.
admit.
Qed.

(** helper: topological groups are topological spaces **)
Theorem topological_group_is_topology : forall G Tg:set, topological_group G Tg -> topology_on G Tg.
admit.
Qed.

(** helper: separated subsets predicate **)
(** from 31 and 32: separated subsets (complete normality context) **)
(** LATEX VERSION: Two sets A,B are separated if cl(A)B= and Acl(B)=. **)
Definition separated_subsets : set -> set -> set -> set -> prop := fun X Tx A B =>
  A c= X /\ B c= X /\
  closure_of X Tx A :/\: B = Empty /\ A :/\: closure_of X Tx B = Empty.

(** helper: completely normal predicate **)
(** from 32 Definition: completely normal spaces **)
(** LATEX VERSION: X is completely normal if every subspace of X is normal. **)
Definition completely_normal_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  (forall Y:set, Y c= X -> normal_space Y (subspace_topology X Tx Y)).

(** helper: linear continuum predicate (order topology with least upper bound property) **)
(** from 24 Definition: linear continuum **)
(** LATEX VERSION: A simply ordered set with more than one element is a linear continuum if it has the least upper bound property and between any x<y there is z with x<z<y. **)
Definition linear_continuum : set -> set -> prop := fun X Tx =>
  (** FIXED: Use `order_rel X` (the order relation used by `order_topology X`), not an unrelated existential relation. **)
  simply_ordered_set X /\
  Tx = order_topology X /\
  (exists x y:set, x :e X /\ y :e X /\ x <> y) /\
  (forall x y:set, x :e X -> y :e X -> order_rel X x y ->
    exists z:set, z :e X /\ order_rel X x z /\ order_rel X z y) /\
  (forall A:set, A c= X -> A <> Empty ->
    (exists upper:set, upper :e X /\ forall a:set, a :e A -> order_rel X a upper \/ a = upper) ->
    exists lub:set, lub :e X /\
      (forall a:set, a :e A -> order_rel X a lub \/ a = lub) /\
      (forall bound:set, bound :e X ->
        (forall a:set, a :e A -> order_rel X a bound \/ a = bound) ->
        order_rel X lub bound \/ lub = bound)).

(** helper for 24: linear continuum gives simply ordered set **)
(** LATEX VERSION: A linear continuum is, in particular, a simply ordered set. **)
Theorem linear_continuum_simply_ordered : forall X Tx:set,
  linear_continuum X Tx ->
  simply_ordered_set X.
admit.
Qed.

(** helper for 24: linear continuum uses the order topology **)
(** LATEX VERSION: By definition, the topology of a linear continuum is its order topology. **)
Theorem linear_continuum_order_topology_eq : forall X Tx:set,
  linear_continuum X Tx ->
  Tx = order_topology X.
admit.
Qed.

(** helper for 24: linear continuum topology is a topology **)
(** LATEX VERSION: The order topology on a simply ordered set is a topology, hence the topology of a linear continuum is a topology. **)
Theorem linear_continuum_topology_on : forall X Tx:set,
  linear_continuum X Tx ->
  topology_on X Tx.
admit.
Qed.

(** from 24 Theorem 24.1: linear continua are connected **)
(** LATEX VERSION: If L is a linear continuum in the order topology, then L is connected, and so are intervals and rays in L. **)
Theorem thm24_1_linear_continuum_connected : forall X Tx:set,
  linear_continuum X Tx ->
  connected_space X Tx.
admit.
Qed.

(** from 24 Theorem 24.1: intervals in a linear continuum are connected **)
(** LATEX VERSION: If L is a linear continuum, then each (nonempty) open interval (a,b) is connected (in the subspace topology). **)
Theorem thm24_1_linear_continuum_intervals_connected : forall X Tx a b:set,
  linear_continuum X Tx ->
  a :e X ->
  b :e X ->
  order_rel X a b ->
  connected_space (order_interval X a b) (subspace_topology X Tx (order_interval X a b)).
admit.
Qed.

(** from 24 Theorem 24.1: rays in a linear continuum are connected **)
(** LATEX VERSION: If L is a linear continuum, then the rays (a,) and (-,b) are connected (in the subspace topology). **)
Theorem thm24_1_linear_continuum_rays_connected : forall X Tx a b:set,
  linear_continuum X Tx ->
  a :e X ->
  b :e X ->
  connected_space {x :e X | order_rel X a x} (subspace_topology X Tx {x :e X | order_rel X a x}) /\
  connected_space {x :e X | order_rel X x b} (subspace_topology X Tx {x :e X | order_rel X x b}).
admit.
Qed.

(** from 30 Exercise 1a: one-point sets are G_delta in first-countable T1 **)
(** LATEX VERSION: In a first-countable T space, every one-point set is a G_ set. **)
Theorem ex30_1a_onepoint_Gdelta_firstcountable_T1 : forall X Tx x:set,
  first_countable_space X Tx ->
  T1_space X Tx ->
  x :e X ->
  Gdelta_in X Tx (Sing x).
admit.
Qed.

(** from 30 Exercise 1b: space with G_delta points but not first-countable **)
(** LATEX VERSION: There exists a space where every one-point set is G_ but which doesn't satisfy the first countability axiom. **)
Theorem ex30_1b_Gdelta_not_firstcountable_exists :
  exists X:set, exists Tx:set,
    topology_on X Tx /\
    (forall x:set, x :e X -> Gdelta_in X Tx (Sing x)) /\
    ~ first_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 2: every basis contains countable basis when space has one **)
(** LATEX VERSION: If X has a countable basis, then every basis for X contains a countable basis. **)
Theorem ex30_2_basis_contains_countable : forall X Tx:set, forall Basis:set,
  second_countable_space X Tx ->
  basis_generates X Basis Tx ->
  exists CountableSub:set,
    CountableSub c= Basis /\
    countable CountableSub /\
    basis_generates X CountableSub Tx.
admit.
Qed.
(** from 30 Exercise 3: uncountable subset has uncountably many limit points **)
(** LATEX VERSION: If X has countable basis and A is uncountable subset, then uncountably many points of A are limit points. **)
(** FIXED: Use limit_point_of X Tx A x (space, topology, set, point), not a permuted argument order. **) 
Theorem ex30_3_uncountably_many_limit_points : forall X Tx A:set,
  second_countable_space X Tx ->
  A c= X ->
  ~ countable A ->
  ~ countable {x :e A | limit_point_of X Tx A x}.
admit.
Qed.
(** from 30 Exercise 4: compact metrizable implies second countable **)
(** LATEX VERSION: Every compact metrizable space has a countable basis. **)
Theorem ex30_4_compact_metrizable_second_countable : forall X Tx d:set,
  compact_space X Tx ->
  metrizable X Tx ->
  metric_on X d ->
  Tx = metric_topology X d ->
  second_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 5a: metrizable with countable dense has countable basis **)
(** LATEX VERSION: Every metrizable space with a countable dense subset has a countable basis. **)
Theorem ex30_5a_metrizable_countable_dense_second_countable : forall X Tx:set,
  metrizable X Tx ->
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  second_countable_space X Tx.
admit.
Qed.

(** from 30 Exercise 5b: metrizable Lindelof has countable basis **)
(** LATEX VERSION: Every metrizable Lindelf space has a countable basis. **)
Theorem ex30_5b_metrizable_Lindelof_second_countable : forall X Tx:set,
  metrizable X Tx ->
  Lindelof_space X Tx ->
  second_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 6a: R_l not metrizable **)
(** LATEX VERSION: The Sorgenfrey line _ is not metrizable. **)
Theorem ex30_6a_Rl_not_metrizable :
  ~ metrizable R R_lower_limit_topology.
admit.
Qed.

(** from 30 Exercise 6b: ordered square not metrizable **)
(** LATEX VERSION: The ordered square is not metrizable. **)
Theorem ex30_6b_ordered_square_not_metrizable :
  ~ metrizable ordered_square ordered_square_topology.
admit.
Qed.
(** from 30 Exercise 7: countability axioms for S_Omega and Sbar_Omega **)
(** LATEX VERSION: Determine which countability axioms S_ and S_ satisfy. **)
(** Uses the existing SOmega_topology and SbarOmega_topology defined earlier in this section. **)
Theorem ex30_7_SOmega_Sbar_Omega_countability :
  (first_countable_space S_Omega SOmega_topology /\
   second_countable_space S_Omega SOmega_topology /\
   Lindelof_space S_Omega SOmega_topology /\
   (exists D:set, D c= S_Omega /\ countable D /\ dense_in D S_Omega SOmega_topology)) /\
  (first_countable_space Sbar_Omega SbarOmega_topology /\
   ~ second_countable_space Sbar_Omega SbarOmega_topology /\
   ~ Lindelof_space Sbar_Omega SbarOmega_topology /\
   ~ (exists D:set, D c= Sbar_Omega /\ countable D /\ dense_in D Sbar_Omega SbarOmega_topology)).
admit.
Qed.
(** from 30 Exercise 8: countability axioms for R^omega uniform topology **)
(** LATEX VERSION: Determine which countability axioms R^ satisfies in the uniform topology. **)
Theorem ex30_8_Romega_uniform_countability :
  first_countable_space real_sequences uniform_topology /\
  ~ second_countable_space real_sequences uniform_topology /\
  ~ Lindelof_space real_sequences uniform_topology /\
  ~ (exists D:set, D c= real_sequences /\ countable D /\ dense_in D real_sequences uniform_topology).
admit.
Qed.
(** from 30 Exercise 9a: closed subspace of Lindelof is Lindelof **)
(** LATEX VERSION: If A is closed in Lindelf space X, then A is Lindelf. **)
Theorem ex30_9a_closed_Lindelof : forall X Tx A:set,
  Lindelof_space X Tx ->
  closed_in X Tx A ->
  Lindelof_space A (subspace_topology X Tx A).
admit.
Qed.

(** from 30 Exercise 9b: dense subspace need not have countable dense subset **)
(** LATEX VERSION: If X has countable dense subset, dense subspace A need not have one. **)
Theorem ex30_9b_dense_not_countable_dense :
  exists X:set, exists Tx:set, exists A:set,
    (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) /\
    dense_in A X Tx /\
    ~ (exists DA:set, DA c= A /\ countable DA /\ dense_in DA A (subspace_topology X Tx A)).
admit.
Qed.

(** from 30 Exercise 10: countable product has countable dense if factors do **)
(** LATEX VERSION: If X is countable product of spaces with countable dense subsets, then X has one. **)
Theorem ex30_10_product_countable_dense : forall Idx:set, forall Fam:set,
  countable Idx ->
  (forall i:set, i :e Idx ->
    exists Xi:set, exists Txi:set, exists Di:set,
      apply_fun Fam i = (Xi, Txi) /\
      Di c= Xi /\ countable Di /\ dense_in Di Xi Txi) ->
  exists D:set,
    D c= product_space Idx Fam /\
    countable D /\
    dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
admit.
Qed.

(** from 30 Exercise 11a: continuous image of Lindelof is Lindelof **)
(** LATEX VERSION: If f:XY continuous and X Lindelf, then f(X) is Lindelf. **)
(** FIXED: Use image_of f X for the image set; apply_fun is for elements. **) 
Theorem ex30_11a_image_Lindelof : forall X Tx Y Ty f:set,
  Lindelof_space X Tx ->
  continuous_map X Tx Y Ty f ->
  Lindelof_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 11b: continuous image of separable is separable **)
(** LATEX VERSION: If f:XY continuous and X has countable dense subset, then f(X) does too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_11b_image_countable_dense : forall X Tx Y Ty f:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  continuous_map X Tx Y Ty f ->
  exists Df:set,
    Df c= (image_of f X) /\
    countable Df /\
    dense_in Df (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 12a: open continuous map preserves first countability **)
(** LATEX VERSION: If f:XY is continuous open and X first-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12a_open_map_first_countable : forall X Tx Y Ty f:set,
  first_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  first_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 12b: open continuous map preserves second countability **)
(** LATEX VERSION: If f:XY is continuous open and X second-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12b_open_map_second_countable : forall X Tx Y Ty f:set,
  second_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  second_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.
(** from 30 Exercise 13: disjoint open sets countable when dense countable **)
(** LATEX VERSION: If X has countable dense subset, every collection of disjoint open sets in X is countable. **)
Theorem ex30_13_disjoint_open_sets_countable : forall X Tx:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  forall Fam:set,
    (forall U:set, U :e Fam -> open_in X Tx U) ->
    (forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty) ->
    countable Fam.
admit.
Qed.
(** from 30 Exercise 14: product of Lindelof with compact is Lindelof **)
(** LATEX VERSION: If X is Lindelf and Y is compact, then X  Y is Lindelf. **)
Theorem ex30_14_product_Lindelof_compact : forall X Tx Y Ty:set,
  Lindelof_space X Tx ->
  compact_space Y Ty ->
  Lindelof_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.
(** from 30 Exercise 15: C(I,R) uniform topology countable dense subset **)
(** LATEX VERSION: C(I,) with uniform metric has countable dense subset and countable basis. **)
(** stub: this metric is meant to be the sup metric on C(I,R) **)
Definition uniform_metric_C_I_R : set := Eps_i (fun d:set => metric_on C_I_R d).
Definition uniform_topology_C_I_R : set := metric_topology C_I_R uniform_metric_C_I_R.
Theorem ex30_15_CI_has_countable_dense_uniform :
  exists D:set,
    D c= C_I_R /\ countable D /\ dense_in D C_I_R uniform_topology_C_I_R /\
    second_countable_space C_I_R uniform_topology_C_I_R.
admit.
Qed.
(** from 30 Exercise 16a: product R^I where I=[0,1] has countable dense subset **)
(** LATEX VERSION: The product space ^I, where I=[0,1], has a countable dense subset. **)
Theorem ex30_16a_product_RI_countable_dense :
  exists D:set,
    D c= product_space unit_interval (const_space_family unit_interval R R_standard_topology) /\
    countable D /\
    dense_in D
      (product_space unit_interval (const_space_family unit_interval R R_standard_topology))
      (product_topology_full unit_interval (const_space_family unit_interval R R_standard_topology)).
admit.
Qed.

(** from 30 Exercise 16b: large product does not have countable dense subset **)
(** LATEX VERSION: If J has cardinality > (), then ^J does not have countable dense subset. **)
Theorem ex30_16b_large_product_no_countable_dense : forall J:set,
  atleastp (Power omega) J ->
  ~ equip J (Power omega) ->
  ~ (exists D:set,
      D c= product_space J (const_space_family J R R_standard_topology) /\
      countable D /\
      dense_in D
        (product_space J (const_space_family J R R_standard_topology))
        (product_topology_full J (const_space_family J R R_standard_topology))).
admit.
Qed.
(** from 30 Exercise 17: Romega box topology countability axioms **)
(** LATEX VERSION: ^ with box topology, subspace ^ (rationals ending in infinite 0s): which countability axioms? **)
(** Define Q_infty as rational sequences eventually equal to 0. **)
Definition Q_infty : set :=
  {f :e R_omega_space |
    (forall n:set, n :e omega -> apply_fun f n :e rational_numbers) /\
    (exists n0:set, n0 :e omega /\
      forall m:set, m :e omega -> ~(m :e n0) -> apply_fun f m = 0)}.
(** from 30 Exercise 17: subspace topology on Q^infty inside R^omega (box topology) **)
(** LATEX VERSION: Consider Q^infty as a subspace of R^omega in the box topology. **)
Definition Q_infty_topology : set :=
  subspace_topology R_omega_space R_omega_box_topology Q_infty.
Theorem ex30_17_Romega_box_countability :
  (first_countable_space Q_infty Q_infty_topology \/ ~ first_countable_space Q_infty Q_infty_topology) /\
  (second_countable_space Q_infty Q_infty_topology \/ ~ second_countable_space Q_infty Q_infty_topology) /\
  (Lindelof_space Q_infty Q_infty_topology \/ ~ Lindelof_space Q_infty Q_infty_topology) /\
  ((exists D:set, D c= Q_infty /\ countable D /\ dense_in D Q_infty Q_infty_topology) \/
   ~ (exists D:set, D c= Q_infty /\ countable D /\ dense_in D Q_infty Q_infty_topology)).
admit.
Qed.
(** from 30 Exercise 18: first-countable topological group with dense/Lindelof implies countable basis **)
(** LATEX VERSION: If G is first-countable topological group with countable dense subset or Lindelf, then G has countable basis. **)
Theorem ex30_18_first_countable_group_countable_basis : forall G Tg:set,
  topological_group G Tg ->
  first_countable_space G Tg ->
  ((exists D:set, D c= G /\ countable D /\ dense_in D G Tg) \/ Lindelof_space G Tg) ->
  second_countable_space G Tg.
admit.
Qed.

(** from 31 Exercise 1: regular implies disjoint closures of neighborhoods **)
(** LATEX VERSION: If X is regular, every pair of points have neighborhoods whose closures are disjoint. **)
Theorem ex31_1_regular_disjoint_closure_neighborhoods : forall X Tx x y:set,
  regular_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    x :e U /\ y :e V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
admit.
Qed.
(** from 31 Exercise 2: normal implies disjoint closures for closed sets **)
(** LATEX VERSION: If X is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. **)
Theorem ex31_2_normal_disjoint_closure_neighborhoods : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    A c= U /\ B c= V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
admit.
Qed.
(** from 31 Exercise 3: every order topology regular **)
(** LATEX VERSION: Every order topology is regular. **)
(** helper: singleton openness away from (1,0) in setprod 2 omega **)
Theorem singleton_setprod_2_omega_open_if_neq_10 : forall x:set,
  x :e setprod 2 omega ->
  x <> (1,0) ->
  {x} :e order_topology (setprod 2 omega).
admit.
Qed.

(** helper: any subset avoiding (1,0) is open in order_topology (setprod 2 omega) **)
Theorem open_in_order_topology_setprod_2_omega_if_not_10 : forall A:set,
  A c= setprod 2 omega ->
  (1,0) /:e A ->
  A :e order_topology (setprod 2 omega).
admit.
Qed.

(** helper: regularity of order_topology (setprod 2 omega) **)
Theorem regular_space_order_topology_setprod_2_omega :
  regular_space (setprod 2 omega) (order_topology (setprod 2 omega)).
admit.
Qed.

(** helper: separation of point and closed set in an order topology **)
Theorem order_topology_regular_sep : forall X x F:set,
  simply_ordered_set X ->
  x :e X ->
  closed_in X (order_topology X) F ->
  x /:e F ->
  exists U V:set, U :e order_topology X /\ V :e order_topology X /\ x :e U /\ F c= V /\ U :/\: V = Empty.
admit.
Qed.
Theorem ex31_3_order_topology_regular : forall X:set,
  simply_ordered_set X ->
  regular_space X (order_topology X).
admit.
Qed.
(** from 31 Exercise 4: comparing finer/coarser separation axioms **)
(** LATEX VERSION: Let X have two topologies T and T', with T'  T. Compare separation properties. **)
Theorem ex31_4_comparison_topologies_separation : forall X Tx Tx':set,
  topology_on X Tx ->
  topology_on X Tx' ->
  Tx c= Tx' ->
  ((Hausdorff_space X Tx -> Hausdorff_space X Tx') /\
   (regular_space X Tx -> Hausdorff_space X Tx') /\
   (normal_space X Tx -> Hausdorff_space X Tx')).
admit.
Qed.
(** from 31 Exercise 5: equalizer of continuous maps into Hausdorff is closed **)
(** LATEX VERSION: Let f,g: X  Y be continuous, Y Hausdorff. Then {x | f(x) = g(x)} is closed in X. **)
Theorem ex31_5_equalizer_closed_in_Hausdorff : forall X Tx Y Ty f g:set,
  continuous_map X Tx Y Ty f ->
  continuous_map X Tx Y Ty g ->
  Hausdorff_space Y Ty ->
  closed_in X Tx {x :e X | apply_fun f x = apply_fun g x}.
admit.
Qed.
(** from 31 Exercise 6: closed continuous surjection preserves normal **)
(** LATEX VERSION: Let p: X  Y be closed continuous surjective map. If X is normal, then so is Y. **)
(** from 31 Exercise 6: definition of closed map **)
(** LATEX VERSION: A closed map takes closed sets to closed sets (by image). **)
Definition closed_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  function_on p X Y /\ forall A:set, closed_in X Tx A -> closed_in Y Ty (image_of p A).
Theorem ex31_6_closed_map_preserves_normal : forall X Tx Y Ty p:set,
  normal_space X Tx ->
  continuous_map X Tx Y Ty p ->
  closed_map X Tx Y Ty p ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) ->
  normal_space Y Ty.
admit.
Qed.
(** from 31 Exercise 7: perfect map preserves separation/countability/local compactness **)
(** LATEX VERSION: Perfect map (closed continuous surjective with compact fibers) preserves Hausdorff, regular, locally compact, second-countable. **)
(** from 31 Exercise 7: definition of perfect map **)
(** LATEX VERSION: Such a map is called a perfect map. **)
Definition perfect_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  continuous_map X Tx Y Ty p /\
  closed_map X Tx Y Ty p /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) /\
  (forall y:set, y :e Y ->
    compact_space {x :e X | apply_fun p x = y}
                 (subspace_topology X Tx {x :e X | apply_fun p x = y})).
Theorem ex31_7_perfect_map_properties : forall X Tx Y Ty p:set,
  perfect_map X Tx Y Ty p ->
  (Hausdorff_space X Tx -> Hausdorff_space Y Ty) /\
  (regular_space X Tx -> regular_space Y Ty) /\
  (locally_compact X Tx -> locally_compact Y Ty) /\
  (second_countable_space X Tx -> second_countable_space Y Ty).
admit.
Qed.
(** from 31 Exercise 8: orbit space of compact group action preserves properties **)
(** LATEX VERSION: Let G be compact topological group,  action of G on X. Orbit space X/G retains Hausdorff, regular, normal, locally compact, second-countable properties. **)
Theorem ex31_8_orbit_space_properties : forall G Tg X Tx alpha:set,
  topological_group G Tg ->
  compact_space G Tg ->
  (Hausdorff_space X Tx -> exists XG TxG:set, Hausdorff_space XG TxG) /\
  (regular_space X Tx -> exists XG TxG:set, regular_space XG TxG) /\
  (normal_space X Tx -> exists XG TxG:set, normal_space XG TxG) /\
  (locally_compact X Tx -> exists XG TxG:set, locally_compact XG TxG) /\
  (second_countable_space X Tx -> exists XG TxG:set, second_countable_space XG TxG).
admit.
Qed.
(** from 31 Exercise 9: Sorgenfrey plane rational/irrational diagonal non-separation **)
(** LATEX VERSION: In _, let A = {x  (-x) | x rational}, B = {x  (-x) | x irrational}. No open sets separate A and B. **)
(** NOTE: This exercise (definitions + statement) is moved earlier near 31 Example 3 so it can be used to prove `Sorgenfrey_plane_not_normal`. **)

(** from 32 Exercise 1: closed subspace of normal is normal **)
(** LATEX VERSION: A closed subspace of a normal space is normal. **)
Theorem ex32_1_closed_subspace_normal : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  normal_space A (subspace_topology X Tx A).
admit.
Qed.
(** from 32 Exercise 2: factor spaces of products inherit separation **)
(** LATEX VERSION: If X_ is Hausdorff/regular/normal, then so is each X_ (assuming X_ nonempty). **)
Theorem ex32_2_factors_inherit_separation : forall Idx Fam:set,
  (forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ Xi <> Empty) ->
  ((Hausdorff_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ Hausdorff_space Xi Txi) /\
   (regular_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ regular_space Xi Txi) /\
      (normal_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ normal_space Xi Txi)).
admit.
Qed.
(** from 32 Exercise 3: locally compact Hausdorff implies regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is regular. **)
Theorem ex32_3_locally_compact_Hausdorff_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  regular_space X Tx.
admit.
Qed.
(** from 32 Exercise 4: regular Lindelof implies normal **)
(** LATEX VERSION: Every regular Lindelf space is normal. **)
Theorem ex32_4_regular_Lindelof_normal : forall X Tx:set,
  regular_space X Tx ->
  Lindelof_space X Tx ->
  normal_space X Tx.
admit.
Qed.
(** from 31 Example: the Sorgenfrey line is normal **)
(** LATEX VERSION: The Sorgenfrey line is normal. **)
(** NOTE: Placed here to avoid forward references to 32.4 regular-Lindelof-normal infrastructure. **)
Theorem Sorgenfrey_line_normal : normal_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.
(** from 32 Exercise 5: normality questions for Romega product topologies **)
(** LATEX VERSION: Is ^ normal in product topology? In uniform topology? **)
Theorem ex32_5_Romega_normality_questions :
  (normal_space R_omega_space R_omega_product_topology \/
   ~ normal_space R_omega_space R_omega_product_topology) /\
  (normal_space real_sequences uniform_topology \/
   ~ normal_space real_sequences uniform_topology).
admit.
Qed.
(** from 32 Exercise 6: completely normal characterization via separated sets **)
(** LATEX VERSION: X is completely normal iff for every separated pair A,B, there exist disjoint open sets containing them. **)
Theorem ex32_6_completely_normal_characterization : forall X Tx:set,
  completely_normal_space X Tx <->
  (one_point_sets_closed X Tx /\
   (forall A B:set, separated_subsets X Tx A B ->
     exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty)).
admit.
Qed.
(** from 32 Exercise 7: completely normal examples **)
(** LATEX VERSION: Which are completely normal: (a) subspace (b) product (c) well-ordered (d) metrizable (e) compact Hausdorff (f) regular+countable basis (g) _? **)
(** helper: restrict a metric graph to a subset A **)
Definition metric_restrict : set -> set -> set -> set := fun X d A =>
  graph (setprod A A) (fun p:set => apply_fun d p).

(** helper: definitional expansion for metric_restrict **)
Theorem metric_restrict_def : forall X d A:set,
  metric_restrict X d A = graph (setprod A A) (fun p:set => apply_fun d p).
admit.
Qed.

(** helper: apply metric_restrict on a pair **)
Theorem metric_restrict_apply : forall X d A x y:set,
  x :e A -> y :e A ->
  apply_fun (metric_restrict X d A) (x,y) = apply_fun d (x,y).
admit.
Qed.

(** helper: restriction of a metric is a metric **)
Theorem metric_restrict_is_metric_on : forall X d A:set,
  metric_on X d ->
  A c= X ->
  metric_on A (metric_restrict X d A).
admit.
Qed.

(** helper: the metric topology of a restricted metric equals the subspace topology **)
Theorem metric_topology_restrict_eq_subspace_topology : forall X d A:set,
  metric_on X d ->
  A c= X ->
  metric_topology A (metric_restrict X d A) = subspace_topology X (metric_topology X d) A.
admit.
Qed.

(** helper: subspaces of a metrizable space are metrizable **)
Theorem subspace_of_metrizable_is_metrizable : forall X Tx A:set,
  metrizable X Tx ->
  A c= X ->
  metrizable A (subspace_topology X Tx A).
admit.
Qed.

(** helper: each Romega_tilde n is metrizable as a subspace of R^omega **)
(** LATEX VERSION: R^omega is metrizable in the product topology, hence any subspace such as R^n (viewed inside R^omega) is metrizable. **)
Theorem Romega_tilde_metrizable : forall n:set,
  n :e omega ->
  metrizable (Romega_tilde n) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n)).
admit.
Qed.

(** FIXED: the subspace clause needs A c= X to match the intended subspace statement. **)
Theorem ex32_7_completely_normal_examples :
  (forall X Tx A:set, completely_normal_space X Tx -> A c= X -> completely_normal_space A (subspace_topology X Tx A)) /\
  (forall X Tx Y Ty:set, completely_normal_space X Tx -> completely_normal_space Y Ty ->
    (completely_normal_space (setprod X Y) (product_topology X Tx Y Ty) \/
     ~ completely_normal_space (setprod X Y) (product_topology X Tx Y Ty))) /\
  (forall X:set, well_ordered_set X -> simply_ordered_set X ->
    (completely_normal_space X (order_topology X) \/
     ~ completely_normal_space X (order_topology X))) /\
  (forall X Tx:set, metrizable X Tx -> completely_normal_space X Tx) /\
  (forall X Tx:set, compact_space X Tx -> Hausdorff_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (forall X Tx:set, regular_space X Tx -> second_countable_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (completely_normal_space R R_lower_limit_topology \/ ~ completely_normal_space R R_lower_limit_topology).
admit.
Qed.
(** helper: basic order intervals and rays are open in the order topology **)
Theorem order_interval_in_order_topology : forall X a b:set,
  simply_ordered_set X ->
  a :e X ->
  b :e X ->
  order_interval X a b :e order_topology X.
admit.
Qed.
Theorem lower_ray_in_order_topology : forall X b:set,
  simply_ordered_set X ->
  b :e X ->
  {x :e X | order_rel X x b} :e order_topology X.
admit.
Qed.
Theorem upper_ray_in_order_topology : forall X a:set,
  simply_ordered_set X ->
  a :e X ->
  {x :e X | order_rel X a x} :e order_topology X.
admit.
Qed.

(** helper: linear continua are locally connected **)
Theorem linear_continuum_locally_connected : forall X Tx:set,
  linear_continuum X Tx ->
  locally_connected X Tx.
admit.
Qed.

(** Note: In this file, the subclaims (a)-(c) for 32 Exercise 8 are stated before the main claim, to avoid forward references in Megalodon. **)

(** helper predicate for 32 Exercise 8 chosen components **)
(** LATEX VERSION: The chosen family consists of components of S, each corresponding to an interval (a,b) determined by points aA and bB with a<b. **)
Definition ex32_8_WFpred : set -> set -> set -> set -> set -> set -> prop :=
  fun X A B S Ts W0 =>
    (exists x:set, x :e S /\ W0 = component_of S Ts x) /\
    (exists a b:set, a :e A /\ b :e B /\ order_rel X a b /\ W0 = order_interval X a b).

(** helper for 32 Exercise 8(b): WF elements are components of S **)
Theorem ex32_8b_WF_is_component_family : forall X A B S Ts WF:set,
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  forall W:set, W :e WF -> exists x:set, x :e S /\ W = component_of S Ts x.
admit.
Qed.

(** helper for 32 Exercise 8(b): the chosen-points set C lies in S **)
Theorem ex32_8b_C_subset_S : forall X A B S Ts WF C:set, forall pick:set->set,
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  C c= S.
admit.
Qed.

(** helper for 32 Exercise 8(b): the chosen-points set is disjoint from A  B **)
(** LATEX VERSION: In part (b), the set C of chosen points lies in X-(AB), hence it does not meet A or B. **)
Theorem ex32_8b_C_disjoint_A_union_B : forall X A B S Ts WF C:set, forall pick:set->set,
  S = X :\: (A :\/: B) ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  C :/\: (A :\/: B) = Empty.
admit.
Qed.

(** helper for 32 Exercise 8(b): the chosen-points set is disjoint from A **)
(** LATEX VERSION: Since C  X-(AB), we have C  A = . **)
Theorem ex32_8b_C_disjoint_A : forall X A B S Ts WF C:set, forall pick:set->set,
  S = X :\: (A :\/: B) ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  C :/\: A = Empty.
admit.
Qed.

(** helper for 32 Exercise 8(b): the chosen-points set is disjoint from B **)
(** LATEX VERSION: Since C  X-(AB), we have C  B = . **)
Theorem ex32_8b_C_disjoint_B : forall X A B S Ts WF C:set, forall pick:set->set,
  S = X :\: (A :\/: B) ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  C :/\: B = Empty.
admit.
Qed.

(** helper for 32 Exercise 8(b): WF members are pairwise disjoint components **)
Theorem ex32_8b_WF_pairwise_disjoint : forall X A B S Ts WF:set,
  topology_on S Ts ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  pairwise_disjoint WF.
admit.
Qed.

(** helper for 32 Exercise 8(b): in each WWF, C meets W at the single chosen point **)
Theorem ex32_8b_C_intersection_W : forall X A B S Ts WF C:set, forall pick:set->set,
  topology_on S Ts ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  forall W:set, W :e WF -> C :/\: W = {pick W}.
admit.
Qed.

(** helper for 32 Exercise 8(b): a component of S not in WF is disjoint from C **)
Theorem ex32_8b_component_disjoint_C_if_not_in_WF :
  forall X A B S Ts WF C:set, forall pick:set->set,
    topology_on S Ts ->
    WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
    C = {pick W0 | W0 :e WF} ->
    (forall W0:set, W0 :e WF -> pick W0 :e W0) ->
    forall x:set, x :e S ->
      forall W:set, W = component_of S Ts x ->
        ~ (W :e WF) ->
        C :/\: W = Empty.
admit.
Qed.

(** from 32 Exercise 8a: components of complement of closed set in linear continuum **)
(** LATEX VERSION: Let C be nonempty closed in a linear continuum X. If U is a component of X-C then U is (c,c') or (c,) or (-,c) with endpoints in C. **)
(** NOTE: We treat this exercise component-classification as an axiom for dependency tracking; a proof sketch is kept below. **)
Axiom ex32_8a_component_of_complement_shape : forall X Tx C x:set,
  linear_continuum X Tx ->
  closed_in X Tx C ->
  C <> Empty ->
  x :e (X :\: C) ->
  (exists c c':set, c :e C /\ c' :e C /\ order_rel X c c' /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = order_interval X c c')
  \/
  (exists c:set, c :e C /\ (forall d:set, d :e C -> ~ order_rel X c d) /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = {y :e X | order_rel X c y})
  \/
  (exists c:set, c :e C /\ (forall d:set, d :e C -> ~ order_rel X d c) /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = {y :e X | order_rel X y c}).

(** Proof sketch (not used for dependencies) **)
Theorem ex32_8a_component_of_complement_shape_sketch : forall X Tx C x:set,
  linear_continuum X Tx ->
  closed_in X Tx C ->
  C <> Empty ->
  x :e (X :\: C) ->
  (exists c c':set, c :e C /\ c' :e C /\ order_rel X c c' /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = order_interval X c c')
  \/
  (exists c:set, c :e C /\ (forall d:set, d :e C -> ~ order_rel X c d) /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = {y :e X | order_rel X c y})
  \/
  (exists c:set, c :e C /\ (forall d:set, d :e C -> ~ order_rel X d c) /\
     component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x = {y :e X | order_rel X y c}).
admit.
Qed.

(** from 32 Exercise 8b: chosen points form a closed set **)
(** LATEX VERSION: Let A,B be disjoint closed in a linear continuum X. For each component W of X-(AB) that is an open interval with one endpoint in A and the other in B, choose a point c_W in W. Show the set C of all c_W is closed. **)
(** helper for 32 Exercise 8(b): the complement of C is open **)
(** LATEX VERSION: The main work in part (b) is to show X minus C is open by constructing, for each point outside C, an interval neighborhood disjoint from C. **)
(** NOTE: We treat this exercise complement-openness claim as an axiom for dependency tracking; a proof sketch is kept below. **)
Axiom ex32_8b_complement_open : forall X Tx A B S Ts WF C:set, forall pick:set->set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  S = X :\: (A :\/: B) ->
  Ts = subspace_topology X Tx S ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  (X :\: C) :e Tx.

(** Proof sketch (not used for dependencies) **)
Theorem ex32_8b_complement_open_sketch : forall X Tx A B S Ts WF C:set, forall pick:set->set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  S = X :\: (A :\/: B) ->
  Ts = subspace_topology X Tx S ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  (X :\: C) :e Tx.
admit.
Qed.
Theorem ex32_8b_chosen_points_set_closed : forall X Tx A B S Ts WF C:set, forall pick:set->set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  S = X :\: (A :\/: B) ->
  Ts = subspace_topology X Tx S ->
  WF = {W0 :e Power S | ex32_8_WFpred X A B S Ts W0} ->
  C = {pick W0 | W0 :e WF} ->
  (forall W:set, W :e WF -> pick W :e W) ->
  closed_in X Tx C.
admit.
Qed.
(** helper for 32 Exercise 8(c): find an A-B interval component inside a component of X \\ C **)
(** LATEX VERSION: If a component of X-C meets both A and B, then it contains a component W of X-(AB) that is an open interval (a0,b0) with a0A and b0B. **)
(** NOTE: We treat this exercise extraction lemma as an axiom for dependency tracking; a proof sketch is kept below. **)
Axiom ex32_8c_find_interval_component_in_component : forall X Tx A B C x a b:set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  closed_in X Tx C ->
  a :e A ->
  b :e B ->
  x :e (X :\: C) ->
  a :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x ->
  b :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x ->
  exists W:set,
    (exists y:set,
      y :e (X :\: (A :\/: B)) /\
      W = component_of (X :\: (A :\/: B)) (subspace_topology X Tx (X :\: (A :\/: B))) y) /\
    (exists a0 b0:set, a0 :e A /\ b0 :e B /\ order_rel X a0 b0 /\ W = order_interval X a0 b0) /\
    W c= component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x.

(** Proof sketch (not used for dependencies) **)
Theorem ex32_8c_find_interval_component_in_component_sketch : forall X Tx A B C x a b:set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  closed_in X Tx C ->
  a :e A ->
  b :e B ->
  x :e (X :\: C) ->
  a :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x ->
  b :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x ->
  exists W:set,
    (exists y:set,
      y :e (X :\: (A :\/: B)) /\
      W = component_of (X :\: (A :\/: B)) (subspace_topology X Tx (X :\: (A :\/: B))) y) /\
    (exists a0 b0:set, a0 :e A /\ b0 :e B /\ order_rel X a0 b0 /\ W = order_interval X a0 b0) /\
    W c= component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x.
admit.
Qed.

(** from 32 Exercise 8c: components of X-C do not meet both closed sets **)
(** LATEX VERSION: If V is a component of X-C, then V does not intersect both A and B. **)
Theorem ex32_8c_component_of_X_minus_C_not_both : forall X Tx A B C:set,
  linear_continuum X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  (forall W:set,
    (exists x:set,
      x :e (X :\: (A :\/: B)) /\
      W = component_of (X :\: (A :\/: B)) (subspace_topology X Tx (X :\: (A :\/: B))) x) ->
    (exists a b:set, a :e A /\ b :e B /\ order_rel X a b /\ W = order_interval X a b) ->
    exists cW:set, cW :e C /\ cW :e W) ->
  closed_in X Tx C ->
  (forall x:set, x :e (X :\: C) ->
    ~ (exists a b:set,
        a :e A /\ b :e B /\
        a :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x /\
        b :e component_of (X :\: C) (subspace_topology X Tx (X :\: C)) x)).
admit.
Qed.

(** from 32 Exercise 8: linear continuum normal **)
(** LATEX VERSION: Theorem. Every linear continuum X is normal. (a) If C is nonempty closed and U is a component of X-C then U is (c,c') or (c,) or (-,c) with endpoints in C. (b) For disjoint closed A,B: choose one point c_W in each component W of X-(AB) that is an open interval with one endpoint in A and the other in B; show the set C of all such c_W is closed. (c) If V is a component of X-C then V does not meet both A and B. **) 
Theorem ex32_8_linear_continuum_normal : forall X Tx:set,
  linear_continuum X Tx ->
  normal_space X Tx.
admit.
Qed.

(** from 32 Exercise 9: uncountable product of R not normal **)
(** LATEX VERSION: If J is uncountable, then ^J is not normal. **)
Theorem ex32_9_uncountable_product_not_normal : forall J:set,
  ~ countable J ->
  ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
admit.
Qed.

(** helper: perfect normality predicate **)
(** from 33 Exercise 6: perfectly normal spaces **)
(** LATEX VERSION: X is perfectly normal if X is normal and every closed set in X is a G_delta set. **)
Definition perfectly_normal_space : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\ (forall A:set, closed_in X Tx A -> Gdelta_in X Tx A).

(** FIXED: Removed nonsensical fourth clause: forall r, apply_fun f X = {x :e X | apply_fun f x = r} mixes an image in R with a level set in X; now left as a separate admitted exercise. **)
(** from 33 Exercise 1: expression for level sets in Urysohn proof **)
(** LATEX VERSION: In Urysohn lemma proof, show f^{-1}(r) = _{p>r} U_p - _{q<r} U_q for rational p,q. **)
Theorem ex33_1_level_sets_urysohn : forall X Tx A B:set, forall U:set -> set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 2: connected normal/regular uncountable **)
(** LATEX VERSION: Connected normal/regular space with >1 point is uncountable. **)
(** helper for 33 Exercise 2: unit closed interval is uncountable **)
(** LATEX VERSION: The closed interval [0,1] is uncountable. **)
Theorem atleastp_R_closed_interval_0_1 : atleastp R (closed_interval 0 1).
admit.
Qed.
Theorem closed_interval_0_1_uncountable : ~ countable (closed_interval 0 1).
admit.
Qed.
Theorem ex33_2a_connected_normal_uncountable : forall X Tx:set,
  connected_space X Tx ->
  normal_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
admit.
Qed.
Theorem ex33_2b_connected_regular_uncountable : forall X Tx:set,
  connected_space X Tx ->
  regular_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
admit.
Qed.
(** from 33 Exercise 3: direct Urysohn proof in metric space **)
(** LATEX VERSION: For metric space, Urysohn lemma direct proof: f(x) = d(x,A)/(d(x,A)+d(x,B)). **)
Theorem ex33_3_urysohn_metric_direct : forall X d A B:set,
  metric_on X d ->
  closed_in X (metric_topology X d) A ->
  closed_in X (metric_topology X d) B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X (metric_topology X d) R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 4: closed G_delta sets and vanishing functions **)
(** LATEX VERSION: In normal X, f:X[0,1] vanishing precisely on A iff A is closed G_. **)
Theorem ex33_4_closed_Gdelta_vanishing_function : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
	  (Gdelta_in X Tx A <->
	    exists f:set,
	      continuous_map X Tx R R_standard_topology f /\
	      (forall x:set, x :e A -> apply_fun f x = 0) /\
	      (forall x:set, x :e X -> x /:e A -> ~ (apply_fun f x = 0))).
admit.
Qed.
(** from 33 Exercise 5: strong Urysohn lemma **)
(** LATEX VERSION: Strong Urysohn: f with f(A)=0, f(B)=1, 0<f<1 elsewhere iff A,B closed G_. **)
Theorem ex33_5_strong_urysohn : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  (Gdelta_in X Tx A /\ Gdelta_in X Tx B <->
    exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      (forall x:set, x :e A -> apply_fun f x = 0) /\
      (forall x:set, x :e B -> apply_fun f x = 1) /\
      (forall x:set, x :e X -> x /:e A -> x /:e B -> ~ (apply_fun f x = 0) /\ ~ (apply_fun f x = 1))).
admit.
Qed.

(** helper for 33 Exercise 6a: closed sets in metric spaces are G_delta **)
(** LATEX VERSION: In a metric space, any closed set is a countable intersection of open sets. **)
Theorem metric_closed_is_Gdelta : forall X d A:set,
  metric_on X d ->
  closed_in X (metric_topology X d) A ->
  Gdelta_in X (metric_topology X d) A.
admit.
Qed.
(** from 33 Exercise 6a: metrizable implies perfectly normal **)
(** LATEX VERSION: Every metrizable space is perfectly normal. **)
Theorem ex33_6a_metrizable_perfectly_normal : forall X Tx:set,
  metrizable X Tx ->
  perfectly_normal_space X Tx.
admit.
Qed.

(** from 33 Exercise 6b: perfectly normal implies completely normal **)
(** LATEX VERSION: Every perfectly normal space is completely normal. **)
Theorem ex33_6b_perfectly_completely_normal : forall X Tx:set,
  perfectly_normal_space X Tx ->
  completely_normal_space X Tx.
admit.
Qed.

(** from 33 Exercise 6c: completely normal not perfectly normal example **)
(** LATEX VERSION: There exists completely normal but not perfectly normal space. **)
Theorem ex33_6c_completely_not_perfectly_normal :
  exists X Tx:set,
    completely_normal_space X Tx /\
    ~ perfectly_normal_space X Tx.
admit.
Qed.
(** from 33 Exercise 7: locally compact Hausdorff completely regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is completely regular. **)
Theorem ex33_7_locally_compact_Hausdorff_completely_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  completely_regular_space X Tx.
admit.
Qed.
(** from 33 Exercise 8: continuous separation when A compact **)
(** LATEX VERSION: If X completely regular, A compact, B closed disjoint from A, then f:X[0,1] with f(A)=0, f(B)=1. **)
Theorem ex33_8_compact_subset_continuous_separation : forall X Tx A B:set,
  completely_regular_space X Tx ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 9: Romega box topology completely regular **)
(** LATEX VERSION: ^ in box topology is completely regular. **)
Theorem ex33_9_Romega_box_completely_regular :
  completely_regular_space (product_space omega (const_space_family omega R R_standard_topology))
                           (box_topology omega (const_space_family omega R R_standard_topology)).
admit.
Qed.
(** from 33 Exercise 10: topological group completely regular **)
(** LATEX VERSION: Every topological group is completely regular. **)
Theorem ex33_10_topological_group_completely_regular : forall G Tg:set,
  topological_group G Tg ->
  completely_regular_space G Tg.
admit.
Qed.
(** from 33 Exercise 11: regular not completely regular example **)
(** LATEX VERSION: There exists regular space that is not completely regular. **)
Theorem ex33_11_regular_not_completely_regular :
  exists X Tx:set,
    regular_space X Tx /\
    ~ completely_regular_space X Tx.
admit.
Qed.

(** helper: retraction data **) 
(** from 35 Exercise 4: retracts and retractions **)
(** LATEX VERSION: If Y is a subspace of Z, a retraction r:ZY satisfies r(y)=y for each y in Y. **)
Definition retraction_of : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\ exists r:set,
    function_on r X X /\ continuous_map X Tx X Tx r /\
    (forall x:set, x :e X -> apply_fun r x :e A) /\
    (forall x:set, x :e A -> apply_fun r x = x).

(** from 35 Exercise 6: absolute retracts (image of embedding) **)
(** LATEX VERSION: Absolute retract: for every normal Z and closed Y0 homeomorphic to Y, the subspace Y0 is a retract of Z. **)
Definition image_of_map : set -> set -> set -> set -> set -> set :=
  fun X Tx Y Ty f => image_of f X.

(** from 35 Exercise 6: absolute retracts **)
(** LATEX VERSION: A normal space Y is an absolute retract if every closed copy of Y in a normal space is a retract. **)
Definition absolute_retract : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\
  forall Z Tz Y0 f:set,
    normal_space Z Tz ->
    Y0 c= Z ->
    closed_in Z Tz Y0 ->
    homeomorphism X Tx Y0 (subspace_topology Z Tz Y0) f ->
    retraction_of Z Tz Y0.

(** from Supplementary Exercises (Review of the Basics) Exercise 9: coherent topology **)
(** LATEX VERSION: Let X_1  X_2  ... be a sequence of spaces, with X_i closed in X_{i+1}; let X =  X_i.
    Declare U open in X iff U  X_i is open in X_i for each i. **)
(** NOTE: We formalize the sequence as two functions Xi,Ti on omega, with Xi i = X_i and Ti i the topology on X_i. **)
Definition coherent_union : set -> set := fun Xi =>
  Union {apply_fun Xi i | i :e omega}.

(** helper: each component sits inside the coherent union **)
Theorem coherent_union_contains : forall Xi i x:set,
  i :e omega ->
  x :e apply_fun Xi i ->
  x :e coherent_union Xi.
admit.
Qed.

(** helper: every point in the coherent union lies in some component **)
Theorem coherent_unionE : forall Xi x:set,
  x :e coherent_union Xi ->
  exists i:set, i :e omega /\ x :e apply_fun Xi i.
admit.
Qed.

(** helper: each component is a subset of the coherent union **)
Theorem coherent_union_component_subset : forall Xi i:set,
  i :e omega -> apply_fun Xi i c= coherent_union Xi.
admit.
Qed.

Definition coherent_topology : set -> set -> set := fun Xi Ti =>
  {U :e Power (coherent_union Xi) |
    forall i :e omega, (U :/\: apply_fun Xi i) :e apply_fun Ti i }.

(** helper: coherent chain of closed subspaces X_0  X_1  ... with compatible topologies **)
(** LATEX VERSION: X_i is a closed subspace of X_{i+1} for each i. **)
Definition coherent_chain : set -> set -> prop := fun Xi Ti =>
  (forall i:set, i :e omega -> topology_on (apply_fun Xi i) (apply_fun Ti i)) /\
  (forall i:set, i :e omega -> apply_fun Xi i c= apply_fun Xi (ordsucc i)) /\
  (forall i:set, i :e omega ->
     subspace_topology (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i)) (apply_fun Xi i) = apply_fun Ti i) /\
  (forall i:set, i :e omega -> closed_in (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i)) (apply_fun Xi i)).

(** helper: coherent chains are monotone along finite successor iteration **)
(** LATEX VERSION: Used implicitly in the coherent topology exercise, via X_i c= X_{i+1} c= ... c= X_{i+k}. **)
Theorem coherent_chain_mono_add_nat : forall Xi Ti i k:set,
  coherent_chain Xi Ti ->
  i :e omega ->
  k :e omega ->
  apply_fun Xi i c= apply_fun Xi (add_nat i k).
admit.
Qed.

(** helper: coherent chains are monotone along the membership order on omega **)
(** LATEX VERSION: Used implicitly in the coherent topology exercise, via i :e j -> X_i c= X_j. **)
Theorem coherent_chain_mono_mem : forall Xi Ti j:set,
  coherent_chain Xi Ti ->
  j :e omega ->
  forall i:set, i :e j -> apply_fun Xi i c= apply_fun Xi j.
admit.
Qed.

(** helper: closed sets in a coherent chain stay closed in the successor space **)
(** LATEX VERSION: If X_i is closed in X_{i+1} and T_i is the induced subspace topology, then T_i-closed sets are T_{i+1}-closed. **)
Theorem coherent_chain_closed_in_succ : forall Xi Ti i A:set,
  coherent_chain Xi Ti ->
  i :e omega ->
  closed_in (apply_fun Xi i) (apply_fun Ti i) A ->
  closed_in (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i)) A.
admit.
Qed.

(** helper: Tietze extension step along a coherent chain successor **)
(** LATEX VERSION: If X_i is closed in X_{i+1} and T_i is the induced topology, then any continuous f:X_i[a,b] extends continuously to X_{i+1}. **)
Theorem coherent_chain_Tietze_extend_interval_succ : forall Xi Ti i a b f:set,
  coherent_chain Xi Ti ->
  i :e omega ->
  Rle a b ->
  normal_space (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i)) ->
  continuous_map (apply_fun Xi i) (apply_fun Ti i) (closed_interval a b) (closed_interval_topology a b) f ->
  exists g:set,
    continuous_map (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i))
                   (closed_interval a b) (closed_interval_topology a b) g /\
    (forall x:set, x :e apply_fun Xi i -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** helper: a set closed in the coherent topology has closed traces on each component **)
Theorem closed_in_coherent_component : forall Xi Ti A i:set,
  (forall j:set, j :e omega -> topology_on (apply_fun Xi j) (apply_fun Ti j)) ->
  closed_in (coherent_union Xi) (coherent_topology Xi Ti) A ->
  i :e omega ->
  closed_in (apply_fun Xi i) (apply_fun Ti i) (A :/\: apply_fun Xi i).
admit.
Qed.

(** helper for 35 Exercise 9(c): successor extension with boundary values **)
(** LATEX VERSION: Extend an interval valued map along a coherent chain successor while forcing values 0 and 1 on two disjoint closed traces. **)
Theorem coherent_chain_extend_interval_succ_with_boundary : forall Xi Ti A B i fi:set,
  coherent_chain Xi Ti ->
  (forall j:set, j :e omega -> normal_space (apply_fun Xi j) (apply_fun Ti j)) ->
  i :e omega ->
  closed_in (coherent_union Xi) (coherent_topology Xi Ti) A ->
  closed_in (coherent_union Xi) (coherent_topology Xi Ti) B ->
  A :/\: B = Empty ->
  continuous_map (apply_fun Xi i) (apply_fun Ti i)
    (closed_interval 0 1) (closed_interval_topology 0 1) fi ->
  (forall x:set, x :e (A :/\: apply_fun Xi i) -> apply_fun fi x = 0) ->
  (forall x:set, x :e (B :/\: apply_fun Xi i) -> apply_fun fi x = 1) ->
  exists gi:set,
    continuous_map (apply_fun Xi (ordsucc i)) (apply_fun Ti (ordsucc i))
      (closed_interval 0 1) (closed_interval_topology 0 1) gi /\
    (forall x:set, x :e apply_fun Xi i -> apply_fun gi x = apply_fun fi x) /\
    (forall x:set, x :e (A :/\: apply_fun Xi (ordsucc i)) -> apply_fun gi x = 0) /\
    (forall x:set, x :e (B :/\: apply_fun Xi (ordsucc i)) -> apply_fun gi x = 1).
admit.
Qed.

(** from 37 Theorem (Tychonoff): product of compact spaces is compact **)
(** LATEX VERSION: If each factor X_alpha is compact, then the product space is compact. **)
Definition compact_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i).

(** from 22 Definition: surjective map **)
(** LATEX VERSION: A map p:XY is surjective if every y in Y equals p(x) for some x in X. **)
Definition surjective_map : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\ forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.

(** from 34 Exercise 1: Hausdorff with countable basis need not be metrizable **) 
(** LATEX VERSION: Find an example of a Hausdorff second countable space that is not metrizable. **)
Definition ex34_1_Hausdorff_countable_basis_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      Hausdorff_space X Tx /\ second_countable_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 2: completely normal etc. not metrizable example **) 
(** LATEX VERSION: Find an example of a completely normal space that is not metrizable. **)
Definition ex34_2_completely_normal_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ completely_normal_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 3: compact Hausdorff metrizable iff countable basis **) 
(** LATEX VERSION: Prove that for compact Hausdorff spaces, metrizability is equivalent to second countability. **)
Definition ex34_3_compact_Hausdorff_metrizable_iff_second_countable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      (metrizable X Tx <-> second_countable_space X Tx)}.
(** from 34 Exercise 4: locally compact Hausdorff and countable basis vs metrizable **) 
(** LATEX VERSION: Study metrizability questions for locally compact Hausdorff spaces under second countability. **)
Definition ex34_4_locally_compact_Hausdorff_metrizable_questions : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_compact X Tx /\ Hausdorff_space X Tx /\
      (second_countable_space X Tx -> metrizable X Tx)}.
(** from 34 Exercise 5: one-point compactification metrizable vs base **) 
(** LATEX VERSION: Relate metrizability of a space and its one-point compactification. **)
Definition ex34_5_one_point_compactification_metrizable_questions : set :=
  {q :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty p:set,
      q = setprod (setprod (setprod X Tx) (setprod Y Ty)) p /\
      one_point_compactification X Tx Y Ty /\ p :e Y /\ ~ p :e X /\
      (metrizable X Tx <-> metrizable Y Ty)}.
(** from 34 Exercise 6: details of imbedding theorem proof **) 
(** LATEX VERSION: Check details in the embedding theorem proof for completely regular Hausdorff spaces. **)
Definition ex34_6_check_imbedding_proof : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx f:set,
      p = setprod (setprod X Tx) f /\
      completely_regular_space X Tx /\ Hausdorff_space X Tx /\
      embedding_of X Tx (power_real omega) (product_topology_full omega (const_space_family omega R R_standard_topology)) f}.
(** from 34 Exercise 7: locally metrizable compact Hausdorff implies metrizable **) 
(** LATEX VERSION: Show that a locally metrizable compact Hausdorff space is metrizable. **)
Definition ex34_7_locally_metrizable_compact_Hausdorff_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_metrizable_space X Tx /\ compact_space X Tx /\ Hausdorff_space X Tx /\
      metrizable X Tx}.
(** from 34 Exercise 8: regular Lindelof locally metrizable implies metrizable **) 
(** LATEX VERSION: Show that regular Lindelof and locally metrizable implies metrizable. **)
Definition ex34_8_regular_Lindelof_locally_metrizable_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      (regular_space X Tx /\ Lindelof_space X Tx /\ locally_metrizable_space X Tx ->
        metrizable X Tx)}.
(** from 34 Exercise 9: compact Hausdorff union of two metrizable closed sets is metrizable **) 
(** LATEX VERSION: If X is compact Hausdorff and is the union of two metrizable closed subsets, then X is metrizable. **)
Definition ex34_9_compact_union_two_metrizable_closed_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A B:set,
      p = setprod (setprod X Tx) (setprod A B) /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      closed_in X Tx A /\ closed_in X Tx B /\ Union (UPair A B) = X /\
      metrizable A (subspace_topology X Tx A) /\ metrizable B (subspace_topology X Tx B) /\
      metrizable X Tx}.

(** from 35 Exercise 1: Tietze implies Urysohn lemma **) 
(** LATEX VERSION: Use the Tietze extension theorem to derive Urysohn's lemma in a normal space. **)
Definition ex35_1_Tietze_implies_Urysohn : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      normal_space X Tx /\
      (forall A B:set, closed_in X Tx A /\ closed_in X Tx B /\ A :/\: B = Empty ->
         exists f:set, continuous_map X Tx R R_standard_topology f /\
           (forall x:set, x :e A -> apply_fun f x = 0) /\
           (forall x:set, x :e B -> apply_fun f x = 1))}.
(** from 35 Exercise 2: interval partition parameter in Tietze proof **) 
(** LATEX VERSION: Choose an interval partition parameter used in a proof of the Tietze extension theorem. **)
Definition ex35_2_interval_partition_parameter : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ normal_space X Tx}.
(** from 35 Exercise 3: boundedness equivalences in metrizable spaces **) 
(** LATEX VERSION: Establish equivalences relating boundedness notions in metrizable spaces. **)
Definition ex35_3_boundedness_equivalences_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx d:set, p = setprod (setprod X Tx) d /\
      metric_on X d /\ metric_topology X d = Tx}.
(** from 35 Exercise 4: retract properties **) 
(** LATEX VERSION: Prove basic properties of retracts and retractions. **)
Definition ex35_4_retract_properties : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 5: universal extension property and retracts **) 
(** LATEX VERSION: Show that retracts in a normal space satisfy an appropriate universal extension property. **)
Definition ex35_5_universal_extension_retracts : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set,
      p = setprod (setprod X Tx) A /\
      normal_space X Tx /\ retraction_of X Tx A /\
      forall Y Ty f:set, continuous_map A (subspace_topology X Tx A) Y Ty f ->
        exists g:set, continuous_map X Tx Y Ty g /\
          forall x:set, x :e A -> apply_fun g x = apply_fun f x}.
(** from 35 Exercise 6: absolute retract equivalence **) 
(** LATEX VERSION: Prove a characterization of absolute retracts via a universal extension property. **)
Definition ex35_6_absolute_retract_universal_extension : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from 35 Exercise 7: retract examples spiral/knotted axis **) 
(** LATEX VERSION: Give examples of retracts, such as spiral and knotted axis subsets. **)
Definition ex35_7_retract_examples : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 8: absolute retract iff universal extension **) 
(** LATEX VERSION: Prove an equivalence for absolute retracts (as stated in the exercises). **)
Definition ex35_8_absolute_retract_equivalence : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from Supplementary Exercises (Review of the Basics) Exercise 9(a) **)
(** LATEX VERSION: This is a topology on X; each X_i is a subspace (indeed closed) of X. **)
Theorem ex35_9a_coherent_topology_is_topology : forall Xi Ti:set,
  (forall i:set, i :e omega -> topology_on (apply_fun Xi i) (apply_fun Ti i)) ->
  topology_on (coherent_union Xi) (coherent_topology Xi Ti).
admit.
Qed.

(** from Supplementary Exercises (Review of the Basics) Exercise 9(b) **)
(** LATEX VERSION: f:XY is continuous if each restriction f|X_i is continuous. **)
Theorem ex35_9b_continuous_if_restrictions_continuous : forall Xi Ti Y Ty f:set,
  (forall i:set, i :e omega -> topology_on (apply_fun Xi i) (apply_fun Ti i)) ->
  topology_on Y Ty ->
  function_on f (coherent_union Xi) Y ->
  (forall i:set, i :e omega -> continuous_map (apply_fun Xi i) (apply_fun Ti i) Y Ty f) ->
  continuous_map (coherent_union Xi) (coherent_topology Xi Ti) Y Ty f.
admit.
Qed.

(** from Supplementary Exercises (Review of the Basics) Exercise 9(c) **)
(** LATEX VERSION: If each X_i is normal, then X is normal (hint: extend Urysohn functions stepwise). **)
Theorem ex35_9c_coherent_topology_normal : forall Xi Ti:set,
  coherent_chain Xi Ti ->
  (forall i:set, i :e omega -> normal_space (apply_fun Xi i) (apply_fun Ti i)) ->
  normal_space (coherent_union Xi) (coherent_topology Xi Ti).
admit.
Qed.

(** from 36 Exercises: manifolds and partitions of unity (placeholder) **) 
(** LATEX VERSION: Exercises on manifolds and partitions of unity. **)
Definition ex36_manifold_embedding_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists M TM m f:set,
      p = setprod (setprod M TM) f /\
      m_manifold M TM m ->
      exists n:set, embedding_of M TM (euclidean_space n) (euclidean_topology n) f}.
(** from 37 Exercises: Tychonoff theorem applications (placeholder) **) 
(** LATEX VERSION: Exercises applying the Tychonoff theorem to products of compact spaces. **)
Definition ex37_tychonoff_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists I Xi:set,
      p = setprod I Xi /\
      compact_spaces_family I Xi /\
      compact_space (product_space I Xi) (product_topology_full I Xi)}.
(** from 38 Exercises: Stone-Cech compactification (placeholder) **) 
(** LATEX VERSION: Exercises about Stone-Cech compactification and related embeddings. **)
Definition ex38_stone_cech_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      completely_regular_space X Tx /\ compact_space Y Ty /\ Hausdorff_space Y Ty /\
      exists e:set, embedding_of X Tx Y Ty e}.
(** from 39 Exercises: local finiteness (placeholder) **) 
(** LATEX VERSION: Exercises on locally finite families. **)
Definition ex39_local_finiteness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\ locally_finite_family X Tx U}.
(** from 40 Exercises: Nagata-Smirnov metrization (placeholder) **) 
(** LATEX VERSION: Exercises on Nagata-Smirnov metrization type criteria. **)
Definition ex40_nagata_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 41 Exercises: paracompactness (placeholder) **) 
(** LATEX VERSION: Exercises on paracompactness and open covers. **)
Definition ex41_paracompactness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\
      paracompact_space X Tx /\ open_cover X Tx U}.
(** from 42 Exercises: Smirnov metrization (placeholder) **) 
(** LATEX VERSION: Exercises on Smirnov metrization type criteria. **)
Definition ex42_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 43 Exercises: complete metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set for completeness properties. **)
Definition ex43_complete_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ complete_metric_space X d}.

(** from 44 Exercises: space-filling curve (placeholder) **) 
(** LATEX VERSION: Exercise set involving space-filling curves. **)
Definition ex44_space_filling_exercises : set :=
  {f :e Power (Power (Power R)) |
    continuous_map unit_interval R2_standard_topology unit_square unit_square_topology f /\
    surjective_map unit_interval unit_square f}.

(** from 45 Exercises: compactness in metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set on compactness equivalences in metric spaces. **)
Definition ex45_compact_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ compact_space X Tx}.

(** from 46 Exercises: pointwise/compact convergence (placeholder) **) 
(** LATEX VERSION: Exercises on pointwise and compact convergence topologies. **)
Definition ex46_convergence_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      topology_on X Tx /\ topology_on Y Ty}.

(** from 47 Exercises: Ascoli theorem (placeholder) **) 
(** LATEX VERSION: Exercises related to the AscoliArzel theorem. **)
Definition ex47_ascoli_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      compact_space X Tx /\ Hausdorff_space Y Ty}.

(** from 48 Exercise 1: nonempty Baire union has set with nonempty interior closure **)
(** LATEX VERSION: If X = B is a nonempty Baire space, then at least one B has nonempty interior. **)
Theorem ex48_1_Baire_union_interior : forall X Tx:set, forall Fam:set,
  Baire_space X Tx ->
  X <> Empty ->
  countable_set Fam ->
  X = Union Fam ->
  exists B:set, B :e Fam /\
    exists U:set, U :e Tx /\ U <> Empty /\ U c= (closure_of X Tx B).
admit.
Qed.

(** from 48 Exercise 2: R is not countable union of closed empty interior sets **)
(** LATEX VERSION:  cannot be written as countable union of closed sets with empty interior, but fails without closure requirement. **)
Theorem ex48_2_R_not_countable_empty_interior : forall Fam:set,
  countable_set Fam ->
  (forall C:set, C :e Fam -> closed_in R R_standard_topology C /\
    (forall U:set, U :e R_standard_topology -> U c= C -> U = Empty)) ->
  R <> Union Fam.
admit.
Qed.

(** from 48 Exercise 4: locally Baire implies Baire **)
(** LATEX VERSION: If every point has a neighborhood that is Baire, then X is Baire. **)
Theorem ex48_4_locally_Baire_implies_Baire : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      Baire_space U (subspace_topology X Tx U)) ->
  Baire_space X Tx.
admit.
Qed.

(** NOTE: Exercise 3 is placed after Exercise 4 because it uses Exercise 4. **)
(** from 48 Exercise 3: locally compact Hausdorff is Baire **)
(** LATEX VERSION: Every locally compact Hausdorff space is a Baire space. **)
Theorem ex48_3_locally_compact_Hausdorff_Baire : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  Baire_space X Tx.
admit.
Qed.

(** from 48 Exercise 5: G_delta in compact Hausdorff or complete metric is Baire **)
(** LATEX VERSION: If Y is G_ in X, and X is compact Hausdorff or complete metric, then Y is Baire in subspace topology. **)
Theorem ex48_5_Gdelta_Baire : forall X Tx Y:set,
  (compact_space X Tx /\ Hausdorff_space X Tx) ->
  (exists Fam:set, countable_set Fam /\
    (forall W:set, W :e Fam -> W :e Tx) /\
    Y = intersection_over_family X Fam) ->
  Baire_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** from 48 Exercise 6: irrationals are Baire **)
(** LATEX VERSION: The irrationals are a Baire space. **)
Theorem ex48_6_irrationals_Baire :
  Baire_space (R :\: Q) (subspace_topology R R_standard_topology (R :\: Q)).
admit.
Qed.

(** from 48 Exercise 7a: continuity set is G_delta **)
(** LATEX VERSION: For f:, the set C of continuity points is G_. **)
Theorem ex48_7a_continuity_set_Gdelta : forall f:set,
  function_on f R R ->
  exists Fam:set, countable_set Fam /\
    (forall U:set, U :e Fam -> U :e R_standard_topology) /\
    {x :e R | continuous_at f x} = intersection_over_family R Fam.
admit.
Qed.

(** from 48 Exercise 7b: countable dense not G_delta **)
(** LATEX VERSION: Countable dense D   is not G_. **)
Theorem ex48_7b_countable_dense_not_Gdelta : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists Fam:set, countable_set Fam /\
      (forall W:set, W :e Fam -> W :e R_standard_topology) /\
      D = intersection_over_family R Fam).
admit.
Qed.

(** from 48 Exercise 7: no function continuous precisely on countable dense set **)
(** LATEX VERSION: If D is countable dense in , no f: is continuous precisely on D. **)
Theorem ex48_7_no_function_continuous_on_countable_dense : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists f:set, function_on f R R /\
      (forall x:set, x :e D -> continuous_at f x) /\
      (forall x:set, x :e R -> x /:e D -> ~ continuous_at f x)).
admit.
Qed.

(** from 48 Exercise 8: pointwise limit continuous uncountably many points **)
(** LATEX VERSION: If f: continuous with f(x)f(x) for all x, then f is continuous at uncountably many points. **)
Definition pointwise_limit_of_sequence_of_functions : set -> set -> prop := fun fn f =>
  forall x:set, x :e R ->
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (Abs (add_SNo (apply_fun (apply_fun fn n) x) (minus_SNo (apply_fun f x)))) eps.
Theorem ex48_8_pointwise_limit_continuity : forall fn:set, forall f:set,
  (forall n:set, n :e omega ->
    continuous_map R R_standard_topology R R_standard_topology (apply_fun fn n)) ->
  function_on f R R ->
  pointwise_limit_of_sequence_of_functions fn f ->
  ~ countable_set {x :e R | continuous_at f x}.
admit.
Qed.

(** from 48 Exercise 9: Thomae function **)
(** LATEX VERSION: Define f(x)=1/n for rationals, f(x)=0 for irrationals. Then f is continuous at irrationals. **)
Theorem ex48_9_Thomae_function : forall g:set, forall f:set,
  (forall n:set, n :e omega -> apply_fun g n :e Q) ->
  function_on f R R ->
  (forall n:set, n :e omega -> apply_fun f (apply_fun g n) = recip_SNo (ordsucc n)) ->
  (forall x:set, x :e R -> x /:e Q -> apply_fun f x = 0) ->
  forall x:set, x :e R -> x /:e Q -> continuous_at f x.
admit.
Qed.

(** from 48 Exercise 10: uniform boundedness principle **)
(** LATEX VERSION: Uniform boundedness: if X complete metric and C(X,) pointwise bounded, then uniformly bounded on some nonempty open set. **)
Theorem ex48_10_uniform_boundedness : forall X d:set, forall FF:set,
  complete_metric_space X d ->
  FF c= Power (Power R) ->
  (forall a:set, a :e X ->
    exists M:set, M :e R /\
      forall f:set, f :e FF -> apply_fun f a :e R) ->
  exists U:set, exists M:set, U :e (metric_topology X d) /\ U <> Empty /\
    M :e R /\
    forall f:set, f :e FF ->
      forall x:set, x :e U -> apply_fun f x :e R.
admit.
Qed.

(** from 48 Exercise 11: is R_l a Baire space **)
(** LATEX VERSION: Determine whether _ is a Baire space. **)
(** FIXED: Use the existing lower limit topology constant R_lower_limit_topology. **)
Theorem ex48_11_Rl_Baire : Baire_space R R_lower_limit_topology.
admit.
Qed.

(** from 49 Exercise 1: verify properties of example functions **)
(** LATEX VERSION: Check the stated properties of the functions f, g, and k of Example 1. **)
(** note: Example 1 functions are still abstractly named; continuity is derived from membership in C(I,R) **)
(** from 49 Exercise 1: choose the named example functions f, g, k **)
(** LATEX VERSION: Example 1 defines three specific continuous maps f,g,k from [0,1] to R. **)
(** note: the explicit formulas are not formalized; we select functions via Eps_i from C(I,R) **)
Definition ex49_example1_f : set := Eps_i (fun f:set => f :e C_I_R).
Definition ex49_example1_g : set := Eps_i (fun g:set => g :e C_I_R).
Definition ex49_example1_k : set := Eps_i (fun k:set => k :e C_I_R).

(** helper: C(I,R) is nonempty **)
(** LATEX VERSION: Constant functions are continuous, so C(I,R) is nonempty. **)
Theorem C_I_R_nonempty : exists f:set, f :e C_I_R.
admit.
Qed.
Theorem ex49_example1_f_in_C_I_R : ex49_example1_f :e C_I_R.
admit.
Qed.
Theorem ex49_example1_g_in_C_I_R : ex49_example1_g :e C_I_R.
admit.
Qed.
Theorem ex49_example1_k_in_C_I_R : ex49_example1_k :e C_I_R.
admit.
Qed.
Theorem ex49_1_verify_example_functions :
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_f /\
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_g /\
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_k.
admit.
Qed.

(** from 49 Exercise 2: construct continuous function in U_n with bounded values **)
(** LATEX VERSION: Given n and , define continuous f:I such that fU and |f(x)| for all x. **)
(** stub: the analytic inequalities are not expanded here **)
Theorem ex49_2_construct_bounded_function : forall n:set, forall eps:set,
  n :e omega ->
  2 c= n ->
  eps :e R ->
  exists f:set,
    continuous_map unit_interval I_topology R R_standard_topology f /\
    (forall x:set, x :e unit_interval -> apply_fun f x :e R) /\
    f :e U_n n /\
    (forall x:set, x :e unit_interval -> Rle (Abs (apply_fun f x)) eps).
admit.
Qed.

(** from 50 Exercises: dimension theory introduction (placeholder) **) 
(** LATEX VERSION: Exercises introducing dimension theory concepts. **)
Definition ex50_dimension_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx n:set,
      p = setprod (setprod X Tx) n /\ topology_on X Tx /\ ordinal n}.



End Topology.

Section AlgTop.

(** ============================================================ **)
(** Chapter 9: The Fundamental Group                             **)
(** Formalizing Munkres Topology Chapters 9-14 (algtop.tex)      **)
(** ============================================================ **)

(** ============================================================ **)
(** S51 Homotopy of Paths                                        **)
(** ============================================================ **)

(** from S51 Definition (line 90 in algtop.tex): homotopy between continuous maps **)
(** LATEX VERSION: If f and f' are continuous maps of X into Y, f is homotopic to f' if there is a continuous map F: X x I -> Y with F(x,0)=f(x) and F(x,1)=f'(x). The map F is called a homotopy. **)
Definition homotopic_maps : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f f' =>
    continuous_map X Tx Y Ty f /\
    continuous_map X Tx Y Ty f' /\
    exists F:set,
      continuous_map (setprod X unit_interval)
        (product_topology X Tx unit_interval unit_interval_topology)
        Y Ty F /\
      (forall x:set, x :e X ->
        apply_fun F (x, 0) = apply_fun f x) /\
      (forall x:set, x :e X ->
        apply_fun F (x, 1) = apply_fun f' x).

(** from S51 Definition (line 96 in algtop.tex): nulhomotopic map **)
(** LATEX VERSION: If f is homotopic to f' and f' is a constant map, we say that f is nulhomotopic. **)
Definition nulhomotopic : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    exists y0:set, y0 :e Y /\
      homotopic_maps X Tx Y Ty f (const_fun X y0).

(** from S51 Definition (line 104 in algtop.tex): path homotopy **)
(** LATEX VERSION: Two paths f and f' mapping I into X are path homotopic if they have the same initial point x0 and final point x1, and there is a continuous map F: I x I -> X with F(s,0)=f(s), F(s,1)=f'(s), F(0,t)=x0, F(1,t)=x1. **)
Definition path_homotopic : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx x0 x1 f f' =>
    continuous_map unit_interval unit_interval_topology X Tx f /\
    continuous_map unit_interval unit_interval_topology X Tx f' /\
    apply_fun f 0 = x0 /\ apply_fun f 1 = x1 /\
    apply_fun f' 0 = x0 /\ apply_fun f' 1 = x1 /\
    exists F:set,
      continuous_map unit_square unit_square_topology X Tx F /\
      (forall s:set, s :e unit_interval ->
        apply_fun F (s, 0) = apply_fun f s) /\
      (forall s:set, s :e unit_interval ->
        apply_fun F (s, 1) = apply_fun f' s) /\
      (forall t:set, t :e unit_interval ->
        apply_fun F (0, t) = x0) /\
      (forall t:set, t :e unit_interval ->
        apply_fun F (1, t) = x1).

(** from S51 Lemma 51.1 (line 125 in algtop.tex): homotopy and path homotopy are equivalence relations **)
(** LATEX VERSION: Lemma 51.1: The relations ~ and ~p are equivalence relations. **)

(** EFFORT: 2 lines textbook, difficulty 2/10, USD 30 **)
Theorem Lemma_51_1_homotopy_refl : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  homotopic_maps X Tx Y Ty f f.
admit.
Qed.

(** from S51 Lemma 51.1 (line 125 in algtop.tex): homotopy symmetry **)
(** EFFORT: 2 lines textbook, difficulty 3/10, USD 40 **)
Theorem Lemma_51_1_homotopy_sym : forall X Tx Y Ty f f':set,
  homotopic_maps X Tx Y Ty f f' ->
  homotopic_maps X Tx Y Ty f' f.
admit.
Qed.

(** from S51 Lemma 51.1 (line 125 in algtop.tex): homotopy transitivity **)
(** EFFORT: 5 lines textbook, difficulty 5/10, USD 100 **)
Theorem Lemma_51_1_homotopy_trans : forall X Tx Y Ty f f' f'':set,
  homotopic_maps X Tx Y Ty f f' ->
  homotopic_maps X Tx Y Ty f' f'' ->
  homotopic_maps X Tx Y Ty f f''.
admit.
Qed.

(** from S51 Lemma 51.1 (line 125 in algtop.tex): path homotopy reflexivity **)
(** EFFORT: 2 lines textbook, difficulty 2/10, USD 30 **)
Theorem Lemma_51_1_path_homotopy_refl : forall X Tx x0 x1 f:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  path_homotopic X Tx x0 x1 f f.
admit.
Qed.

(** from S51 Lemma 51.1 (line 125 in algtop.tex): path homotopy symmetry **)
(** EFFORT: 2 lines textbook, difficulty 3/10, USD 40 **)
Theorem Lemma_51_1_path_homotopy_sym : forall X Tx x0 x1 f f':set,
  path_homotopic X Tx x0 x1 f f' ->
  path_homotopic X Tx x0 x1 f' f.
admit.
Qed.

(** from S51 Lemma 51.1 (line 125 in algtop.tex): path homotopy transitivity **)
(** EFFORT: 6 lines textbook, difficulty 5/10, USD 100 **)
Theorem Lemma_51_1_path_homotopy_trans : forall X Tx x0 x1 f f' f'':set,
  path_homotopic X Tx x0 x1 f f' ->
  path_homotopic X Tx x0 x1 f' f'' ->
  path_homotopic X Tx x0 x1 f f''.
admit.
Qed.

(** from S51 Definition (line 200 in algtop.tex): product of paths **)
(** LATEX VERSION: If f is a path from x0 to x1 and g is a path from x1 to x2, define the product fg by h(s)=f(2s) for s in the left half, g(2s-1) for s in the right half. **)
Definition path_concat : set -> set -> set :=
  fun f g =>
    {(t, apply_fun f (mul_SNo 2 t)) | t :e unit_interval_left_half}
    :\/:
    {(t, apply_fun g (add_SNo (mul_SNo 2 t) (minus_SNo 1))) | t :e unit_interval_right_half}.

(** helper: reverse of a path **)
(** from S51 (line 240 in algtop.tex): fbar(s) = f(1-s) **)
(** LATEX VERSION: Given path f from x0 to x1, define the reverse fbar by fbar(s) = f(1-s). **)
Definition reverse_path : set -> set :=
  fun f => compose_fun unit_interval flip_unit_interval f.

(** helper: constant path at a point **)
(** LATEX VERSION: e_x denotes the constant path at x, carrying all of I to x. **)
Definition constant_path : set -> set := fun x => const_fun unit_interval x.

(** from S51 (line 200 in algtop.tex): path product is continuous **)
(** EFFORT: 6 lines textbook, difficulty 6/10, USD 120 **)
Theorem path_concat_continuous : forall X Tx x0 x1 x2 f g:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  continuous_map unit_interval unit_interval_topology X Tx g ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  apply_fun g 0 = x1 -> apply_fun g 1 = x2 ->
  continuous_map unit_interval unit_interval_topology X Tx (path_concat f g).
admit.
Qed.

(** from S51 (line 200 in algtop.tex): path product starts at f(0) **)
(** EFFORT: 3 lines textbook, difficulty 4/10, USD 50 **)
Theorem path_concat_at_zero : forall f g:set,
  apply_fun (path_concat f g) 0 = apply_fun f 0.
admit.
Qed.

(** from S51 (line 200 in algtop.tex): path product ends at g(1) **)
(** EFFORT: 3 lines textbook, difficulty 4/10, USD 50 **)
Theorem path_concat_at_one : forall f g:set,
  apply_fun (path_concat f g) 1 = apply_fun g 1.
admit.
Qed.

(** from S51 (line 208 in algtop.tex): path product is well-defined on homotopy classes **)
(** LATEX VERSION: [f] times [g] = [f times g] is well-defined on path-homotopy classes. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem path_concat_well_defined_on_classes : forall X Tx x0 x1 x2 f f' g g':set,
  path_homotopic X Tx x0 x1 f f' ->
  path_homotopic X Tx x1 x2 g g' ->
  path_homotopic X Tx x0 x2 (path_concat f g) (path_concat f' g').
admit.
Qed.

(** from S51 Theorem 51.2 (line 232 in algtop.tex): groupoid properties of the path product **)
(** LATEX VERSION: Theorem 51.2: The path product operation has: (1) Associativity, (2) Right and left identities, (3) Inverse. **)

(** part (1): Associativity **)
(** EFFORT: 15 lines textbook, difficulty 7/10, USD 250 **)
Theorem Theorem_51_2_associativity : forall X Tx x0 x1 x2 x3 f g h:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  continuous_map unit_interval unit_interval_topology X Tx g ->
  continuous_map unit_interval unit_interval_topology X Tx h ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  apply_fun g 0 = x1 -> apply_fun g 1 = x2 ->
  apply_fun h 0 = x2 -> apply_fun h 1 = x3 ->
  path_homotopic X Tx x0 x3
    (path_concat f (path_concat g h))
    (path_concat (path_concat f g) h).
admit.
Qed.

(** from S51 Theorem 51.2 part (2) (line 232 in algtop.tex): right identity **)
(** EFFORT: 8 lines textbook, difficulty 6/10, USD 150 **)
Theorem Theorem_51_2_right_identity : forall X Tx x0 x1 f:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  x1 :e X ->
  path_homotopic X Tx x0 x1 (path_concat f (constant_path x1)) f.
admit.
Qed.

(** from S51 Theorem 51.2 part (2) (line 232 in algtop.tex): left identity **)
(** EFFORT: 8 lines textbook, difficulty 6/10, USD 150 **)
Theorem Theorem_51_2_left_identity : forall X Tx x0 x1 f:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  x0 :e X ->
  path_homotopic X Tx x0 x1 (path_concat (constant_path x0) f) f.
admit.
Qed.

(** from S51 Theorem 51.2 part (3) (line 232 in algtop.tex): right inverse **)
(** EFFORT: 8 lines textbook, difficulty 6/10, USD 150 **)
Theorem Theorem_51_2_right_inverse : forall X Tx x0 x1 f:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  path_homotopic X Tx x0 x0 (path_concat f (reverse_path f)) (constant_path x0).
admit.
Qed.

(** from S51 Theorem 51.2 part (3) (line 232 in algtop.tex): left inverse **)
(** EFFORT: 8 lines textbook, difficulty 6/10, USD 150 **)
Theorem Theorem_51_2_left_inverse : forall X Tx x0 x1 f:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  path_homotopic X Tx x1 x1 (path_concat (reverse_path f) f) (constant_path x1).
admit.
Qed.

(** from S51 Theorem 51.3 (line 321 in algtop.tex): reparametrization **)
(** LATEX VERSION: Let f be a path in X, and let a0,...,an with 0=a0<a1<...<an=1. Let fi be the path that equals the positive linear map of I onto [ai-1,ai] followed by f. Then [f]=[f1] times ... times [fn]. **)
(** EFFORT: 12 lines textbook, difficulty 7/10, USD 250 **)
Theorem Theorem_51_3_reparametrization : forall X Tx x0 x1 f a:set,
  continuous_map unit_interval unit_interval_topology X Tx f ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  a :e unit_interval -> Rlt 0 a -> Rlt a 1 ->
  exists f1 f2:set,
    continuous_map unit_interval unit_interval_topology X Tx f1 /\
    continuous_map unit_interval unit_interval_topology X Tx f2 /\
    apply_fun f1 0 = x0 /\ apply_fun f1 1 = apply_fun f a /\
    apply_fun f2 0 = apply_fun f a /\ apply_fun f2 1 = x1 /\
    path_homotopic X Tx x0 x1 f (path_concat f1 f2).
admit.
Qed.

(** from S51 Example 1 (line 150 in algtop.tex): straight-line homotopy **)
(** LATEX VERSION: In any convex subspace A of Rn, any two paths f,g from x0 to x1 are path homotopic via F(x,t)=(1-t)f(x)+tg(x). **)
(** EFFORT: 5 lines textbook, difficulty 5/10, USD 80 **)
Theorem Example_51_1_convex_paths_homotopic : forall A Ta x0 x1 f g:set,
  A c= R -> convex_in R A ->
  topology_on A Ta ->
  continuous_map unit_interval unit_interval_topology A Ta f ->
  continuous_map unit_interval unit_interval_topology A Ta g ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  apply_fun g 0 = x0 -> apply_fun g 1 = x1 ->
  path_homotopic A Ta x0 x1 f g.
admit.
Qed.

(** S51 Exercises **)

(** from S51 Exercise 1 (line 329 in algtop.tex) **)
(** LATEX VERSION: If h,h': X->Y are homotopic and k,k': Y->Z are homotopic, then k o h and k' o h' are homotopic. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex51_1_composition_homotopic : forall X Tx Y Ty Z Tz h h' k k':set,
  homotopic_maps X Tx Y Ty h h' ->
  homotopic_maps Y Ty Z Tz k k' ->
  homotopic_maps X Tx Z Tz (compose_fun X h k) (compose_fun X h' k').
admit.
Qed.

(** from S51 Exercise 2a (line 331 in algtop.tex) **)
(** LATEX VERSION: For any X, the set [X, I] has a single element. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex51_2a_maps_to_I : forall X Tx f g:set,
  continuous_map X Tx unit_interval unit_interval_topology f ->
  continuous_map X Tx unit_interval unit_interval_topology g ->
  homotopic_maps X Tx unit_interval unit_interval_topology f g.
admit.
Qed.

(** from S51 Exercise 2b (line 332 in algtop.tex) **)
(** LATEX VERSION: If Y is path connected, the set [I, Y] has a single element. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex51_2b_maps_from_I_path_connected : forall Y Ty f g:set,
  path_connected_space Y Ty ->
  continuous_map unit_interval unit_interval_topology Y Ty f ->
  continuous_map unit_interval unit_interval_topology Y Ty g ->
  homotopic_maps unit_interval unit_interval_topology Y Ty f g.
admit.
Qed.

(** from S51 Exercise 3 (line 333 in algtop.tex): contractible spaces **)
(** LATEX VERSION: A space X is said to be contractible if the identity map iX: X->X is nulhomotopic. **)
Definition contractible_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  nulhomotopic X Tx X Tx (graph X (fun x:set => x)).

(** from S51 Exercise 3a (line 334 in algtop.tex) **)
(** LATEX VERSION: I and R are contractible. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex51_3a_I_contractible : contractible_space unit_interval unit_interval_topology.
admit.
Qed.

(** from S51 Exercise 3(a) (line 327 in algtop.tex): R is contractible **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex51_3a_R_contractible : contractible_space R R_standard_topology.
admit.
Qed.

(** from S51 Exercise 3b (line 335 in algtop.tex) **)
(** LATEX VERSION: A contractible space is path connected. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex51_3b_contractible_path_connected : forall X Tx:set,
  contractible_space X Tx -> path_connected_space X Tx.
admit.
Qed.

(** from S51 Exercise 3c (line 336 in algtop.tex) **)
(** LATEX VERSION: If Y is contractible, then for any X, the set [X,Y] has a single element. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex51_3c_contractible_codomain : forall X Tx Y Ty f g:set,
  contractible_space Y Ty ->
  continuous_map X Tx Y Ty f ->
  continuous_map X Tx Y Ty g ->
  homotopic_maps X Tx Y Ty f g.
admit.
Qed.

(** from S51 Exercise 3d (line 337 in algtop.tex) **)
(** LATEX VERSION: If X is contractible and Y is path connected, then [X,Y] has a single element. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex51_3d_contractible_domain : forall X Tx Y Ty f g:set,
  contractible_space X Tx ->
  path_connected_space Y Ty ->
  continuous_map X Tx Y Ty f ->
  continuous_map X Tx Y Ty g ->
  homotopic_maps X Tx Y Ty f g.
admit.
Qed.

(** ============================================================ **)
(** S52 The Fundamental Group                                    **)
(** ============================================================ **)

(** helper: predicate for a group structure on a set G **)
Definition group_structure : set -> set -> set -> set -> prop :=
  fun G mult e inv =>
    function_on mult (setprod G G) G /\
    function_on inv G G /\
    e :e G /\
    (forall x y z:set, x :e G -> y :e G -> z :e G ->
      apply_fun mult (apply_fun mult (x, y), z) = apply_fun mult (x, apply_fun mult (y, z))) /\
    (forall x:set, x :e G -> apply_fun mult (e, x) = x /\ apply_fun mult (x, e) = x) /\
    (forall x:set, x :e G ->
      apply_fun mult (x, apply_fun inv x) = e /\ apply_fun mult (apply_fun inv x, x) = e).

(** helper: group homomorphism **)
Definition group_homomorphism : set -> set -> set -> set -> set -> prop :=
  fun G1 mult1 G2 mult2 phi =>
    function_on phi G1 G2 /\
    (forall x y:set, x :e G1 -> y :e G1 ->
      apply_fun phi (apply_fun mult1 (x, y)) = apply_fun mult2 (apply_fun phi x, apply_fun phi y)).

(** helper: group isomorphism **)
Definition group_isomorphism : set -> set -> set -> set -> set -> prop :=
  fun G1 mult1 G2 mult2 phi =>
    group_homomorphism G1 mult1 G2 mult2 phi /\
    bijection G1 G2 phi.

(** helper: a loop based at x0 **)
Definition loop_at : set -> set -> set -> set -> prop :=
  fun X Tx x0 f =>
    continuous_map unit_interval unit_interval_topology X Tx f /\
    apply_fun f 0 = x0 /\ apply_fun f 1 = x0.

(** helper: the set of all continuous loops based at x0 **)
Definition loop_space : set -> set -> set -> set :=
  fun X Tx x0 =>
    {f :e function_space unit_interval X |
      loop_at X Tx x0 f}.

(** helper: the path homotopy equivalence class of a loop **)
Definition path_homotopy_class_loop : set -> set -> set -> set -> set :=
  fun X Tx x0 f =>
    {g :e loop_space X Tx x0 | path_homotopic X Tx x0 x0 f g}.

(** from S52 Definition (line 358 in algtop.tex): the fundamental group **)
(** LATEX VERSION: The set of path homotopy classes of loops based at x0, with the path product operation, is called the fundamental group of X relative to x0, denoted pi1(X, x0). **)
Definition fundamental_group : set -> set -> set -> set :=
  fun X Tx x0 =>
    {path_homotopy_class_loop X Tx x0 f | f :e loop_space X Tx x0}.

(** helper: the multiplication on fundamental_group **)
Definition fundamental_group_mult : set -> set -> set -> set :=
  fun X Tx x0 =>
    graph (setprod (fundamental_group X Tx x0) (fundamental_group X Tx x0))
      (fun p:set =>
        path_homotopy_class_loop X Tx x0
          (path_concat
            (Eps_i (fun f:set => f :e p 0))
            (Eps_i (fun g:set => g :e p 1)))).

(** helper: the identity element of fundamental_group **)
Definition fundamental_group_id : set -> set -> set -> set :=
  fun X Tx x0 =>
    path_homotopy_class_loop X Tx x0 (constant_path x0).

(** helper: the inverse operation on fundamental_group **)
Definition fundamental_group_inv : set -> set -> set -> set :=
  fun X Tx x0 =>
    graph (fundamental_group X Tx x0)
      (fun cls:set =>
        path_homotopy_class_loop X Tx x0
          (reverse_path (Eps_i (fun f:set => f :e cls)))).

(** from S52 (line 361 in algtop.tex): the fundamental group is a group **)
(** LATEX VERSION: It follows from Theorem 51.2 that the path product, when restricted to loops at x0, satisfies the axioms for a group. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem fundamental_group_is_group : forall X Tx x0:set,
  topology_on X Tx -> x0 :e X ->
  group_structure
    (fundamental_group X Tx x0)
    (fundamental_group_mult X Tx x0)
    (fundamental_group_id X Tx x0)
    (fundamental_group_inv X Tx x0).
admit.
Qed.

(** from S52 Example 1 (line 365 in algtop.tex): pi1(Rn, x0) is trivial **)
(** LATEX VERSION: pi1(Rn, x0) is the trivial group. More generally, if X is any convex subset of Rn, then pi1(X, x0) is trivial. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 50 **)
Theorem Example_52_1_convex_trivial_pi1 : forall A Ta x0:set,
  A c= R -> convex_in R A ->
  topology_on A Ta -> x0 :e A ->
  fundamental_group A Ta x0 = {fundamental_group_id A Ta x0}.
admit.
Qed.

(** from S52 Definition (line 374 in algtop.tex): the alpha-hat map for change of basepoint **)
(** LATEX VERSION: Let alpha be a path from x0 to x1. Define alpha-hat: pi1(X,x0) -> pi1(X,x1) by alpha-hat([f]) = [alpha-bar] . [f] . [alpha]. **)
Definition basepoint_change_map : set -> set -> set -> set -> set -> set :=
  fun X Tx x0 x1 alpha =>
    graph (fundamental_group X Tx x0)
      (fun cls:set =>
        path_homotopy_class_loop X Tx x1
          (path_concat (reverse_path alpha)
            (path_concat (Eps_i (fun f:set => f :e cls)) alpha))).

(** from S52 Theorem 52.1 (line 396 in algtop.tex): alpha-hat is a group isomorphism **)
(** LATEX VERSION: The map alpha-hat is a group isomorphism from pi1(X,x0) to pi1(X,x1). **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem Theorem_52_1_basepoint_isomorphism : forall X Tx x0 x1 alpha:set,
  topology_on X Tx ->
  continuous_map unit_interval unit_interval_topology X Tx alpha ->
  apply_fun alpha 0 = x0 -> apply_fun alpha 1 = x1 ->
  group_isomorphism
    (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
    (fundamental_group X Tx x1) (fundamental_group_mult X Tx x1)
    (basepoint_change_map X Tx x0 x1 alpha).
admit.
Qed.

(** from S52 Corollary 52.2 (line 418 in algtop.tex) **)
(** LATEX VERSION: If X is path connected and x0, x1 are two points of X, then pi1(X,x0) is isomorphic to pi1(X,x1). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem Corollary_52_2_path_connected_pi1_isomorphic : forall X Tx x0 x1:set,
  path_connected_space X Tx -> x0 :e X -> x1 :e X ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
      (fundamental_group X Tx x1) (fundamental_group_mult X Tx x1)
      phi.
admit.
Qed.

(** from S52 Definition (line 426 in algtop.tex): simply connected spaces **)
(** LATEX VERSION: A space X is simply connected if it is path connected and pi1(X,x0) is the trivial group for some (hence every) x0. **)
Definition simply_connected : set -> set -> prop := fun X Tx =>
  path_connected_space X Tx /\
  exists x0:set, x0 :e X /\
    fundamental_group X Tx x0 = {fundamental_group_id X Tx x0}.

(** from S52 Lemma 52.3 (line 428 in algtop.tex) **)
(** LATEX VERSION: In a simply connected space X, any two paths having the same initial and final points are path homotopic. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem Lemma_52_3_simply_connected_unique_homotopy : forall X Tx x0 x1 f g:set,
  simply_connected X Tx ->
  continuous_map unit_interval unit_interval_topology X Tx f ->
  continuous_map unit_interval unit_interval_topology X Tx g ->
  apply_fun f 0 = x0 -> apply_fun f 1 = x1 ->
  apply_fun g 0 = x0 -> apply_fun g 1 = x1 ->
  path_homotopic X Tx x0 x1 f g.
admit.
Qed.

(** from S52 Definition (line 446 in algtop.tex): the induced homomorphism **)
(** LATEX VERSION: Let h: (X,x0) -> (Y,y0) be continuous. Define h-star: pi1(X,x0) -> pi1(Y,y0) by h-star([f]) = [h o f]. **)
Definition induced_homomorphism : set -> set -> set -> set -> set -> set -> set -> set :=
  fun X Tx x0 Y Ty y0 h =>
    graph (fundamental_group X Tx x0)
      (fun cls:set =>
        path_homotopy_class_loop Y Ty y0
          (compose_fun unit_interval (Eps_i (fun f:set => f :e cls)) h)).

(** from S52 (line 458 in algtop.tex): h-star is a homomorphism **)
(** LATEX VERSION: The map h-star is a well-defined group homomorphism. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem induced_homomorphism_is_homomorphism : forall X Tx x0 Y Ty y0 h:set,
  continuous_map X Tx Y Ty h ->
  apply_fun h x0 = y0 -> x0 :e X ->
  group_homomorphism
    (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
    (fundamental_group Y Ty y0) (fundamental_group_mult Y Ty y0)
    (induced_homomorphism X Tx x0 Y Ty y0 h).
admit.
Qed.

(** from S52 Theorem 52.4 (line 475 in algtop.tex): functorial properties **)
(** LATEX VERSION: If h: (X,x0)->(Y,y0) and k: (Y,y0)->(Z,z0) are continuous, then (k o h)-star = k-star o h-star. If i is the identity, then i-star is the identity. **)

(** EFFORT: 4 lines textbook, difficulty 2/10, USD 30 **)
Theorem Theorem_52_4_functorial_composition : forall X Tx x0 Y Ty y0 Z Tz z0 h k:set,
  continuous_map X Tx Y Ty h -> continuous_map Y Ty Z Tz k ->
  apply_fun h x0 = y0 -> apply_fun k y0 = z0 -> x0 :e X ->
  forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Z Tz z0 (compose_fun X h k)) cls
    = apply_fun (compose_fun (fundamental_group X Tx x0)
        (induced_homomorphism X Tx x0 Y Ty y0 h)
        (induced_homomorphism Y Ty y0 Z Tz z0 k)) cls.
admit.
Qed.

(** from S52 Theorem 52.4 (line 475 in algtop.tex): identity induces identity **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 15 **)
Theorem Theorem_52_4_functorial_identity : forall X Tx x0:set,
  topology_on X Tx -> x0 :e X ->
  forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 X Tx x0 (graph X (fun x:set => x))) cls = cls.
admit.
Qed.

(** from S52 Corollary 52.5 (line 488 in algtop.tex) **)
(** LATEX VERSION: If h: (X,x0)->(Y,y0) is a homeomorphism, then h-star is an isomorphism. **)
(** EFFORT: 4 lines textbook, difficulty 2/10, USD 30 **)
Theorem Corollary_52_5_homeomorphism_isomorphism : forall X Tx x0 Y Ty y0 h:set,
  homeomorphism X Tx Y Ty h ->
  apply_fun h x0 = y0 -> x0 :e X ->
  group_isomorphism
    (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
    (fundamental_group Y Ty y0) (fundamental_group_mult Y Ty y0)
    (induced_homomorphism X Tx x0 Y Ty y0 h).
admit.
Qed.

(** S52 Exercises **)

(** from S52 Exercise 1 (line 494 in algtop.tex): star convex **)
(** LATEX VERSION: A subset A of Rn is star convex if for some a0, all line segments joining a0 to other points of A lie in A. **)
Definition star_convex : set -> set -> prop := fun A a0 =>
  A c= R /\ a0 :e A /\
  (forall a:set, a :e A ->
    forall t:set, t :e unit_interval ->
      add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) a0) (mul_SNo t a) :e A).

(** from S52 Exercise 1a (line 495 in algtop.tex) **)
(** LATEX VERSION: Find a star convex set that is not convex. **)
(** Note: formulated in R2 since star convex but not convex requires dimension >= 2 **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 10 **)
Theorem ex52_1a_star_convex_not_convex :
  exists A:set, exists a0:set,
    A c= EuclidPlane /\
    a0 :e A /\
    (forall a:set, a :e A ->
      forall t:set, t :e unit_interval ->
        (add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (R2_xcoord a0)) (mul_SNo t (R2_xcoord a)),
         add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (R2_ycoord a0)) (mul_SNo t (R2_ycoord a))) :e A) /\
    (exists x y:set, x :e A /\ y :e A /\
      exists t:set, t :e unit_interval /\
        ~(add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (R2_xcoord x)) (mul_SNo t (R2_xcoord y)),
          add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (R2_ycoord x)) (mul_SNo t (R2_ycoord y))) :e A).
admit.
Qed.

(** from S52 Exercise 1b (line 496 in algtop.tex) **)
(** LATEX VERSION: If A is star convex, A is simply connected. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex52_1b_star_convex_simply_connected : forall A Ta a0:set,
  star_convex A a0 ->
  topology_on A Ta ->
  simply_connected A Ta.
admit.
Qed.

(** from S52 Exercise 2 (line 497 in algtop.tex) **)
(** LATEX VERSION: If gamma = alpha . beta, then gamma-hat = beta-hat o alpha-hat. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex52_2_basepoint_composition : forall X Tx x0 x1 x2 alpha beta:set,
  topology_on X Tx ->
  continuous_map unit_interval unit_interval_topology X Tx alpha ->
  continuous_map unit_interval unit_interval_topology X Tx beta ->
  apply_fun alpha 0 = x0 -> apply_fun alpha 1 = x1 ->
  apply_fun beta 0 = x1 -> apply_fun beta 1 = x2 ->
  forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (basepoint_change_map X Tx x0 x2 (path_concat alpha beta)) cls
    = apply_fun (compose_fun (fundamental_group X Tx x0)
        (basepoint_change_map X Tx x0 x1 alpha)
        (basepoint_change_map X Tx x1 x2 beta)) cls.
admit.
Qed.

(** from S52 Exercise 3 (line 498 in algtop.tex) **)
(** LATEX VERSION: pi1(X,x0) is abelian iff for every pair alpha, beta of paths from x0 to x1, alpha-hat = beta-hat. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex52_3_abelian_iff_unique_basepoint_change : forall X Tx x0:set,
  path_connected_space X Tx -> x0 :e X ->
  ((forall a b:set, a :e fundamental_group X Tx x0 -> b :e fundamental_group X Tx x0 ->
      apply_fun (fundamental_group_mult X Tx x0) (a, b)
      = apply_fun (fundamental_group_mult X Tx x0) (b, a))
   <->
   (forall x1 alpha beta:set, x1 :e X ->
      continuous_map unit_interval unit_interval_topology X Tx alpha ->
      continuous_map unit_interval unit_interval_topology X Tx beta ->
      apply_fun alpha 0 = x0 -> apply_fun alpha 1 = x1 ->
      apply_fun beta 0 = x0 -> apply_fun beta 1 = x1 ->
      forall cls:set, cls :e fundamental_group X Tx x0 ->
        apply_fun (basepoint_change_map X Tx x0 x1 alpha) cls
        = apply_fun (basepoint_change_map X Tx x0 x1 beta) cls)).
admit.
Qed.

(** from S52 Exercise 4 (line 499 in algtop.tex): retraction and pi1 **)
(** LATEX VERSION: Let r: X -> A be a retraction. If a0 in A, show that r-star: pi1(X,a0) -> pi1(A,a0) is surjective. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex52_4_retraction_surjective_pi1 : forall X Tx A Ta a0 r:set,
  topology_on X Tx -> A c= X ->
  Ta = subspace_topology X Tx A ->
  continuous_map X Tx A Ta r ->
  (forall a:set, a :e A -> apply_fun r a = a) ->
  a0 :e A ->
  forall cls:set, cls :e fundamental_group A Ta a0 ->
    exists cls':set, cls' :e fundamental_group X Tx a0 /\
      apply_fun (induced_homomorphism X Tx a0 A Ta a0 r) cls' = cls.
admit.
Qed.

(** from S52 Exercise 5 (line 507 in algtop.tex) **)
(** LATEX VERSION: If h: (A,a0)->(Y,y0) is extendable to Rn, then h-star is the trivial homomorphism. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex52_5_extendable_trivial : forall A Ta a0 Y Ty y0 h:set,
  A c= R ->
  topology_on A Ta -> topology_on Y Ty ->
  continuous_map A Ta Y Ty h ->
  apply_fun h a0 = y0 -> a0 :e A ->
  (exists H:set, continuous_map R R_standard_topology Y Ty H /\
    (forall a:set, a :e A -> apply_fun H a = apply_fun h a)) ->
  forall cls:set, cls :e fundamental_group A Ta a0 ->
    apply_fun (induced_homomorphism A Ta a0 Y Ty y0 h) cls = fundamental_group_id Y Ty y0.
admit.
Qed.

(** from S52 Exercise 6 (line 508 in algtop.tex) **)
(** LATEX VERSION: If X path connected, h: X->Y continuous, alpha path from x0 to x1, beta=h o alpha, then beta-hat o (h_x0)-star = (h_x1)-star o alpha-hat. **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex52_6_naturality : forall X Tx x0 x1 Y Ty y0 y1 h alpha:set,
  path_connected_space X Tx ->
  continuous_map X Tx Y Ty h ->
  continuous_map unit_interval unit_interval_topology X Tx alpha ->
  apply_fun alpha 0 = x0 -> apply_fun alpha 1 = x1 ->
  apply_fun h x0 = y0 -> apply_fun h x1 = y1 ->
  x0 :e X -> x1 :e X ->
  forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (basepoint_change_map Y Ty y0 y1 (compose_fun unit_interval alpha h))
      (apply_fun (induced_homomorphism X Tx x0 Y Ty y0 h) cls)
    = apply_fun (induced_homomorphism X Tx x1 Y Ty y1 h)
        (apply_fun (basepoint_change_map X Tx x0 x1 alpha) cls).
admit.
Qed.

(** from S52 Exercise 7 (line 516-526 in algtop.tex): topological group pi1 abelian **)
(** LATEX VERSION: Let G be a topological group with identity x0. Define f tensor g by **)
(** (f tensor g)(s) = f(s) . g(s). (a) This makes loops into a group. **)
(** (b) It induces a group operation on pi1. (c) The operations star and tensor agree. **)
(** (d) pi1(G, x0) is abelian. **)

(** from S52 Exercise 7(a) (line 516 in algtop.tex): tensor operation on loops is a group operation **)
(** EFFORT: 8 lines textbook, difficulty 3/10, USD 60 **)
Theorem ex52_7a_tensor_loop_group : forall G Tg:set,
  topological_group G Tg ->
  forall e mult inv:set,
  e :e G ->
  function_on mult (setprod G G) G ->
  function_on inv G G ->
  (forall x:set, x :e G -> apply_fun mult (e,x) = x /\ apply_fun mult (x,e) = x) ->
  (forall x:set, x :e G ->
    apply_fun mult (x, apply_fun inv x) = e /\ apply_fun mult (apply_fun inv x, x) = e) ->
  continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult ->
  forall f g:set,
    loop_at G Tg e f -> loop_at G Tg e g ->
    loop_at G Tg e
      (graph unit_interval (fun s:set => apply_fun mult (apply_fun f s, apply_fun g s))).
admit.
Qed.

(** from S52 Exercise 7(b) (line 516 in algtop.tex): tensor induces operation on pi1 **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex52_7b_tensor_induces_operation : forall G Tg:set,
  topological_group G Tg ->
  forall e mult:set,
  e :e G ->
  function_on mult (setprod G G) G ->
  continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult ->
  forall f f' g g':set,
    loop_at G Tg e f -> loop_at G Tg e g ->
    loop_at G Tg e f' -> loop_at G Tg e g' ->
    path_homotopic G Tg e e f f' ->
    path_homotopic G Tg e e g g' ->
    path_homotopic G Tg e e
      (graph unit_interval (fun s:set => apply_fun mult (apply_fun f s, apply_fun g s)))
      (graph unit_interval (fun s:set => apply_fun mult (apply_fun f' s, apply_fun g' s))).
admit.
Qed.

(** from S52 Exercise 7(c) (line 516 in algtop.tex): star and tensor agree on pi1 **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex52_7c_star_equals_tensor : forall G Tg:set,
  topological_group G Tg ->
  forall e mult:set,
  e :e G ->
  function_on mult (setprod G G) G ->
  (forall x:set, x :e G -> apply_fun mult (e,x) = x /\ apply_fun mult (x,e) = x) ->
  continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult ->
  forall f g:set,
    loop_at G Tg e f -> loop_at G Tg e g ->
    path_homotopic G Tg e e
      (path_concat f g)
      (graph unit_interval (fun s:set => apply_fun mult (apply_fun f s, apply_fun g s))).
admit.
Qed.

(** from S52 Exercise 7(d) (line 516 in algtop.tex): pi1 of a topological group is abelian **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex52_7d_topological_group_pi1_abelian : forall G Tg:set,
  topological_group G Tg ->
  forall e:set, e :e G ->
  (exists mult:set, function_on mult (setprod G G) G /\
    (forall x:set, x :e G -> apply_fun mult (e,x) = x /\ apply_fun mult (x,e) = x) /\
    continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult) ->
  forall cls1 cls2:set,
    cls1 :e fundamental_group G Tg e ->
    cls2 :e fundamental_group G Tg e ->
    apply_fun (fundamental_group_mult G Tg e) (cls1, cls2) =
    apply_fun (fundamental_group_mult G Tg e) (cls2, cls1).
admit.
Qed.

(** ================================================================ **)
(** S53: Covering Spaces (starting at line 528 in algtop.tex)       **)
(** ================================================================ **)

(** from S53 Definition (line 531 in algtop.tex) **)
(** LATEX VERSION: The open set U of B is evenly covered by p if p^{-1}(U) is a union of **)
(** disjoint open sets (slices) V_alpha in E, each mapped homeomorphically onto U by p. **)
Definition evenly_covered : set -> set -> set -> set -> set -> set -> prop :=
  fun E Te B Tb p U =>
    U :e Tb /\
    exists slices:set,
      slices c= Te /\
      pairwise_disjoint slices /\
      Union slices = preimage_of E p U /\
      (forall V:set, V :e slices ->
        homeomorphism V (subspace_topology E Te V) U (subspace_topology B Tb U)
          (graph V (fun x:set => apply_fun p x))).

(** from S53 Definition (line 543 in algtop.tex) **)
(** LATEX VERSION: If every point b of B has a neighborhood U that is evenly covered by p, **)
(** then p is called a covering map, and E is said to be a covering space of B. **)
Definition covering_map : set -> set -> set -> set -> set -> prop :=
  fun E Te B Tb p =>
    continuous_map E Te B Tb p /\
    surjective_map E B p /\
    (forall b:set, b :e B ->
      exists U:set, U :e Tb /\ b :e U /\ evenly_covered E Te B Tb p U).

(** from S53 text (line 533 in algtop.tex) **)
(** LATEX VERSION: If U is evenly covered by p and W is an open subset of U, **)
(** then W is also evenly covered by p. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem evenly_covered_open_subset : forall E Te B Tb p U W:set,
  evenly_covered E Te B Tb p U -> W :e Tb -> W c= U ->
  evenly_covered E Te B Tb p W.
admit.
Qed.

(** from S53 text (line 545 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map, then for each b in B **)
(** the subspace p^{-1}(b) of E has the discrete topology. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem covering_map_discrete_fibers : forall E Te B Tb p b:set,
  covering_map E Te B Tb p -> b :e B ->
  subspace_topology E Te {x :e E | apply_fun p x = b} =
    discrete_topology {x :e E | apply_fun p x = b}.
admit.
Qed.

(** from S53 text (line 547 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map, then p is an open map. **)
(** EFFORT: 6 lines textbook, difficulty 3/10, USD 50 **)
Theorem covering_map_is_open : forall E Te B Tb p:set,
  covering_map E Te B Tb p -> open_map E Te B Tb p.
admit.
Qed.

(** from S53 text (line 580 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map, then p is a local homeomorphism: **)
(** each point e of E has a neighborhood mapped homeomorphically onto an open set in B. **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 20 **)
Theorem covering_map_local_homeomorphism : forall E Te B Tb p e:set,
  covering_map E Te B Tb p -> e :e E ->
  exists U V:set, U :e Te /\ e :e U /\ V :e Tb /\
    homeomorphism U (subspace_topology E Te U) V (subspace_topology B Tb V)
      (graph U (fun x:set => apply_fun p x)).
admit.
Qed.

(** Infrastructure: Trigonometric functions cos and sin, jointly characterized **)
(** via the Pythagorean identity, initial values, and addition formulas **)
Definition cos_sin_pair : set := Eps_i (fun p:set =>
  function_on (p 0) R R /\ function_on (p 1) R R /\
  continuous_map R R_standard_topology R R_standard_topology (p 0) /\
  continuous_map R R_standard_topology R R_standard_topology (p 1) /\
  apply_fun (p 0) 0 = 1 /\
  apply_fun (p 1) 0 = 0 /\
  (forall x:set, x :e R ->
    add_SNo (mul_SNo (apply_fun (p 0) x) (apply_fun (p 0) x))
            (mul_SNo (apply_fun (p 1) x) (apply_fun (p 1) x)) = 1) /\
  (forall x y:set, x :e R -> y :e R ->
    apply_fun (p 0) (add_SNo x y) =
      add_SNo (mul_SNo (apply_fun (p 0) x) (apply_fun (p 0) y))
              (minus_SNo (mul_SNo (apply_fun (p 1) x) (apply_fun (p 1) y)))) /\
  (forall x y:set, x :e R -> y :e R ->
    apply_fun (p 1) (add_SNo x y) =
      add_SNo (mul_SNo (apply_fun (p 1) x) (apply_fun (p 0) y))
              (mul_SNo (apply_fun (p 0) x) (apply_fun (p 1) y)))).

(** The cosine function: first component of cos_sin_pair **)
Definition cos_real : set := cos_sin_pair 0.

(** The sine function: second component of cos_sin_pair **)
Definition sin_real : set := cos_sin_pair 1.

(** Infrastructure: the mathematical constant pi **)
(** Characterized as the smallest positive real where cos(pi) = -1, sin(pi) = 0 **)
Definition pi_real : set := Eps_i (fun p:set =>
  p :e R /\ Rlt 0 p /\
  apply_fun cos_real p = minus_SNo 1 /\
  apply_fun sin_real p = 0 /\
  (forall x:set, x :e R -> Rlt 0 x -> Rlt x p ->
    Rlt 0 (apply_fun sin_real x))).

(** Two times pi: the fundamental period of cos and sin **)
Definition two_pi : set := add_SNo pi_real pi_real.

(** Infrastructure: The unit circle S^1 = {(x,y) in R x R : x^2 + y^2 = 1} **)
Definition S1 : set :=
  {p :e setprod R R |
    add_SNo (mul_SNo (p 0) (p 0)) (mul_SNo (p 1) (p 1)) = 1}.

(** The standard product topology on R^2 = R x R **)
Definition R2_topology : set :=
  product_topology R R_standard_topology R R_standard_topology.

(** The subspace topology on S^1 inherited from R^2 **)
Definition S1_topology : set :=
  subspace_topology (setprod R R) R2_topology S1.

(** The standard covering map p: R -> S^1, p(x) = (cos 2pi x, sin 2pi x) **)
Definition covering_map_R_S1 : set :=
  graph R (fun x:set =>
    (apply_fun cos_real (mul_SNo two_pi x),
     apply_fun sin_real (mul_SNo two_pi x))).

(** from S53 Theorem 53.1 (line 553 in algtop.tex) **)
(** LATEX VERSION: The map p: R -> S^1 given by p(x) = (cos 2pi x, sin 2pi x) **)
(** is a covering map. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm53_1_R_covers_S1 :
  covering_map R R_standard_topology S1 S1_topology covering_map_R_S1.
admit.
Qed.

(** from S53 Theorem 53.2 (line 608 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be a covering map. If B0 is a subspace of B, **)
(** and E0 = p^{-1}(B0), then the restriction p0: E0 -> B0 is a covering map. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm53_2_subspace_covering : forall E Te B Tb p B0:set,
  covering_map E Te B Tb p -> B0 c= B ->
  covering_map
    (preimage_of E p B0)
    (subspace_topology E Te (preimage_of E p B0))
    B0
    (subspace_topology B Tb B0)
    (graph (preimage_of E p B0) (fun x:set => apply_fun p x)).
admit.
Qed.

(** Infrastructure: Product of two maps f x g : X x X' -> Y x Y' **)
(** sending (a, b) to (f(a), g(b)) **)
Definition product_of_maps : set -> set -> set -> set -> set := fun X X' f g =>
  graph (setprod X X') (fun p:set =>
    (apply_fun f (p 0), apply_fun g (p 1))).

(** from S53 Theorem 53.3 (line 612 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B and p': E' -> B' are covering maps, then **)
(** p x p': E x E' -> B x B' is a covering map. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm53_3_product_covering : forall E Te B Tb p E' Te' B' Tb' p':set,
  covering_map E Te B Tb p -> covering_map E' Te' B' Tb' p' ->
  covering_map
    (setprod E E') (product_topology E Te E' Te')
    (setprod B B') (product_topology B Tb B' Tb')
    (product_of_maps E E' p p').
admit.
Qed.

(** Infrastructure: complex multiplication on R^2 (viewing R^2 as C) **)
(** (a,b) times (c,d) = (ac - bd, ad + bc) **)
Definition complex_mult_R2 : set -> set -> set := fun z w =>
  (add_SNo (mul_SNo (z 0) (w 0)) (minus_SNo (mul_SNo (z 1) (w 1))),
   add_SNo (mul_SNo (z 0) (w 1)) (mul_SNo (z 1) (w 0))).

(** Infrastructure: complex n-th power on R^2 via repeated multiplication **)
(** z^0 = (1,0), z^(n+1) = z times z^n **)
Definition complex_power_R2 : set -> set -> set := fun z n =>
  nat_primrec (1, 0) (fun _ r => complex_mult_R2 z r) n.

(** Infrastructure: the map z -> z^n on S^1 **)
Definition S1_power_map : set -> set := fun n =>
  graph S1 (fun z:set => complex_power_R2 z n).

(** Infrastructure: k-fold covering (from Exercise 53.3 text, line 689 in algtop.tex) **)
Definition k_fold_covering : set -> set -> set -> set -> set -> set -> prop :=
  fun E Te B Tb p k =>
    covering_map E Te B Tb p /\
    k :e omega /\
    (forall b:set, b :e B -> equip {x :e E | apply_fun p x = b} k).

(** from S53 Exercise 1 (line 687 in algtop.tex) **)
(** LATEX VERSION: Let Y have the discrete topology. If p: X x Y -> X is projection **)
(** on the first coordinate, then p is a covering map. **)
(** EFFORT: 4 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex53_1_discrete_projection_covering : forall X Tx Y:set,
  topology_on X Tx -> Y <> Empty ->
  covering_map
    (setprod X Y) (product_topology X Tx Y (discrete_topology Y))
    X Tx (projection1 X Y).
admit.
Qed.

(** from S53 Exercise 2 (line 688 in algtop.tex) **)
(** LATEX VERSION: If U is connected and evenly covered by p, **)
(** then the partition of p^{-1}(U) into slices is unique. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex53_2_unique_partition : forall E Te B Tb p U:set,
  topology_on E Te -> topology_on B Tb ->
  connected_space U (subspace_topology B Tb U) ->
  U :e Tb ->
  forall slices1 slices2:set,
    slices1 c= Te -> pairwise_disjoint slices1 ->
    Union slices1 = preimage_of E p U ->
    (forall V:set, V :e slices1 ->
      homeomorphism V (subspace_topology E Te V) U (subspace_topology B Tb U)
        (graph V (fun x:set => apply_fun p x))) ->
    slices2 c= Te -> pairwise_disjoint slices2 ->
    Union slices2 = preimage_of E p U ->
    (forall V:set, V :e slices2 ->
      homeomorphism V (subspace_topology E Te V) U (subspace_topology B Tb U)
        (graph V (fun x:set => apply_fun p x))) ->
    slices1 = slices2.
admit.
Qed.

(** from S53 Exercise 3 (line 689 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be a covering map; B connected. If p^{-1}(b0) **)
(** has k elements for some b0 in B, then p^{-1}(b) has k elements for every b in B. **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex53_3_uniform_fiber_size : forall E Te B Tb p b0 k:set,
  covering_map E Te B Tb p ->
  connected_space B Tb ->
  b0 :e B -> k :e omega ->
  equip {x :e E | apply_fun p x = b0} k ->
  forall b:set, b :e B ->
    equip {x :e E | apply_fun p x = b} k.
admit.
Qed.

(** from S53 Exercise 4 (line 690 in algtop.tex) **)
(** LATEX VERSION: Let q: X -> Y and r: Y -> Z be covering maps; **)
(** if r^{-1}(z) is finite for each z in Z, then r o q is a covering map. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex53_4_composition_covering : forall X Tx Y Ty Z Tz q r:set,
  covering_map X Tx Y Ty q -> covering_map Y Ty Z Tz r ->
  (forall z:set, z :e Z -> finite {y :e Y | apply_fun r y = z}) ->
  covering_map X Tx Z Tz (compose_fun X q r).
admit.
Qed.

(** from S53 Exercise 5 (line 691 in algtop.tex) **)
(** LATEX VERSION: The map p(z) = z^n is a covering map S^1 -> S^1. **)
(** Generalized to all natural n >= 1. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex53_5_power_map_covering : forall n:set,
  n :e omega -> 0 :e n ->
  covering_map S1 S1_topology S1 S1_topology (S1_power_map n).
admit.
Qed.

(** from S53 Exercise 6a (line 692 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map and B is Hausdorff, then E is Hausdorff. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex53_6a_hausdorff : forall E Te B Tb p:set,
  covering_map E Te B Tb p -> Hausdorff_space B Tb -> Hausdorff_space E Te.
admit.
Qed.

(** from S53 Exercise 6a (line 692 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map and B is regular, then E is regular. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex53_6a_regular : forall E Te B Tb p:set,
  covering_map E Te B Tb p -> regular_space B Tb -> regular_space E Te.
admit.
Qed.

(** from S53 Exercise 6a (line 692 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map and B is completely regular, **)
(** then E is completely regular. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex53_6a_completely_regular : forall E Te B Tb p:set,
  covering_map E Te B Tb p -> completely_regular_space B Tb ->
  completely_regular_space E Te.
admit.
Qed.

(** from S53 Exercise 6a (line 692 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a covering map and B is locally compact Hausdorff, **)
(** then E is locally compact Hausdorff. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 60 **)
Theorem ex53_6a_locally_compact_hausdorff : forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  locally_compact B Tb -> Hausdorff_space B Tb ->
  locally_compact E Te /\ Hausdorff_space E Te.
admit.
Qed.

(** from S53 Exercise 6b (line 694 in algtop.tex) **)
(** LATEX VERSION: If B is compact and p^{-1}(b) is finite for each b in B, **)
(** then E is compact. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex53_6b_compact_finite_fiber : forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  compact_space B Tb ->
  (forall b:set, b :e B -> finite {x :e E | apply_fun p x = b}) ->
  compact_space E Te.
admit.
Qed.

(** ================================================================ **)
(** S54: The Fundamental Group of the Circle                         **)
(** (starting at line 697 in algtop.tex)                             **)
(** ================================================================ **)

(** from S54 Definition (line 700 in algtop.tex) **)
(** LATEX VERSION: If p: E -> B is a map and f: X -> B is continuous, **)
(** a lifting of f is a map f_tilde: X -> E such that p o f_tilde = f. **)
Definition lifting_of : set -> set -> set -> set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx E Te B Tb p f f_tilde =>
    continuous_map X Tx E Te f_tilde /\
    (forall x:set, x :e X -> apply_fun p (apply_fun f_tilde x) = apply_fun f x).

(** Infrastructure: the unique lift of a path in B starting at e0 in E **)
(** Uses Eps_i to select the lift guaranteed by Lemma 54.1 **)
Definition path_lift : set -> set -> set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p e0 f =>
    Eps_i (fun ft:set =>
      continuous_map unit_interval unit_interval_topology E Te ft /\
      apply_fun ft 0 = e0 /\
      (forall t:set, t :e unit_interval ->
        apply_fun p (apply_fun ft t) = apply_fun f t)).

(** from S54 Lemma 54.1 (line 715 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be a covering map, p(e0) = b0. Any path f:[0,1] -> B **)
(** beginning at b0 has a unique lifting to a path in E beginning at e0. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 120 **)
Theorem lemma54_1_path_lifting : forall E Te B Tb p e0 f:set,
  covering_map E Te B Tb p ->
  e0 :e E -> apply_fun p e0 = apply_fun f 0 ->
  continuous_map unit_interval unit_interval_topology B Tb f ->
  continuous_map unit_interval unit_interval_topology E Te (path_lift E Te B Tb p e0 f) /\
  apply_fun (path_lift E Te B Tb p e0 f) 0 = e0 /\
  (forall t:set, t :e unit_interval ->
    apply_fun p (apply_fun (path_lift E Te B Tb p e0 f) t) = apply_fun f t).
admit.
Qed.

(** from S54 Lemma 54.1 uniqueness (line 728 in algtop.tex) **)
(** LATEX VERSION: The lifting of a path is unique. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma54_1_path_lifting_unique : forall E Te B Tb p e0 f ft1 ft2:set,
  covering_map E Te B Tb p ->
  e0 :e E ->
  continuous_map unit_interval unit_interval_topology B Tb f ->
  lifting_of unit_interval unit_interval_topology E Te B Tb p f ft1 ->
  apply_fun ft1 0 = e0 ->
  lifting_of unit_interval unit_interval_topology E Te B Tb p f ft2 ->
  apply_fun ft2 0 = e0 ->
  forall t:set, t :e unit_interval -> apply_fun ft1 t = apply_fun ft2 t.
admit.
Qed.

(** Infrastructure: the unique lift of a homotopy F: I x I -> B starting at e0 **)
Definition homotopy_lift : set -> set -> set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p e0 F =>
    Eps_i (fun Ft:set =>
      continuous_map unit_square unit_square_topology E Te Ft /\
      apply_fun Ft (0, 0) = e0 /\
      (forall s t:set, s :e unit_interval -> t :e unit_interval ->
        apply_fun p (apply_fun Ft (s, t)) = apply_fun F (s, t))).

(** from S54 Lemma 54.2 (line 730 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be a covering map; p(e0) = b0. Let F: I x I -> B be **)
(** continuous with F(0,0) = b0. There is a unique lifting F_tilde: I x I -> E with **)
(** F_tilde(0,0) = e0. If F is a path homotopy, then F_tilde is a path homotopy. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 200 **)
Theorem lemma54_2_homotopy_lifting : forall E Te B Tb p e0 F:set,
  covering_map E Te B Tb p ->
  e0 :e E -> apply_fun p e0 = apply_fun F (0, 0) ->
  continuous_map unit_square unit_square_topology B Tb F ->
  continuous_map unit_square unit_square_topology E Te (homotopy_lift E Te B Tb p e0 F) /\
  apply_fun (homotopy_lift E Te B Tb p e0 F) (0, 0) = e0 /\
  (forall s t:set, s :e unit_interval -> t :e unit_interval ->
    apply_fun p (apply_fun (homotopy_lift E Te B Tb p e0 F) (s, t)) = apply_fun F (s, t)).
admit.
Qed.

(** from S54 Lemma 54.2 path homotopy preservation (line 783 in algtop.tex) **)
(** LATEX VERSION: If F is a path homotopy, then the lift F_tilde is also a path homotopy. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem lemma54_2_path_homotopy_preserved : forall E Te B Tb p e0 F x0 x1:set,
  covering_map E Te B Tb p ->
  e0 :e E -> apply_fun p e0 = apply_fun F (0, 0) ->
  continuous_map unit_square unit_square_topology B Tb F ->
  (forall t:set, t :e unit_interval -> apply_fun F (0, t) = x0) ->
  (forall t:set, t :e unit_interval -> apply_fun F (1, t) = x1) ->
  exists e0' e1':set,
    (forall t:set, t :e unit_interval ->
      apply_fun (homotopy_lift E Te B Tb p e0 F) (0, t) = e0') /\
    (forall t:set, t :e unit_interval ->
      apply_fun (homotopy_lift E Te B Tb p e0 F) (1, t) = e1').
admit.
Qed.

(** from S54 Theorem 54.3 (line 785 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be covering, p(e0) = b0. Let f and g be paths in B **)
(** from b0 to b1; let f_tilde and g_tilde be their liftings beginning at e0. **)
(** from S54 Theorem 54.3 (line 785 in algtop.tex): homotopic lifts **)
(** If f and g are path homotopic, then f_tilde and g_tilde end at the same point **)
(** and are path homotopic. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm54_3_homotopic_lifts : forall E Te B Tb p e0 b0 b1 f g:set,
  covering_map E Te B Tb p ->
  e0 :e E -> apply_fun p e0 = b0 ->
  path_homotopic B Tb b0 b1 f g ->
  apply_fun (path_lift E Te B Tb p e0 f) 1 =
    apply_fun (path_lift E Te B Tb p e0 g) 1 /\
  path_homotopic E Te e0 (apply_fun (path_lift E Te B Tb p e0 f) 1)
    (path_lift E Te B Tb p e0 f) (path_lift E Te B Tb p e0 g).
admit.
Qed.

(** from S54 Definition (line 791 in algtop.tex) **)
(** LATEX VERSION: The lifting correspondence phi: pi_1(B,b0) -> p^{-1}(b0) maps **)
(** [f] to the endpoint f_tilde(1) of the lift of f starting at e0. **)
Definition lifting_correspondence : set -> set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p e0 =>
    graph (fundamental_group B Tb (apply_fun p e0))
      (fun cls:set =>
        apply_fun (path_lift E Te B Tb p e0 (Eps_i (fun f:set => f :e cls))) 1).

(** from S54 Theorem 54.4 (line 799 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be covering, p(e0) = b0. If E is path connected, **)
(** then phi: pi_1(B,b0) -> p^{-1}(b0) is surjective. **)
(** If E is simply connected, phi is bijective. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm54_4_lifting_correspondence_surjective : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  path_connected_space E Te ->
  surjective_map
    (fundamental_group B Tb (apply_fun p e0))
    {x :e E | apply_fun p x = apply_fun p e0}
    (lifting_correspondence E Te B Tb p e0).
admit.
Qed.

(** from S54 Theorem 54.4 (line 799 in algtop.tex): lifting correspondence bijective **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 60 **)
Theorem thm54_4_lifting_correspondence_bijective : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  simply_connected E Te ->
  bijection
    (fundamental_group B Tb (apply_fun p e0))
    {x :e E | apply_fun p x = apply_fun p e0}
    (lifting_correspondence E Te B Tb p e0).
admit.
Qed.

(** Infrastructure: the additive group of integers **)
(** Multiplication is addition of surreal numbers restricted to int **)
Definition integers_group_mult : set :=
  graph (setprod int int) (fun p:set => add_SNo (p 0) (p 1)).

(** Inverse is negation of surreal numbers restricted to int **)
Definition integers_group_inv : set :=
  graph int (fun n:set => minus_SNo n).

(** The basepoint (1,0) on S^1 **)
Definition S1_basepoint : set := (1, 0).

(** from S54 Theorem 54.5 (line 810 in algtop.tex) **)
(** LATEX VERSION: The fundamental group of S^1 is isomorphic to the additive group **)
(** of integers. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm54_5_pi1_circle : exists phi:set,
  group_isomorphism
    (fundamental_group S1 S1_topology S1_basepoint)
    (fundamental_group_mult S1 S1_topology S1_basepoint)
    int integers_group_mult
    phi.
admit.
Qed.

(** from S54 Definition (line 831 in algtop.tex) **)
(** LATEX VERSION: x^n denotes the n-fold product of x with itself in a group. **)
(** If G = {x^m : m in Z}, then G is cyclic and x is a generator. **)

(** Infrastructure: n-th power of x in a group (for natural n) **)
(** x^0 = e, x^(n+1) = mult(x, x^n) **)
Definition group_power_nat : set -> set -> set -> set -> set :=
  fun mult e x n => nat_primrec e (fun _ r => apply_fun mult (x, r)) n.

(** Infrastructure: cyclic group definition **)
Definition cyclic_group : set -> set -> set -> set -> prop :=
  fun G mult e inv =>
    group_structure G mult e inv /\
    exists x:set, x :e G /\
      forall g:set, g :e G ->
        exists n:set, n :e int /\
          ((n :e omega /\ g = group_power_nat mult e x n) \/
           (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
            g = group_power_nat mult e (apply_fun inv x) (ordsucc m))).

(** Infrastructure: generator of a cyclic group **)
Definition generator_of : set -> set -> set -> set -> set -> prop :=
  fun G mult e inv x =>
    x :e G /\
    forall g:set, g :e G ->
      exists n:set, n :e int /\
        ((n :e omega /\ g = group_power_nat mult e x n) \/
         (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
          g = group_power_nat mult e (apply_fun inv x) (ordsucc m))).

(** from S54 text (line 833 in algtop.tex) **)
(** LATEX VERSION: A group is cyclic of infinite order iff it is isomorphic to Z; **)
(** cyclic of order k iff isomorphic to Z/k. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cyclic_infinite_order_iff_Z : forall G mult e inv:set,
  group_structure G mult e inv ->
  cyclic_group G mult e inv ->
  ~ finite G ->
  exists phi:set, group_isomorphism G mult int integers_group_mult phi.
admit.
Qed.

(** from S54 text (line 835 in algtop.tex) **)
(** LATEX VERSION: If x generates the infinite cyclic group G, and y is in an arbitrary **)
(** group H, then there is a unique homomorphism h: G -> H with h(x) = y. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem infinite_cyclic_universal_property : forall G multG eG invG x H multH eH invH y:set,
  group_structure G multG eG invG ->
  cyclic_group G multG eG invG ->
  ~ finite G ->
  generator_of G multG eG invG x ->
  group_structure H multH eH invH ->
  y :e H ->
  exists h:set,
    group_homomorphism G multG H multH h /\
    apply_fun h x = y /\
    (forall h':set, group_homomorphism G multG H multH h' -> apply_fun h' x = y ->
      forall g:set, g :e G -> apply_fun h' g = apply_fun h g).
admit.
Qed.

(** Infrastructure: right coset H . g = {h . g : h in H} **)
Definition right_coset : set -> set -> set -> set :=
  fun mult H g => {apply_fun mult (h, g) | h :e H}.

(** Infrastructure: set of right cosets G/H **)
Definition right_coset_set : set -> set -> set -> set :=
  fun G mult H => {right_coset mult H g | g :e G}.

(** Infrastructure: image of a homomorphism **)
Definition homomorphism_image : set -> set -> set :=
  fun G phi => {apply_fun phi x | x :e G}.

(** from S54 Theorem 54.6a (line 838 in algtop.tex) **)
(** LATEX VERSION: The homomorphism p-star: pi_1(E,e0) -> pi_1(B,b0) is a monomorphism. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem thm54_6a_p_star_injective : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  forall cls1 cls2:set,
    cls1 :e fundamental_group E Te e0 ->
    cls2 :e fundamental_group E Te e0 ->
    apply_fun (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p) cls1 =
    apply_fun (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p) cls2 ->
    cls1 = cls2.
admit.
Qed.

(** from S54 Theorem 54.6b (line 840 in algtop.tex) **)
(** LATEX VERSION: Let H = p-star(pi_1(E,e0)). The lifting correspondence induces **)
(** an injective map Phi: pi_1(B,b0)/H -> p^{-1}(b0), bijective if E is path connected. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm54_6b_coset_correspondence : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  exists Phi:set,
    function_on Phi
      (right_coset_set
        (fundamental_group B Tb (apply_fun p e0))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)))
      {x :e E | apply_fun p x = apply_fun p e0} /\
    (forall c1 c2:set,
      c1 :e right_coset_set
        (fundamental_group B Tb (apply_fun p e0))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)) ->
      c2 :e right_coset_set
        (fundamental_group B Tb (apply_fun p e0))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)) ->
      apply_fun Phi c1 = apply_fun Phi c2 -> c1 = c2).
admit.
Qed.

(** from S54 Theorem 54.6b surjectivity when E is path connected **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem thm54_6b_coset_correspondence_surjective : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  path_connected_space E Te ->
  exists Phi:set,
    surjective_map
      (right_coset_set
        (fundamental_group B Tb (apply_fun p e0))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)))
      {x :e E | apply_fun p x = apply_fun p e0}
      Phi.
admit.
Qed.

(** from S54 Theorem 54.6c (line 847 in algtop.tex) **)
(** LATEX VERSION: [f] in H iff f lifts to a loop in E based at e0. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm54_6c_loop_characterization : forall E Te B Tb p e0 f:set,
  covering_map E Te B Tb p -> e0 :e E ->
  loop_at B Tb (apply_fun p e0) f ->
  (path_homotopy_class_loop B Tb (apply_fun p e0) f :e
    homomorphism_image
      (fundamental_group E Te e0)
      (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
  <->
  apply_fun (path_lift E Te B Tb p e0 f) 1 = e0.
admit.
Qed.

(** from S54 Exercise 3 (line 871 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be covering. If alpha and beta are paths in B with **)
(** alpha(1) = beta(0), and their lifts satisfy alpha_tilde(1) = beta_tilde(0), **)
(** then alpha_tilde . beta_tilde is a lifting of alpha . beta. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex54_3_lift_of_product : forall E Te B Tb p e0 alpha beta:set,
  covering_map E Te B Tb p -> e0 :e E ->
  continuous_map unit_interval unit_interval_topology B Tb alpha ->
  continuous_map unit_interval unit_interval_topology B Tb beta ->
  apply_fun alpha 1 = apply_fun beta 0 ->
  apply_fun p e0 = apply_fun alpha 0 ->
  lifting_of unit_interval unit_interval_topology E Te B Tb p
    (path_concat alpha beta)
    (path_concat
      (path_lift E Te B Tb p e0 alpha)
      (path_lift E Te B Tb p (apply_fun (path_lift E Te B Tb p e0 alpha) 1) beta)).
admit.
Qed.

(** Infrastructure: complex inversion on S^1: z -> (z_0, -z_1) = conjugate = 1/z **)
Definition S1_conjugate_map : set :=
  graph S1 (fun z:set => (z 0, minus_SNo (z 1))).

(** Infrastructure: the map z -> 1/z^n on S^1 **)
Definition S1_inv_power_map : set -> set := fun n =>
  compose_fun S1 (S1_power_map n) S1_conjugate_map.

(** from S54 Exercise 6 (line 891 in algtop.tex) **)
(** LATEX VERSION: For g(z) = z^n: the induced homomorphism g-star on pi_1(S^1,b0) **)
(** is multiplication by n. For h(z) = 1/z^n: h-star is multiplication by -n. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex54_6_power_map_induced : forall n:set,
  n :e omega -> 0 :e n ->
  forall cls:set, cls :e fundamental_group S1 S1_topology S1_basepoint ->
    apply_fun
      (induced_homomorphism S1 S1_topology S1_basepoint S1 S1_topology S1_basepoint (S1_power_map n))
      cls =
    apply_fun
      (graph (fundamental_group S1 S1_topology S1_basepoint)
        (fun c:set => group_power_nat (fundamental_group_mult S1 S1_topology S1_basepoint)
          (fundamental_group_id S1 S1_topology S1_basepoint) c n))
      cls.
admit.
Qed.

(** from S54 Exercise 6 second part (line 891 in algtop.tex) **)
(** LATEX VERSION: For h(z) = 1/z^n: the induced homomorphism h-star on pi_1(S^1,b0) **)
(** is multiplication by -n. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex54_6b_inv_power_map_induced : forall n:set,
  n :e omega -> 0 :e n ->
  forall cls:set, cls :e fundamental_group S1 S1_topology S1_basepoint ->
    apply_fun
      (induced_homomorphism S1 S1_topology S1_basepoint S1 S1_topology S1_basepoint (S1_inv_power_map n))
      cls =
    apply_fun
      (graph (fundamental_group S1 S1_topology S1_basepoint)
        (fun c:set => group_power_nat (fundamental_group_mult S1 S1_topology S1_basepoint)
          (fundamental_group_id S1 S1_topology S1_basepoint)
          (apply_fun (fundamental_group_inv S1 S1_topology S1_basepoint) c) n))
      cls.
admit.
Qed.

(** Infrastructure: the torus T = S^1 x S^1 and its topology **)
Definition torus : set := setprod S1 S1.
Definition torus_topology : set := product_topology S1 S1_topology S1 S1_topology.

(** Infrastructure: product group multiplication **)
(** (G1 x G2, mult) where mult((a,b),(c,d)) = (mult1(a,c), mult2(b,d)) **)
Definition product_group_mult : set -> set -> set -> set -> set :=
  fun G1 mult1 G2 mult2 =>
    graph (setprod (setprod G1 G2) (setprod G1 G2))
      (fun p:set =>
        (apply_fun mult1 ((p 0) 0, (p 1) 0),
         apply_fun mult2 ((p 0) 1, (p 1) 1))).

(** from S54 Exercise 7 (line 892 in algtop.tex) **)
(** LATEX VERSION: The fundamental group of the torus is isomorphic to Z x Z. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex54_7_pi1_torus : exists phi:set,
  group_isomorphism
    (fundamental_group torus torus_topology (S1_basepoint, S1_basepoint))
    (fundamental_group_mult torus torus_topology (S1_basepoint, S1_basepoint))
    (setprod int int)
    (product_group_mult int integers_group_mult int integers_group_mult)
    phi.
admit.
Qed.

(** from S54 Exercise 8 (line 893 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> B be a covering map with E path connected. **)
(** If B is simply connected, then p is a homeomorphism. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex54_8_simply_connected_base_homeomorphism : forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  path_connected_space E Te ->
  simply_connected B Tb ->
  homeomorphism E Te B Tb p.
admit.
Qed.

(** ======================= S55 RETRACTIONS AND FIXED POINTS ======================= **)

(** Infrastructure: closed unit disk B^2 = {(x,y) in R^2 : x^2 + y^2 <= 1} **)
Definition B2 : set :=
  {p :e setprod R R |
    ~(Rlt 1 (add_SNo (mul_SNo (p 0) (p 0)) (mul_SNo (p 1) (p 1))))}.

(** Infrastructure: topology on B^2 as subspace of R^2 **)
Definition B2_topology : set :=
  subspace_topology (setprod R R) R2_topology B2.

(** Infrastructure: R^2 minus the origin {(x,y) in R^2 : not(x=0 and y=0)} **)
Definition R2_minus_origin : set :=
  {p :e setprod R R | ~(p 0 = 0 /\ p 1 = 0)}.

(** Infrastructure: topology on R^2 minus origin as subspace of R^2 **)
Definition R2_minus_origin_topology : set :=
  subspace_topology (setprod R R) R2_topology R2_minus_origin.

(** Infrastructure: scalar multiplication in R^2, lambda (x,y) = (lambda x, lambda y) **)
Definition R2_scalar_mult : set -> set -> set := fun lam p =>
  (mul_SNo lam (p 0), mul_SNo lam (p 1)).

(** Infrastructure: vector field on B^2 "points directly inward" at x in S^1 **)
(** means v(x) = -a times x for some positive a **)
Definition points_directly_inward : set -> set -> prop := fun v x =>
  x :e S1 /\
  exists a:set, a :e R /\ Rlt 0 a /\
    apply_fun v x = R2_scalar_mult (minus_SNo a) x.

(** Infrastructure: vector field on B^2 "points directly outward" at x in S^1 **)
(** means v(x) = a times x for some positive a **)
Definition points_directly_outward : set -> set -> prop := fun v x =>
  x :e S1 /\
  exists a:set, a :e R /\ Rlt 0 a /\
    apply_fun v x = R2_scalar_mult a x.

(** from S55 Definition (line 898 in algtop.tex): retraction of X onto A **)
(** LATEX VERSION: A retraction of X onto A is a continuous map r: X -> A with r|A = id_A. **)
(** NOTE: Already defined as retraction_of at line 27749. **)

(** from S55 Lemma 55.1 (line 900 in algtop.tex) **)
(** LATEX VERSION: If A is a retract of X, then the homomorphism of fundamental groups induced by inclusion j: A -> X is injective. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem lemma55_1_retract_injective_pi1 : forall X Tx A a:set,
  topology_on X Tx ->
  A c= X ->
  retraction_of X Tx A ->
  a :e A ->
  (forall cls1 cls2:set,
    cls1 :e fundamental_group A (subspace_topology X Tx A) a ->
    cls2 :e fundamental_group A (subspace_topology X Tx A) a ->
    apply_fun (induced_homomorphism A (subspace_topology X Tx A) a X Tx a
      (graph A (fun x:set => x))) cls1 =
    apply_fun (induced_homomorphism A (subspace_topology X Tx A) a X Tx a
      (graph A (fun x:set => x))) cls2 ->
    cls1 = cls2).
admit.
Qed.

(** from S55 Theorem 55.2 (line 904 in algtop.tex): No-retraction theorem **)
(** LATEX VERSION: There is no retraction of B^2 onto S^1. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm55_2_no_retraction_B2_S1 : ~(retraction_of B2 B2_topology S1).
admit.
Qed.

(** from S55 Lemma 55.3 direction (1) implies (2) (line 907 in algtop.tex) **)
(** LATEX VERSION: Let h: S^1 -> X be continuous. If h is nulhomotopic, then h extends to a continuous map k: B^2 -> X. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 120 **)
Theorem lemma55_3_nulhomotopic_extends_to_B2 : forall X Tx h:set,
  continuous_map S1 S1_topology X Tx h ->
  nulhomotopic S1 S1_topology X Tx h ->
  exists k:set, continuous_map B2 B2_topology X Tx k /\
    (forall x:set, x :e S1 -> apply_fun k x = apply_fun h x).
admit.
Qed.

(** from S55 Lemma 55.3 direction (2) implies (3) (line 907 in algtop.tex) **)
(** LATEX VERSION: If h extends to k: B^2 -> X, then h-star is the trivial homomorphism. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem lemma55_3_extends_implies_trivial : forall X Tx h b0:set,
  continuous_map S1 S1_topology X Tx h ->
  b0 :e S1 ->
  (exists k:set, continuous_map B2 B2_topology X Tx k /\
    (forall x:set, x :e S1 -> apply_fun k x = apply_fun h x)) ->
  (forall cls:set, cls :e fundamental_group S1 S1_topology b0 ->
    apply_fun (induced_homomorphism S1 S1_topology b0 X Tx (apply_fun h b0) h) cls =
    fundamental_group_id X Tx (apply_fun h b0)).
admit.
Qed.

(** from S55 Lemma 55.3 direction (3) implies (1) (line 907 in algtop.tex) **)
(** LATEX VERSION: If h-star is the trivial homomorphism, then h is nulhomotopic. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 180 **)
Theorem lemma55_3_trivial_implies_nulhomotopic : forall X Tx h b0:set,
  continuous_map S1 S1_topology X Tx h ->
  b0 :e S1 ->
  (forall cls:set, cls :e fundamental_group S1 S1_topology b0 ->
    apply_fun (induced_homomorphism S1 S1_topology b0 X Tx (apply_fun h b0) h) cls =
    fundamental_group_id X Tx (apply_fun h b0)) ->
  nulhomotopic S1 S1_topology X Tx h.
admit.
Qed.

(** from S55 Corollary 55.4 part (a) (line 947 in algtop.tex) **)
(** LATEX VERSION: The inclusion map j: S^1 -> R^2 - 0 is not nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor55_4a_inclusion_S1_R2_not_nulhomotopic :
  ~(nulhomotopic S1 S1_topology R2_minus_origin R2_minus_origin_topology
    (graph S1 (fun x:set => x))).
admit.
Qed.

(** from S55 Corollary 55.4 part (b) (line 947 in algtop.tex) **)
(** LATEX VERSION: The identity map i: S^1 -> S^1 is not nulhomotopic. **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 20 **)
Theorem cor55_4b_identity_S1_not_nulhomotopic :
  ~(nulhomotopic S1 S1_topology S1 S1_topology (graph S1 (fun x:set => x))).
admit.
Qed.

(** from S55 Theorem 55.5 (line 950 in algtop.tex) **)
(** LATEX VERSION: Given a nonvanishing vector field on B^2, there exists a point of S^1 where the vector field points directly inward and a point of S^1 where it points directly outward. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm55_5_nonvanishing_vector_field : forall v:set,
  continuous_map B2 B2_topology (setprod R R) R2_topology v ->
  (forall x:set, x :e B2 -> ~(apply_fun v x 0 = 0 /\ apply_fun v x 1 = 0)) ->
  (exists x:set, x :e S1 /\ points_directly_inward v x) /\
  (exists x:set, x :e S1 /\ points_directly_outward v x).
admit.
Qed.

(** from S55 Theorem 55.6 (line 983 in algtop.tex): Brouwer fixed-point theorem for the disc **)
(** LATEX VERSION: If f: B^2 -> B^2 is continuous, then there exists a point x in B^2 such that f(x) = x. **)
(** EFFORT: 6 lines textbook, difficulty 3/10, USD 60 **)
Theorem thm55_6_brouwer_fixed_point_disc : forall f:set,
  continuous_map B2 B2_topology B2 B2_topology f ->
  exists x:set, x :e B2 /\ apply_fun f x = x.
admit.
Qed.

(** Infrastructure for starred Corollary 55.7: finite sum of real-valued terms **)
(** finite_real_sum f n = f(0) + f(1) + ... + f(n-1) **)
Definition finite_real_sum : (set -> set) -> set -> set := fun f n =>
  nat_primrec 0 (fun j r => add_SNo r (f j)) n.

(** Infrastructure: n-by-n matrix applied to n-vector **)
(** (Av)_i = sum_{j<n} A(i,j) v(j) **)
Definition matrix_vector_mult : set -> set -> set -> set := fun n A v =>
  graph n (fun i:set =>
    finite_real_sum (fun j:set => mul_SNo (apply_fun A (i, j)) (apply_fun v j)) n).

(** Infrastructure: eigenvalue of an n-by-n real matrix **)
Definition eigenvalue_of_matrix : set -> set -> set -> prop := fun n A lam =>
  lam :e R /\
  exists v:set,
    function_on v n R /\
    ~(forall i:set, i :e n -> apply_fun v i = 0) /\
    (forall i:set, i :e n ->
      finite_real_sum (fun j:set => mul_SNo (apply_fun A (i, j)) (apply_fun v j)) n =
      mul_SNo lam (apply_fun v i)).

(** from S55 starred Corollary 55.7 (line 994 in algtop.tex) **)
(** LATEX VERSION: Let A be a 3 by 3 matrix of positive real numbers. Then A has a positive real eigenvalue. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 150 **)
Theorem cor55_7_positive_matrix_eigenvalue : forall A:set,
  function_on A (setprod 3 3) R ->
  (forall i j:set, i :e 3 -> j :e 3 -> Rlt 0 (apply_fun A (i, j))) ->
  exists lam:set, Rlt 0 lam /\ eigenvalue_of_matrix 3 A lam.
admit.
Qed.

(** Infrastructure: Euclidean distance in R^2 **)
Definition R2_distance : set -> set -> set := fun p q =>
  sqrt_SNo_nonneg (add_SNo
    (mul_SNo (add_SNo (p 0) (minus_SNo (q 0))) (add_SNo (p 0) (minus_SNo (q 0))))
    (mul_SNo (add_SNo (p 1) (minus_SNo (q 1))) (add_SNo (p 1) (minus_SNo (q 1))))).

(** Infrastructure: triangular region T = {(x,y) : x >= 0, y >= 0, x+y <= 1} **)
Definition triangular_region : set :=
  {p :e setprod R R |
    ~(Rlt (p 0) 0) /\ ~(Rlt (p 1) 0) /\
    ~(Rlt 1 (add_SNo (p 0) (p 1)))}.

(** Infrastructure: topology on the triangular region as subspace of R^2 **)
Definition triangular_region_topology : set :=
  subspace_topology (setprod R R) R2_topology triangular_region.

(** from S55 starred Theorem 55.8 (line 1020 in algtop.tex) **)
(** LATEX VERSION: There is an epsilon > 0 such that for every open covering of T by sets of diameter less than epsilon, some point of T belongs to at least three elements of the covering. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 300 **)
Theorem thm55_8_dimension_triangular_region :
  exists eps:set, eps :e R /\ Rlt 0 eps /\
    (forall cov:set,
      (forall U:set, U :e cov ->
        U :e triangular_region_topology) ->
      triangular_region c= Union cov ->
      (forall U:set, U :e cov ->
        forall x y:set, x :e U -> y :e U ->
          Rlt (R2_distance x y) eps) ->
      exists x:set, x :e triangular_region /\
        exists U1 U2 U3:set, U1 :e cov /\ U2 :e cov /\ U3 :e cov /\
          U1 <> U2 /\ U1 <> U3 /\ U2 <> U3 /\
          x :e U1 /\ x :e U2 /\ x :e U3).
admit.
Qed.

(** from S55 Exercise 1 (line 1042 in algtop.tex) **)
(** LATEX VERSION: If A is a retract of B^2, then every continuous map f: A -> A has a fixed point. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex55_1_retract_B2_fixed_point : forall A:set,
  A c= B2 ->
  retraction_of B2 B2_topology A ->
  forall f:set,
    continuous_map A (subspace_topology B2 B2_topology A)
                   A (subspace_topology B2 B2_topology A) f ->
    exists x:set, x :e A /\ apply_fun f x = x.
admit.
Qed.

(** from S55 Exercise 2 (line 1043 in algtop.tex) **)
(** LATEX VERSION: If h: S^1 -> S^1 is nulhomotopic, then h has a fixed point and h maps some point x to its antipode -x. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex55_2_nulhomotopic_S1_fixed_and_antipodal : forall h:set,
  continuous_map S1 S1_topology S1 S1_topology h ->
  nulhomotopic S1 S1_topology S1 S1_topology h ->
  (exists x:set, x :e S1 /\ apply_fun h x = x) /\
  (exists x:set, x :e S1 /\
    apply_fun h x = (minus_SNo (x 0), minus_SNo (x 1))).
admit.
Qed.

(** from S55 Exercise 3 (line 1044 in algtop.tex) **)
(** LATEX VERSION: If A is a nonsingular 3x3 matrix having nonnegative entries, then A has a positive real eigenvalue. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex55_3_nonneg_nonsingular_matrix_eigenvalue : forall A:set,
  function_on A (setprod 3 3) R ->
  (forall i j:set, i :e 3 -> j :e 3 -> ~(Rlt (apply_fun A (i, j)) 0)) ->
  (forall v:set, function_on v 3 R ->
    ~(forall i:set, i :e 3 -> apply_fun v i = 0) ->
    ~(forall i:set, i :e 3 ->
      finite_real_sum (fun j:set => mul_SNo (apply_fun A (i, j)) (apply_fun v j)) 3 = 0)) ->
  exists lam:set, Rlt 0 lam /\ eigenvalue_of_matrix 3 A lam.
admit.
Qed.

(** Infrastructure for Exercise 55.4: norm squared in Euclidean n-space **)
(** euclidean_norm_sq n v = sum_{i<n} v(i)^2 **)
Definition euclidean_norm_sq : set -> set -> set := fun n v =>
  finite_real_sum (fun i:set => mul_SNo (apply_fun v i) (apply_fun v i)) n.

(** Infrastructure: unit n-sphere S^n = {v in R^{n+1} : ||v||^2 = 1} **)
Definition Sn : set -> set := fun n =>
  {v :e euclidean_space (ordsucc n) | euclidean_norm_sq (ordsucc n) v = 1}.

(** Infrastructure: topology on S^n as subspace of R^{n+1} **)
Definition Sn_topology : set -> set := fun n =>
  subspace_topology (euclidean_space (ordsucc n)) (euclidean_topology (ordsucc n)) (Sn n).

(** Infrastructure: closed unit ball B^{n+1} = {v in R^{n+1} : ||v||^2 <= 1} **)
Definition Bn_closed : set -> set := fun n =>
  {v :e euclidean_space (ordsucc n) | ~(Rlt 1 (euclidean_norm_sq (ordsucc n) v))}.

(** Infrastructure: topology on the closed unit ball as subspace of R^{n+1} **)
Definition Bn_closed_topology : set -> set := fun n =>
  subspace_topology (euclidean_space (ordsucc n)) (euclidean_topology (ordsucc n)) (Bn_closed n).

(** Infrastructure: R^n minus the origin (nonzero vectors) **)
Definition Rn_minus_origin : set -> set := fun n =>
  {v :e euclidean_space n | ~(forall i:set, i :e n -> apply_fun v i = 0)}.

(** Infrastructure: topology on R^n minus origin **)
Definition Rn_minus_origin_topology : set -> set := fun n =>
  subspace_topology (euclidean_space n) (euclidean_topology n) (Rn_minus_origin n).

(** Infrastructure: scalar multiplication in R^n, lambda v = (lambda v_0, ..., lambda v_{n-1}) **)
Definition Rn_scalar_mult : set -> set -> set -> set := fun n lam v =>
  graph n (fun i:set => mul_SNo lam (apply_fun v i)).

(** Infrastructure: negation in R^n, -v = (-v_0, ..., -v_{n-1}) (the antipodal map) **)
Definition Rn_negate : set -> set -> set := fun n v =>
  graph n (fun i:set => minus_SNo (apply_fun v i)).

(** Infrastructure: vector field on B^{n+1} "points directly inward" at x in S^n **)
Definition points_directly_inward_Rn : set -> set -> set -> prop := fun n v x =>
  x :e Sn n /\
  exists a:set, a :e R /\ Rlt 0 a /\
    apply_fun v x = Rn_scalar_mult (ordsucc n) (minus_SNo a) x.

(** Infrastructure: vector field on B^{n+1} "points directly outward" at x in S^n **)
Definition points_directly_outward_Rn : set -> set -> set -> prop := fun n v x =>
  x :e Sn n /\
  exists a:set, a :e R /\ Rlt 0 a /\
    apply_fun v x = Rn_scalar_mult (ordsucc n) a x.

(** from S55 Exercise 4(a) (line 1046 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, the identity map i: S^n -> S^n is not nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex55_4a_identity_Sn_not_nulhomotopic : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  ~(nulhomotopic (Sn n) (Sn_topology n) (Sn n) (Sn_topology n)
    (graph (Sn n) (fun x:set => x))).
admit.
Qed.

(** from S55 Exercise 4(b) (line 1047 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, the inclusion j: S^n -> R^{n+1} - 0 is not nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex55_4b_inclusion_Sn_not_nulhomotopic : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  ~(nulhomotopic (Sn n) (Sn_topology n)
    (Rn_minus_origin (ordsucc n)) (Rn_minus_origin_topology (ordsucc n))
    (graph (Sn n) (fun x:set => x))).
admit.
Qed.

(** from S55 Exercise 4(c) (line 1048 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, every nonvanishing vector field on B^{n+1} points outward and inward at some points of S^n. **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex55_4c_nonvanishing_vector_field_Rn : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  forall v:set,
    continuous_map (Bn_closed n) (Bn_closed_topology n)
                   (euclidean_space (ordsucc n)) (euclidean_topology (ordsucc n)) v ->
    (forall x:set, x :e Bn_closed n ->
      ~(forall i:set, i :e ordsucc n -> apply_fun (apply_fun v x) i = 0)) ->
    (exists x:set, x :e Sn n /\ points_directly_inward_Rn n v x) /\
    (exists x:set, x :e Sn n /\ points_directly_outward_Rn n v x).
admit.
Qed.

(** from S55 Exercise 4(d) (line 1049 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, every continuous map f: B^{n+1} -> B^{n+1} has a fixed point. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex55_4d_brouwer_fixed_point_Rn : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  forall f:set,
    continuous_map (Bn_closed n) (Bn_closed_topology n)
                   (Bn_closed n) (Bn_closed_topology n) f ->
    exists x:set, x :e Bn_closed n /\ apply_fun f x = x.
admit.
Qed.

(** from S55 Exercise 4(e) (line 1050 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, every (n+1) by (n+1) matrix with positive entries has a positive eigenvalue. **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex55_4e_positive_matrix_eigenvalue_Rn : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  forall A:set,
    function_on A (setprod (ordsucc n) (ordsucc n)) R ->
    (forall i j:set, i :e ordsucc n -> j :e ordsucc n -> Rlt 0 (apply_fun A (i, j))) ->
    exists lam:set, Rlt 0 lam /\ eigenvalue_of_matrix (ordsucc n) A lam.
admit.
Qed.

(** from S55 Exercise 4(f) (line 1051 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^{n+1} -> S^n, if h: S^n -> S^n is nulhomotopic, then h has a fixed point and maps some x to -x. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex55_4f_nulhomotopic_Sn_fixed_and_antipodal : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)) ->
  forall h:set,
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    nulhomotopic (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    (exists x:set, x :e Sn n /\ apply_fun h x = x) /\
    (exists x:set, x :e Sn n /\ apply_fun h x = Rn_negate (ordsucc n) x).
admit.
Qed.

(** ======================= S56 THE FUNDAMENTAL THEOREM OF ALGEBRA ======================= **)

(** Infrastructure: complex addition in R^2 representation **)
Definition complex_add_R2 : set -> set -> set := fun z w =>
  (add_SNo (z 0) (w 0), add_SNo (z 1) (w 1)).

(** Infrastructure: complex modulus squared |z|^2 = x^2 + y^2 **)
Definition complex_modulus_sq : set -> set := fun z =>
  add_SNo (mul_SNo (z 0) (z 0)) (mul_SNo (z 1) (z 1)).

(** Infrastructure: complex modulus |z| = sqrt(x^2 + y^2) **)
Definition complex_modulus : set -> set := fun z =>
  sqrt_SNo_nonneg (complex_modulus_sq z).

(** Infrastructure: finite sum of complex numbers (R^2 vectors) **)
(** finite_complex_sum f n = f(0) + f(1) + ... + f(n-1) **)
Definition finite_complex_sum : (set -> set) -> set -> set := fun f n =>
  nat_primrec (0, 0) (fun j r => complex_add_R2 r (f j)) n.

(** Infrastructure: evaluate a monic polynomial of degree n at z **)
(** poly(z) = z^n + a(n-1) z^{n-1} + ... + a(1) z + a(0) **)
(** Here a is a function from n to C (= R^2) giving coefficients a_0, ..., a_{n-1} **)
Definition monic_poly_eval : set -> set -> set -> set := fun a n z =>
  complex_add_R2
    (complex_power_R2 z n)
    (finite_complex_sum (fun k:set => complex_mult_R2 (apply_fun a k) (complex_power_R2 z k)) n).

(** from S56 Theorem 56.1 (line 1066 in algtop.tex): Fundamental theorem of algebra **)
(** LATEX VERSION: A polynomial equation x^n + a_{n-1} x^{n-1} + ... + a_0 = 0 of degree n > 0 with real or complex coefficients has at least one root. **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 400 **)
Theorem thm56_1_fundamental_theorem_of_algebra : forall n a:set,
  n :e omega -> n <> 0 ->
  function_on a n (setprod R R) ->
  exists z:set, z :e setprod R R /\
    monic_poly_eval a n z = (0, 0).
admit.
Qed.

(** from S56 Exercise 1 (line 1167 in algtop.tex) **)
(** LATEX VERSION: If |a_{n-1}| + ... + |a_0| < 1, then all roots of x^n + a_{n-1} x^{n-1} + ... + a_0 lie in the interior of B^2. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex56_1_small_coeff_roots_in_B2 : forall n a:set,
  n :e omega -> n <> 0 ->
  function_on a n (setprod R R) ->
  Rlt (finite_real_sum (fun k:set => complex_modulus (apply_fun a k)) n) 1 ->
  forall z:set, z :e setprod R R ->
    monic_poly_eval a n z = (0, 0) ->
    Rlt (complex_modulus_sq z) 1.
admit.
Qed.

(** from S56 Exercise 2 (line 1175 in algtop.tex) **)
(** LATEX VERSION: Find a circle about the origin containing all roots of x^7 + x^2 + 1 = 0. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
(** Answer: radius 2 works since for |z| >= 2, |z^7| >= 128 > 5 >= |z^2| + 1 **)
Theorem ex56_2_roots_of_x7_x2_1 : forall z:set, z :e setprod R R ->
  complex_add_R2 (complex_power_R2 z 7)
    (complex_add_R2 (complex_power_R2 z 2) (1, 0)) = (0, 0) ->
  Rlt (complex_modulus_sq z) (mul_SNo 2 2).
admit.
Qed.

(** ======================= S57 THE BORSUK-ULAM THEOREM ======================= **)

(** from S57 Definition (line 1184 in algtop.tex): antipode and antipode-preserving map **)
(** LATEX VERSION: If x is a point of S^n, its antipode is -x. A map h: S^n -> S^m is antipode-preserving if h(-x) = -h(x) for all x in S^n. **)
Definition antipode_preserving_S1 : set -> prop := fun h =>
  continuous_map S1 S1_topology S1 S1_topology h /\
  (forall z:set, z :e S1 ->
    apply_fun h (minus_SNo (z 0), minus_SNo (z 1)) =
    (minus_SNo (apply_fun h z 0), minus_SNo (apply_fun h z 1))).

(** Infrastructure: general antipode-preserving for S^n -> S^m **)
Definition antipode_preserving_Sn : set -> set -> set -> prop := fun n m h =>
  continuous_map (Sn n) (Sn_topology n) (Sn m) (Sn_topology m) h /\
  (forall x:set, x :e Sn n ->
    apply_fun h (Rn_negate (ordsucc n) x) = Rn_negate (ordsucc m) (apply_fun h x)).

(** from S57 Theorem 57.1 (line 1186 in algtop.tex) **)
(** LATEX VERSION: If h: S^1 -> S^1 is continuous and antipode-preserving, then h is not nulhomotopic. **)
(** EFFORT: 25 lines textbook, difficulty 7/10, USD 350 **)
Theorem thm57_1_antipode_preserving_not_nulhomotopic : forall h:set,
  antipode_preserving_S1 h ->
  ~(nulhomotopic S1 S1_topology S1 S1_topology h).
admit.
Qed.

(** from S57 Theorem 57.2 (line 1214 in algtop.tex) **)
(** LATEX VERSION: There is no continuous antipode-preserving map g: S^2 -> S^1. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm57_2_no_antipode_preserving_S2_S1 :
  ~(exists g:set, antipode_preserving_Sn 2 1 g).
admit.
Qed.

(** from S57 Theorem 57.3 (line 1217 in algtop.tex): Borsuk-Ulam theorem for S^2 **)
(** LATEX VERSION: Given a continuous map f: S^2 -> R^2, there is a point x of S^2 such that f(x) = f(-x). **)
(** EFFORT: 4 lines textbook, difficulty 2/10, USD 30 **)
Theorem thm57_3_borsuk_ulam_S2 : forall f:set,
  continuous_map (Sn 2) (Sn_topology 2) (setprod R R) R2_topology f ->
  exists x:set, x :e Sn 2 /\
    apply_fun f x = apply_fun f (Rn_negate 3 x).
admit.
Qed.

(** Infrastructure: bounded polygonal region in R^2 (abstract -- a bounded Jordan-measurable set) **)
(** We abstract this as a bounded measurable subset of R^2 with an area function **)
Definition bounded_measurable_R2 : set -> prop := fun A =>
  A c= setprod R R /\
  exists M:set, M :e R /\ Rlt 0 M /\
    (forall p:set, p :e A -> Rlt (complex_modulus_sq p) (mul_SNo M M)).

(** Infrastructure: a line in R^2 through a point with direction, splitting into half-planes **)
(** For the bisection theorem, we need: a line bisects A if the area on each side is equal **)
(** We abstract this as: exists a line such that the area measure on each side is half **)

(** from S57 Theorem 57.4 (line 1227 in algtop.tex): The bisection theorem **)
(** LATEX VERSION: Given two bounded polygonal regions in R^2, there exists a line in R^2 that bisects each of them. **)
(** We state this using the Borsuk-Ulam theorem abstractly **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 150 **)
(** from S57 Theorem 57.4 (line 1227 in algtop.tex): bisection theorem **)
(** NOTE: The full statement requires an area measure; we state it using an abstract **)
(** continuous area function f_i: S^2 -> R measuring the area of A_i on one side of the **)
(** plane normal to u, with the antipodal property f_i(u) + f_i(-u) = area(A_i). **)
Theorem thm57_4_bisection_theorem : forall f1 f2:set,
  continuous_map (Sn 2) (Sn_topology 2) R R_standard_topology f1 ->
  continuous_map (Sn 2) (Sn_topology 2) R R_standard_topology f2 ->
  (exists area1:set, area1 :e R /\
    (forall u:set, u :e Sn 2 ->
      add_SNo (apply_fun f1 u) (apply_fun f1 (Rn_negate 3 u)) = area1)) ->
  (exists area2:set, area2 :e R /\
    (forall u:set, u :e Sn 2 ->
      add_SNo (apply_fun f2 u) (apply_fun f2 (Rn_negate 3 u)) = area2)) ->
  exists u:set, u :e Sn 2 /\
    apply_fun f1 u = apply_fun f1 (Rn_negate 3 u) /\
    apply_fun f2 u = apply_fun f2 (Rn_negate 3 u).
admit.
Qed.

(** from S57 Exercise 1 (line 1257 in algtop.tex) **)
(** LATEX VERSION: At any given moment, there exist antipodal points on Earth **)
(** where both temperature and barometric pressure are equal. **)
(** This is the Borsuk-Ulam theorem for S^2 -> R^2. **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 10 **)
Theorem ex57_1_meteorology : forall f:set,
  continuous_map (Sn 2) (Sn_topology 2) (setprod R R) R2_topology f ->
  exists x:set, x :e Sn 2 /\
    apply_fun f x = apply_fun f (Rn_negate 3 x).
admit.
Qed.

(** from S57 Exercise 2 (line 1258 in algtop.tex) **)
(** LATEX VERSION: If g: S^2 -> S^2 is continuous and g(x) != g(-x) for all x, then g is surjective. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex57_2_antipodal_distinct_surjective : forall g:set,
  continuous_map (Sn 2) (Sn_topology 2) (Sn 2) (Sn_topology 2) g ->
  (forall x:set, x :e Sn 2 ->
    apply_fun g x <> apply_fun g (Rn_negate 3 x)) ->
  surjective_map (Sn 2) (Sn 2) g.
admit.
Qed.

(** from S57 Exercise 3 (line 1259 in algtop.tex) **)
(** LATEX VERSION: Let h: S^1 -> S^1 be continuous, antipode-preserving, h(b0)=b0. Then h-star carries a generator to an odd power of itself. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex57_3_antipode_preserving_odd_power : forall h:set,
  antipode_preserving_S1 h ->
  apply_fun h S1_basepoint = S1_basepoint ->
  exists m:set, m :e omega /\
    (forall cls:set, cls :e fundamental_group S1 S1_topology S1_basepoint ->
      cls = fundamental_group_id S1 S1_topology S1_basepoint \/
      apply_fun (induced_homomorphism S1 S1_topology S1_basepoint
        S1 S1_topology S1_basepoint h) cls =
      group_power_nat (fundamental_group_mult S1 S1_topology S1_basepoint)
        (fundamental_group_id S1 S1_topology S1_basepoint)
        cls (ordsucc (add_SNo m m))).
admit.
Qed.

(** from S57 Exercise 4(a) (line 1261 in algtop.tex) **)
(** LATEX VERSION: Given no continuous antipode-preserving map h: S^n -> S^n is nulhomotopic, there is no retraction r: B^{n+1} -> S^n. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex57_4a_no_retraction_from_borsuk : forall n:set, n :e omega ->
  (forall h:set, antipode_preserving_Sn n n h ->
    ~(nulhomotopic (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h)) ->
  ~(retraction_of (Bn_closed n) (Bn_closed_topology n) (Sn n)).
admit.
Qed.

(** from S57 Exercise 4(b) (line 1262 in algtop.tex) **)
(** LATEX VERSION: Given the hypothesis, there is no continuous antipode-preserving map g: S^{n+1} -> S^n. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex57_4b_no_antipode_higher : forall n:set, n :e omega ->
  (forall h:set, antipode_preserving_Sn (ordsucc n) (ordsucc n) h ->
    ~(nulhomotopic (Sn (ordsucc n)) (Sn_topology (ordsucc n))
                   (Sn (ordsucc n)) (Sn_topology (ordsucc n)) h)) ->
  ~(exists g:set, antipode_preserving_Sn (ordsucc n) n g).
admit.
Qed.

(** from S57 Exercise 4(c) (line 1263 in algtop.tex) **)
(** LATEX VERSION: (Borsuk-Ulam) Given the hypothesis, for any continuous f: S^{n+1} -> R^{n+1}, there exists x with f(x) = f(-x). **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex57_4c_borsuk_ulam_general : forall n:set, n :e omega ->
  (forall h:set, antipode_preserving_Sn (ordsucc n) (ordsucc n) h ->
    ~(nulhomotopic (Sn (ordsucc n)) (Sn_topology (ordsucc n))
                   (Sn (ordsucc n)) (Sn_topology (ordsucc n)) h)) ->
  forall f:set,
    continuous_map (Sn (ordsucc n)) (Sn_topology (ordsucc n))
                   (euclidean_space (ordsucc n)) (euclidean_topology (ordsucc n)) f ->
    exists x:set, x :e Sn (ordsucc n) /\
      apply_fun f x = apply_fun f (Rn_negate (ordsucc (ordsucc n)) x).
admit.
Qed.

(** ======================= S58 DEFORMATION RETRACTS AND HOMOTOPY TYPE ======================= **)

(** from S58 Lemma 58.1 (line 1272 in algtop.tex) **)
(** LATEX VERSION: Let h, k: (X,x0) -> (Y,y0) be continuous. If h and k are homotopic and the basepoint x0 remains fixed at y0 during the homotopy, then h-star = k-star. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem lemma58_1_basepoint_fixed_homotopy : forall X Tx Y Ty x0 y0 h k:set,
  continuous_map X Tx Y Ty h ->
  continuous_map X Tx Y Ty k ->
  apply_fun h x0 = y0 -> apply_fun k x0 = y0 ->
  x0 :e X ->
  (exists H:set, continuous_map (setprod X unit_interval)
    (product_topology X Tx unit_interval unit_interval_topology) Y Ty H /\
    (forall x:set, x :e X -> apply_fun H (x, 0) = apply_fun h x) /\
    (forall x:set, x :e X -> apply_fun H (x, 1) = apply_fun k x) /\
    (forall t:set, t :e unit_interval -> apply_fun H (x0, t) = y0)) ->
  (forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty y0 h) cls =
    apply_fun (induced_homomorphism X Tx x0 Y Ty y0 k) cls).
admit.
Qed.

(** from S58 Theorem 58.2 (line 1284 in algtop.tex) **)
(** LATEX VERSION: The inclusion map j: S^n -> R^{n+1}-0 induces an isomorphism of fundamental groups. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm58_2_inclusion_Sn_isomorphism : forall n:set, n :e omega ->
  forall b0:set, b0 :e Sn n ->
  group_isomorphism
    (fundamental_group (Sn n) (Sn_topology n) b0)
    (fundamental_group_mult (Sn n) (Sn_topology n) b0)
    (fundamental_group (Rn_minus_origin (ordsucc n)) (Rn_minus_origin_topology (ordsucc n)) b0)
    (fundamental_group_mult (Rn_minus_origin (ordsucc n)) (Rn_minus_origin_topology (ordsucc n)) b0)
    (induced_homomorphism (Sn n) (Sn_topology n) b0
      (Rn_minus_origin (ordsucc n)) (Rn_minus_origin_topology (ordsucc n)) b0
      (graph (Sn n) (fun x:set => x))).
admit.
Qed.

(** from S58 Definition (line 1315 in algtop.tex): deformation retract **)
(** LATEX VERSION: A is a deformation retract of X if there is a continuous H: X x I -> X with H(x,0)=x, H(x,1) in A for all x, and H(a,t)=a for all a in A, t in I. **)
Definition deformation_retract : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\
  exists H:set,
    continuous_map (setprod X unit_interval)
      (product_topology X Tx unit_interval unit_interval_topology) X Tx H /\
    (forall x:set, x :e X -> apply_fun H (x, 0) = x) /\
    (forall x:set, x :e X -> apply_fun H (x, 1) :e A) /\
    (forall a t:set, a :e A -> t :e unit_interval -> apply_fun H (a, t) = a).

(** from S58 Theorem 58.3 (line 1319 in algtop.tex) **)
(** LATEX VERSION: Let A be a deformation retract of X; let x0 in A. Then inclusion j: (A,x0) -> (X,x0) induces an isomorphism of fundamental groups. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm58_3_deformation_retract_isomorphism : forall X Tx A x0:set,
  topology_on X Tx ->
  deformation_retract X Tx A ->
  x0 :e A ->
  group_isomorphism
    (fundamental_group A (subspace_topology X Tx A) x0)
    (fundamental_group_mult A (subspace_topology X Tx A) x0)
    (fundamental_group X Tx x0)
    (fundamental_group_mult X Tx x0)
    (induced_homomorphism A (subspace_topology X Tx A) x0 X Tx x0
      (graph A (fun x:set => x))).
admit.
Qed.

(** from S58 Definition (line 1357 in algtop.tex): homotopy equivalence **)
(** LATEX VERSION: f: X -> Y and g: Y -> X are homotopy equivalences if g o f ~ id_X and f o g ~ id_Y. **)
Definition homotopy_equivalence : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    continuous_map X Tx Y Ty f /\
    exists g:set, continuous_map Y Ty X Tx g /\
      homotopic_maps X Tx X Tx
        (compose_fun X f g) (graph X (fun x:set => x)) /\
      homotopic_maps Y Ty Y Ty
        (compose_fun Y g f) (graph Y (fun y:set => y)).

(** Infrastructure: same homotopy type **)
Definition same_homotopy_type : set -> set -> set -> set -> prop :=
  fun X Tx Y Ty =>
    exists f:set, homotopy_equivalence X Tx Y Ty f.

(** from S58 Lemma 58.4 (line 1365 in algtop.tex) **)
(** LATEX VERSION: Let h, k: X -> Y be homotopic with h(x0)=y0, k(x0)=y1. There is a path alpha in Y from y0 to y1 such that k-star = alpha-hat o h-star. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma58_4_homotopy_path : forall X Tx Y Ty x0 h k:set,
  continuous_map X Tx Y Ty h ->
  continuous_map X Tx Y Ty k ->
  x0 :e X ->
  homotopic_maps X Tx Y Ty h k ->
  exists alpha:set,
    path_between Y (apply_fun h x0) (apply_fun k x0) alpha /\
    (forall cls:set, cls :e fundamental_group X Tx x0 ->
      apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun k x0) k) cls =
      apply_fun (basepoint_change_map Y Ty (apply_fun h x0) (apply_fun k x0) alpha)
        (apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls)).
admit.
Qed.

(** from S58 Corollary 58.5 (line 1423 in algtop.tex) **)
(** LATEX VERSION: Let h, k: X -> Y be homotopic. If h-star is injective (or surjective, or trivial), so is k-star. **)
(** EFFORT: 2 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor58_5_homotopic_maps_injective : forall X Tx Y Ty x0 h k:set,
  continuous_map X Tx Y Ty h ->
  continuous_map X Tx Y Ty k ->
  x0 :e X ->
  homotopic_maps X Tx Y Ty h k ->
  (forall cls1 cls2:set,
    cls1 :e fundamental_group X Tx x0 ->
    cls2 :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls1 =
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls2 ->
    cls1 = cls2) ->
  (forall cls1 cls2:set,
    cls1 :e fundamental_group X Tx x0 ->
    cls2 :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun k x0) k) cls1 =
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun k x0) k) cls2 ->
    cls1 = cls2).
admit.
Qed.

(** from S58 Corollary 58.5 surjective case (line 1423 in algtop.tex) **)
(** LATEX VERSION: Let h, k: X -> Y be homotopic. If h-star is surjective, so is k-star. **)
(** EFFORT: 2 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor58_5_homotopic_maps_surjective : forall X Tx Y Ty x0 h k:set,
  continuous_map X Tx Y Ty h ->
  continuous_map X Tx Y Ty k ->
  x0 :e X ->
  homotopic_maps X Tx Y Ty h k ->
  (forall cls:set,
    cls :e fundamental_group Y Ty (apply_fun h x0) ->
    exists cls0:set, cls0 :e fundamental_group X Tx x0 /\
      apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls0 = cls) ->
  (forall cls:set,
    cls :e fundamental_group Y Ty (apply_fun k x0) ->
    exists cls0:set, cls0 :e fundamental_group X Tx x0 /\
      apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun k x0) k) cls0 = cls).
admit.
Qed.

(** from S58 Corollary 58.5 trivial case (line 1423 in algtop.tex) **)
(** LATEX VERSION: Let h, k: X -> Y be homotopic. If h-star is trivial, so is k-star. **)
(** EFFORT: 2 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor58_5_homotopic_maps_trivial : forall X Tx Y Ty x0 h k:set,
  continuous_map X Tx Y Ty h ->
  continuous_map X Tx Y Ty k ->
  x0 :e X ->
  homotopic_maps X Tx Y Ty h k ->
  (forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls =
    fundamental_group_id Y Ty (apply_fun h x0)) ->
  (forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun k x0) k) cls =
    fundamental_group_id Y Ty (apply_fun k x0)).
admit.
Qed.

(** from S58 Corollary 58.6 (line 1425 in algtop.tex) **)
(** LATEX VERSION: If h: X -> Y is nulhomotopic, then h-star is the trivial homomorphism. **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 20 **)
Theorem cor58_6_nulhomotopic_trivial : forall X Tx Y Ty h x0:set,
  continuous_map X Tx Y Ty h ->
  x0 :e X ->
  nulhomotopic X Tx Y Ty h ->
  (forall cls:set, cls :e fundamental_group X Tx x0 ->
    apply_fun (induced_homomorphism X Tx x0 Y Ty (apply_fun h x0) h) cls =
    fundamental_group_id Y Ty (apply_fun h x0)).
admit.
Qed.

(** from S58 Theorem 58.7 (line 1429 in algtop.tex) **)
(** LATEX VERSION: If f: X -> Y is a homotopy equivalence with f(x0) = y0, then f-star: pi_1(X,x0) -> pi_1(Y,y0) is an isomorphism. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm58_7_homotopy_equiv_isomorphism : forall X Tx Y Ty f x0:set,
  homotopy_equivalence X Tx Y Ty f ->
  x0 :e X ->
  group_isomorphism
    (fundamental_group X Tx x0)
    (fundamental_group_mult X Tx x0)
    (fundamental_group Y Ty (apply_fun f x0))
    (fundamental_group_mult Y Ty (apply_fun f x0))
    (induced_homomorphism X Tx x0 Y Ty (apply_fun f x0) f).
admit.
Qed.

(** from S58 Exercise 1 (line 1475 in algtop.tex) **)
(** LATEX VERSION: If A is a deformation retract of X, and B is a deformation retract of A, then B is a deformation retract of X. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_1_transitive_deformation_retract : forall X Tx A B:set,
  topology_on X Tx ->
  deformation_retract X Tx A ->
  deformation_retract A (subspace_topology X Tx A) B ->
  deformation_retract X Tx B.
admit.
Qed.

(** from S58 Exercise 3 (line 1492 in algtop.tex) **)
(** LATEX VERSION: Homotopy equivalence is an equivalence relation. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_3_homotopy_equiv_transitive : forall X Tx Y Ty Z Tz:set,
  same_homotopy_type X Tx Y Ty ->
  same_homotopy_type Y Ty Z Tz ->
  same_homotopy_type X Tx Z Tz.
admit.
Qed.

(** from S58 Exercise 5 (line 1494 in algtop.tex) **)
(** LATEX VERSION: X is contractible if and only if X has the homotopy type of a one-point space. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_5_contractible_iff_point_type : forall X Tx:set,
  topology_on X Tx -> X <> Empty ->
  (contractible_space X Tx <->
   exists x0:set, x0 :e X /\
     same_homotopy_type X Tx (Sing x0) (Power (Sing x0))).
admit.
Qed.

(** from S58 Exercise 6 (line 1495 in algtop.tex) **)
(** LATEX VERSION: A retract of a contractible space is contractible. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex58_6_retract_of_contractible : forall X Tx A:set,
  topology_on X Tx ->
  contractible_space X Tx ->
  retraction_of X Tx A ->
  contractible_space A (subspace_topology X Tx A).
admit.
Qed.

(** from S58 Exercise 2 (line 1476-1491 in algtop.tex) **)
(** LATEX VERSION: For each of the following spaces, the fundamental group is either **)
(** trivial, infinite cyclic, or isomorphic to the figure eight fundamental group. **)

(** from S58 Exercise 2(a) (line 1477 in algtop.tex): solid torus B^2 x S^1 has infinite cyclic pi1 **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex58_2a_solid_torus_pi1 : forall x0:set,
  x0 :e setprod B2 S1 ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod B2 S1) (product_topology B2 B2_topology S1 S1_topology) x0)
      (fundamental_group_mult (setprod B2 S1) (product_topology B2 B2_topology S1 S1_topology) x0)
      (fundamental_group S1 S1_topology (x0 1))
      (fundamental_group_mult S1 S1_topology (x0 1))
      phi.
admit.
Qed.

(** from S58 Exercise 2(b) (line 1478 in algtop.tex): torus minus point **)
(** This is the free group on 2 generators (stated via homotopy equivalence) **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex58_2b_torus_minus_point_pi1 : forall p:set,
  p :e torus ->
  forall x0:set,
  x0 :e torus :\: Sing p ->
  let T' := torus :\: Sing p in
  let TT' := subspace_topology torus torus_topology T' in
  ~(forall cls1 cls2:set,
    cls1 :e fundamental_group T' TT' x0 ->
    cls2 :e fundamental_group T' TT' x0 ->
    apply_fun (fundamental_group_mult T' TT' x0) (cls1, cls2) =
    apply_fun (fundamental_group_mult T' TT' x0) (cls2, cls1)).
admit.
Qed.

(** from S58 Exercise 2(c) (line 1479 in algtop.tex): cylinder pi1 **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex58_2c_cylinder_pi1 : forall x0:set,
  x0 :e setprod S1 unit_interval ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod S1 unit_interval)
        (product_topology S1 S1_topology unit_interval unit_interval_topology) x0)
      (fundamental_group_mult (setprod S1 unit_interval)
        (product_topology S1 S1_topology unit_interval unit_interval_topology) x0)
      (fundamental_group S1 S1_topology (x0 0))
      (fundamental_group_mult S1 S1_topology (x0 0))
      phi.
admit.
Qed.

(** from S58 Exercise 2(d) (line 1480 in algtop.tex): infinite cylinder pi1 **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex58_2d_infinite_cylinder_pi1 : forall x0:set,
  x0 :e setprod S1 R ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod S1 R)
        (product_topology S1 S1_topology R R_standard_topology) x0)
      (fundamental_group_mult (setprod S1 R)
        (product_topology S1 S1_topology R R_standard_topology) x0)
      (fundamental_group S1 S1_topology (x0 0))
      (fundamental_group_mult S1 S1_topology (x0 0))
      phi.
admit.
Qed.

(** from S58 Exercise 2(e) (line 1481 in algtop.tex): R^3 with nonneg axes deleted pi1 **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex58_2e_R3_axes_deleted_pi1 :
  let R3 := setprod (setprod R R) R in
  let R3T := product_topology (setprod R R) R2_topology R R_standard_topology in
  let axes := {p :e R3 |
    (Rle 0 (p 0 0) /\ p 0 1 = 0 /\ p 1 = 0) \/
    (p 0 0 = 0 /\ Rle 0 (p 0 1) /\ p 1 = 0) \/
    (p 0 0 = 0 /\ p 0 1 = 0 /\ Rle 0 (p 1))} in
  let X := R3 :\: axes in
  forall x0:set, x0 :e X ->
  let TX := subspace_topology R3 R3T X in
  ~(forall cls1 cls2:set,
    cls1 :e fundamental_group X TX x0 ->
    cls2 :e fundamental_group X TX x0 ->
    apply_fun (fundamental_group_mult X TX x0) (cls1, cls2) =
    apply_fun (fundamental_group_mult X TX x0) (cls2, cls1)).
admit.
Qed.

(** from S58 Exercise 2(f) (line 1485 in algtop.tex) **)
(** LATEX VERSION: {x in R^2 : norm(x) > 1} has pi1 = Z (infinite cyclic). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex58_2f_exterior_open_disk_pi1 :
  let X := {p :e EuclidPlane | SNoLt 1 (distance_R2 p (0, 0))} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  forall x0:set, x0 :e X ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X TX x0) (fundamental_group_mult X TX x0)
      (fundamental_group S1 S1_topology S1_basepoint)
      (fundamental_group_mult S1 S1_topology S1_basepoint) phi.
admit.
Qed.

(** from S58 Exercise 2(g) (line 1486 in algtop.tex) **)
(** LATEX VERSION: {x in R^2 : norm(x) >= 1} has pi1 = Z (infinite cyclic). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex58_2g_exterior_closed_disk_pi1 :
  let X := {p :e EuclidPlane | Rle 1 (distance_R2 p (0, 0))} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  forall x0:set, x0 :e X ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X TX x0) (fundamental_group_mult X TX x0)
      (fundamental_group S1 S1_topology S1_basepoint)
      (fundamental_group_mult S1 S1_topology S1_basepoint) phi.
admit.
Qed.

(** from S58 Exercise 2(h) (line 1487 in algtop.tex) **)
(** LATEX VERSION: {x in R^2 : norm(x) < 1} (open disk) is simply connected. **)
(** EFFORT: 2 lines textbook, difficulty 1/10, USD 10 **)
Theorem ex58_2h_open_disk_simply_connected :
  let X := {p :e EuclidPlane | SNoLt (distance_R2 p (0, 0)) 1} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  simply_connected X TX.
admit.
Qed.

(** from S58 Exercise 2(i) (line 1488 in algtop.tex) **)
(** LATEX VERSION: S^1 union (R+ x {0}) has pi1 = Z (infinite cyclic). **)
(** The circle with a ray attached deformation retracts to S^1. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex58_2i_circle_with_ray_pi1 :
  let X := S1 :\/: {p :e EuclidPlane | R2_ycoord p = 0 /\ Rle 0 (R2_xcoord p)} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  forall x0:set, x0 :e X ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X TX x0) (fundamental_group_mult X TX x0)
      (fundamental_group S1 S1_topology S1_basepoint)
      (fundamental_group_mult S1 S1_topology S1_basepoint) phi.
admit.
Qed.

(** from S58 Exercise 2(j) (line 1489 in algtop.tex) **)
(** LATEX VERSION: S^1 union (R+ x R) has pi1 = Z (infinite cyclic). **)
(** The circle with a half-plane deformation retracts to S^1. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex58_2j_circle_with_halfplane_pi1 :
  let X := S1 :\/: {p :e EuclidPlane | Rle 0 (R2_xcoord p)} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  forall x0:set, x0 :e X ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X TX x0) (fundamental_group_mult X TX x0)
      (fundamental_group S1 S1_topology S1_basepoint)
      (fundamental_group_mult S1 S1_topology S1_basepoint) phi.
admit.
Qed.

(** from S58 Exercise 2(k) (line 1490 in algtop.tex) **)
(** LATEX VERSION: S^1 union (R x {0}) has pi1 isomorphic to the figure eight **)
(** (free group on 2 generators). The x-axis crosses the circle at two points, **)
(** creating a theta-like space. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex58_2k_circle_with_line_pi1 :
  let X := S1 :\/: {p :e EuclidPlane | R2_ycoord p = 0} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  forall x0:set, x0 :e X ->
  ~(forall cls1 cls2:set,
    cls1 :e fundamental_group X TX x0 ->
    cls2 :e fundamental_group X TX x0 ->
    apply_fun (fundamental_group_mult X TX x0) (cls1, cls2) =
    apply_fun (fundamental_group_mult X TX x0) (cls2, cls1)).
admit.
Qed.

(** from S58 Exercise 2(l) (line 1491 in algtop.tex) **)
(** LATEX VERSION: R^2 minus (R+ x {0}) (plane minus positive x-axis) **)
(** is simply connected. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex58_2l_plane_minus_ray_simply_connected :
  let X := EuclidPlane :\: {p :e EuclidPlane | R2_ycoord p = 0 /\ Rle 0 (R2_xcoord p)} in
  let TX := subspace_topology EuclidPlane R2_topology X in
  simply_connected X TX.
admit.
Qed.

(** from S58 Exercise 4 (line 1493 in algtop.tex) **)
(** LATEX VERSION: Let X be the figure eight and Y be the theta space. **)
(** Describe maps f: X -> Y and g: Y -> X that are homotopy inverse to each other. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_4_figure_eight_theta_homotopy_equiv :
  forall X Tx Y Ty:set,
  (** X is a figure-eight: union of two arcs sharing exactly two endpoints **)
  (exists a b A1 A2:set,
    X = A1 :\/: A2 /\
    A1 :/\: A2 = UPair a b /\ a <> b /\
    arc A1 (subspace_topology X Tx A1) /\
    arc A2 (subspace_topology X Tx A2) /\
    end_points_of_arc A1 (subspace_topology X Tx A1) a b /\
    end_points_of_arc A2 (subspace_topology X Tx A2) a b) ->
  (** Y is a theta space: union of three arcs sharing exactly their endpoints **)
  (exists a b A B C:set,
    Hausdorff_space Y Ty /\
    Y = A :\/: B :\/: C /\
    arc A (subspace_topology Y Ty A) /\
    arc B (subspace_topology Y Ty B) /\
    arc C (subspace_topology Y Ty C) /\
    end_points_of_arc A (subspace_topology Y Ty A) a b /\
    end_points_of_arc B (subspace_topology Y Ty B) a b /\
    end_points_of_arc C (subspace_topology Y Ty C) a b /\
    A :/\: B = UPair a b /\ A :/\: C = UPair a b /\ B :/\: C = UPair a b) ->
  same_homotopy_type X Tx Y Ty.
admit.
Qed.

(** from S58 Exercise 7 (line 1496-1499 in algtop.tex) **)
(** LATEX VERSION: Let A be a subspace of X with inclusion j. Let f: X -> A with **)
(** H: X x I -> X a homotopy between j o f and id_X. **)

(** from S58 Exercise 7(a) (line 1496 in algtop.tex): retraction implies isomorphism **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_7a_retraction_homotopy_isomorphism : forall X Tx A a0 f:set,
  A c= X ->
  a0 :e A ->
  continuous_map X Tx A (subspace_topology X Tx A) f ->
  (forall a:set, a :e A -> apply_fun f a = a) ->
  homotopic_maps X Tx X Tx
    (compose_fun X f (graph A (fun a:set => a)))
    (graph X (fun x:set => x)) ->
  group_isomorphism
    (fundamental_group A (subspace_topology X Tx A) a0)
    (fundamental_group_mult A (subspace_topology X Tx A) a0)
    (fundamental_group X Tx a0)
    (fundamental_group_mult X Tx a0)
    (induced_homomorphism A (subspace_topology X Tx A) a0 X Tx a0
      (graph A (fun x:set => x))).
admit.
Qed.

(** from S58 Exercise 7(b) (line 1496 in algtop.tex): A-preserving homotopy implies isomorphism **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex58_7b_A_preserved_homotopy_isomorphism : forall X Tx A a0 f H:set,
  A c= X ->
  a0 :e A ->
  continuous_map X Tx A (subspace_topology X Tx A) f ->
  continuous_map (setprod X unit_interval)
    (product_topology X Tx unit_interval unit_interval_topology) X Tx H ->
  (forall x:set, x :e X -> apply_fun H (x, 0) = apply_fun (graph A (fun a:set => a)) (apply_fun f x)) ->
  (forall x:set, x :e X -> apply_fun H (x, 1) = x) ->
  (forall a t:set, a :e A -> t :e unit_interval -> apply_fun H (a, t) :e A) ->
  group_isomorphism
    (fundamental_group A (subspace_topology X Tx A) a0)
    (fundamental_group_mult A (subspace_topology X Tx A) a0)
    (fundamental_group X Tx a0)
    (fundamental_group_mult X Tx a0)
    (induced_homomorphism A (subspace_topology X Tx A) a0 X Tx a0
      (graph A (fun x:set => x))).
admit.
Qed.

(** from S58 Exercise 10 (line 1528-1536 in algtop.tex) **)
(** LATEX VERSION: Suppose a degree function deg: (S^n -> S^n) -> Z exists with **)
(** properties (i) homotopic maps have same degree, (ii) deg(h o k) = deg h times deg k, **)
(** (iii) id has degree 1, constant has degree 0, reflection has degree -1. **)

(** from S58 Exercise 10(a) (line 1528 in algtop.tex): no retraction B^{n+1} -> S^n **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex58_10a_no_retraction_from_degree : forall n:set, n :e omega ->
  forall deg:set,
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    homotopic_maps (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h k ->
    apply_fun deg h = apply_fun deg k) ->
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    apply_fun deg (compose_fun (Sn n) k h) = mul_SNo (apply_fun deg h) (apply_fun deg k)) ->
  apply_fun deg (graph (Sn n) (fun x:set => x)) = 1 ->
  ~(retraction_of (Bn_closed (ordsucc n)) (Bn_closed_topology (ordsucc n)) (Sn n)).
admit.
Qed.

(** from S58 Exercise 10(b) (line 1528 in algtop.tex): degree and fixed point **)
(** EFFORT: 6 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex58_10b_degree_fixed_point : forall n:set, n :e omega ->
  forall deg:set,
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    homotopic_maps (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h k ->
    apply_fun deg h = apply_fun deg k) ->
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    apply_fun deg (compose_fun (Sn n) k h) = mul_SNo (apply_fun deg h) (apply_fun deg k)) ->
  apply_fun deg (graph (Sn n) (fun x:set => x)) = 1 ->
  apply_fun deg (graph (Sn n) (fun x:set => Rn_negate (ordsucc n) x)) = minus_SNo 1 ->
  forall h:set,
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    apply_fun deg h <> nat_primrec 1 (fun _ r => mul_SNo (minus_SNo 1) r) (ordsucc n) ->
    exists x:set, x :e Sn n /\ apply_fun h x = x.
admit.
Qed.

(** from S58 Exercise 10(d) (line 1528 in algtop.tex): tangent vector field implies n odd **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex58_10d_tangent_field_odd : forall n:set, n :e omega ->
  forall deg:set,
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    homotopic_maps (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h k ->
    apply_fun deg h = apply_fun deg k) ->
  (forall h k:set, continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) h ->
    continuous_map (Sn n) (Sn_topology n) (Sn n) (Sn_topology n) k ->
    apply_fun deg (compose_fun (Sn n) k h) = mul_SNo (apply_fun deg h) (apply_fun deg k)) ->
  apply_fun deg (graph (Sn n) (fun x:set => x)) = 1 ->
  apply_fun deg (graph (Sn n) (fun x:set => Rn_negate (ordsucc n) x)) = minus_SNo 1 ->
  (exists v:set,
    continuous_map (Sn n) (Sn_topology n)
      (euclidean_space (ordsucc n)) (euclidean_topology (ordsucc n)) v /\
    (forall x:set, x :e Sn n ->
      apply_fun v x <> graph (ordsucc n) (fun i:set => 0) /\
      finite_real_sum (fun i:set => mul_SNo (apply_fun x i) (apply_fun (apply_fun v x) i)) (ordsucc n) = 0)) ->
  exists k:set, k :e omega /\ n = add_SNo (mul_SNo 2 k) 1.
admit.
Qed.

(** Infrastructure for Exercise 58.9: degree of a continuous map h: S^1 -> S^1 **)
(** The degree d is the unique integer such that for any lift starting point e0 **)
(** covering h(b0), the lift of h o p0 from e0 ends at e0 + d **)
Definition degree_of_map_S1 : set -> set := fun h =>
  Eps_i (fun d:set => d :e int /\
    forall e0:set, e0 :e R ->
      apply_fun covering_map_R_S1 e0 = apply_fun h S1_basepoint ->
      apply_fun (path_lift R R_standard_topology S1 S1_topology
        covering_map_R_S1 e0
        (compose_fun unit_interval
          (graph unit_interval (fun s:set => apply_fun covering_map_R_S1 s))
          h))
        1 = add_SNo e0 d).

(** from S58 Exercise 9(a) (line 1523 in algtop.tex) **)
(** LATEX VERSION: The degree d is independent of the choice of x0. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_9a_degree_well_defined : forall h:set,
  continuous_map S1 S1_topology S1 S1_topology h ->
  degree_of_map_S1 h :e int.
admit.
Qed.

(** from S58 Exercise 9(b) (line 1524 in algtop.tex) **)
(** LATEX VERSION: If h, k: S^1 -> S^1 are homotopic, they have the same degree. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_9b_homotopic_same_degree : forall h k:set,
  continuous_map S1 S1_topology S1 S1_topology h ->
  continuous_map S1 S1_topology S1 S1_topology k ->
  homotopic_maps S1 S1_topology S1 S1_topology h k ->
  degree_of_map_S1 h = degree_of_map_S1 k.
admit.
Qed.

(** from S58 Exercise 9(c) (line 1525 in algtop.tex) **)
(** LATEX VERSION: deg(h o k) = (deg h) times (deg k). **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex58_9c_degree_multiplicative : forall h k:set,
  continuous_map S1 S1_topology S1 S1_topology h ->
  continuous_map S1 S1_topology S1 S1_topology k ->
  degree_of_map_S1 (compose_fun S1 k h) =
    mul_SNo (degree_of_map_S1 h) (degree_of_map_S1 k).
admit.
Qed.

(** from S58 Exercise 9(d) (line 1526 in algtop.tex) **)
(** LATEX VERSION: Degrees: constant map has degree 0, identity has degree 1, reflection has degree -1, z^n has degree n. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex58_9d_degree_computations :
  (forall c:set, c :e S1 ->
    degree_of_map_S1 (const_fun S1 c) = 0) /\
  degree_of_map_S1 (graph S1 (fun x:set => x)) = 1 /\
  degree_of_map_S1 (graph S1 (fun z:set => (z 0, minus_SNo (z 1)))) = minus_SNo 1 /\
  (forall n:set, n :e omega -> n <> 0 ->
    degree_of_map_S1 (S1_power_map n) = n).
admit.
Qed.

(** ======================= S59 THE FUNDAMENTAL GROUP OF S^n ======================= **)

(** from S59 Theorem 59.1 (line 1541 in algtop.tex) **)
(** LATEX VERSION: Suppose X = U union V where U, V are open in X. If U intersect V is path connected and x0 in U intersect V, then the images of i-star and j-star generate pi_1(X, x0). **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm59_1_open_cover_generates_pi1 : forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx ->
  X = U :\/: V ->
  x0 :e U :/\: V ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  (forall cls:set, cls :e fundamental_group X Tx x0 ->
    exists n:set, n :e omega /\
    exists gs:set, function_on gs n (fundamental_group X Tx x0) /\
      (forall i:set, i :e n ->
        (exists ucls:set, ucls :e fundamental_group U (subspace_topology X Tx U) x0 /\
          apply_fun gs i =
            apply_fun (induced_homomorphism U (subspace_topology X Tx U) x0 X Tx x0
              (graph U (fun x:set => x))) ucls) \/
        (exists vcls:set, vcls :e fundamental_group V (subspace_topology X Tx V) x0 /\
          apply_fun gs i =
            apply_fun (induced_homomorphism V (subspace_topology X Tx V) x0 X Tx x0
              (graph V (fun x:set => x))) vcls)) /\
      cls = nat_primrec (fundamental_group_id X Tx x0)
        (fun k r => apply_fun (fundamental_group_mult X Tx x0) (r, apply_fun gs k)) n).
admit.
Qed.

(** from S59 Corollary 59.2 (line 1585 in algtop.tex) **)
(** LATEX VERSION: If X = U union V, U and V open and simply connected, U intersect V nonempty and path connected, then X is simply connected. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor59_2_simply_connected_union : forall X Tx U V:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx ->
  X = U :\/: V ->
  simply_connected U (subspace_topology X Tx U) ->
  simply_connected V (subspace_topology X Tx V) ->
  (U :/\: V) <> Empty ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  simply_connected X Tx.
admit.
Qed.

(** from S59 Theorem 59.3 (line 1587 in algtop.tex) **)
(** LATEX VERSION: If n >= 2, the n-sphere S^n is simply connected. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm59_3_Sn_simply_connected : forall n:set,
  n :e omega -> 2 c= n ->
  simply_connected (Sn n) (Sn_topology n).
admit.
Qed.

(** from S59 Exercise 1 (line 1615 in algtop.tex) **)
(** LATEX VERSION: Let X be the union of two copies of S^2 having a single point in common. The fundamental group of X is trivial. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex59_1_wedge_S2_trivial_pi1 : forall X Tx x0 A B fA fB:set,
  topology_on X Tx ->
  X = A :\/: B ->
  A :/\: B = Sing x0 ->
  homeomorphism A (subspace_topology X Tx A) (Sn 2) (Sn_topology 2) fA ->
  homeomorphism B (subspace_topology X Tx B) (Sn 2) (Sn_topology 2) fB ->
  simply_connected X Tx.
admit.
Qed.

(** from S59 Exercise 3(a) (line 1617 in algtop.tex) **)
(** LATEX VERSION: R^1 and R^n are not homeomorphic if n > 1. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex59_3a_R1_not_homeo_Rn : forall n:set,
  n :e omega -> 2 c= n ->
  ~(exists f:set, homeomorphism R R_standard_topology
    (euclidean_space n) (euclidean_topology n) f).
admit.
Qed.

(** from S59 Exercise 3(b) (line 1618 in algtop.tex) **)
(** LATEX VERSION: R^2 and R^n are not homeomorphic if n > 2. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex59_3b_R2_not_homeo_Rn : forall n:set,
  n :e omega -> 3 c= n ->
  ~(exists f:set, homeomorphism (setprod R R) R2_topology
    (euclidean_space n) (euclidean_topology n) f).
admit.
Qed.

(** from S59 Exercise 4(a) (line 1622-1623 in algtop.tex) **)
(** LATEX VERSION: Assume hypotheses of Thm 59.1. What if j-star is trivial? **)
(** Then pi1(X,x0) is generated by the image of i-star alone. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex59_4a_trivial_j_star : forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx ->
  X = U :\/: V ->
  x0 :e U :/\: V ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  (forall cls:set,
    cls :e fundamental_group V (subspace_topology X Tx V) x0 ->
    apply_fun (induced_homomorphism V (subspace_topology X Tx V) x0 X Tx x0
      (graph V (fun x:set => x))) cls = fundamental_group_id X Tx x0) ->
  forall cls:set, cls :e fundamental_group X Tx x0 ->
    exists ucls:set,
      ucls :e fundamental_group U (subspace_topology X Tx U) x0 /\
      cls = apply_fun (induced_homomorphism U (subspace_topology X Tx U) x0 X Tx x0
        (graph U (fun x:set => x))) ucls.
admit.
Qed.

(** from S59 Exercise 4(a) continued: both i-star and j-star trivial **)
(** LATEX VERSION: If both i-star and j-star are trivial, then pi1(X,x0) is trivial. **)
(** EFFORT: 2 lines textbook, difficulty 2/10, USD 25 **)
Theorem ex59_4a_both_trivial : forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx ->
  X = U :\/: V ->
  x0 :e U :/\: V ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  (forall cls:set,
    cls :e fundamental_group U (subspace_topology X Tx U) x0 ->
    apply_fun (induced_homomorphism U (subspace_topology X Tx U) x0 X Tx x0
      (graph U (fun x:set => x))) cls = fundamental_group_id X Tx x0) ->
  (forall cls:set,
    cls :e fundamental_group V (subspace_topology X Tx V) x0 ->
    apply_fun (induced_homomorphism V (subspace_topology X Tx V) x0 X Tx x0
      (graph V (fun x:set => x))) cls = fundamental_group_id X Tx x0) ->
  simply_connected X Tx.
admit.
Qed.

(** ============================================================ **)
(** S60 Fundamental Groups of Some Surfaces                      **)
(** (lines 1626-1792 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: abelian (commutative) group **)
Definition abelian_group : set -> set -> set -> set -> prop :=
  fun G mult e inv =>
    group_structure G mult e inv /\
    (forall x y:set, x :e G -> y :e G ->
      apply_fun mult (x, y) = apply_fun mult (y, x)).

(** from S60 Theorem 60.1 (line 1639 in algtop.tex) **)
(** LATEX VERSION: pi_1(X x Y, x0 x y0) is isomorphic with pi_1(X, x0) x pi_1(Y, y0). **)
(** EFFORT: 20 lines textbook, difficulty 5/10, USD 200 **)
Theorem thm60_1_pi1_product : forall X Tx x0 Y Ty y0:set,
  topology_on X Tx -> topology_on Y Ty -> x0 :e X -> y0 :e Y ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod X Y) (product_topology X Tx Y Ty) (x0, y0))
      (fundamental_group_mult (setprod X Y) (product_topology X Tx Y Ty) (x0, y0))
      (setprod
        (fundamental_group X Tx x0)
        (fundamental_group Y Ty y0))
      (product_group_mult
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
        (fundamental_group Y Ty y0) (fundamental_group_mult Y Ty y0))
      phi.
admit.
Qed.

(** from S60 Corollary 60.2 (line 1683 in algtop.tex) **)
(** LATEX VERSION: pi_1(torus) isomorphic to Z x Z. **)
(** Already stated as ex54_7_pi1_torus above. **)

(** from S60 Definition (line 1687 in algtop.tex) **)
(** LATEX VERSION: The projective plane P^2 is the quotient space obtained **)
(** from S^2 by identifying each point x with its antipodal point -x. **)

(** Infrastructure: projective n-space P^n as quotient of S^n **)
(** The quotient map sends x to its equivalence class {x, -x} **)
Definition projective_n_space : set -> set := fun n =>
  {UPair x (Rn_negate (ordsucc n) x) | x :e Sn n}.

Definition projective_n_space_map : set -> set := fun n =>
  graph (Sn n) (fun x:set => UPair x (Rn_negate (ordsucc n) x)).

Definition projective_n_space_topology : set -> set := fun n =>
  quotient_topology (Sn n) (Sn_topology n)
    (projective_n_space n) (projective_n_space_map n).

(** Specialization to P^2 **)
Definition projective_plane : set := projective_n_space 2.
Definition projective_plane_topology : set := projective_n_space_topology 2.
Definition projective_plane_map : set := projective_n_space_map 2.

(** from S60 Theorem 60.3 (line 1691 in algtop.tex) **)
(** LATEX VERSION: P^2 is a compact surface, and the quotient map p: S^2 -> P^2 **)
(** is a covering map. **)
(** EFFORT: 25 lines textbook, difficulty 6/10, USD 300 **)
Theorem thm60_3_projective_plane_surface_covering :
  m_manifold projective_plane projective_plane_topology 2 /\
  compact_space projective_plane projective_plane_topology /\
  covering_map (Sn 2) (Sn_topology 2)
    projective_plane projective_plane_topology projective_plane_map.
admit.
Qed.

(** from S60 Corollary 60.4 (line 1725 in algtop.tex) **)
(** LATEX VERSION: pi_1(P^2, y) is a group of order 2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor60_4_pi1_projective_plane : forall y:set,
  y :e projective_plane ->
  exists a:set,
    a :e fundamental_group projective_plane projective_plane_topology y /\
    a <> fundamental_group_id projective_plane projective_plane_topology y /\
    (forall g:set,
      g :e fundamental_group projective_plane projective_plane_topology y ->
      g = fundamental_group_id projective_plane projective_plane_topology y \/ g = a).
admit.
Qed.

(** from S60 text (line 1730 in algtop.tex) **)
(** LATEX VERSION: pi_1(P^n, y) is a two-element group for n >= 2, **)
(** because S^n is simply connected and p: S^n -> P^n is a covering map. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem pi1_projective_n_space_order_2 : forall n:set,
  n :e omega -> 2 c= n ->
  forall y:set, y :e projective_n_space n ->
  exists a:set,
    a :e fundamental_group (projective_n_space n) (projective_n_space_topology n) y /\
    a <> fundamental_group_id (projective_n_space n) (projective_n_space_topology n) y /\
    (forall g:set,
      g :e fundamental_group (projective_n_space n) (projective_n_space_topology n) y ->
      g = fundamental_group_id (projective_n_space n) (projective_n_space_topology n) y \/ g = a).
admit.
Qed.

(** Infrastructure: the figure eight (wedge of two circles in R^2) **)
(** Circle A: centered at (-1, 0) with radius 1 **)
(** Circle B: centered at (1, 0) with radius 1 **)
(** They meet at the base point (0, 0) **)
Definition figure_eight : set :=
  {p :e setprod R R |
    add_SNo (mul_SNo (add_SNo (p 0) 1) (add_SNo (p 0) 1))
            (mul_SNo (p 1) (p 1)) = 1 \/
    add_SNo (mul_SNo (add_SNo (p 0) (minus_SNo 1)) (add_SNo (p 0) (minus_SNo 1)))
            (mul_SNo (p 1) (p 1)) = 1}.

Definition figure_eight_topology : set :=
  subspace_topology (setprod R R) R2_topology figure_eight.

Definition figure_eight_basepoint : set := (0, 0).

(** from S60 Lemma 60.5 (line 1734 in algtop.tex) **)
(** LATEX VERSION: The fundamental group of the figure eight is not abelian. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma60_5_figure_eight_nonabelian :
  ~(abelian_group
    (fundamental_group figure_eight figure_eight_topology figure_eight_basepoint)
    (fundamental_group_mult figure_eight figure_eight_topology figure_eight_basepoint)
    (fundamental_group_id figure_eight figure_eight_topology figure_eight_basepoint)
    (fundamental_group_inv figure_eight figure_eight_topology figure_eight_basepoint)).
admit.
Qed.

(** Infrastructure: disjoint union (coproduct) topology **)
(** U is open in X :+: Y iff preimages under both injections are open **)
Definition disjoint_union_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    {U :e Power (X :+: Y) |
      {x :e X | Inj0 x :e U} :e Tx /\
      {y :e Y | Inj1 y :e U} :e Ty}.

(** Infrastructure: connected sum of two surfaces **)
(** M1 # M2 is obtained by removing disk interiors and gluing boundaries **)
(** h is a homeomorphism from boundary(D1) to boundary(D2) **)
(** Quotient map: Inj0 x -> Inj0 x, Inj1 y on bdry -> Inj0 (h^-1 y), else Inj1 y **)
Definition connected_sum_quot_map : set -> set -> set -> set -> set -> set -> set -> set :=
  fun M1 TM1 D1 M2 TM2 D2 h =>
    {(Inj0 x, Inj0 x) | x :e M1 :\: interior_of M1 TM1 D1} :\/:
    {(Inj1 y,
      Inj0 (Eps_i (fun x:set =>
        x :e D1 :\: interior_of M1 TM1 D1 /\ apply_fun h x = y))) |
      y :e D2 :\: interior_of M2 TM2 D2} :\/:
    {(Inj1 y, Inj1 y) | y :e M2 :\: D2}.

(** The connected sum as a set **)
Definition connected_sum_space : set -> set -> set -> set -> set -> set -> set -> set :=
  fun M1 TM1 D1 M2 TM2 D2 h =>
    {Inj0 x | x :e M1 :\: interior_of M1 TM1 D1} :\/:
    {Inj1 y | y :e M2 :\: D2}.

(** The topology on the connected sum **)
Definition connected_sum_topology : set -> set -> set -> set -> set -> set -> set -> set :=
  fun M1 TM1 D1 M2 TM2 D2 h =>
    quotient_topology
      ((M1 :\: interior_of M1 TM1 D1) :+: (M2 :\: interior_of M2 TM2 D2))
      (disjoint_union_topology
        (M1 :\: interior_of M1 TM1 D1)
        (subspace_topology M1 TM1 (M1 :\: interior_of M1 TM1 D1))
        (M2 :\: interior_of M2 TM2 D2)
        (subspace_topology M2 TM2 (M2 :\: interior_of M2 TM2 D2)))
      (connected_sum_space M1 TM1 D1 M2 TM2 D2 h)
      (connected_sum_quot_map M1 TM1 D1 M2 TM2 D2 h).

(** Infrastructure: embedded closed disk in torus for double torus construction **)
Definition double_torus_disk : set :=
  Eps_i (fun D:set => D c= torus /\
    (exists f:set,
      homeomorphism D (subspace_topology torus torus_topology D)
                    B2 B2_topology f)).

(** Infrastructure: gluing homeomorphism for double torus **)
Definition double_torus_gluing : set :=
  Eps_i (fun h:set =>
    homeomorphism
      (double_torus_disk :\: interior_of torus torus_topology double_torus_disk)
      (subspace_topology torus torus_topology
        (double_torus_disk :\: interior_of torus torus_topology double_torus_disk))
      (double_torus_disk :\: interior_of torus torus_topology double_torus_disk)
      (subspace_topology torus torus_topology
        (double_torus_disk :\: interior_of torus torus_topology double_torus_disk))
      h).

(** The double torus T # T: connected sum of two copies of the torus **)
Definition double_torus : set :=
  connected_sum_space torus torus_topology double_torus_disk
                      torus torus_topology double_torus_disk
                      double_torus_gluing.

Definition double_torus_topology : set :=
  connected_sum_topology torus torus_topology double_torus_disk
                         torus torus_topology double_torus_disk
                         double_torus_gluing.

(** from S60 Theorem 60.6 (line 1759 in algtop.tex) **)
(** LATEX VERSION: The fundamental group of the double torus is not abelian. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm60_6_double_torus_nonabelian : forall x0:set,
  x0 :e double_torus ->
  ~(abelian_group
    (fundamental_group double_torus double_torus_topology x0)
    (fundamental_group_mult double_torus double_torus_topology x0)
    (fundamental_group_id double_torus double_torus_topology x0)
    (fundamental_group_inv double_torus double_torus_topology x0)).
admit.
Qed.

(** from S60 Corollary 60.7 (line 1774 in algtop.tex) **)
(** LATEX VERSION: The 2-sphere, torus, projective plane, and double torus **)
(** are topologically distinct. **)
(** EFFORT: 8 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor60_7_surfaces_distinct :
  ~(exists f:set, homeomorphism
    (Sn 2) (Sn_topology 2) torus torus_topology f) /\
  ~(exists f:set, homeomorphism
    (Sn 2) (Sn_topology 2) projective_plane projective_plane_topology f) /\
  ~(exists f:set, homeomorphism
    (Sn 2) (Sn_topology 2) double_torus double_torus_topology f) /\
  ~(exists f:set, homeomorphism
    torus torus_topology projective_plane projective_plane_topology f) /\
  ~(exists f:set, homeomorphism
    torus torus_topology double_torus double_torus_topology f) /\
  ~(exists f:set, homeomorphism
    projective_plane projective_plane_topology double_torus double_torus_topology f).
admit.
Qed.

(** from S60 Exercise 1 (line 1778 in algtop.tex) **)
(** LATEX VERSION: Compute pi_1 of the solid torus S^1 x B^2 and of S^1 x S^2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex60_1a_pi1_solid_torus : forall x0:set, x0 :e S1 ->
  forall b0:set, b0 :e B2 ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod S1 B2)
        (product_topology S1 S1_topology B2 B2_topology) (x0, b0))
      (fundamental_group_mult (setprod S1 B2)
        (product_topology S1 S1_topology B2 B2_topology) (x0, b0))
      int integers_group_mult phi.
admit.
Qed.

(** from S60 Exercise 1(b) (line 1776 in algtop.tex): pi1 of S^1 x S^2 **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex60_1b_pi1_S1_cross_S2 : forall x0:set, x0 :e S1 ->
  forall s0:set, s0 :e Sn 2 ->
  exists phi:set,
    group_isomorphism
      (fundamental_group (setprod S1 (Sn 2))
        (product_topology S1 S1_topology (Sn 2) (Sn_topology 2)) (x0, s0))
      (fundamental_group_mult (setprod S1 (Sn 2))
        (product_topology S1 S1_topology (Sn 2) (Sn_topology 2)) (x0, s0))
      int integers_group_mult phi.
admit.
Qed.

(** from S60 Exercise 2 (line 1779 in algtop.tex) **)
(** LATEX VERSION: B^2 with antipodal identification on S^1 is homeomorphic to P^2. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex60_2_quotient_B2_is_P2 :
  exists X TX q:set,
    quotient_map B2 B2_topology X q /\
    TX = quotient_topology B2 B2_topology X q /\
    (forall x:set, x :e B2 :\: S1 ->
      forall y:set, y :e B2 -> apply_fun q x = apply_fun q y -> x = y) /\
    (forall x:set, x :e S1 ->
      apply_fun q x =
      apply_fun q (minus_SNo (x 0), minus_SNo (x 1))) /\
    (exists f:set, homeomorphism X TX
      projective_plane projective_plane_topology f).
admit.
Qed.

(** from S60 Exercise 4 (line 1781 in algtop.tex) **)
(** LATEX VERSION: P^1 and the covering map S^1 -> P^1 are familiar: P^1 is S^1. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex60_4_P1_is_S1 :
  exists f:set, homeomorphism
    (projective_n_space 1) (projective_n_space_topology 1)
    (Sn 1) (Sn_topology 1) f.
admit.
Qed.

(** from S60 Exercise 3 (line 1780 in algtop.tex) **)
(** LATEX VERSION: Let p: E -> X be the map from Lemma 60.5 proof, E' the **)
(** union of x-axis and y-axis in E. Show p|E' is not a covering map. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex60_3_restriction_not_covering : forall E Te X Tx p:set,
  covering_map E Te X Tx p ->
  forall E':set, E' c= E ->
  (** E' is a union of two lines through the origin **)
  (exists f1 f2:set,
    E' = image_of f1 R :\/: image_of f2 R /\
    continuous_map R R_standard_topology E Te f1 /\
    continuous_map R R_standard_topology E Te f2) ->
  (** E' restricted to p is not a covering map (the fibers are not uniform) **)
  exists U:set, U :e Tx /\
    ~(evenly_covered E' (subspace_topology E Te E') X Tx
      (graph E' (fun x:set => apply_fun p x)) U).
admit.
Qed.

(** from S60 Exercise 5 (line 1782 in algtop.tex) **)
(** LATEX VERSION: Consider the covering map indicated in Figure 60.3. **)
(** p wraps A1 around A twice and B1 around B twice. **)
(** Use this covering space to show pi1(figure eight) is not abelian. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex60_5_covering_figure_eight_not_abelian : forall X Tx x0 E Te e0 p:set,
  (** X is a figure eight **)
  (exists A B:set,
    X = A :\/: B /\
    arc A (subspace_topology X Tx A) /\ arc B (subspace_topology X Tx B) /\
    A :/\: B = Sing x0) ->
  covering_map E Te X Tx p ->
  apply_fun p e0 = x0 ->
  ~(forall cls1 cls2:set,
    cls1 :e fundamental_group X Tx x0 ->
    cls2 :e fundamental_group X Tx x0 ->
    apply_fun (fundamental_group_mult X Tx x0) (cls1, cls2) =
    apply_fun (fundamental_group_mult X Tx x0) (cls2, cls1)).
admit.
Qed.

(** ============================================================ **)
(** S61 The Jordan Separation Theorem                            **)
(** (lines 1797-1925 in algtop.tex)                              **)
(** ============================================================ **)

(** from S61 Definition (line 1853 in algtop.tex) **)
(** LATEX VERSION: A separates X if X-A is not connected. **)
Definition separates : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\
  ~(connected_space (X :\: A) (subspace_topology X Tx (X :\: A))).

(** from S61 Definition (line 1863 in algtop.tex) **)
(** LATEX VERSION: An arc is a space homeomorphic to [0,1]. **)
Definition is_arc : set -> set -> prop := fun A TA =>
  exists h:set, homeomorphism A TA unit_interval unit_interval_topology h.

(** from S61 Definition (line 1865 in algtop.tex) **)
(** LATEX VERSION: A simple closed curve is a space homeomorphic to S^1. **)
Definition is_simple_closed_curve : set -> set -> prop := fun C TC =>
  exists h:set, homeomorphism C TC S1 S1_topology h.

(** Infrastructure: bounded subset of R^2 **)
Definition bounded_subset_R2 : set -> prop := fun A =>
  A c= setprod R R /\
  exists M:set, M :e R /\ Rlt 0 M /\
    (forall p:set, p :e A ->
      ~(Rlt M (add_SNo (mul_SNo (p 0) (p 0)) (mul_SNo (p 1) (p 1))))).

(** from S61 Lemma 61.1 (line 1806 in algtop.tex) **)
(** LATEX VERSION: Let C be compact in S^2, b in S^2-C, h: S^2-b -> R^2 homeomorphism. **)
(** If U is a component of S^2-C not containing b, then h(U) is bounded. **)
(** If U contains b, then h(U-b) is the unbounded component of R^2-h(C). **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 250 **)
Theorem lemma61_1_components_stereographic : forall C:set,
  C c= Sn 2 ->
  compact_space C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
  forall b:set, b :e Sn 2 -> ~(b :e C) ->
  forall h:set,
    homeomorphism (Sn 2 :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing b))
      (setprod R R) R2_topology h ->
  (forall u:set, u :e Sn 2 :\: C ->
    let U := component_of (Sn 2 :\: C) (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) u in
    ~(b :e U) -> bounded_subset_R2 (image_of h U)) /\
  (forall u:set, u :e Sn 2 :\: C ->
    let U := component_of (Sn 2 :\: C) (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) u in
    b :e U ->
    ~(bounded_subset_R2 (image_of h (U :\: Sing b)))).
admit.
Qed.

(** from S61 Lemma 61.2 (line 1815 in algtop.tex) **)
(** LATEX VERSION: Let a, b be points of S^2. Let A be compact, f: A -> S^2-a-b continuous. **)
(** If a and b lie in the same component of S^2-f(A), then f is nulhomotopic. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem lemma61_2_nulhomotopy : forall a b:set,
  a :e Sn 2 -> b :e Sn 2 -> a <> b ->
  forall A TA:set, compact_space A TA ->
  forall f:set,
    continuous_map A TA (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f ->
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) a =
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) b ->
    nulhomotopic A TA
      (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f.
admit.
Qed.

(** from S61 Theorem 61.3 (line 1867 in algtop.tex) **)
(** LATEX VERSION: (Jordan separation theorem) A simple closed curve in S^2 separates S^2. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 350 **)
Theorem thm61_3_jordan_separation : forall C:set,
  C c= Sn 2 ->
  is_simple_closed_curve C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
  separates (Sn 2) (Sn_topology 2) C.
admit.
Qed.

(** from S61 Theorem 61.4 (line 1908 in algtop.tex) **)
(** LATEX VERSION: (General separation theorem) Let A1, A2 be closed connected subsets **)
(** of S^2 whose intersection consists of exactly two points a and b. **)
(** Then C = A1 union A2 separates S^2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm61_4_general_separation : forall A1 A2 a b:set,
  A1 c= Sn 2 -> A2 c= Sn 2 ->
  Sn 2 :\: A1 :e Sn_topology 2 ->
  Sn 2 :\: A2 :e Sn_topology 2 ->
  connected_space A1 (subspace_topology (Sn 2) (Sn_topology 2) A1) ->
  connected_space A2 (subspace_topology (Sn 2) (Sn_topology 2) A2) ->
  a :e Sn 2 -> b :e Sn 2 -> a <> b ->
  A1 :/\: A2 = UPair a b ->
  separates (Sn 2) (Sn_topology 2) (A1 :\/: A2).
admit.
Qed.

(** from S61 Exercise 2 (line 1916 in algtop.tex) **)
(** LATEX VERSION: If C is homeomorphic to the closed topologists sine curve, C separates S^2. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex61_2_closed_sin_curve_separates : forall C:set,
  C c= Sn 2 ->
  compact_space C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
  connected_space C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
  (exists A1 A2:set,
    C = A1 :\/: A2 /\ A1 c= Sn 2 /\ A2 c= Sn 2 /\
    connected_space A1 (subspace_topology (Sn 2) (Sn_topology 2) A1) /\
    connected_space A2 (subspace_topology (Sn 2) (Sn_topology 2) A2) /\
    exists a b:set, a <> b /\ A1 :/\: A2 = UPair a b) ->
  separates (Sn 2) (Sn_topology 2) C.
admit.
Qed.

(** from S61 Exercise 1 (line 1915 in algtop.tex) **)
(** LATEX VERSION: A simple closed curve in the torus may or may not separate the torus. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex61_1a_torus_separating_curve : exists C:set,
  C c= torus /\
  is_simple_closed_curve C (subspace_topology torus torus_topology C) /\
  separates torus torus_topology C.
admit.
Qed.

(** from S61 Exercise 1 (line 1915 in algtop.tex) **)
(** LATEX VERSION: A simple closed curve in the torus may not separate the torus. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex61_1b_torus_non_separating_curve : exists C:set,
  C c= torus /\
  is_simple_closed_curve C (subspace_topology torus torus_topology C) /\
  ~(separates torus torus_topology C).
admit.
Qed.

(** ============================================================ **)
(** S62 Invariance of Domain                                     **)
(** (lines 1927-2011 in algtop.tex)                              **)
(** ============================================================ **)

(** from S62 Lemma 62.1 (line 1930 in algtop.tex) **)
(** LATEX VERSION: (Homotopy extension lemma) Let X x I be normal, A closed in X, **)
(** f: A -> Y continuous with Y open in R^n. If f is nulhomotopic, **)
(** then f extends to g: X -> Y that is also nulhomotopic. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 250 **)
Theorem lemma62_1_homotopy_extension : forall X Tx A Y n:set,
  normal_space (setprod X unit_interval)
    (product_topology X Tx unit_interval unit_interval_topology) ->
  A c= X -> X :\: A :e Tx ->
  n :e omega ->
  Y :e euclidean_topology n ->
  forall f:set,
    continuous_map A (subspace_topology X Tx A)
      Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) f ->
    nulhomotopic A (subspace_topology X Tx A)
      Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) f ->
    exists g:set,
      continuous_map X Tx
        Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) g /\
      (forall a:set, a :e A -> apply_fun g a = apply_fun f a) /\
      nulhomotopic X Tx
        Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) g.
admit.
Qed.

(** from S62 Lemma 62.2 (line 1953 in algtop.tex) **)
(** LATEX VERSION: (Borsuk lemma) Let a, b in S^2, A compact, f: A -> S^2-a-b **)
(** continuous injective. If f is nulhomotopic, then a and b lie in the same **)
(** component of S^2-f(A). **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 300 **)
Theorem lemma62_2_borsuk : forall a b:set,
  a :e Sn 2 -> b :e Sn 2 -> a <> b ->
  forall A TA:set, compact_space A TA ->
  forall f:set,
    continuous_map A TA (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f ->
    (forall x y:set, x :e A -> y :e A -> apply_fun f x = apply_fun f y -> x = y) ->
    nulhomotopic A TA
      (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f ->
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) a =
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) b.
admit.
Qed.

(** from S62 Theorem 62.3 (line 1975 in algtop.tex) **)
(** LATEX VERSION: (Invariance of domain) If U is open in R^2 and f: U -> R^2 **)
(** is continuous and injective, then f(U) is open in R^2 and f^-1 is continuous. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 350 **)
Theorem thm62_3_invariance_of_domain : forall U:set,
  U :e R2_topology ->
  forall f:set,
    continuous_map U (subspace_topology (setprod R R) R2_topology U)
      (setprod R R) R2_topology f ->
    (forall x y:set, x :e U -> y :e U -> apply_fun f x = apply_fun f y -> x = y) ->
    image_of f U :e R2_topology /\
    exists finv:set,
      continuous_map (image_of f U) (subspace_topology (setprod R R) R2_topology (image_of f U))
        U (subspace_topology (setprod R R) R2_topology U) finv /\
      (forall x:set, x :e U -> apply_fun finv (apply_fun f x) = x).
admit.
Qed.

(** from S62 Exercise 2 (line 2001 in algtop.tex) **)
(** LATEX VERSION: A compact contractible subspace of S^2 does not separate S^2. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex62_2_contractible_no_separation : forall A:set,
  A c= Sn 2 ->
  compact_space A (subspace_topology (Sn 2) (Sn_topology 2) A) ->
  contractible_space A (subspace_topology (Sn 2) (Sn_topology 2) A) ->
  ~(separates (Sn 2) (Sn_topology 2) A).
admit.
Qed.

(** from S62 Exercise 1 (line 2000 in algtop.tex) **)
(** LATEX VERSION: The conclusion of the Borsuk lemma need not hold if f is not injective. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex62_1_borsuk_fails_without_injectivity :
  exists A TA a b:set, exists f:set,
    a :e Sn 2 /\ b :e Sn 2 /\ a <> b /\
    compact_space A TA /\
    continuous_map A TA (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f /\
    nulhomotopic A TA
      (Sn 2 :\: Sing a :\: Sing b)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: Sing a :\: Sing b)) f /\
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) a <>
    component_of (Sn 2 :\: image_of f A)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: image_of f A)) b.
admit.
Qed.

(** from S62 Exercise 3 (line 2002 in algtop.tex) **)
(** LATEX VERSION: Let X x I be normal, A closed in X, f: A -> Y continuous, **)
(** Y open in R^n. If f is homotopic to a map extendable to h: X -> Y, **)
(** then f itself extends to g: X -> Y with g homotopic to h. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex62_3_homotopy_extension_general : forall X Tx A Y n:set,
  normal_space (setprod X unit_interval)
    (product_topology X Tx unit_interval unit_interval_topology) ->
  A c= X -> X :\: A :e Tx ->
  n :e omega ->
  Y :e euclidean_topology n ->
  forall f h:set,
    continuous_map A (subspace_topology X Tx A)
      Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) f ->
    continuous_map X Tx
      Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) h ->
    homotopic_maps A (subspace_topology X Tx A)
      Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y)
      f (graph A (fun a => apply_fun h a)) ->
    exists g:set,
      continuous_map X Tx
        Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) g /\
      (forall a:set, a :e A -> apply_fun g a = apply_fun f a) /\
      homotopic_maps X Tx
        Y (subspace_topology (euclidean_space n) (euclidean_topology n) Y) g h.
admit.
Qed.

(** from S62 Exercise 4 (line 2003 in algtop.tex) **)
(** LATEX VERSION: Let C be a simple closed curve in R^2 - 0. The inclusion-induced **)
(** homomorphism is trivial if 0 lies in unbounded component of R^2-C. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex62_4a_winding_trivial : forall C:set,
  C c= setprod R R -> ~((0, 0) :e C) ->
  is_simple_closed_curve C (subspace_topology (setprod R R) R2_topology C) ->
  ~(bounded_subset_R2 (component_of (setprod R R :\: C)
    (subspace_topology (setprod R R) R2_topology (setprod R R :\: C)) (0, 0))) ->
  forall x0:set, x0 :e C ->
    forall cls:set,
      cls :e fundamental_group C (subspace_topology (setprod R R) R2_topology C) x0 ->
      apply_fun (induced_homomorphism
        C (subspace_topology (setprod R R) R2_topology C) x0
        (setprod R R :\: Sing (0, 0))
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: Sing (0, 0)))
        x0 (graph C (fun x => x))) cls =
      fundamental_group_id (setprod R R :\: Sing (0, 0))
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: Sing (0, 0))) x0.
admit.
Qed.

(** from S62 Exercise 4 (line 2003 in algtop.tex) **)
(** LATEX VERSION: If 0 lies in bounded component of R^2-C, the inclusion-induced **)
(** homomorphism is nontrivial. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex62_4b_winding_nontrivial : forall C:set,
  C c= setprod R R -> ~((0, 0) :e C) ->
  is_simple_closed_curve C (subspace_topology (setprod R R) R2_topology C) ->
  bounded_subset_R2 (component_of (setprod R R :\: C)
    (subspace_topology (setprod R R) R2_topology (setprod R R :\: C)) (0, 0)) ->
  forall x0:set, x0 :e C ->
    exists cls:set,
      cls :e fundamental_group C (subspace_topology (setprod R R) R2_topology C) x0 /\
      apply_fun (induced_homomorphism
        C (subspace_topology (setprod R R) R2_topology C) x0
        (setprod R R :\: Sing (0, 0))
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: Sing (0, 0)))
        x0 (graph C (fun x => x))) cls <>
      fundamental_group_id (setprod R R :\: Sing (0, 0))
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: Sing (0, 0))) x0.
admit.
Qed.

(** from S62 Exercise 5 (line 2004 in algtop.tex) **)
(** LATEX VERSION: Let U be simply connected open in R^2. If C is a simple closed curve **)
(** in U, then each bounded component of R^2 - C lies in U. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex62_5_simply_connected_bounded_components : forall U:set,
  U :e R2_topology ->
  simply_connected U (subspace_topology (setprod R R) R2_topology U) ->
  forall C:set,
    C c= U ->
    is_simple_closed_curve C (subspace_topology (setprod R R) R2_topology C) ->
    forall v:set, v :e setprod R R :\: C ->
      bounded_subset_R2 (component_of (setprod R R :\: C)
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: C)) v) ->
      component_of (setprod R R :\: C)
        (subspace_topology (setprod R R) R2_topology (setprod R R :\: C)) v c= U.
admit.
Qed.

(** from S62 Exercise 6(a) (line 2007 in algtop.tex) **)
(** LATEX VERSION: Borsuk lemma for S^n: If no retraction B^n -> S^{n-1}, **)
(** then f: A -> S^n-a-b injective nulhomotopic implies a, b same component. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex62_6a_borsuk_lemma_Sn : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed (ordsucc n)) (Bn_closed_topology (ordsucc n)) (Sn n)) ->
  forall a b:set,
    a :e Sn n -> b :e Sn n -> a <> b ->
    forall A TA:set, compact_space A TA ->
    forall f:set,
      continuous_map A TA (Sn n :\: Sing a :\: Sing b)
        (subspace_topology (Sn n) (Sn_topology n) (Sn n :\: Sing a :\: Sing b)) f ->
      (forall x y:set, x :e A -> y :e A -> apply_fun f x = apply_fun f y -> x = y) ->
      nulhomotopic A TA
        (Sn n :\: Sing a :\: Sing b)
        (subspace_topology (Sn n) (Sn_topology n) (Sn n :\: Sing a :\: Sing b)) f ->
      component_of (Sn n :\: image_of f A)
        (subspace_topology (Sn n) (Sn_topology n) (Sn n :\: image_of f A)) a =
      component_of (Sn n :\: image_of f A)
        (subspace_topology (Sn n) (Sn_topology n) (Sn n :\: image_of f A)) b.
admit.
Qed.

(** from S62 Exercise 6(b) (line 2009 in algtop.tex) **)
(** LATEX VERSION: No compact contractible subspace of S^n separates S^n. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex62_6b_contractible_no_separation_Sn : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed (ordsucc n)) (Bn_closed_topology (ordsucc n)) (Sn n)) ->
  forall A:set,
    A c= Sn n ->
    compact_space A (subspace_topology (Sn n) (Sn_topology n) A) ->
    contractible_space A (subspace_topology (Sn n) (Sn_topology n) A) ->
    ~(separates (Sn n) (Sn_topology n) A).
admit.
Qed.

(** from S62 Exercise 6(c) (line 2010 in algtop.tex) **)
(** LATEX VERSION: Given no retraction B^n -> S^{n-1} and S^{n-1} separates S^n, **)
(** invariance of domain holds in dimension n. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem ex62_6c_invariance_of_domain_n : forall n:set, n :e omega ->
  ~(retraction_of (Bn_closed (ordsucc n)) (Bn_closed_topology (ordsucc n)) (Sn n)) ->
  (forall C:set, C c= Sn n ->
    (exists h:set, homeomorphism C (subspace_topology (Sn n) (Sn_topology n) C)
      (Sn (nat_primrec 0 (fun i _ => i) n)) (Sn_topology (nat_primrec 0 (fun i _ => i) n)) h) ->
    separates (Sn n) (Sn_topology n) C) ->
  forall U:set,
    U :e euclidean_topology n ->
    forall f:set,
      continuous_map U (subspace_topology (euclidean_space n) (euclidean_topology n) U)
        (euclidean_space n) (euclidean_topology n) f ->
      (forall x y:set, x :e U -> y :e U -> apply_fun f x = apply_fun f y -> x = y) ->
      image_of f U :e euclidean_topology n.
admit.
Qed.

(** ============================================================ **)
(** S63 The Jordan Curve Theorem                                 **)
(** (lines 2013-2249 in algtop.tex)                              **)
(** ============================================================ **)

(** from S63 Theorem 63.1(a) (line 2016 in algtop.tex) **)
(** LATEX VERSION: Let X = U union V open, U cap V = A disjoint-union B open. **)
(** If alpha in U from a in A to b in B, beta in V from b to a, **)
(** then [alpha . beta] generates an infinite cyclic subgroup of pi_1(X, a). **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 400 **)
Theorem thm63_1a_infinite_cyclic_subgroup : forall X Tx U V A B:set,
  topology_on X Tx -> U :e Tx -> V :e Tx -> X = U :\/: V ->
  A :e subspace_topology X Tx (U :/\: V) ->
  B :e subspace_topology X Tx (U :/\: V) ->
  U :/\: V = A :\/: B -> A :/\: B = Empty ->
  forall a b:set, a :e A -> b :e B ->
  forall alpha:set, path_between U a b alpha ->
    (forall s:set, s :e unit_interval -> apply_fun alpha s :e U) ->
  forall beta:set, path_between V b a beta ->
    (forall s:set, s :e unit_interval -> apply_fun beta s :e V) ->
  forall m:set, m :e omega -> m <> 0 ->
    group_power_nat
      (fundamental_group_mult X Tx a)
      (fundamental_group_id X Tx a)
      (path_homotopy_class_loop X Tx a (path_concat alpha beta)) m <>
    fundamental_group_id X Tx a.
admit.
Qed.

(** from S63 Theorem 63.1(b) (line 2018 in algtop.tex) **)
(** LATEX VERSION: If pi_1(X,a) is itself infinite cyclic, it is generated by [f]. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 250 **)
Theorem thm63_1b_infinite_cyclic_generator : forall X Tx U V A B:set,
  topology_on X Tx -> U :e Tx -> V :e Tx -> X = U :\/: V ->
  A :e subspace_topology X Tx (U :/\: V) ->
  B :e subspace_topology X Tx (U :/\: V) ->
  U :/\: V = A :\/: B -> A :/\: B = Empty ->
  forall a b:set, a :e A -> b :e B ->
  forall alpha:set, path_between U a b alpha ->
    (forall s:set, s :e unit_interval -> apply_fun alpha s :e U) ->
  forall beta:set, path_between V b a beta ->
    (forall s:set, s :e unit_interval -> apply_fun beta s :e V) ->
  cyclic_group
    (fundamental_group X Tx a)
    (fundamental_group_mult X Tx a)
    (fundamental_group_id X Tx a)
    (fundamental_group_inv X Tx a) ->
  ~ finite (fundamental_group X Tx a) ->
  generator_of
    (fundamental_group X Tx a)
    (fundamental_group_mult X Tx a)
    (fundamental_group_id X Tx a)
    (fundamental_group_inv X Tx a)
    (path_homotopy_class_loop X Tx a (path_concat alpha beta)).
admit.
Qed.

(** from S63 Theorem 63.1(c) (line 2019 in algtop.tex) **)
(** LATEX VERSION: With additional paths gamma in U from a to a' in A, delta in V from a' to a, **)
(** the subgroups generated by [alpha . beta] and [gamma . delta] intersect in the identity alone. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 350 **)
Theorem thm63_1c_subgroups_trivial_intersection : forall X Tx U V A B:set,
  topology_on X Tx -> U :e Tx -> V :e Tx -> X = U :\/: V ->
  A :e subspace_topology X Tx (U :/\: V) ->
  B :e subspace_topology X Tx (U :/\: V) ->
  U :/\: V = A :\/: B -> A :/\: B = Empty ->
  forall a b:set, a :e A -> b :e B ->
  forall alpha:set, path_between U a b alpha ->
    (forall s:set, s :e unit_interval -> apply_fun alpha s :e U) ->
  forall beta:set, path_between V b a beta ->
    (forall s:set, s :e unit_interval -> apply_fun beta s :e V) ->
  forall a':set, a' :e A ->
  forall gamma:set, path_between U a a' gamma ->
    (forall s:set, s :e unit_interval -> apply_fun gamma s :e U) ->
  forall delta:set, path_between V a' a delta ->
    (forall s:set, s :e unit_interval -> apply_fun delta s :e V) ->
  forall h:set, h :e fundamental_group X Tx a ->
    (exists n:set, n :e int /\
      ((n :e omega /\ h = group_power_nat
        (fundamental_group_mult X Tx a)
        (fundamental_group_id X Tx a)
        (path_homotopy_class_loop X Tx a (path_concat alpha beta)) n) \/
       (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
        h = group_power_nat
          (fundamental_group_mult X Tx a)
          (fundamental_group_id X Tx a)
          (apply_fun (fundamental_group_inv X Tx a) (path_homotopy_class_loop X Tx a (path_concat alpha beta))) (ordsucc m)))) ->
    (exists n:set, n :e int /\
      ((n :e omega /\ h = group_power_nat
        (fundamental_group_mult X Tx a)
        (fundamental_group_id X Tx a)
        (path_homotopy_class_loop X Tx a (path_concat gamma delta)) n) \/
       (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
        h = group_power_nat
          (fundamental_group_mult X Tx a)
          (fundamental_group_id X Tx a)
          (apply_fun (fundamental_group_inv X Tx a) (path_homotopy_class_loop X Tx a (path_concat gamma delta))) (ordsucc m)))) ->
    h = fundamental_group_id X Tx a.
admit.
Qed.

(** from S63 Theorem 63.2 (line 2135 in algtop.tex) **)
(** LATEX VERSION: (Nonseparation theorem) An arc in S^2 does not separate S^2. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 250 **)
Theorem thm63_2_arc_nonseparation : forall D:set,
  D c= Sn 2 ->
  is_arc D (subspace_topology (Sn 2) (Sn_topology 2) D) ->
  ~(separates (Sn 2) (Sn_topology 2) D).
admit.
Qed.

(** from S63 Theorem 63.3 (line 2177 in algtop.tex) **)
(** LATEX VERSION: (General nonseparation) Let D1, D2 be closed subsets of S^2 **)
(** such that S^2 - D1 cap D2 is simply connected. **)
(** If neither D1 nor D2 separates S^2, then D1 union D2 does not separate S^2. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm63_3_general_nonseparation : forall D1 D2:set,
  D1 c= Sn 2 -> D2 c= Sn 2 ->
  Sn 2 :\: D1 :e Sn_topology 2 ->
  Sn 2 :\: D2 :e Sn_topology 2 ->
  simply_connected (Sn 2 :\: (D1 :/\: D2))
    (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: (D1 :/\: D2))) ->
  ~(separates (Sn 2) (Sn_topology 2) D1) ->
  ~(separates (Sn 2) (Sn_topology 2) D2) ->
  ~(separates (Sn 2) (Sn_topology 2) (D1 :\/: D2)).
admit.
Qed.

(** from S63 Theorem 63.4 (line 2180 in algtop.tex) **)
(** LATEX VERSION: (Jordan curve theorem) A simple closed curve C in S^2 separates **)
(** S^2 into precisely two components W1 and W2, and C is the common boundary. **)
(** EFFORT: 30 lines textbook, difficulty 8/10, USD 500 **)
Theorem thm63_4_jordan_curve_theorem : forall C:set,
  C c= Sn 2 ->
  is_simple_closed_curve C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
  exists W1 W2:set,
    W1 :e Sn_topology 2 /\ W2 :e Sn_topology 2 /\
    W1 :/\: W2 = Empty /\
    Sn 2 :\: C = W1 :\/: W2 /\
    W1 <> Empty /\ W2 <> Empty /\
    connected_space W1 (subspace_topology (Sn 2) (Sn_topology 2) W1) /\
    connected_space W2 (subspace_topology (Sn 2) (Sn_topology 2) W2) /\
    closure_of (Sn 2) (Sn_topology 2) W1 :\: W1 = C /\
    closure_of (Sn 2) (Sn_topology 2) W2 :\: W2 = C.
admit.
Qed.

(** from S63 Theorem 63.5 (line 2211 in algtop.tex) **)
(** LATEX VERSION: Let C1, C2 be closed connected subsets of S^2 whose intersection **)
(** consists of two points. If neither separates S^2, then C1 union C2 **)
(** separates S^2 into precisely two components. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm63_5_general_jordan : forall C1 C2:set,
  C1 c= Sn 2 -> C2 c= Sn 2 ->
  Sn 2 :\: C1 :e Sn_topology 2 ->
  Sn 2 :\: C2 :e Sn_topology 2 ->
  connected_space C1 (subspace_topology (Sn 2) (Sn_topology 2) C1) ->
  connected_space C2 (subspace_topology (Sn 2) (Sn_topology 2) C2) ->
  (exists a b:set, a :e Sn 2 /\ b :e Sn 2 /\ a <> b /\ C1 :/\: C2 = UPair a b) ->
  ~(separates (Sn 2) (Sn_topology 2) C1) ->
  ~(separates (Sn 2) (Sn_topology 2) C2) ->
  exists W1 W2:set,
    W1 :e Sn_topology 2 /\ W2 :e Sn_topology 2 /\
    W1 :/\: W2 = Empty /\
    Sn 2 :\: (C1 :\/: C2) = W1 :\/: W2 /\
    W1 <> Empty /\ W2 <> Empty /\
    connected_space W1 (subspace_topology (Sn 2) (Sn_topology 2) W1) /\
    connected_space W2 (subspace_topology (Sn 2) (Sn_topology 2) W2).
admit.
Qed.

(** from S63 Exercise 1(a) (line 2239 in algtop.tex) **)
(** LATEX VERSION: Let C1 and C2 be disjoint simple closed curves in S^2. **)
(** Then S^2 - C1 - C2 has precisely three components. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex63_1a_disjoint_curves_three_components : forall C1 C2:set,
  C1 c= Sn 2 -> C2 c= Sn 2 -> C1 :/\: C2 = Empty ->
  is_simple_closed_curve C1 (subspace_topology (Sn 2) (Sn_topology 2) C1) ->
  is_simple_closed_curve C2 (subspace_topology (Sn 2) (Sn_topology 2) C2) ->
  exists W1 W2 W3:set,
    W1 :e Sn_topology 2 /\ W2 :e Sn_topology 2 /\ W3 :e Sn_topology 2 /\
    W1 <> Empty /\ W2 <> Empty /\ W3 <> Empty /\
    W1 :/\: W2 = Empty /\ W1 :/\: W3 = Empty /\ W2 :/\: W3 = Empty /\
    Sn 2 :\: (C1 :\/: C2) = W1 :\/: W2 :\/: W3 /\
    connected_space W1 (subspace_topology (Sn 2) (Sn_topology 2) W1) /\
    connected_space W2 (subspace_topology (Sn 2) (Sn_topology 2) W2) /\
    connected_space W3 (subspace_topology (Sn 2) (Sn_topology 2) W3).
admit.
Qed.

(** from S63 Exercise 1(b) (line 2241 in algtop.tex) **)
(** LATEX VERSION: The three components have boundaries C1, C2, and C1 union C2. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex63_1b_disjoint_curves_boundaries : forall C1 C2:set,
  C1 c= Sn 2 -> C2 c= Sn 2 -> C1 :/\: C2 = Empty ->
  is_simple_closed_curve C1 (subspace_topology (Sn 2) (Sn_topology 2) C1) ->
  is_simple_closed_curve C2 (subspace_topology (Sn 2) (Sn_topology 2) C2) ->
  exists W1 W2 W3:set,
    Sn 2 :\: (C1 :\/: C2) = W1 :\/: W2 :\/: W3 /\
    W1 :/\: W2 = Empty /\ W1 :/\: W3 = Empty /\ W2 :/\: W3 = Empty /\
    connected_space W1 (subspace_topology (Sn 2) (Sn_topology 2) W1) /\
    connected_space W2 (subspace_topology (Sn 2) (Sn_topology 2) W2) /\
    connected_space W3 (subspace_topology (Sn 2) (Sn_topology 2) W3) /\
    closure_of (Sn 2) (Sn_topology 2) W1 :\: W1 = C1 /\
    closure_of (Sn 2) (Sn_topology 2) W2 :\: W2 = C2 /\
    closure_of (Sn 2) (Sn_topology 2) W3 :\: W3 = C1 :\/: C2.
admit.
Qed.

(** from S63 Exercise 2(a) (line 2243 in algtop.tex) **)
(** LATEX VERSION: If D is closed connected separating S^2 into n components, **)
(** and A is an arc with only one endpoint in D, then D union A separates S^2 into n components. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 150 **)
Theorem ex63_2a_arc_one_endpoint : forall D:set,
  D c= Sn 2 -> Sn 2 :\: D :e Sn_topology 2 ->
  connected_space D (subspace_topology (Sn 2) (Sn_topology 2) D) ->
  forall n:set, n :e omega ->
  (exists Ws:set, function_on Ws n (Power (Sn 2)) /\
    (forall i:set, i :e n -> apply_fun Ws i :e Sn_topology 2 /\
      apply_fun Ws i <> Empty /\
      connected_space (apply_fun Ws i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws i))) /\
    (forall i j:set, i :e n -> j :e n -> i <> j -> apply_fun Ws i :/\: apply_fun Ws j = Empty) /\
    Sn 2 :\: D = Union (image_of Ws n)) ->
  forall A:set,
    A c= Sn 2 -> is_arc A (subspace_topology (Sn 2) (Sn_topology 2) A) ->
    (exists a:set, a :e A /\ A :/\: D = Sing a) ->
    exists Ws':set, function_on Ws' n (Power (Sn 2)) /\
      (forall i:set, i :e n -> apply_fun Ws' i :e Sn_topology 2 /\
        apply_fun Ws' i <> Empty /\
        connected_space (apply_fun Ws' i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws' i))) /\
      (forall i j:set, i :e n -> j :e n -> i <> j -> apply_fun Ws' i :/\: apply_fun Ws' j = Empty) /\
      Sn 2 :\: (D :\/: A) = Union (image_of Ws' n).
admit.
Qed.

(** from S63 Exercise 2(b) (line 2244 in algtop.tex) **)
(** LATEX VERSION: If A is an arc with both endpoints in D (otherwise disjoint), **)
(** then D union A separates S^2 into n+1 components. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 150 **)
Theorem ex63_2b_arc_both_endpoints : forall D:set,
  D c= Sn 2 -> Sn 2 :\: D :e Sn_topology 2 ->
  connected_space D (subspace_topology (Sn 2) (Sn_topology 2) D) ->
  forall n:set, n :e omega ->
  (exists Ws:set, function_on Ws n (Power (Sn 2)) /\
    (forall i:set, i :e n -> apply_fun Ws i :e Sn_topology 2 /\
      apply_fun Ws i <> Empty /\
      connected_space (apply_fun Ws i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws i))) /\
    (forall i j:set, i :e n -> j :e n -> i <> j -> apply_fun Ws i :/\: apply_fun Ws j = Empty) /\
    Sn 2 :\: D = Union (image_of Ws n)) ->
  forall A:set,
    A c= Sn 2 -> is_arc A (subspace_topology (Sn 2) (Sn_topology 2) A) ->
    (exists a b:set, a :e D /\ b :e D /\ a <> b /\ A :/\: D = UPair a b) ->
    exists Ws':set, function_on Ws' (ordsucc n) (Power (Sn 2)) /\
      (forall i:set, i :e ordsucc n -> apply_fun Ws' i :e Sn_topology 2 /\
        apply_fun Ws' i <> Empty /\
        connected_space (apply_fun Ws' i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws' i))) /\
      (forall i j:set, i :e ordsucc n -> j :e ordsucc n -> i <> j -> apply_fun Ws' i :/\: apply_fun Ws' j = Empty) /\
      Sn 2 :\: (D :\/: A) = Union (image_of Ws' (ordsucc n)).
admit.
Qed.

(** from S63 Exercise 2(c) (line 2245 in algtop.tex) **)
(** LATEX VERSION: If C is a simple closed curve intersecting D in a single point, **)
(** then D union C separates S^2 into n+1 components. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex63_2c_curve_one_point : forall D:set,
  D c= Sn 2 -> Sn 2 :\: D :e Sn_topology 2 ->
  connected_space D (subspace_topology (Sn 2) (Sn_topology 2) D) ->
  forall n:set, n :e omega ->
  (exists Ws:set, function_on Ws n (Power (Sn 2)) /\
    (forall i:set, i :e n -> apply_fun Ws i :e Sn_topology 2 /\
      apply_fun Ws i <> Empty /\
      connected_space (apply_fun Ws i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws i))) /\
    (forall i j:set, i :e n -> j :e n -> i <> j -> apply_fun Ws i :/\: apply_fun Ws j = Empty) /\
    Sn 2 :\: D = Union (image_of Ws n)) ->
  forall C:set,
    C c= Sn 2 ->
    is_simple_closed_curve C (subspace_topology (Sn 2) (Sn_topology 2) C) ->
    (exists p:set, C :/\: D = Sing p) ->
    exists Ws':set, function_on Ws' (ordsucc n) (Power (Sn 2)) /\
      (forall i:set, i :e ordsucc n -> apply_fun Ws' i :e Sn_topology 2 /\
        apply_fun Ws' i <> Empty /\
        connected_space (apply_fun Ws' i) (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ws' i))) /\
      (forall i j:set, i :e ordsucc n -> j :e ordsucc n -> i <> j -> apply_fun Ws' i :/\: apply_fun Ws' j = Empty) /\
      Sn 2 :\: (D :\/: C) = Union (image_of Ws' (ordsucc n)).
admit.
Qed.

(** from S63 Exercise 3(a) (line 2246 in algtop.tex) **)
(** LATEX VERSION: A subspace of S^2 homeomorphic to the topologists sine curve does not separate S^2. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem ex63_3a_sine_curve_no_separation : forall D:set,
  D c= Sn 2 ->
  connected_space D (subspace_topology (Sn 2) (Sn_topology 2) D) ->
  ~(compact_space D (subspace_topology (Sn 2) (Sn_topology 2) D)) ->
  (exists A1 A2:set,
    D = A1 :\/: A2 /\ A1 c= Sn 2 /\ A2 c= Sn 2 /\
    A1 :/\: A2 = Empty /\
    path_connected_space A1 (subspace_topology (Sn 2) (Sn_topology 2) A1) /\
    closure_of (Sn 2) (Sn_topology 2) A1 = A1 :\/: A2 /\
    (exists h:set, homeomorphism A1 (subspace_topology (Sn 2) (Sn_topology 2) A1)
      R R_standard_topology h)) ->
  ~(separates (Sn 2) (Sn_topology 2) D).
admit.
Qed.

(** ============================================================ **)
(** S64 Imbedding Graphs in the Plane                            **)
(** (lines 2251-2368 in algtop.tex)                              **)
(** ============================================================ **)

(** from S64 Definition (line 2270 in algtop.tex) **)
(** LATEX VERSION: A theta space X is a Hausdorff space written as the union **)
(** of three arcs A, B, C, each pair intersecting precisely in their end points. **)
Definition theta_space : set -> set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx A B C a b =>
    Hausdorff_space X Tx /\
    X = A :\/: B :\/: C /\
    A c= X /\ B c= X /\ C c= X /\
    arc A (subspace_topology X Tx A) /\
    arc B (subspace_topology X Tx B) /\
    arc C (subspace_topology X Tx C) /\
    end_points_of_arc A (subspace_topology X Tx A) a b /\
    end_points_of_arc B (subspace_topology X Tx B) a b /\
    end_points_of_arc C (subspace_topology X Tx C) a b /\
    A :/\: B = UPair a b /\
    B :/\: C = UPair a b /\
    A :/\: C = UPair a b.

(** from S64 Example 1 (line 2258 in algtop.tex) **)
(** LATEX VERSION: Complete graph G_n on n vertices: every pair of distinct **)
(** vertices is joined by an edge. **)
Definition complete_graph_on : set -> set -> set -> prop := fun V G Tg =>
  linear_graph G Tg /\
  V c= G /\ finite V /\
  (forall u v:set, u :e V -> v :e V -> u <> v ->
    exists A:set, A c= G /\
      arc A (subspace_topology G Tg A) /\
      end_points_of_arc A (subspace_topology G Tg A) u v).

(** from S64 Example 2 (line 2268 in algtop.tex) **)
(** LATEX VERSION: The utilities graph K_{3,3}: bipartite complete graph with **)
(** two groups H, W of 3 vertices, every vertex in H joined to every in W. **)
Definition utilities_graph : set -> set -> set -> set -> prop := fun H W G Tg =>
  linear_graph G Tg /\
  H c= G /\ W c= G /\
  equip H 3 /\ equip W 3 /\
  H :/\: W = Empty /\
  (forall h w:set, h :e H -> w :e W ->
    exists A:set, A c= G /\
      arc A (subspace_topology G Tg A) /\
      end_points_of_arc A (subspace_topology G Tg A) h w).

(** from S64 Lemma 64.1 (line 2282 in algtop.tex) **)
(** LATEX VERSION: Let X be a theta space in S^2. Then X separates S^2 into **)
(** three components with boundaries A union B, B union C, and A union C. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 200 **)
Theorem lemma64_1_theta_separates : forall X Tx A B C a b:set,
  theta_space X Tx A B C a b ->
  X c= Sn 2 -> Tx = subspace_topology (Sn 2) (Sn_topology 2) X ->
  exists U V W:set,
    Sn 2 :\: X = U :\/: V :\/: W /\
    U <> Empty /\ V <> Empty /\ W <> Empty /\
    U :/\: V = Empty /\ V :/\: W = Empty /\ U :/\: W = Empty /\
    connected_space U (subspace_topology (Sn 2) (Sn_topology 2) U) /\
    connected_space V (subspace_topology (Sn 2) (Sn_topology 2) V) /\
    connected_space W (subspace_topology (Sn 2) (Sn_topology 2) W) /\
    boundary_of (Sn 2) (Sn_topology 2) U = A :\/: B /\
    boundary_of (Sn 2) (Sn_topology 2) V = B :\/: C /\
    boundary_of (Sn 2) (Sn_topology 2) W = A :\/: C.
admit.
Qed.

(** from S64 Theorem 64.2 (line 2297 in algtop.tex) **)
(** LATEX VERSION: The utilities graph cannot be imbedded in the plane. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 120 **)
Theorem thm64_2_utilities_not_planar : forall G Tg H W:set,
  utilities_graph H W G Tg ->
  ~(exists f:set, embedding_of G Tg (setprod R R) R2_topology f).
admit.
Qed.

(** from S64 Lemma 64.3 (line 2322 in algtop.tex) **)
(** LATEX VERSION: Let X be a subspace of S^2 that is a complete graph on four **)
(** vertices a1,a2,a3,a4. Then X separates S^2 into four components whose **)
(** boundaries are X1,X2,X3,X4, where Xi = union of edges not having ai as vertex. **)
(** EFFORT: 25 lines textbook, difficulty 7/10, USD 280 **)
Theorem lemma64_3_K4_separates : forall V G Tg:set,
  complete_graph_on V G Tg ->
  equip V 4 ->
  G c= Sn 2 -> Tg = subspace_topology (Sn 2) (Sn_topology 2) G ->
  exists verts:set, function_on verts 4 (Sn 2) /\
    V = {apply_fun verts i | i :e 4} /\
    (forall i j:set, i :e 4 -> j :e 4 -> i <> j ->
      apply_fun verts i <> apply_fun verts j) /\
    exists Ufam:set, function_on Ufam 4 (Power (Sn 2)) /\
    Sn 2 :\: G = Union {apply_fun Ufam i | i :e 4} /\
    (forall i:set, i :e 4 -> apply_fun Ufam i <> Empty) /\
    (forall i j:set, i :e 4 -> j :e 4 -> i <> j ->
      apply_fun Ufam i :/\: apply_fun Ufam j = Empty) /\
    (forall i:set, i :e 4 ->
      connected_space (apply_fun Ufam i)
        (subspace_topology (Sn 2) (Sn_topology 2) (apply_fun Ufam i))) /\
    (** boundary of Ui is the union of edges not containing vertex ai **)
    (forall i:set, i :e 4 ->
      boundary_of (Sn 2) (Sn_topology 2) (apply_fun Ufam i) =
        Union {A :e Power G |
          exists j k:set, j :e 4 /\ k :e 4 /\ j <> k /\ j <> i /\ k <> i /\
            arc A (subspace_topology G Tg A) /\
            end_points_of_arc A (subspace_topology G Tg A)
              (apply_fun verts j) (apply_fun verts k)}).
admit.
Qed.

(** from S64 Theorem 64.4 (line 2350 in algtop.tex) **)
(** LATEX VERSION: The complete graph on five vertices cannot be imbedded **)
(** in the plane. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 120 **)
Theorem thm64_4_K5_not_planar : forall V G Tg:set,
  complete_graph_on V G Tg -> equip V 5 ->
  ~(exists f:set, embedding_of G Tg (setprod R R) R2_topology f).
admit.
Qed.

(** from S64 Exercise 1(a) (line 2365 in algtop.tex) **)
(** LATEX VERSION: X is the union of finitely many arcs, each pair meeting **)
(** in at most a common endpoint. X is Hausdorff iff each arc is closed. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex64_1a_hausdorff_iff_arcs_closed : forall X Tx Arcs:set,
  topology_on X Tx ->
  finite Arcs ->
  X = Union Arcs ->
  (forall A:set, A :e Arcs -> A c= X /\ arc A (subspace_topology X Tx A)) ->
  (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
    exists p:set, (A :/\: B = Empty \/ A :/\: B = Sing p)) ->
  (Hausdorff_space X Tx <->
    (forall A:set, A :e Arcs -> X :\: A :e Tx)).
admit.
Qed.

(** from S64 Exercise 1(b) (line 2367 in algtop.tex) **)
(** LATEX VERSION: Give an example to show that X (union of finitely many **)
(** arcs intersecting only at endpoints) need not be Hausdorff. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex64_1b_non_hausdorff_arc_union :
  exists X Tx Arcs:set,
    topology_on X Tx /\
    finite Arcs /\
    X = Union Arcs /\
    (forall A:set, A :e Arcs -> A c= X /\ arc A (subspace_topology X Tx A)) /\
    (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
      (A :/\: B = Empty \/ exists p:set, A :/\: B = Sing p)) /\
    ~Hausdorff_space X Tx.
admit.
Qed.

(** ============================================================ **)
(** S65 The Winding Number of a Simple Closed Curve              **)
(** (lines 2370-2481 in algtop.tex)                              **)
(** ============================================================ **)

(** from S65 Lemma 65.1 (line 2397 in algtop.tex) **)
(** LATEX VERSION: Let G be a subspace of S^2, a complete graph on 4 vertices. **)
(** Let C be a simple closed curve subgraph. Then there exist p, q in G minus C **)
(** from S65 Lemma 65.1 (line 2397 in algtop.tex): complete graph separation **)
(** in different components of S^2 minus C, and the inclusion C -> S^2-p-q **)
(** induces an isomorphism of fundamental groups. **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 350 **)
Theorem lemma65_1_complete_graph_separation : forall V G Tg C Tc x0:set,
  complete_graph_on V G Tg -> equip V 4 ->
  G c= Sn 2 -> Tg = subspace_topology (Sn 2) (Sn_topology 2) G ->
  C c= G -> is_simple_closed_curve C Tc ->
  Tc = subspace_topology (Sn 2) (Sn_topology 2) C ->
  x0 :e C ->
  exists p q:set, p :e G :\: C /\ q :e G :\: C /\
    component_of (Sn 2 :\: C)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) p <>
    component_of (Sn 2 :\: C)
      (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) q /\
    group_isomorphism
      (fundamental_group C Tc x0) (fundamental_group_mult C Tc x0)
      (fundamental_group (Sn 2 :\: (Sing p :\/: Sing q))
        (subspace_topology (Sn 2) (Sn_topology 2)
          (Sn 2 :\: (Sing p :\/: Sing q))) x0)
      (fundamental_group_mult (Sn 2 :\: (Sing p :\/: Sing q))
        (subspace_topology (Sn 2) (Sn_topology 2)
          (Sn 2 :\: (Sing p :\/: Sing q))) x0)
      (induced_homomorphism C Tc x0
        (Sn 2 :\: (Sing p :\/: Sing q))
        (subspace_topology (Sn 2) (Sn_topology 2)
          (Sn 2 :\: (Sing p :\/: Sing q))) x0
        (graph C (fun x:set => x))).
admit.
Qed.

(** from S65 Theorem 65.2 (line 2437 in algtop.tex) **)
(** LATEX VERSION: Let C be a simple closed curve in S^2, p and q in different **)
(** components of S^2 minus C. Then inclusion j: C -> S^2-p-q induces **)
(** an isomorphism of fundamental groups. **)
(** EFFORT: 40 lines textbook, difficulty 8/10, USD 500 **)
Theorem thm65_2_inclusion_isomorphism : forall C Tc p q x0:set,
  C c= Sn 2 -> is_simple_closed_curve C Tc ->
  Tc = subspace_topology (Sn 2) (Sn_topology 2) C ->
  p :e Sn 2 :\: C -> q :e Sn 2 :\: C ->
  component_of (Sn 2 :\: C)
    (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) p <>
  component_of (Sn 2 :\: C)
    (subspace_topology (Sn 2) (Sn_topology 2) (Sn 2 :\: C)) q ->
  x0 :e C ->
  group_isomorphism
    (fundamental_group C Tc x0) (fundamental_group_mult C Tc x0)
    (fundamental_group (Sn 2 :\: (Sing p :\/: Sing q))
      (subspace_topology (Sn 2) (Sn_topology 2)
        (Sn 2 :\: (Sing p :\/: Sing q))) x0)
    (fundamental_group_mult (Sn 2 :\: (Sing p :\/: Sing q))
      (subspace_topology (Sn 2) (Sn_topology 2)
        (Sn 2 :\: (Sing p :\/: Sing q))) x0)
    (induced_homomorphism C Tc x0
      (Sn 2 :\: (Sing p :\/: Sing q))
      (subspace_topology (Sn 2) (Sn_topology 2)
        (Sn 2 :\: (Sing p :\/: Sing q))) x0
      (graph C (fun x:set => x))).
admit.
Qed.

(** ============================================================ **)
(** S66 The Cauchy Integral Formula                              **)
(** (lines 2482-2581 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: R^2 vector subtraction **)
Definition R2_sub : set -> set -> set := fun z w =>
  (add_SNo (z 0) (minus_SNo (w 0)), add_SNo (z 1) (minus_SNo (w 1))).

(** Infrastructure: R^2 normalization v/||v||, maps nonzero v to S^1 **)
Definition R2_normalize : set -> set := fun v =>
  R2_scalar_mult (recip_SNo (complex_modulus v)) v.

(** from S66 Definition (line 2488 in algtop.tex) **)
(** LATEX VERSION: Winding number n(f,a): set g(s) = (f(s)-a)/||f(s)-a||, **)
(** lift g to R via covering map, n(f,a) = g_tilde(1) - g_tilde(0). **)
Definition winding_number : set -> set -> set := fun f a =>
  Eps_i (fun n:set => n :e int /\
    forall e0:set, e0 :e R ->
      apply_fun covering_map_R_S1 e0 =
        R2_normalize (R2_sub (apply_fun f 0) a) ->
      apply_fun (path_lift R R_standard_topology S1 S1_topology
        covering_map_R_S1 e0
        (graph unit_interval (fun s:set =>
          R2_normalize (R2_sub (apply_fun f s) a))))
        1 = add_SNo e0 n).

(** from S66 Definition (line 2498 in algtop.tex) **)
(** LATEX VERSION: Free homotopy of loops: F: I x I -> X continuous **)
(** with F(0,t) = F(1,t) for all t, F(s,0) = f0(s), F(s,1) = f1(s). **)
Definition free_homotopy_loops : set -> set -> set -> set -> set -> prop :=
  fun X Tx f0 f1 F =>
    continuous_map (setprod unit_interval unit_interval)
      (product_topology unit_interval unit_interval_topology
                        unit_interval unit_interval_topology)
      X Tx F /\
    (forall s:set, s :e unit_interval ->
      apply_fun F (s, 0) = apply_fun f0 s) /\
    (forall s:set, s :e unit_interval ->
      apply_fun F (s, 1) = apply_fun f1 s) /\
    (forall t:set, t :e unit_interval ->
      apply_fun F (0, t) = apply_fun F (1, t)).

(** from S66 Lemma 66.1(a) (line 2501 in algtop.tex) **)
(** LATEX VERSION: If f_bar is the reverse of f, then n(f_bar, a) = -n(f,a). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem lemma66_1a_reverse_winding : forall f a:set,
  loop_at (setprod R R) R2_topology (apply_fun f 0) f ->
  a :e setprod R R -> ~(a :e image_of f unit_interval) ->
  winding_number (reverse_path f) a = minus_SNo (winding_number f a).
admit.
Qed.

(** from S66 Lemma 66.1(b) (line 2502 in algtop.tex) **)
(** LATEX VERSION: If f is freely homotopic to f' through loops in R^2-a, **)
(** then n(f,a) = n(f',a). **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem lemma66_1b_free_homotopy_winding : forall f f' a F:set,
  loop_at (setprod R R) R2_topology (apply_fun f 0) f ->
  loop_at (setprod R R) R2_topology (apply_fun f' 0) f' ->
  a :e setprod R R ->
  ~(a :e image_of f unit_interval) ->
  ~(a :e image_of f' unit_interval) ->
  free_homotopy_loops
    (setprod R R :\: Sing a)
    (subspace_topology (setprod R R) R2_topology (setprod R R :\: Sing a))
    f f' F ->
  winding_number f a = winding_number f' a.
admit.
Qed.

(** from S66 Lemma 66.1(c) (line 2503 in algtop.tex) **)
(** LATEX VERSION: If a, b lie in the same component of R^2 minus f(I), **)
(** then n(f,a) = n(f,b). **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem lemma66_1c_same_component_winding : forall f a b:set,
  loop_at (setprod R R) R2_topology (apply_fun f 0) f ->
  a :e setprod R R -> b :e setprod R R ->
  ~(a :e image_of f unit_interval) ->
  ~(b :e image_of f unit_interval) ->
  component_of
    (setprod R R :\: image_of f unit_interval)
    (subspace_topology (setprod R R) R2_topology
      (setprod R R :\: image_of f unit_interval))
    a =
  component_of
    (setprod R R :\: image_of f unit_interval)
    (subspace_topology (setprod R R) R2_topology
      (setprod R R :\: image_of f unit_interval))
    b ->
  winding_number f a = winding_number f b.
admit.
Qed.

(** from S66 Definition (line 2515 in algtop.tex) **)
(** LATEX VERSION: A simple loop f satisfies f(s) = f(s') only if s = s' **)
(** or one of s, s' is 0 and the other is 1. **)
Definition simple_loop : set -> set -> set -> prop :=
  fun X Tx f =>
    loop_at X Tx (apply_fun f 0) f /\
    (forall s s':set, s :e unit_interval -> s' :e unit_interval ->
      apply_fun f s = apply_fun f s' ->
      s = s' \/ (s = 0 /\ s' = 1) \/ (s = 1 /\ s' = 0)).

(** from S66 Theorem 66.2 (line 2517 in algtop.tex) **)
(** LATEX VERSION: Let f be a simple loop in R^2. If a is in the unbounded **)
(** component of R^2-f(I), n(f,a)=0; if a is in bounded component, n(f,a)=+-1. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 280 **)
Theorem thm66_2_simple_loop_winding : forall f a:set,
  simple_loop (setprod R R) R2_topology f ->
  a :e setprod R R ->
  ~(a :e image_of f unit_interval) ->
  (~(bounded_subset_R2 (component_of
    (setprod R R :\: image_of f unit_interval)
    (subspace_topology (setprod R R) R2_topology
      (setprod R R :\: image_of f unit_interval)) a)) ->
    winding_number f a = 0) /\
  (bounded_subset_R2 (component_of
    (setprod R R :\: image_of f unit_interval)
    (subspace_topology (setprod R R) R2_topology
      (setprod R R :\: image_of f unit_interval)) a) ->
    winding_number f a = 1 \/ winding_number f a = minus_SNo 1).
admit.
Qed.

(** from S66 Definition (line 2527 in algtop.tex) **)
(** LATEX VERSION: Counterclockwise loop: simple loop with n(f,a) = +1 **)
(** for a in the bounded component. **)
Definition counterclockwise_loop : set -> prop := fun f =>
  simple_loop (setprod R R) R2_topology f /\
  (exists a:set, a :e setprod R R /\
    ~(a :e image_of f unit_interval) /\
    bounded_subset_R2 (component_of
      (setprod R R :\: image_of f unit_interval)
      (subspace_topology (setprod R R) R2_topology
        (setprod R R :\: image_of f unit_interval)) a) /\
    winding_number f a = 1).

(** from S66 Definition (line 2527 in algtop.tex) **)
(** LATEX VERSION: Clockwise loop: simple loop with n(f,a) = -1. **)
Definition clockwise_loop : set -> prop := fun f =>
  simple_loop (setprod R R) R2_topology f /\
  (exists a:set, a :e setprod R R /\
    ~(a :e image_of f unit_interval) /\
    bounded_subset_R2 (component_of
      (setprod R R :\: image_of f unit_interval)
      (subspace_topology (setprod R R) R2_topology
        (setprod R R :\: image_of f unit_interval)) a) /\
    winding_number f a = minus_SNo 1).

(** Infrastructure: complex reciprocal 1/z = (x, -y) / (x^2 + y^2) **)
Definition complex_reciprocal : set -> set := fun z =>
  (div_SNo (z 0) (complex_modulus_sq z),
   div_SNo (minus_SNo (z 1)) (complex_modulus_sq z)).

(** Infrastructure: complex division z/w **)
Definition complex_div_R2 : set -> set -> set := fun z w =>
  complex_mult_R2 z (complex_reciprocal w).

(** Infrastructure: differentiability on open interval (a,b) **)
Definition differentiable_on_interval : set -> set -> set -> prop := fun f a b =>
  forall x:set, x :e R -> Rlt a x -> Rlt x b ->
    exists L:set, L :e R /\
      forall eps:set, eps :e R -> Rlt 0 eps ->
        exists delta:set, delta :e R /\ Rlt 0 delta /\
          forall h:set, h :e R ->
            ~(h = 0) ->
            Rlt (Abs h) delta ->
            Rlt a (add_SNo x h) -> Rlt (add_SNo x h) b ->
            Rlt (Abs (add_SNo
              (div_SNo (add_SNo (apply_fun f (add_SNo x h))
                                (minus_SNo (apply_fun f x))) h)
              (minus_SNo L))) eps.

(** Infrastructure: piecewise differentiable path f: [0,1] -> R^2 **)
Definition piecewise_differentiable_path : set -> prop := fun f =>
  continuous_map unit_interval unit_interval_topology (setprod R R) R2_topology f /\
  exists n:set, n :e omega /\ n <> 0 /\
    exists P:set, function_on P (ordsucc n) R /\
      apply_fun P 0 = 0 /\
      apply_fun P n = 1 /\
      (forall i:set, i :e n ->
        Rlt (apply_fun P i) (apply_fun P (ordsucc i))) /\
      (forall i:set, i :e n ->
        differentiable_on_interval
          (graph R (fun t:set => (apply_fun f t) 0))
          (apply_fun P i) (apply_fun P (ordsucc i)) /\
        differentiable_on_interval
          (graph R (fun t:set => (apply_fun f t) 1))
          (apply_fun P i) (apply_fun P (ordsucc i))).

(** Infrastructure: piecewise differentiable loop **)
Definition piecewise_differentiable_loop : set -> prop := fun f =>
  piecewise_differentiable_path f /\
  apply_fun f 0 = apply_fun f 1.

(** Infrastructure: Riemann integral of f: R -> R on [a,b] **)
(** The unique I such that all Riemann sums with small mesh approximate I **)
Definition riemann_integral : set -> set -> set -> set := fun f a b =>
  Eps_i (fun I:set => I :e R /\
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        forall m:set, m :e omega -> m <> 0 ->
        forall P c:set,
          function_on P (ordsucc m) R ->
          apply_fun P 0 = a -> apply_fun P m = b ->
          (forall i:set, i :e m ->
            Rlt (apply_fun P i) (apply_fun P (ordsucc i)) /\
            ~(Rlt delta (add_SNo (apply_fun P (ordsucc i))
                                  (minus_SNo (apply_fun P i))))) ->
          function_on c m R ->
          (forall i:set, i :e m ->
            ~(Rlt (apply_fun c i) (apply_fun P i)) /\
            ~(Rlt (apply_fun P (ordsucc i)) (apply_fun c i))) ->
          Rlt (Abs (add_SNo
            (finite_real_sum
              (fun i:set => mul_SNo (apply_fun f (apply_fun c i))
                (add_SNo (apply_fun P (ordsucc i))
                         (minus_SNo (apply_fun P i))))
              m)
            (minus_SNo I))) eps).

(** Infrastructure: complex line integral of G along path gamma **)
(** Limit of sums: G(gamma(c_i)) times (gamma(t_{i+1}) - gamma(t_i)) **)
Definition complex_line_integral : set -> set -> set := fun G gamma =>
  Eps_i (fun I:set => I :e setprod R R /\
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        forall m:set, m :e omega -> m <> 0 ->
        forall P c:set,
          function_on P (ordsucc m) R ->
          apply_fun P 0 = 0 -> apply_fun P m = 1 ->
          (forall i:set, i :e m ->
            Rlt (apply_fun P i) (apply_fun P (ordsucc i)) /\
            ~(Rlt delta (add_SNo (apply_fun P (ordsucc i))
                                  (minus_SNo (apply_fun P i))))) ->
          function_on c m R ->
          (forall i:set, i :e m ->
            ~(Rlt (apply_fun c i) (apply_fun P i)) /\
            ~(Rlt (apply_fun P (ordsucc i)) (apply_fun c i))) ->
          Rlt (complex_modulus (R2_sub
            (finite_complex_sum
              (fun i:set =>
                complex_mult_R2
                  (apply_fun G (apply_fun gamma (apply_fun c i)))
                  (R2_sub (apply_fun gamma (apply_fun P (ordsucc i)))
                          (apply_fun gamma (apply_fun P i))))
              m)
            I)) eps).

(** Infrastructure: complex derivative of F at z equals L **)
Definition complex_derivative_at : set -> set -> set -> prop := fun F z L =>
  z :e setprod R R /\ L :e setprod R R /\
  forall eps:set, eps :e R -> Rlt 0 eps ->
    exists delta:set, delta :e R /\ Rlt 0 delta /\
      forall h:set, h :e setprod R R ->
        ~(h 0 = 0 /\ h 1 = 0) ->
        Rlt (complex_modulus h) delta ->
        Rlt (complex_modulus (R2_sub
          (complex_div_R2
            (R2_sub (apply_fun F (complex_add_R2 z h)) (apply_fun F z))
            h)
          L)) eps.

(** from S66 (line 2483 in algtop.tex): analytic (holomorphic) function **)
(** LATEX VERSION: F is analytic on open set Omega if F has a complex **)
(** derivative at every point of Omega. **)
Definition holomorphic_on : set -> set -> prop := fun F Omega =>
  Omega :e R2_topology /\
  (forall z:set, z :e Omega -> apply_fun F z :e setprod R R) /\
  (forall z:set, z :e Omega ->
    exists L:set, complex_derivative_at F z L).

(** from S66 Lemma 66.3 (line 2533 in algtop.tex) **)
(** LATEX VERSION: For piecewise-differentiable loop f and a not in image: **)
(** n(f,a) = (1/(2 pi i)) integral_f dz/(z-a). **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 120 **)
Theorem lemma66_3_integral_winding : forall f a:set,
  piecewise_differentiable_loop f ->
  a :e setprod R R ->
  ~(a :e image_of f unit_interval) ->
  (winding_number f a, 0) =
  complex_mult_R2
    (complex_reciprocal (0, mul_SNo 2 pi_real))
    (complex_line_integral
      (graph (setprod R R)
        (fun z:set => complex_reciprocal (R2_sub z a)))
      f).
admit.
Qed.

(** from S66 Theorem 66.4 (line 2551 in algtop.tex) **)
(** LATEX VERSION: Cauchy integral formula (Ahlfors version, used in proof of classical). **)
(** For piecewise-differentiable loop f in Omega, F analytic on Omega, **)
(** n(f,b)=0 for b not in Omega: n(f,a) F(a) = (1/(2 pi i)) integral_f F(z)/(z-a) dz **)
(** EFFORT: 12 lines textbook, difficulty 6/10, USD 150 **)
Theorem thm66_4_cauchy_integral_formula : forall f a Omega F:set,
  piecewise_differentiable_loop f ->
  holomorphic_on F Omega ->
  a :e Omega ->
  ~(a :e image_of f unit_interval) ->
  image_of f unit_interval c= Omega ->
  (forall b:set, b :e setprod R R ->
    ~(b :e Omega) ->
    ~(b :e image_of f unit_interval) ->
    winding_number f b = 0) ->
  complex_mult_R2 (winding_number f a, 0) (apply_fun F a) =
  complex_mult_R2
    (complex_reciprocal (0, mul_SNo 2 pi_real))
    (complex_line_integral
      (graph (setprod R R)
        (fun z:set => complex_div_R2 (apply_fun F z) (R2_sub z a)))
      f).
admit.
Qed.

(** from S66 Exercise 1 (line 2572 in algtop.tex) **)
(** LATEX VERSION: n(f,a) equals the degree of the induced map h: S^1 -> S^1. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex66_1_winding_equals_degree : forall f a h:set,
  loop_at (setprod R R) R2_topology (apply_fun f 0) f ->
  a :e setprod R R -> ~(a :e image_of f unit_interval) ->
  continuous_map S1 S1_topology S1 S1_topology h ->
  (forall s:set, s :e unit_interval ->
    apply_fun h (apply_fun covering_map_R_S1 s) =
      R2_normalize (R2_sub (apply_fun f s) a)) ->
  winding_number f a = degree_of_map_S1 h.
admit.
Qed.

(** Infrastructure: C is a smooth 1-dimensional submanifold of R^2 **)
(** For each point p in C, there is an open interval and a smooth injective **)
(** map gamma from that interval into R^2 whose image is a neighborhood of **)
(** p in C, with nonvanishing derivative. **)
Definition smooth_1_submanifold_R2 : set -> prop := fun C =>
  C c= setprod R R /\
  (forall p:set, p :e C ->
    exists a b:set, a :e R /\ b :e R /\ Rlt a b /\
    exists gamma:set,
      (forall t:set, t :e R -> Rlt a t -> Rlt t b ->
        apply_fun gamma t :e setprod R R) /\
      (forall t:set, t :e R -> Rlt a t -> Rlt t b ->
        apply_fun gamma t :e C) /\
      (forall t1 t2:set, t1 :e R -> t2 :e R ->
        Rlt a t1 -> Rlt t1 b -> Rlt a t2 -> Rlt t2 b ->
        apply_fun gamma t1 = apply_fun gamma t2 -> t1 = t2) /\
      (exists t0:set, t0 :e R /\ Rlt a t0 /\ Rlt t0 b /\
        apply_fun gamma t0 = p) /\
      (exists W:set, W :e subspace_topology (setprod R R) R2_topology C /\
        p :e W /\
        W c= image_of gamma (Sep R (fun t => Rlt a t /\ Rlt t b))) /\
      (forall t:set, t :e R -> Rlt a t -> Rlt t b ->
        exists Dx Dy:set, Dx :e R /\ Dy :e R /\
          ~(Dx = 0 /\ Dy = 0) /\
          forall eps:set, eps :e R -> Rlt 0 eps ->
            exists delta:set, delta :e R /\ Rlt 0 delta /\
              forall h:set, h :e R -> ~(h = 0) -> Rlt (Abs h) delta ->
                Rlt a (add_SNo t h) -> Rlt (add_SNo t h) b ->
                Rlt (Abs (add_SNo (div_SNo (add_SNo ((apply_fun gamma (add_SNo t h)) 0)
                                                      (minus_SNo ((apply_fun gamma t) 0))) h)
                                  (minus_SNo Dx))) eps /\
                Rlt (Abs (add_SNo (div_SNo (add_SNo ((apply_fun gamma (add_SNo t h)) 1)
                                                      (minus_SNo ((apply_fun gamma t) 1))) h)
                                  (minus_SNo Dy))) eps)).

(** Infrastructure: f smoothly parameterizes C - f is differentiable on (0,1) with **)
(** both components having derivatives, and f maps I onto C **)
Definition smooth_parameterization : set -> set -> prop := fun f C =>
  simple_loop (setprod R R) R2_topology f /\
  image_of f unit_interval = C /\
  (forall t:set, t :e R -> Rlt 0 t -> Rlt t 1 ->
    exists Dx Dy:set, Dx :e R /\ Dy :e R /\
      forall eps:set, eps :e R -> Rlt 0 eps ->
        exists delta:set, delta :e R /\ Rlt 0 delta /\
          forall h:set, h :e R -> ~(h = 0) -> Rlt (Abs h) delta ->
            Rlt 0 (add_SNo t h) -> Rlt (add_SNo t h) 1 ->
            Rlt (Abs (add_SNo (div_SNo (add_SNo ((apply_fun f (add_SNo t h)) 0)
                                                  (minus_SNo ((apply_fun f t) 0))) h)
                              (minus_SNo Dx))) eps /\
            Rlt (Abs (add_SNo (div_SNo (add_SNo ((apply_fun f (add_SNo t h)) 1)
                                                  (minus_SNo ((apply_fun f t) 1))) h)
                              (minus_SNo Dy))) eps).

(** from S66 Exercise 2 Theorem (line 2576 in algtop.tex) **)
(** LATEX VERSION: Let C be a simple closed curve in R^2 that is a smooth **)
(** submanifold of R^2; let f: I -> C be a simple loop smoothly parameterizing C. **)
(** If 0 is a point of the bounded component of R^2 - C, then n(f, 0) = +-1. **)
(** EFFORT: 25 lines textbook, difficulty 7/10, USD 350 **)
Theorem ex66_2_smooth_curve_winding : forall C f:set,
  C c= setprod R R ->
  is_simple_closed_curve C (subspace_topology (setprod R R) R2_topology C) ->
  smooth_1_submanifold_R2 C ->
  smooth_parameterization f C ->
  ~((0, 0) :e C) ->
  bounded_subset_R2 (component_of (setprod R R :\: C)
    (subspace_topology (setprod R R) R2_topology (setprod R R :\: C)) (0, 0)) ->
  winding_number f (0, 0) = 1 \/ winding_number f (0, 0) = minus_SNo 1.
admit.
Qed.

(** ============================================================ **)
(** Chapter 11: The Seifert-van Kampen Theorem                   **)
(** ============================================================ **)

(** ============================================================ **)
(** S67 Direct Sums of Abelian Groups                            **)
(** (lines 2582-2721 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: subgroup predicate **)
(** H is a subgroup of (G, mult, e, inv) **)
Definition subgroup_of : set -> set -> set -> set -> set -> prop :=
  fun H G mult e inv =>
    H c= G /\
    e :e H /\
    (forall x y:set, x :e H -> y :e H -> apply_fun mult (x, y) :e H) /\
    (forall x:set, x :e H -> apply_fun inv x :e H).

(** Infrastructure: a family of subgroups generates an abelian group G **)
(** Each x in G can be written as a finite sum of elements from the G_alpha **)
Definition subgroups_generate_abelian : set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J Gfam =>
    abelian_group G mult e inv /\
    (forall alpha:set, alpha :e J -> subgroup_of (apply_fun Gfam alpha) G mult e inv) /\
    (forall x:set, x :e G ->
      exists n:set, n :e omega /\ n <> 0 /\
      exists alphas:set, function_on alphas n J /\
      exists xs:set, function_on xs n G /\
        (forall i:set, i :e n -> apply_fun xs i :e apply_fun Gfam (apply_fun alphas i)) /\
        (forall i j:set, i :e n -> j :e n -> i <> j ->
          apply_fun alphas i <> apply_fun alphas j) /\
        x = nat_primrec e (fun i r => apply_fun mult (r, apply_fun xs i)) n).

(** from S67 Definition (line 2597-2604 in algtop.tex): direct sum of subgroups **)
(** LATEX VERSION: G is the direct sum of the groups G_alpha if G_alpha generate G **)
(** and for each x in G, the expression x = sum x_alpha is unique. **)
Definition direct_sum_of_subgroups : set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J Gfam =>
    subgroups_generate_abelian G mult e inv J Gfam /\
    (forall x:set, x :e G ->
      forall n1 n2:set, n1 :e omega -> n2 :e omega -> n1 <> 0 -> n2 <> 0 ->
      forall a1 a2:set, function_on a1 n1 J -> function_on a2 n2 J ->
      forall x1 x2:set, function_on x1 n1 G -> function_on x2 n2 G ->
        (forall i:set, i :e n1 -> apply_fun x1 i :e apply_fun Gfam (apply_fun a1 i)) ->
        (forall i:set, i :e n2 -> apply_fun x2 i :e apply_fun Gfam (apply_fun a2 i)) ->
        (forall i j:set, i :e n1 -> j :e n1 -> i <> j -> apply_fun a1 i <> apply_fun a1 j) ->
        (forall i j:set, i :e n2 -> j :e n2 -> i <> j -> apply_fun a2 i <> apply_fun a2 j) ->
        x = nat_primrec e (fun i r => apply_fun mult (r, apply_fun x1 i)) n1 ->
        x = nat_primrec e (fun i r => apply_fun mult (r, apply_fun x2 i)) n2 ->
        (forall alpha:set, alpha :e J ->
          (forall i j:set, i :e n1 -> j :e n2 ->
            apply_fun a1 i = alpha -> apply_fun a2 j = alpha ->
            apply_fun x1 i = apply_fun x2 j) /\
          ((exists i:set, i :e n1 /\ apply_fun a1 i = alpha) ->
           ~(exists j:set, j :e n2 /\ apply_fun a2 j = alpha) ->
           forall i:set, i :e n1 -> apply_fun a1 i = alpha -> apply_fun x1 i = e) /\
          (~(exists i:set, i :e n1 /\ apply_fun a1 i = alpha) ->
           (exists j:set, j :e n2 /\ apply_fun a2 j = alpha) ->
           forall j:set, j :e n2 -> apply_fun a2 j = alpha -> apply_fun x2 j = e))).

(** Infrastructure: kernel of a group homomorphism **)
Definition kernel_of : set -> set -> set -> set :=
  fun G e phi => {x :e G | apply_fun phi x = e}.

(** Infrastructure: normal subgroup **)
Definition normal_subgroup : set -> set -> set -> set -> set -> prop :=
  fun N G mult e inv =>
    subgroup_of N G mult e inv /\
    (forall n g:set, n :e N -> g :e G ->
      apply_fun mult (apply_fun mult (g, n), apply_fun inv g) :e N).

(** Infrastructure: quotient group G/N where N is normal **)
(** Elements are left cosets gN = {g.n : n in N} **)
Definition left_coset : set -> set -> set -> set :=
  fun mult g N => {apply_fun mult (g, n) | n :e N}.

Definition quotient_group_set : set -> set -> set -> set :=
  fun G mult N => {left_coset mult g N | g :e G}.

Definition quotient_group_mult : set -> set -> set -> set :=
  fun G mult N =>
    graph (setprod (quotient_group_set G mult N) (quotient_group_set G mult N))
      (fun p:set =>
        left_coset mult
          (apply_fun mult (Eps_i (fun g:set => g :e G /\ p 0 = left_coset mult g N),
                           Eps_i (fun g:set => g :e G /\ p 1 = left_coset mult g N)))
          N).

Definition quotient_group_id : set -> set -> set -> set -> set :=
  fun G mult e N => left_coset mult e N.

Definition quotient_group_inv : set -> set -> set -> set -> set :=
  fun G mult inv N =>
    graph (quotient_group_set G mult N)
      (fun c:set =>
        left_coset mult (apply_fun inv (Eps_i (fun g:set => g :e G /\ c = left_coset mult g N))) N).

(** Infrastructure: quotient projection homomorphism **)
Definition quotient_projection : set -> set -> set -> set :=
  fun G mult N =>
    graph G (fun g:set => left_coset mult g N).

(** from S67 Lemma 67.1 (line 2609 in algtop.tex): extension condition for direct sums **)
(** LATEX VERSION: If G is the direct sum of the groups G_alpha, then given any abelian **)
(** group H and any family of homomorphisms h_alpha: G_alpha -> H, there exists a unique **)
(** homomorphism h: G -> H whose restriction to G_alpha equals h_alpha. **)
(** from S67 Lemma 67.1 (line 2609 in algtop.tex): extension condition for direct sum **)
(** Conversely, if the groups G_alpha generate G and the extension condition holds, **)
(** then G is the direct sum of the G_alpha. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma67_1_extension_condition_direct_sum :
  forall G multG eG invG J Gfam:set,
  direct_sum_of_subgroups G multG eG invG J Gfam ->
  (forall H multH eH invH:set,
    abelian_group H multH eH invH ->
    forall hfam:set, function_on hfam J (Power (setprod G H)) ->
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) multG H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h x = apply_fun (apply_fun hfam alpha) x) /\
        (forall h':set, group_homomorphism G multG H multH h' ->
          (forall alpha:set, alpha :e J ->
            forall x:set, x :e apply_fun Gfam alpha ->
              apply_fun h' x = apply_fun (apply_fun hfam alpha) x) ->
          forall x:set, x :e G -> apply_fun h' x = apply_fun h x)).
admit.
Qed.

(** from S67 Lemma 67.1 converse (line 2613 in algtop.tex) **)
(** LATEX VERSION: If the groups G_alpha generate G and the extension condition holds, **)
(** then G is the direct sum of the G_alpha. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma67_1_converse :
  forall G multG eG invG J Gfam:set,
  subgroups_generate_abelian G multG eG invG J Gfam ->
  (forall H multH eH invH:set,
    abelian_group H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) multG H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h x = apply_fun (apply_fun hfam alpha) x)) ->
  direct_sum_of_subgroups G multG eG invG J Gfam.
admit.
Qed.

(** from S67 Corollary 67.2 (line 2629 in algtop.tex): associativity of direct sums **)
(** LATEX VERSION: Let G = G1 + G2. If G1 = direct sum H_alpha (alpha in J) and **)
(** G2 = direct sum H_beta (beta in K) with J,K disjoint, then G = direct sum H_gamma **)
(** for gamma in J union K. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor67_2_associativity_direct_sum :
  forall G multG eG invG G1 G2 J K Hfam:set,
  abelian_group G multG eG invG ->
  subgroup_of G1 G multG eG invG ->
  subgroup_of G2 G multG eG invG ->
  direct_sum_of_subgroups G multG eG invG (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2)) ->
  J :/\: K = Empty ->
  direct_sum_of_subgroups G1 multG eG invG J
    (graph J (fun alpha:set => apply_fun Hfam alpha)) ->
  direct_sum_of_subgroups G2 multG eG invG K
    (graph K (fun beta:set => apply_fun Hfam beta)) ->
  direct_sum_of_subgroups G multG eG invG (J :\/: K) Hfam.
admit.
Qed.

(** from S67 Corollary 67.3 (line 2639 in algtop.tex): quotient by direct summand **)
(** LATEX VERSION: If G = G1 + G2, then G/G2 is isomorphic to G1. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor67_3_quotient_by_summand :
  forall G multG eG invG G1 G2:set,
  abelian_group G multG eG invG ->
  subgroup_of G1 G multG eG invG ->
  subgroup_of G2 G multG eG invG ->
  direct_sum_of_subgroups G multG eG invG (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2)) ->
  normal_subgroup G2 G multG eG invG ->
  exists phi:set,
    group_isomorphism
      (quotient_group_set G multG G2) (quotient_group_mult G multG G2)
      G1 multG phi.
admit.
Qed.

(** from S67 Definition (line 2644 in algtop.tex): external direct sum **)
(** LATEX VERSION: G is the external direct sum of groups G_alpha relative to **)
(** monomorphisms i_alpha: G_alpha -> G if G is the direct sum of the images i_alpha(G_alpha). **)
Definition external_direct_sum : set -> set -> set -> set -> set -> set -> set -> prop :=
  fun G multG eG invG J Gfam ifam =>
    abelian_group G multG eG invG /\
    (forall alpha:set, alpha :e J ->
      group_homomorphism (apply_fun Gfam alpha) (Eps_i (fun m:set =>
        exists ea ia:set, abelian_group (apply_fun Gfam alpha) m ea ia))
        G multG (apply_fun ifam alpha)) /\
    (forall alpha:set, alpha :e J ->
      forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
        apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y) /\
    direct_sum_of_subgroups G multG eG invG J
      (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))).

(** from S67 Theorem 67.4 (line 2648 in algtop.tex): existence of external direct sum **)
(** LATEX VERSION: Given a family of abelian groups {G_alpha}, there exists an abelian **)
(** group G and monomorphisms i_alpha: G_alpha -> G such that G is the direct sum **)
(** of the images i_alpha(G_alpha). **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm67_4_existence_external_direct_sum :
  forall J Gfam multfam efam invfam:set,
  (forall alpha:set, alpha :e J ->
    abelian_group (apply_fun Gfam alpha)
      (apply_fun multfam alpha)
      (apply_fun efam alpha)
      (apply_fun invfam alpha)) ->
  exists G multG eG invG ifam:set,
    abelian_group G multG eG invG /\
    (forall alpha:set, alpha :e J ->
      group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha) /\
      (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
        apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y)) /\
    direct_sum_of_subgroups G multG eG invG J
      (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))).
admit.
Qed.

(** from S67 Lemma 67.5 (line 2660 in algtop.tex): extension condition for external direct sums **)
(** LATEX VERSION: If each i_alpha is a monomorphism and G is the direct sum of i_alpha(G_alpha), **)
(** then given any abelian group H and homomorphisms h_alpha: G_alpha -> H, there exists a unique **)
(** from S67 Lemma 67.5 (line 2660 in algtop.tex): external extension condition **)
(** homomorphism h: G -> H such that h o i_alpha = h_alpha. Conversely, if the extension condition **)
(** holds, then each i_alpha is a monomorphism and G is the direct sum. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma67_5_extension_external :
  forall G multG eG invG J Gfam multfam ifam:set,
  abelian_group G multG eG invG ->
  (forall alpha:set, alpha :e J ->
    group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha) /\
    (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
      apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y)) ->
  direct_sum_of_subgroups G multG eG invG J
    (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))) ->
  (forall H multH eH invH:set,
    abelian_group H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h (apply_fun (apply_fun ifam alpha) x) =
              apply_fun (apply_fun hfam alpha) x) /\
        (forall h':set, group_homomorphism G multG H multH h' ->
          (forall alpha:set, alpha :e J ->
            forall x:set, x :e apply_fun Gfam alpha ->
              apply_fun h' (apply_fun (apply_fun ifam alpha) x) =
                apply_fun (apply_fun hfam alpha) x) ->
          forall x:set, x :e G -> apply_fun h' x = apply_fun h x)).
admit.
Qed.

(** from S67 Lemma 67.5 converse (line 2665 in algtop.tex): extension condition implies direct sum **)
(** LATEX VERSION: If the groups i_alpha(G_alpha) generate G and the extension condition holds, **)
(** then each i_alpha is a monomorphism and G is the direct sum of the groups i_alpha(G_alpha). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma67_5_extension_converse :
  forall G multG eG invG J Gfam multfam efam invfam ifam:set,
  abelian_group G multG eG invG ->
  (forall alpha:set, alpha :e J ->
    abelian_group (apply_fun Gfam alpha) (apply_fun multfam alpha) (apply_fun efam alpha) (apply_fun invfam alpha)) ->
  (forall alpha:set, alpha :e J ->
    group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha)) ->
  subgroups_generate_abelian G multG eG invG J
    (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))) ->
  (forall H multH eH invH:set,
    abelian_group H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h (apply_fun (apply_fun ifam alpha) x) =
              apply_fun (apply_fun hfam alpha) x)) ->
  (forall alpha:set, alpha :e J ->
    forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
      apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y) /\
  direct_sum_of_subgroups G multG eG invG J
    (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))).
admit.
Qed.

(** from S67 Theorem 67.6 (line 2671 in algtop.tex): uniqueness of direct sums **)
(** LATEX VERSION: If G and G' are both external direct sums of {G_alpha} via **)
(** i_alpha and i'_alpha respectively, then there is a unique isomorphism **)
(** phi: G -> G' such that phi o i_alpha = i'_alpha. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm67_6_uniqueness_direct_sum :
  forall J Gfam multfam G multG eG invG ifam G' multG' eG' invG' ifam':set,
  abelian_group G multG eG invG ->
  abelian_group G' multG' eG' invG' ->
  (forall alpha:set, alpha :e J ->
    group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha) /\
    (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
      apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y)) ->
  (forall alpha:set, alpha :e J ->
    group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G' multG' (apply_fun ifam' alpha) /\
    (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
      apply_fun (apply_fun ifam' alpha) x = apply_fun (apply_fun ifam' alpha) y -> x = y)) ->
  direct_sum_of_subgroups G multG eG invG J
    (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha))) ->
  direct_sum_of_subgroups G' multG' eG' invG' J
    (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam' alpha))) ->
  exists phi:set,
    group_isomorphism G multG G' multG' phi /\
    (forall alpha:set, alpha :e J ->
      forall x:set, x :e apply_fun Gfam alpha ->
        apply_fun phi (apply_fun (apply_fun ifam alpha) x) =
          apply_fun (apply_fun ifam' alpha) x) /\
    (forall phi':set, group_isomorphism G multG G' multG' phi' ->
      (forall alpha:set, alpha :e J ->
        forall x:set, x :e apply_fun Gfam alpha ->
          apply_fun phi' (apply_fun (apply_fun ifam alpha) x) =
            apply_fun (apply_fun ifam' alpha) x) ->
      forall x:set, x :e G -> apply_fun phi' x = apply_fun phi x).
admit.
Qed.

(** Infrastructure: infinite cyclic subgroup generated by an element **)
Definition infinite_cyclic_subgroup : set -> set -> set -> set -> set -> prop :=
  fun G mult e inv a =>
    a :e G /\
    (forall n:set, n :e omega -> group_power_nat mult e a n :e G) /\
    (forall m:set, m :e omega -> group_power_nat mult e (apply_fun inv a) (ordsucc m) :e G) /\
    ~(exists n:set, n :e omega /\ n <> 0 /\ group_power_nat mult e a n = e).

(** from S67 Definition (line 2679 in algtop.tex): free abelian group with basis **)
(** LATEX VERSION: If each G_alpha (generated by a_alpha) is infinite cyclic, and **)
(** G is the direct sum of the G_alpha, then G is a free abelian group with **)
(** basis {a_alpha}. **)
Definition free_abelian_group_with_basis : set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J basis =>
    abelian_group G mult e inv /\
    function_on basis J G /\
    (forall alpha:set, alpha :e J ->
      infinite_cyclic_subgroup G mult e inv (apply_fun basis alpha)) /\
    direct_sum_of_subgroups G mult e inv J
      (graph J (fun alpha:set =>
        {g :e G | exists n:set, n :e int /\
          ((n :e omega /\ g = group_power_nat mult e (apply_fun basis alpha) n) \/
           (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
            g = group_power_nat mult e (apply_fun inv (apply_fun basis alpha)) (ordsucc m)))})).

(** from S67 Lemma 67.7 (line 2683 in algtop.tex): extension condition for free abelian groups **)
(** LATEX VERSION: G is a free abelian group with basis {a_alpha} iff for any abelian **)
(** group H and any family {y_alpha} of elements of H, there is a unique homomorphism **)
(** h: G -> H with h(a_alpha) = y_alpha. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma67_7_extension_free_abelian :
  forall G mult e inv J basis:set,
  abelian_group G mult e inv ->
  function_on basis J G ->
  (forall alpha:set, alpha :e J ->
    generator_of G mult e inv (apply_fun basis alpha)) ->
  (free_abelian_group_with_basis G mult e inv J basis <->
   (forall H multH eH invH:set,
     abelian_group H multH eH invH ->
     forall ys:set, function_on ys J H ->
       exists h:set,
         group_homomorphism G mult H multH h /\
         (forall alpha:set, alpha :e J ->
           apply_fun h (apply_fun basis alpha) = apply_fun ys alpha) /\
         (forall h':set, group_homomorphism G mult H multH h' ->
           (forall alpha:set, alpha :e J ->
             apply_fun h' (apply_fun basis alpha) = apply_fun ys alpha) ->
           forall x:set, x :e G -> apply_fun h' x = apply_fun h x))).
admit.
Qed.

(** from S67 Theorem 67.8 (line 2689 in algtop.tex): rank is well-defined **)
(** LATEX VERSION: If G is a free abelian group with basis {a_1,...,a_n}, **)
(** then n is uniquely determined by G. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm67_8_rank_well_defined :
  forall G mult e inv n1 n2 basis1 basis2:set,
  free_abelian_group_with_basis G mult e inv n1 basis1 ->
  free_abelian_group_with_basis G mult e inv n2 basis2 ->
  finite n1 -> finite n2 ->
  equip n1 n2.
admit.
Qed.

(** from S67 Definition (line 2693 in algtop.tex): rank of a free abelian group **)
(** LATEX VERSION: If G is a free abelian group with a finite basis, the number of **)
(** elements in a basis for G is called the rank of G. **)
Definition rank_free_abelian : set -> set -> set -> set -> set :=
  fun G mult e inv =>
    Eps_i (fun n:set => n :e omega /\
      exists J basis:set,
        equip J n /\
        free_abelian_group_with_basis G mult e inv J basis).

(** from S67 Exercises Exercise 6 / Theorem (line 2712 in algtop.tex): free abelian subgroup rank **)
(** LATEX VERSION: If A is a free abelian group of rank n, then any subgroup B **)
(** of A is a free abelian group of rank at most n. **)
(** EFFORT: 12 lines textbook, difficulty 6/10, USD 150 **)
Theorem ex67_6_free_abelian_subgroup_rank :
  forall A multA eA invA:set,
  group_structure A multA eA invA ->
  forall n:set, n :e omega ->
  rank_free_abelian A multA eA invA = n ->
  forall B:set, subgroup_of B A multA eA invA ->
  exists m:set, m :e omega /\ m c= n /\
    exists J basis:set,
      equip J m /\
      free_abelian_group_with_basis B multA eA invA J basis.
admit.
Qed.

(** from S67 Exercise 1 (line 2697 in algtop.tex) **)
(** LATEX VERSION: Sum is direct iff x_{a1} + ... + x_{an} = 0 implies each x_{ai} = 0. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex67_1_direct_sum_characterization :
  forall G mult e inv J Gfam:set,
  subgroups_generate_abelian G mult e inv J Gfam ->
  (direct_sum_of_subgroups G mult e inv J Gfam <->
   (forall n:set, n :e omega -> n <> 0 ->
    forall alphas:set, function_on alphas n J ->
    (forall i j:set, i :e n -> j :e n -> i <> j -> apply_fun alphas i <> apply_fun alphas j) ->
    forall xs:set, function_on xs n G ->
    (forall i:set, i :e n -> apply_fun xs i :e apply_fun Gfam (apply_fun alphas i)) ->
    nat_primrec e (fun i r => apply_fun mult (r, apply_fun xs i)) n = e ->
    (forall i:set, i :e n -> apply_fun xs i = e))).
admit.
Qed.

(** from S67 Exercise 3 (line 2706 in algtop.tex) **)
(** LATEX VERSION: If G is free abelian with basis {x, y}, then {2x+3y, x-y} is also a basis. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex67_3_change_of_basis :
  forall G mult e inv x y:set,
  free_abelian_group_with_basis G mult e inv 2 (graph 2 (fun i =>
    if i = 0 then x else y)) ->
  free_abelian_group_with_basis G mult e inv 2 (graph 2 (fun i =>
    if i = 0
    then apply_fun mult (group_power_nat mult e x 2, group_power_nat mult e y 3)
    else apply_fun mult (x, apply_fun inv y))).
admit.
Qed.

(** from S67 Exercise 4(a) (line 2708 in algtop.tex) **)
(** LATEX VERSION: The elements of finite order in an abelian group G form a subgroup (torsion subgroup). **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex67_4a_torsion_subgroup :
  forall G mult e inv:set,
  abelian_group G mult e inv ->
  subgroup_of
    {a :e G | exists m:set, m :e omega /\ m <> 0 /\ group_power_nat mult e a m = e}
    G mult e inv.
admit.
Qed.

(** from S67 Exercise 4(b) (line 2709 in algtop.tex) **)
(** LATEX VERSION: If G is free abelian, it has no elements of finite order. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex67_4b_free_abelian_no_torsion :
  forall G mult e inv J basis:set,
  free_abelian_group_with_basis G mult e inv J basis ->
  forall a:set, a :e G -> a <> e ->
  ~(exists m:set, m :e omega /\ m <> 0 /\ group_power_nat mult e a m = e).
admit.
Qed.

(** from S67 Exercise 4(c) (line 2710 in algtop.tex) **)
(** LATEX VERSION: The rationals have no elements of finite order but are not free abelian. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex67_4c_rationals_not_free_abelian :
  (forall q:set, q :e rational -> q <> 0 ->
    ~(exists m:set, m :e omega /\ m <> 0 /\
      nat_primrec 0 (fun _ r => add_SNo r q) m = 0)) /\
  ~(exists J basis:set,
    free_abelian_group_with_basis rational
      (graph (setprod rational rational) (fun p:set => add_SNo (p 0) (p 1)))
      0 (graph rational (fun q:set => minus_SNo q)) J basis).
admit.
Qed.

(** from S67 Exercise 5 (line 2711 in algtop.tex) **)
(** LATEX VERSION: Give an example of a free abelian group G of rank n having **)
(** a subgroup H of rank n for which H is not equal to G. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex67_5_proper_subgroup_same_rank :
  forall n:set, n :e omega -> n <> 0 ->
  exists G mult e inv J1 basis1 J2 basis2:set,
    free_abelian_group_with_basis G mult e inv J1 basis1 /\
    equip J1 n /\
    exists H:set,
      subgroup_of H G mult e inv /\ H <> G /\
      free_abelian_group_with_basis H mult e inv J2 basis2 /\
      equip J2 n.
admit.
Qed.

(** ============================================================ **)
(** S68 Free Products of Groups                                  **)
(** (lines 2722-3030 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: a family of subgroups generates a (not necessarily abelian) group G **)
(** Every element x of G can be written as a finite product of elements of the G_alpha **)
Definition subgroups_generate : set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J Gfam =>
    group_structure G mult e inv /\
    (forall alpha:set, alpha :e J -> subgroup_of (apply_fun Gfam alpha) G mult e inv) /\
    (forall x:set, x :e G ->
      x = e \/
      exists n:set, n :e omega /\ n <> 0 /\
      exists xs:set, function_on xs n G /\
        (forall i:set, i :e n ->
          exists alpha:set, alpha :e J /\ apply_fun xs i :e apply_fun Gfam alpha) /\
        x = nat_primrec e (fun i r => apply_fun mult (r, apply_fun xs i)) n).

(** Infrastructure: a word of length n in groups G_alpha is an n-tuple of elements **)
(** where each element belongs to some G_alpha **)
Definition word_in_groups : set -> set -> set -> set -> prop :=
  fun J Gfam n xs =>
    n :e omega /\
    function_on xs n (Union (Repl J (fun alpha:set => apply_fun Gfam alpha))) /\
    (forall i:set, i :e n ->
      exists alpha:set, alpha :e J /\ apply_fun xs i :e apply_fun Gfam alpha).

(** Infrastructure: a reduced word in groups G_alpha **)
(** No adjacent elements from the same group, and no identity elements **)
Definition reduced_word : set -> set -> set -> set -> set -> prop :=
  fun J Gfam efam n xs =>
    n :e omega /\
    (forall i:set, i :e n ->
      exists alpha:set, alpha :e J /\
        apply_fun xs i :e apply_fun Gfam alpha /\
        apply_fun xs i <> apply_fun efam alpha) /\
    (forall i:set, i :e n -> ordsucc i :e n ->
      forall alpha beta:set, alpha :e J -> beta :e J ->
        apply_fun xs i :e apply_fun Gfam alpha ->
        apply_fun xs (ordsucc i) :e apply_fun Gfam beta ->
        alpha <> beta).

(** Infrastructure: the product represented by a word of length n **)
Definition word_product : set -> set -> set -> set -> set :=
  fun mult e xs n =>
    nat_primrec e (fun i r => apply_fun mult (r, apply_fun xs i)) n.

(** from S68 Definition (line 2742 in algtop.tex): free product of subgroups **)
(** LATEX VERSION: G is the free product of {G_alpha} if G_alpha cap G_beta = {1} **)
(** for alpha <> beta, the G_alpha generate G, and each x in G has a unique **)
(** reduced word representation. **)
Definition free_product_of_subgroups : set -> set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J Gfam efam =>
    group_structure G mult e inv /\
    (forall alpha:set, alpha :e J -> subgroup_of (apply_fun Gfam alpha) G mult e inv) /\
    (forall alpha beta:set, alpha :e J -> beta :e J -> alpha <> beta ->
      forall x:set, x :e apply_fun Gfam alpha -> x :e apply_fun Gfam beta -> x = e) /\
    subgroups_generate G mult e inv J Gfam /\
    (forall x:set, x :e G -> x <> e ->
      exists n xs:set,
        reduced_word J Gfam efam n xs /\ n <> 0 /\
        word_product mult e xs n = x /\
        (forall n' xs':set,
          reduced_word J Gfam efam n' xs' -> n' <> 0 ->
          word_product mult e xs' n' = x ->
          n = n' /\ (forall i:set, i :e n -> apply_fun xs i = apply_fun xs' i))).

(** Infrastructure: the least normal subgroup of G containing a subset S **)
Definition least_normal_subgroup : set -> set -> set -> set -> set -> set :=
  fun G mult e inv S =>
    Eps_i (fun N:set =>
      normal_subgroup N G mult e inv /\
      S c= N /\
      (forall N':set, normal_subgroup N' G mult e inv -> S c= N' -> N c= N')).

(** from S68 Lemma 68.1 (line 2781 in algtop.tex): extension condition for free products **)
(** LATEX VERSION: If G is the free product of {G_alpha}, then given any group H and **)
(** homomorphisms h_alpha: G_alpha -> H, there exists a unique h: G -> H whose restriction **)
(** to G_alpha equals h_alpha. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma68_1_extension_condition_free_product :
  forall G multG eG invG J Gfam efam:set,
  free_product_of_subgroups G multG eG invG J Gfam efam ->
  forall H multH eH invH:set,
    group_structure H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) multG H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h x = apply_fun (apply_fun hfam alpha) x) /\
        (forall h':set, group_homomorphism G multG H multH h' ->
          (forall alpha:set, alpha :e J ->
            forall x:set, x :e apply_fun Gfam alpha ->
              apply_fun h' x = apply_fun (apply_fun hfam alpha) x) ->
          forall x:set, x :e G -> apply_fun h' x = apply_fun h x).
admit.
Qed.

(** from S68 Definition (line 2827 in algtop.tex): external free product **)
(** LATEX VERSION: G is the external free product of {G_alpha} relative to **)
(** monomorphisms i_alpha if G is the free product of the images i_alpha(G_alpha). **)
Definition external_free_product : set -> set -> set -> set -> set -> set -> set -> set -> prop :=
  fun G multG eG invG J Gfam multfam ifam =>
    group_structure G multG eG invG /\
    (forall alpha:set, alpha :e J ->
      group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha) /\
      (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
        apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y)) /\
    free_product_of_subgroups G multG eG invG J
      (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha)))
      (graph J (fun alpha:set => apply_fun (apply_fun ifam alpha) (Eps_i (fun ea:set =>
        exists ma ia:set, group_structure (apply_fun Gfam alpha) (apply_fun multfam alpha) ea ia)))).

(** from S68 Theorem 68.2 (line 2831 in algtop.tex): existence of free products **)
(** LATEX VERSION: Given a family {G_alpha} of groups, there exists a group G and **)
(** monomorphisms i_alpha: G_alpha -> G such that G is the free product of i_alpha(G_alpha). **)
(** EFFORT: 50 lines textbook, difficulty 8/10, USD 800 **)
Theorem thm68_2_existence_free_product :
  forall J Gfam multfam efam invfam:set,
  (forall alpha:set, alpha :e J ->
    group_structure (apply_fun Gfam alpha)
      (apply_fun multfam alpha)
      (apply_fun efam alpha)
      (apply_fun invfam alpha)) ->
  exists G multG eG invG ifam:set,
    group_structure G multG eG invG /\
    (forall alpha:set, alpha :e J ->
      group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha) /\
      (forall x y:set, x :e apply_fun Gfam alpha -> y :e apply_fun Gfam alpha ->
        apply_fun (apply_fun ifam alpha) x = apply_fun (apply_fun ifam alpha) y -> x = y)) /\
    free_product_of_subgroups G multG eG invG J
      (graph J (fun alpha:set => homomorphism_image (apply_fun Gfam alpha) (apply_fun ifam alpha)))
      (graph J (fun alpha:set => apply_fun (apply_fun ifam alpha) (apply_fun efam alpha))).
admit.
Qed.

(** from S68 Lemma 68.3 (line 2940 in algtop.tex): extension condition for external free products **)
(** LATEX VERSION: If each i_alpha is a monomorphism and G is the free product of **)
(** i_alpha(G_alpha), then given any group H and homomorphisms h_alpha: G_alpha -> H, **)
(** there exists a unique h: G -> H with h o i_alpha = h_alpha. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem lemma68_3_extension_external_free_product :
  forall G multG eG invG J Gfam multfam ifam:set,
  external_free_product G multG eG invG J Gfam multfam ifam ->
  forall H multH eH invH:set,
    group_structure H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h (apply_fun (apply_fun ifam alpha) x) =
              apply_fun (apply_fun hfam alpha) x) /\
        (forall h':set, group_homomorphism G multG H multH h' ->
          (forall alpha:set, alpha :e J ->
            forall x:set, x :e apply_fun Gfam alpha ->
              apply_fun h' (apply_fun (apply_fun ifam alpha) x) =
                apply_fun (apply_fun hfam alpha) x) ->
          forall x:set, x :e G -> apply_fun h' x = apply_fun h x).
admit.
Qed.

(** from S68 Theorem 68.4 (line 2946 in algtop.tex): uniqueness of free products **)
(** LATEX VERSION: If G and G' are both external free products of {G_alpha} via **)
(** i_alpha and i'_alpha, then there is a unique isomorphism phi: G -> G' **)
(** with phi o i_alpha = i'_alpha. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm68_4_uniqueness_free_product :
  forall J Gfam multfam G multG eG invG ifam G' multG' eG' invG' ifam':set,
  external_free_product G multG eG invG J Gfam multfam ifam ->
  external_free_product G' multG' eG' invG' J Gfam multfam ifam' ->
  exists phi:set,
    group_isomorphism G multG G' multG' phi /\
    (forall alpha:set, alpha :e J ->
      forall x:set, x :e apply_fun Gfam alpha ->
        apply_fun phi (apply_fun (apply_fun ifam alpha) x) =
          apply_fun (apply_fun ifam' alpha) x) /\
    (forall phi':set, group_isomorphism G multG G' multG' phi' ->
      (forall alpha:set, alpha :e J ->
        forall x:set, x :e apply_fun Gfam alpha ->
          apply_fun phi' (apply_fun (apply_fun ifam alpha) x) =
            apply_fun (apply_fun ifam' alpha) x) ->
      forall x:set, x :e G -> apply_fun phi' x = apply_fun phi x).
admit.
Qed.

(** from S68 Lemma 68.5 (line 2950 in algtop.tex): extension condition characterizes free products **)
(** LATEX VERSION: If the extension condition of Lemma 68.3 holds, then each i_alpha **)
(** is a monomorphism and G is the free product of i_alpha(G_alpha). **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem lemma68_5_extension_characterizes_free_product :
  forall G multG eG invG J Gfam multfam efam invfam ifam:set,
  group_structure G multG eG invG ->
  (forall alpha:set, alpha :e J ->
    group_structure (apply_fun Gfam alpha) (apply_fun multfam alpha)
      (apply_fun efam alpha) (apply_fun invfam alpha)) ->
  (forall alpha:set, alpha :e J ->
    group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) G multG (apply_fun ifam alpha)) ->
  (forall H multH eH invH:set,
    group_structure H multH eH invH ->
    forall hfam:set,
      (forall alpha:set, alpha :e J ->
        group_homomorphism (apply_fun Gfam alpha) (apply_fun multfam alpha) H multH (apply_fun hfam alpha)) ->
      exists h:set,
        group_homomorphism G multG H multH h /\
        (forall alpha:set, alpha :e J ->
          forall x:set, x :e apply_fun Gfam alpha ->
            apply_fun h (apply_fun (apply_fun ifam alpha) x) =
              apply_fun (apply_fun hfam alpha) x)) ->
  external_free_product G multG eG invG J Gfam multfam ifam.
admit.
Qed.

(** from S68 Corollary 68.6 (line 2958 in algtop.tex): associativity of free products **)
(** LATEX VERSION: If G = G1 free-prod G2, G1 = free product of H_alpha for alpha in J, **)
(** G2 = free product of H_beta for beta in K, with J,K disjoint, **)
(** then G = free product of H_gamma for gamma in J union K. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor68_6_associativity_free_product :
  forall G multG eG invG G1 G2 J K Hfam efamH:set,
  group_structure G multG eG invG ->
  subgroup_of G1 G multG eG invG ->
  subgroup_of G2 G multG eG invG ->
  free_product_of_subgroups G multG eG invG (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
    (graph (UPair 0 1) (fun i:set => eG)) ->
  J :/\: K = Empty ->
  free_product_of_subgroups G1 multG eG invG J
    (graph J (fun alpha:set => apply_fun Hfam alpha))
    (graph J (fun alpha:set => apply_fun efamH alpha)) ->
  free_product_of_subgroups G2 multG eG invG K
    (graph K (fun beta:set => apply_fun Hfam beta))
    (graph K (fun beta:set => apply_fun efamH beta)) ->
  free_product_of_subgroups G multG eG invG (J :\/: K) Hfam efamH.
admit.
Qed.

(** from S68 Theorem 68.7 (line 2972 in algtop.tex): quotient of free product **)
(** LATEX VERSION: Let G = G1 free-prod G2. Let N_i be normal in G_i. If N is the least **)
(** normal subgroup of G containing N1 and N2, then G/N iso (G1/N1) free-prod (G2/N2). **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 250 **)
Theorem thm68_7_quotient_free_product :
  forall G multG eG invG G1 G2 N1 N2:set,
  free_product_of_subgroups G multG eG invG (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
    (graph (UPair 0 1) (fun i:set => eG)) ->
  normal_subgroup N1 G1 multG eG invG ->
  normal_subgroup N2 G2 multG eG invG ->
  let N := least_normal_subgroup G multG eG invG (N1 :\/: N2) in
  exists FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then quotient_group_set G1 multG N1
        else quotient_group_set G2 multG N2))
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then quotient_group_mult G1 multG N1
        else quotient_group_mult G2 multG N2))
      ifam /\
    exists phi:set,
      group_isomorphism
        (quotient_group_set G multG N) (quotient_group_mult G multG N)
        FP multFP phi.
admit.
Qed.

(** from S68 Corollary 68.8 (line 3006 in algtop.tex): quotient by factor **)
(** LATEX VERSION: If N is the least normal subgroup of G1 free-prod G2 containing G1, **)
(** then (G1 free-prod G2)/N is isomorphic to G2. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor68_8_quotient_by_factor :
  forall G multG eG invG G1 G2:set,
  free_product_of_subgroups G multG eG invG (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
    (graph (UPair 0 1) (fun i:set => eG)) ->
  let N := least_normal_subgroup G multG eG invG G1 in
  exists phi:set,
    group_isomorphism
      (quotient_group_set G multG N) (quotient_group_mult G multG N)
      G2 multG phi.
admit.
Qed.

(** from S68 Lemma 68.9 (line 3010 in algtop.tex): generators of least normal subgroup **)
(** LATEX VERSION: If N is the least normal subgroup of G containing S, then N is **)
(** generated by all conjugates of elements of S. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma68_9_least_normal_generated_by_conjugates :
  forall G mult e inv S:set,
  group_structure G mult e inv ->
  S c= G ->
  let N := least_normal_subgroup G mult e inv S in
  let conjugates := Union (Repl G (fun c:set =>
    Repl S (fun t:set => apply_fun mult (apply_fun mult (c, t), apply_fun inv c)))) in
  subgroups_generate N mult e inv
    (Sing conjugates)
    (graph (Sing conjugates) (fun q:set => conjugates)).
admit.
Qed.

(** from S68 Exercise 2(a) (line 3025 in algtop.tex) **)
(** LATEX VERSION: Let G = G1 free-product G2 where G1, G2 nontrivial. Then G is not abelian. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex68_2a_free_product_not_abelian :
  forall G mult e inv G1 G2:set,
  free_product_of_subgroups G mult e inv 2
    (graph 2 (fun i => if i = 0 then G1 else G2))
    (graph 2 (fun _ => e)) ->
  (exists a:set, a :e G1 /\ a <> e) ->
  (exists b:set, b :e G2 /\ b <> e) ->
  ~(abelian_group G mult e inv).
admit.
Qed.

(** from S68 Exercise 2(c) (line 3028 in algtop.tex) **)
(** LATEX VERSION: The only elements of G that have finite order are elements **)
(** of G1 and G2 that have finite order, and their conjugates. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex68_2c_finite_order_elements :
  forall G mult e inv G1 G2:set,
  free_product_of_subgroups G mult e inv 2
    (graph 2 (fun i => if i = 0 then G1 else G2))
    (graph 2 (fun _ => e)) ->
  forall x:set, x :e G ->
    (exists m:set, m :e omega /\ m <> 0 /\ group_power_nat mult e x m = e) ->
    exists c y:set, c :e G /\ (y :e G1 \/ y :e G2) /\
      (exists m:set, m :e omega /\ m <> 0 /\ group_power_nat mult e y m = e) /\
      x = apply_fun mult (apply_fun mult (c, y), apply_fun inv c).
admit.
Qed.

(** from S68 Exercise 3 (line 3029 in algtop.tex) **)
(** LATEX VERSION: Let G = G1 free-product G2. Given c in G, cG1c^{-1} cap G2 = {1}. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex68_3_conjugate_intersection_trivial :
  forall G mult e inv G1 G2:set,
  free_product_of_subgroups G mult e inv 2
    (graph 2 (fun i => if i = 0 then G1 else G2))
    (graph 2 (fun _ => e)) ->
  forall c:set, c :e G ->
    forall x:set, x :e G1 ->
      apply_fun mult (apply_fun mult (c, x), apply_fun inv c) :e G2 ->
      apply_fun mult (apply_fun mult (c, x), apply_fun inv c) = e.
admit.
Qed.

(** ============================================================ **)
(** S69 Free Groups                                              **)
(** (lines 3033-3182 in algtop.tex)                              **)
(** ============================================================ **)

(** from S69 Definition (line 3036 in algtop.tex): free group **)
(** LATEX VERSION: If each a_alpha generates an infinite cyclic subgroup G_alpha of G, **)
(** and G is the free product of {G_alpha}, then G is a free group and {a_alpha} **)
(** is a system of free generators. **)
Definition free_group_with_generators : set -> set -> set -> set -> set -> set -> prop :=
  fun G mult e inv J gens =>
    group_structure G mult e inv /\
    function_on gens J G /\
    (forall alpha:set, alpha :e J ->
      infinite_cyclic_subgroup G mult e inv (apply_fun gens alpha)) /\
    free_product_of_subgroups G mult e inv J
      (graph J (fun alpha:set =>
        {g :e G | exists n:set, n :e int /\
          ((n :e omega /\ g = group_power_nat mult e (apply_fun gens alpha) n) \/
           (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
            g = group_power_nat mult e (apply_fun inv (apply_fun gens alpha)) (ordsucc m)))}))
      (graph J (fun alpha:set => e)).

(** from S69 Lemma 69.1 (line 3047 in algtop.tex): extension condition for free groups **)
(** LATEX VERSION: G is a free group with generators {a_alpha} iff for any group H **)
(** and any family {y_alpha} of elements of H, there is a unique homomorphism **)
(** h: G -> H with h(a_alpha) = y_alpha. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma69_1_extension_free_group :
  forall G mult e inv J gens:set,
  group_structure G mult e inv ->
  function_on gens J G ->
  (free_group_with_generators G mult e inv J gens <->
   (forall H multH eH invH:set,
     group_structure H multH eH invH ->
     forall ys:set, function_on ys J H ->
       exists h:set,
         group_homomorphism G mult H multH h /\
         (forall alpha:set, alpha :e J ->
           apply_fun h (apply_fun gens alpha) = apply_fun ys alpha) /\
         (forall h':set, group_homomorphism G mult H multH h' ->
           (forall alpha:set, alpha :e J ->
             apply_fun h' (apply_fun gens alpha) = apply_fun ys alpha) ->
           forall x:set, x :e G -> apply_fun h' x = apply_fun h x))).
admit.
Qed.

(** from S69 Theorem 69.2 (line 3057 in algtop.tex): free product of free groups is free **)
(** LATEX VERSION: If G = G1 free-prod G2 where G1, G2 are free with generators a_alpha_J **)
(** and a_alpha_K respectively, and J,K disjoint, then G is free with generators **)
(** a_alpha for J union K. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem thm69_2_free_product_of_free_groups :
  forall G mult e inv G1 G2 J K gens:set,
  group_structure G mult e inv ->
  subgroup_of G1 G mult e inv ->
  subgroup_of G2 G mult e inv ->
  free_product_of_subgroups G mult e inv (UPair 0 1)
    (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
    (graph (UPair 0 1) (fun i:set => e)) ->
  J :/\: K = Empty ->
  free_group_with_generators G1 mult e inv J
    (graph J (fun alpha:set => apply_fun gens alpha)) ->
  free_group_with_generators G2 mult e inv K
    (graph K (fun alpha:set => apply_fun gens alpha)) ->
  free_group_with_generators G mult e inv (J :\/: K) gens.
admit.
Qed.

(** from S69 Definition (line 3071 in algtop.tex): commutator **)
(** LATEX VERSION: [x,y] = x y x^{-1} y^{-1} is called the commutator of x and y. **)
Definition commutator : set -> set -> set -> set -> set :=
  fun mult inv x y =>
    apply_fun mult (apply_fun mult (apply_fun mult (x, y), apply_fun inv x), apply_fun inv y).

(** from S69 Definition (line 3077 in algtop.tex): commutator subgroup **)
(** LATEX VERSION: The subgroup of G generated by all commutators is called the **)
(** commutator subgroup [G,G]. **)
Definition commutator_subgroup : set -> set -> set -> set -> set :=
  fun G mult e inv =>
    Eps_i (fun C:set =>
      subgroup_of C G mult e inv /\
      (forall x y:set, x :e G -> y :e G -> commutator mult inv x y :e C) /\
      (forall C':set, subgroup_of C' G mult e inv ->
        (forall x y:set, x :e G -> y :e G -> commutator mult inv x y :e C') ->
        C c= C')).

(** from S69 Lemma 69.3 (line 3081 in algtop.tex): commutator subgroup properties **)
(** LATEX VERSION: [G,G] is normal in G, G/[G,G] is abelian, and any homomorphism **)
(** from G to an abelian group H has kernel containing [G,G]. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma69_3_commutator_subgroup :
  forall G mult e inv:set,
  group_structure G mult e inv ->
  normal_subgroup (commutator_subgroup G mult e inv) G mult e inv /\
  abelian_group
    (quotient_group_set G mult (commutator_subgroup G mult e inv))
    (quotient_group_mult G mult (commutator_subgroup G mult e inv))
    (quotient_group_id G mult e (commutator_subgroup G mult e inv))
    (quotient_group_inv G mult inv (commutator_subgroup G mult e inv)) /\
  (forall H multH eH invH h:set,
    abelian_group H multH eH invH ->
    group_homomorphism G mult H multH h ->
    commutator_subgroup G mult e inv c= kernel_of G eH h).
admit.
Qed.

(** from S69 Theorem 69.4 (line 3125 in algtop.tex): abelianization of free group **)
(** LATEX VERSION: If G is free with generators {a_alpha}, then G/[G,G] is a free **)
(** abelian group with basis {[a_alpha]}. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem thm69_4_abelianization_free_group :
  forall G mult e inv J gens:set,
  free_group_with_generators G mult e inv J gens ->
  let C := commutator_subgroup G mult e inv in
  free_abelian_group_with_basis
    (quotient_group_set G mult C)
    (quotient_group_mult G mult C)
    (quotient_group_id G mult e C)
    (quotient_group_inv G mult inv C)
    J
    (graph J (fun alpha:set => left_coset mult (apply_fun gens alpha) C)).
admit.
Qed.

(** from S69 Corollary 69.5 (line 3129 in algtop.tex): number of free generators is well-defined **)
(** LATEX VERSION: If G is a free group with n free generators, then any system of **)
(** free generators for G has n elements. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor69_5_free_generators_well_defined :
  forall G mult e inv n1 n2 gens1 gens2:set,
  free_group_with_generators G mult e inv n1 gens1 ->
  free_group_with_generators G mult e inv n2 gens2 ->
  finite n1 -> finite n2 ->
  equip n1 n2.
admit.
Qed.

(** from S69 Definition (line 3146-3151 in algtop.tex): presentation of a group **)
(** LATEX VERSION: A presentation of G consists of generators {a_alpha} and **)
(** relations {r_beta}, where G is isomorphic to F/{r_beta} where F is the free **)
(** group on {a_alpha} and {r_beta} generates the kernel of F -> G as a normal subgroup. **)
Definition group_presentation : set -> set -> set -> set -> set -> set -> set -> set -> set -> set -> set -> set -> prop :=
  fun G multG eG invG J gens K rels F multF eF invF =>
    free_group_with_generators F multF eF invF J
      (graph J (fun alpha:set => apply_fun gens alpha)) /\
    (forall beta:set, beta :e K -> apply_fun rels beta :e F) /\
    exists h:set,
      group_homomorphism F multF G multG h /\
      (forall alpha:set, alpha :e J -> apply_fun h (apply_fun gens alpha) :e G) /\
      homomorphism_image F h = G /\
      kernel_of F eG h =
        least_normal_subgroup F multF eF invF
          (Repl K (fun beta:set => apply_fun rels beta)).

(** from S69 Definition (line 3151 in algtop.tex): finitely presented group **)
(** LATEX VERSION: If both {a_alpha} and {r_beta} are finite, G is finitely presented. **)
Definition finitely_presented : set -> set -> set -> set -> prop :=
  fun G mult e inv =>
    exists J K gens rels F multF eF invF:set,
      finite J /\ finite K /\
      group_presentation G mult e inv J gens K rels F multF eF invF.

(** from S69 Exercises Exercise 3 / Theorem (line 3174 in algtop.tex): free product uniqueness **)
(** LATEX VERSION: Let G = G_1 free-product G_2 where G_1 and G_2 are cyclic of orders m and n **)
(** respectively. Then m and n are uniquely determined by G (up to reordering). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex69_3_free_product_uniqueness_cyclic :
  forall G multG eG invG:set,
  group_structure G multG eG invG ->
  forall m n:set, m :e omega -> n :e omega -> m <> 0 -> n <> 0 ->
  (** G is isomorphic to Z_m free-product Z_n **)
  (exists G1 mult1 e1 inv1 G2 mult2 e2 inv2 FP multFP eFP invFP ifam:set,
    group_structure G1 mult1 e1 inv1 /\ cyclic_group G1 mult1 e1 inv1 /\ equip G1 m /\
    group_structure G2 mult2 e2 inv2 /\ cyclic_group G2 mult2 e2 inv2 /\ equip G2 n /\
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
      (graph (UPair 0 1) (fun i:set => if i = 0 then mult1 else mult2))
      ifam /\
    exists phi:set, group_isomorphism G multG FP multFP phi) ->
  (** Similarly for m2 and n2 **)
  forall m' n':set, m' :e omega -> n' :e omega -> m' <> 0 -> n' <> 0 ->
  (exists G1' mult1' e1' inv1' G2' mult2' e2' inv2' FP' multFP' eFP' invFP' ifam':set,
    group_structure G1' mult1' e1' inv1' /\ cyclic_group G1' mult1' e1' inv1' /\ equip G1' m' /\
    group_structure G2' mult2' e2' inv2' /\ cyclic_group G2' mult2' e2' inv2' /\ equip G2' n' /\
    external_free_product FP' multFP' eFP' invFP' (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then G1' else G2'))
      (graph (UPair 0 1) (fun i:set => if i = 0 then mult1' else mult2'))
      ifam' /\
    exists psi:set, group_isomorphism G multG FP' multFP' psi) ->
  (** Then {m,n} = {m',n'} **)
  UPair m n = UPair m' n'.
admit.
Qed.

(** from S69 Exercise 1 (line 3159 in algtop.tex) **)
(** LATEX VERSION: If G = G1 free-product G2, then G/[G,G] is isomorphic to **)
(** (G1/[G1,G1]) direct-sum (G2/[G2,G2]). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex69_1_abelianization_free_product :
  forall G multG eG invG G1 G2:set,
  free_product_of_subgroups G multG eG invG 2
    (graph 2 (fun i => if i = 0 then G1 else G2))
    (graph 2 (fun _ => eG)) ->
  let CG := commutator_subgroup G multG eG invG in
  let C1 := commutator_subgroup G1 multG eG invG in
  let C2 := commutator_subgroup G2 multG eG invG in
  exists phi:set,
    group_isomorphism
      (quotient_group_set G multG CG)
      (quotient_group_mult G multG CG)
      (setprod (quotient_group_set G1 multG C1) (quotient_group_set G2 multG C2))
      (graph (setprod
        (setprod (quotient_group_set G1 multG C1) (quotient_group_set G2 multG C2))
        (setprod (quotient_group_set G1 multG C1) (quotient_group_set G2 multG C2)))
        (fun p:set =>
          (apply_fun (quotient_group_mult G1 multG C1) ((p 0) 0, (p 1) 0),
           apply_fun (quotient_group_mult G2 multG C2) ((p 0) 1, (p 1) 1))))
      phi.
admit.
Qed.

(** from S69 Exercise 2 (line 3159 in algtop.tex) **)
(** LATEX VERSION: Generalize the result of Exercise 1 to arbitrary free products. **)
(** That is, if G = free product of G_alpha, then G/[G,G] is isomorphic to **)
(** the direct sum of G_alpha/[G_alpha,G_alpha]. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex69_2_abelianization_general_free_product :
  forall G multG eG invG J Gfam multfam efam invfam ifam:set,
  (forall alpha:set, alpha :e J ->
    group_structure (apply_fun Gfam alpha) (apply_fun multfam alpha)
      (apply_fun efam alpha) (apply_fun invfam alpha)) ->
  external_free_product G multG eG invG J Gfam multfam ifam ->
  let CG := commutator_subgroup G multG eG invG in
  exists H multH eH invH:set,
    abelian_group H multH eH invH /\
    direct_sum_of_subgroups H multH eH invH J
      (graph J (fun alpha:set =>
        quotient_group_set (apply_fun Gfam alpha) (apply_fun multfam alpha)
          (commutator_subgroup (apply_fun Gfam alpha) (apply_fun multfam alpha)
            (apply_fun efam alpha) (apply_fun invfam alpha)))) /\
    exists phi:set,
      group_isomorphism
        (quotient_group_set G multG CG)
        (quotient_group_mult G multG CG)
        H multH phi.
admit.
Qed.

(** from S69 Exercise 4 (line 3181 in algtop.tex) **)
(** LATEX VERSION: If G = G1 direct-sum G2 where G1, G2 cyclic of orders m, n **)
(** with gcd(m,n)=1, then G is cyclic of order mn, so m and n are not unique. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex69_4_direct_sum_not_unique :
  exists G multG eG invG m n:set,
    abelian_group G multG eG invG /\
    m :e omega /\ n :e omega /\ m <> 0 /\ n <> 0 /\ m <> 1 /\ n <> 1 /\
    (forall d:set, d :e omega -> d <> 0 -> d <> 1 ->
      ~(exists q r:set, m = mul_nat d q /\ n = mul_nat d r)) /\
    cyclic_group G multG eG invG /\ equip G (mul_nat m n).
admit.
Qed.

(** ============================================================ **)
(** S70 The Seifert-van Kampen Theorem                           **)
(** (lines 3183-3494 in algtop.tex)                              **)
(** ============================================================ **)

(** from S70 Theorem 70.1 (line 3186 in algtop.tex): Seifert-van Kampen theorem **)
(** LATEX VERSION: Let X = U union V where U,V open, U,V,U cap V path connected. **)
(** Let x0 in U cap V. If phi1: pi1(U,x0) -> H and phi2: pi1(V,x0) -> H are **)
(** homomorphisms with phi1 o i1 = phi2 o i2 (where i1,i2 induced by inclusion of **)
(** U cap V), then there is a unique Phi: pi1(X,x0) -> H with Phi o j1 = phi1, **)
(** Phi o j2 = phi2. **)
(** EFFORT: 60 lines textbook, difficulty 9/10, USD 1200 **)
Theorem thm70_1_seifert_van_kampen :
  forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  forall H multH eH invH:set,
    group_structure H multH eH invH ->
    forall phi1 phi2:set,
      group_homomorphism
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0)
        H multH phi1 ->
      group_homomorphism
        (fundamental_group V (subspace_topology X Tx V) x0)
        (fundamental_group_mult V (subspace_topology X Tx V) x0)
        H multH phi2 ->
      (forall g:set, g :e fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0 ->
        apply_fun phi1
          (apply_fun (induced_homomorphism
            (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
            U (subspace_topology X Tx U) x0
            (graph (U :/\: V) (fun x:set => x))) g) =
        apply_fun phi2
          (apply_fun (induced_homomorphism
            (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
            V (subspace_topology X Tx V) x0
            (graph (U :/\: V) (fun x:set => x))) g)) ->
      exists Phi:set,
        group_homomorphism
          (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
          H multH Phi /\
        (forall g:set,
          g :e fundamental_group U (subspace_topology X Tx U) x0 ->
          apply_fun Phi
            (apply_fun (induced_homomorphism
              U (subspace_topology X Tx U) x0 X Tx x0
              (graph U (fun x:set => x))) g) =
            apply_fun phi1 g) /\
        (forall g:set,
          g :e fundamental_group V (subspace_topology X Tx V) x0 ->
          apply_fun Phi
            (apply_fun (induced_homomorphism
              V (subspace_topology X Tx V) x0 X Tx x0
              (graph V (fun x:set => x))) g) =
            apply_fun phi2 g) /\
        (forall Phi':set,
          group_homomorphism
            (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
            H multH Phi' ->
          (forall g:set,
            g :e fundamental_group U (subspace_topology X Tx U) x0 ->
            apply_fun Phi'
              (apply_fun (induced_homomorphism
                U (subspace_topology X Tx U) x0 X Tx x0
                (graph U (fun x:set => x))) g) =
              apply_fun phi1 g) ->
          (forall g:set,
            g :e fundamental_group V (subspace_topology X Tx V) x0 ->
            apply_fun Phi'
              (apply_fun (induced_homomorphism
                V (subspace_topology X Tx V) x0 X Tx x0
                (graph V (fun x:set => x))) g) =
              apply_fun phi2 g) ->
          forall g:set, g :e fundamental_group X Tx x0 ->
            apply_fun Phi' g = apply_fun Phi g).
admit.
Qed.

(** from S70 Theorem 70.2 (line 3389 in algtop.tex): classical Seifert-van Kampen **)
(** LATEX VERSION: j: pi1(U,x0) free-prod pi1(V,x0) -> pi1(X,x0) extending j1,j2 **)
(** is surjective, and its kernel is the least normal subgroup N of the free product **)
(** containing all elements i1(g)^{-1} i2(g) for g in pi1(U cap V, x0). **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 500 **)
Theorem thm70_2_classical_van_kampen :
  forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  forall FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then fundamental_group U (subspace_topology X Tx U) x0
        else fundamental_group V (subspace_topology X Tx V) x0))
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then fundamental_group_mult U (subspace_topology X Tx U) x0
        else fundamental_group_mult V (subspace_topology X Tx V) x0))
      ifam ->
    exists j:set,
      group_homomorphism FP multFP
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) j /\
      homomorphism_image FP j = fundamental_group X Tx x0 /\
      kernel_of FP (fundamental_group_id X Tx x0) j =
        least_normal_subgroup FP multFP eFP invFP
          (Repl (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
            (fun g:set =>
              apply_fun multFP
                (apply_fun invFP
                  (apply_fun (apply_fun ifam 0)
                    (apply_fun (induced_homomorphism
                      (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
                      U (subspace_topology X Tx U) x0
                      (graph (U :/\: V) (fun x:set => x))) g)),
                 apply_fun (apply_fun ifam 1)
                   (apply_fun (induced_homomorphism
                     (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
                     V (subspace_topology X Tx V) x0
                     (graph (U :/\: V) (fun x:set => x))) g)))).
admit.
Qed.

(** from S70 Corollary 70.3 (line 3439 in algtop.tex): simply connected intersection **)
(** LATEX VERSION: If U cap V is simply connected, then pi1(X,x0) is isomorphic to **)
(** pi1(U,x0) free-prod pi1(V,x0). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor70_3_simply_connected_intersection :
  forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  simply_connected (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  forall FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then fundamental_group U (subspace_topology X Tx U) x0
        else fundamental_group V (subspace_topology X Tx V) x0))
      (graph (UPair 0 1) (fun i:set =>
        if i = 0 then fundamental_group_mult U (subspace_topology X Tx U) x0
        else fundamental_group_mult V (subspace_topology X Tx V) x0))
      ifam ->
    exists phi:set,
      group_isomorphism FP multFP
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) phi.
admit.
Qed.

(** from S70 Corollary 70.4 (line 3445 in algtop.tex): one factor simply connected **)
(** LATEX VERSION: If V is simply connected, then pi1(X,x0) iso pi1(U,x0)/N **)
(** where N is the least normal subgroup containing image of i1. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor70_4_one_factor_simply_connected :
  forall X Tx U V x0:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  simply_connected V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  let N := least_normal_subgroup
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0)
    (homomorphism_image
      (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
      (induced_homomorphism
        (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
        U (subspace_topology X Tx U) x0
        (graph (U :/\: V) (fun x:set => x)))) in
  exists phi:set,
    group_isomorphism
      (quotient_group_set
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) N)
      (quotient_group_mult
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) N)
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      phi.
admit.
Qed.

(** from S70 Exercise 1(a) (line 3473 in algtop.tex) **)
(** LATEX VERSION: If i-star is trivial, then j1 and j2 induce an epimorphism **)
(** h: (pi1(U)/N1) free-product (pi1(V)/N2) -> pi1(X). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex70_1a_trivial_inclusion_epimorphism :
  forall X Tx U V x0:set,
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  (forall cls:set,
    cls :e fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0 ->
    apply_fun (induced_homomorphism
      (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
      X Tx x0 (graph (U :/\: V) (fun x => x))) cls =
    fundamental_group_id X Tx x0) ->
  let N1 := least_normal_subgroup
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0)
    (homomorphism_image
      (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
      (induced_homomorphism
        (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
        U (subspace_topology X Tx U) x0
        (graph (U :/\: V) (fun x => x)))) in
  let N2 := least_normal_subgroup
    (fundamental_group V (subspace_topology X Tx V) x0)
    (fundamental_group_mult V (subspace_topology X Tx V) x0)
    (fundamental_group_id V (subspace_topology X Tx V) x0)
    (fundamental_group_inv V (subspace_topology X Tx V) x0)
    (homomorphism_image
      (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
      (induced_homomorphism
        (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
        V (subspace_topology X Tx V) x0
        (graph (U :/\: V) (fun x => x)))) in
  exists FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set =>
        if i = 0
        then quotient_group_set
          (fundamental_group U (subspace_topology X Tx U) x0)
          (fundamental_group_mult U (subspace_topology X Tx U) x0) N1
        else quotient_group_set
          (fundamental_group V (subspace_topology X Tx V) x0)
          (fundamental_group_mult V (subspace_topology X Tx V) x0) N2))
      (graph (UPair 0 1) (fun i:set =>
        if i = 0
        then quotient_group_mult
          (fundamental_group U (subspace_topology X Tx U) x0)
          (fundamental_group_mult U (subspace_topology X Tx U) x0) N1
        else quotient_group_mult
          (fundamental_group V (subspace_topology X Tx V) x0)
          (fundamental_group_mult V (subspace_topology X Tx V) x0) N2))
      ifam /\
    exists h:set,
      group_homomorphism FP multFP
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) h /\
      surjective_map FP (fundamental_group X Tx x0) h.
admit.
Qed.

(** from S70 Exercise 1(b) (line 3481 in algtop.tex) **)
(** LATEX VERSION: Under the hypotheses of Ex 1(a) (i-star trivial), **)
(** h: (pi1(U)/N1) free-product (pi1(V)/N2) -> pi1(X) is an isomorphism. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 120 **)
Theorem ex70_1b_trivial_inclusion_isomorphism :
  forall X Tx U V x0:set,
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  (forall cls:set,
    cls :e fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0 ->
    apply_fun (induced_homomorphism
      (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
      X Tx x0 (graph (U :/\: V) (fun x => x))) cls =
    fundamental_group_id X Tx x0) ->
  let N1 := least_normal_subgroup
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0)
    (homomorphism_image
      (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
      (induced_homomorphism
        (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
        U (subspace_topology X Tx U) x0
        (graph (U :/\: V) (fun x => x)))) in
  let N2 := least_normal_subgroup
    (fundamental_group V (subspace_topology X Tx V) x0)
    (fundamental_group_mult V (subspace_topology X Tx V) x0)
    (fundamental_group_id V (subspace_topology X Tx V) x0)
    (fundamental_group_inv V (subspace_topology X Tx V) x0)
    (homomorphism_image
      (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
      (induced_homomorphism
        (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
        V (subspace_topology X Tx V) x0
        (graph (U :/\: V) (fun x => x)))) in
  exists FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set =>
        if i = 0
        then quotient_group_set
          (fundamental_group U (subspace_topology X Tx U) x0)
          (fundamental_group_mult U (subspace_topology X Tx U) x0) N1
        else quotient_group_set
          (fundamental_group V (subspace_topology X Tx V) x0)
          (fundamental_group_mult V (subspace_topology X Tx V) x0) N2))
      (graph (UPair 0 1) (fun i:set =>
        if i = 0
        then quotient_group_mult
          (fundamental_group U (subspace_topology X Tx U) x0)
          (fundamental_group_mult U (subspace_topology X Tx U) x0) N1
        else quotient_group_mult
          (fundamental_group V (subspace_topology X Tx V) x0)
          (fundamental_group_mult V (subspace_topology X Tx V) x0) N2))
      ifam /\
    exists h:set,
      group_isomorphism FP multFP
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) h.
admit.
Qed.

(** from S70 Exercise 2(a) (line 3483 in algtop.tex) **)
(** LATEX VERSION: If i2 is surjective, then j1 induces an epimorphism **)
(** h: pi1(U)/M -> pi1(X), where M is the least normal subgroup **)
(** of pi1(U) containing i1(ker i2). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex70_2a_surjective_i2_epimorphism :
  forall X Tx U V x0:set,
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  let i2 := induced_homomorphism
    (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
    V (subspace_topology X Tx V) x0
    (graph (U :/\: V) (fun x => x)) in
  surjective_map
    (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
    (fundamental_group V (subspace_topology X Tx V) x0) i2 ->
  let i1 := induced_homomorphism
    (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
    U (subspace_topology X Tx U) x0
    (graph (U :/\: V) (fun x => x)) in
  let M := least_normal_subgroup
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0)
    (homomorphism_image
      (kernel_of
        (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
        (fundamental_group_id V (subspace_topology X Tx V) x0) i2)
      i1) in
  exists h:set,
    surjective_map
      (quotient_group_set
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) M)
      (fundamental_group X Tx x0) h /\
    group_homomorphism
      (quotient_group_set
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) M)
      (quotient_group_mult
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) M)
      (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) h.
admit.
Qed.

(** from S70 Exercise 2(b) (line 3489 in algtop.tex) **)
(** LATEX VERSION: Under the hypotheses of Ex 2(a) (i2 surjective), **)
(** h: pi1(U)/M -> pi1(X) is an isomorphism. **)
(** EFFORT: 12 lines textbook, difficulty 6/10, USD 150 **)
Theorem ex70_2b_surjective_i2_isomorphism :
  forall X Tx U V x0:set,
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  let i2 := induced_homomorphism
    (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
    V (subspace_topology X Tx V) x0
    (graph (U :/\: V) (fun x => x)) in
  surjective_map
    (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
    (fundamental_group V (subspace_topology X Tx V) x0) i2 ->
  let i1 := induced_homomorphism
    (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0
    U (subspace_topology X Tx U) x0
    (graph (U :/\: V) (fun x => x)) in
  let M := least_normal_subgroup
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0)
    (homomorphism_image
      (kernel_of
        (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
        (fundamental_group_id V (subspace_topology X Tx V) x0) i2)
      i1) in
  exists h:set,
    group_isomorphism
      (quotient_group_set
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) M)
      (quotient_group_mult
        (fundamental_group U (subspace_topology X Tx U) x0)
        (fundamental_group_mult U (subspace_topology X Tx U) x0) M)
      (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0) h.
admit.
Qed.

(** from S70 Exercise 3(a) (line 3492 in algtop.tex) **)
(** LATEX VERSION: If G1 and G2 have finite presentations, so does G1 free-product G2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex70_3a_free_product_finitely_presented :
  forall G1 mult1 e1 inv1 G2 mult2 e2 inv2:set,
  finitely_presented G1 mult1 e1 inv1 ->
  finitely_presented G2 mult2 e2 inv2 ->
  forall FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
      (graph (UPair 0 1) (fun i:set => if i = 0 then mult1 else mult2))
      ifam ->
    finitely_presented FP multFP eFP invFP.
admit.
Qed.

(** from S70 Exercise 3(b) (line 3492 in algtop.tex) **)
(** LATEX VERSION: If pi1(U cap V) is finitely generated and pi1(U), pi1(V) **)
(** have finite presentations, then pi1(X) has a finite presentation. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex70_3b_van_kampen_finitely_presented :
  forall X Tx U V x0:set,
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  path_connected_space U (subspace_topology X Tx U) ->
  path_connected_space V (subspace_topology X Tx V) ->
  path_connected_space (U :/\: V) (subspace_topology X Tx (U :/\: V)) ->
  x0 :e U :/\: V ->
  (exists S:set, S c= fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0 /\
    finite S /\
    (forall g:set,
      g :e fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0 ->
      exists n xs:set, n :e omega /\
        function_on xs n (fundamental_group (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0) /\
        (forall i:set, i :e n ->
          apply_fun xs i :e S \/
          (exists s:set, s :e S /\
            apply_fun xs i = apply_fun
              (fundamental_group_inv (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0) s)) /\
        g = nat_primrec
          (fundamental_group_id (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
          (fun i r => apply_fun
            (fundamental_group_mult (U :/\: V) (subspace_topology X Tx (U :/\: V)) x0)
            (r, apply_fun xs i)) n)) ->
  finitely_presented
    (fundamental_group U (subspace_topology X Tx U) x0)
    (fundamental_group_mult U (subspace_topology X Tx U) x0)
    (fundamental_group_id U (subspace_topology X Tx U) x0)
    (fundamental_group_inv U (subspace_topology X Tx U) x0) ->
  finitely_presented
    (fundamental_group V (subspace_topology X Tx V) x0)
    (fundamental_group_mult V (subspace_topology X Tx V) x0)
    (fundamental_group_id V (subspace_topology X Tx V) x0)
    (fundamental_group_inv V (subspace_topology X Tx V) x0) ->
  finitely_presented
    (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
    (fundamental_group_id X Tx x0) (fundamental_group_inv X Tx x0).
admit.
Qed.

(** ============================================================ **)
(** S71 The Fundamental Group of a Wedge of Circles              **)
(** (lines 3495-3607 in algtop.tex)                              **)
(** ============================================================ **)

(** from S71 Definition (line 3498 in algtop.tex): wedge of circles (finite) **)
(** LATEX VERSION: X is Hausdorff, union of S_1,...,S_n homeomorphic to S^1, **)
(** with S_i cap S_j = {p} for i <> j. **)
Definition wedge_of_circles_finite : set -> set -> set -> set -> set -> prop :=
  fun X Tx n Sfam p =>
    Hausdorff_space X Tx /\
    n :e omega /\ n <> 0 /\
    p :e X /\
    (forall i:set, i :e n -> apply_fun Sfam i c= X) /\
    X = Union (Repl n (fun i:set => apply_fun Sfam i)) /\
    (forall i:set, i :e n ->
      exists h:set, continuous_map S1 S1_topology (apply_fun Sfam i)
        (subspace_topology X Tx (apply_fun Sfam i)) h /\
        bijection S1 (apply_fun Sfam i) h) /\
    (forall i j:set, i :e n -> j :e n -> i <> j ->
      apply_fun Sfam i :/\: apply_fun Sfam j = Sing p).

(** from S71 Theorem 71.1 (line 3502 in algtop.tex): pi1 of finite wedge **)
(** LATEX VERSION: If X is wedge of S_1,...,S_n, then pi1(X,p) is a free group. **)
(** If f_i represents a generator of pi1(S_i,p), then f_1,...,f_n represent **)
(** a system of free generators for pi1(X,p). **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm71_1_pi1_wedge_finite :
  forall X Tx n Sfam p:set,
  wedge_of_circles_finite X Tx n Sfam p ->
  exists gens:set,
    function_on gens n (fundamental_group X Tx p) /\
    free_group_with_generators
      (fundamental_group X Tx p)
      (fundamental_group_mult X Tx p)
      (fundamental_group_id X Tx p)
      (fundamental_group_inv X Tx p)
      n gens.
admit.
Qed.

(** from S71 Definition (line 3529 in algtop.tex): coherent topology with subspaces **)
(** LATEX VERSION: X = union X_alpha, topology of X is coherent with subspaces X_alpha **)
(** if C is closed in X iff C cap X_alpha is closed in X_alpha for each alpha. **)
Definition coherent_with_subspaces : set -> set -> set -> set -> prop :=
  fun X Tx J Sfam =>
    (forall alpha:set, alpha :e J -> apply_fun Sfam alpha c= X) /\
    X = Union (Repl J (fun alpha:set => apply_fun Sfam alpha)) /\
    (forall C:set, C c= X ->
      (closed_in X Tx C <->
        (forall alpha:set, alpha :e J ->
          closed_in (apply_fun Sfam alpha) (subspace_topology X Tx (apply_fun Sfam alpha))
            (C :/\: apply_fun Sfam alpha)))).

(** from S71 Definition (line 3533 in algtop.tex): wedge of circles (general) **)
(** LATEX VERSION: X is union of S_alpha each homeomorphic to S^1, S_alpha cap S_beta = {p} **)
(** for alpha <> beta, and topology of X is coherent with subspaces S_alpha. **)
Definition wedge_of_circles : set -> set -> set -> set -> set -> prop :=
  fun X Tx J Sfam p =>
    p :e X /\
    (forall alpha:set, alpha :e J -> apply_fun Sfam alpha c= X) /\
    X = Union (Repl J (fun alpha:set => apply_fun Sfam alpha)) /\
    (forall alpha:set, alpha :e J ->
      exists h:set, continuous_map S1 S1_topology (apply_fun Sfam alpha)
        (subspace_topology X Tx (apply_fun Sfam alpha)) h /\
        bijection S1 (apply_fun Sfam alpha) h) /\
    (forall alpha beta:set, alpha :e J -> beta :e J -> alpha <> beta ->
      apply_fun Sfam alpha :/\: apply_fun Sfam beta = Sing p) /\
    coherent_with_subspaces X Tx J Sfam.

(** from S71 Lemma 71.2 (line 3537 in algtop.tex): wedge of circles is normal **)
(** LATEX VERSION: Let X be wedge of circles S_alpha. Then X is normal. **)
(** Any compact subspace of X is contained in finitely many S_alpha. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma71_2_wedge_normal :
  forall X Tx J Sfam p:set,
  wedge_of_circles X Tx J Sfam p ->
  normal_space X Tx /\
  (forall C:set, C c= X ->
    compact_space C (subspace_topology X Tx C) ->
    exists F:set, F c= J /\ finite F /\
      C c= Union (Repl F (fun alpha:set => apply_fun Sfam alpha))).
admit.
Qed.

(** from S71 Theorem 71.3 (line 3544 in algtop.tex): pi1 of general wedge **)
(** LATEX VERSION: pi1(X,p) is a free group with system of free generators **)
(** {f_alpha}, where f_alpha represents a generator of pi1(S_alpha, p). **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm71_3_pi1_wedge_general :
  forall X Tx J Sfam p:set,
  wedge_of_circles X Tx J Sfam p ->
  exists gens:set,
    function_on gens J (fundamental_group X Tx p) /\
    free_group_with_generators
      (fundamental_group X Tx p)
      (fundamental_group_mult X Tx p)
      (fundamental_group_id X Tx p)
      (fundamental_group_inv X Tx p)
      J gens.
admit.
Qed.

(** from S71 Lemma 71.4 (line 3579 in algtop.tex): existence of wedge of circles **)
(** LATEX VERSION: Given an index set J, there exists a space X that is a wedge of **)
(** circles S_alpha for alpha in J. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma71_4_existence_wedge :
  forall J:set,
  exists X Tx Sfam p:set,
    wedge_of_circles X Tx J Sfam p.
admit.
Qed.

(** from S71 Exercise 1(a) (line 3597 in algtop.tex) **)
(** LATEX VERSION: Let X be the union of subspaces S1,...,Sn, each homeomorphic to S^1, **)
(** with Si cap Sj = {p} for i <> j. X is Hausdorff iff each Si is closed in X. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex71_1a_circle_union_hausdorff_iff_closed :
  forall X Tx n Sfam p:set,
  topology_on X Tx ->
  n :e omega -> n <> 0 -> p :e X ->
  (forall i:set, i :e n -> apply_fun Sfam i c= X /\
    exists h:set, continuous_map S1 S1_topology (apply_fun Sfam i)
      (subspace_topology X Tx (apply_fun Sfam i)) h /\
      bijection S1 (apply_fun Sfam i) h) ->
  X = Union (Repl n (fun i:set => apply_fun Sfam i)) ->
  (forall i j:set, i :e n -> j :e n -> i <> j ->
    apply_fun Sfam i :/\: apply_fun Sfam j = Sing p) ->
  (Hausdorff_space X Tx <->
    (forall i:set, i :e n -> X :\: (apply_fun Sfam i) :e Tx)).
admit.
Qed.

(** from S71 Exercise 1(b) (line 3599 in algtop.tex) **)
(** LATEX VERSION: X (union of circles meeting at p) is Hausdorff iff **)
(** the topology of X is coherent with the subspaces Si. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex71_1b_circle_union_hausdorff_iff_coherent :
  forall X Tx n Sfam p:set,
  topology_on X Tx ->
  n :e omega -> n <> 0 -> p :e X ->
  (forall i:set, i :e n -> apply_fun Sfam i c= X /\
    exists h:set, continuous_map S1 S1_topology (apply_fun Sfam i)
      (subspace_topology X Tx (apply_fun Sfam i)) h /\
      bijection S1 (apply_fun Sfam i) h) ->
  X = Union (Repl n (fun i:set => apply_fun Sfam i)) ->
  (forall i j:set, i :e n -> j :e n -> i <> j ->
    apply_fun Sfam i :/\: apply_fun Sfam j = Sing p) ->
  (Hausdorff_space X Tx <->
    Tx = coherent_topology
      (Repl n (fun i:set => apply_fun Sfam i))
      (graph (Repl n (fun i:set => apply_fun Sfam i))
        (fun S:set => subspace_topology X Tx S))).
admit.
Qed.

(** from S71 Exercise 1(c) (line 3600 in algtop.tex) **)
(** LATEX VERSION: Give an example to show that X (union of circles meeting at p) **)
(** need not be Hausdorff. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 20 **)
Theorem ex71_1c_circle_union_not_hausdorff :
  exists X Tx n Sfam p:set,
    topology_on X Tx /\
    n :e omega /\ n <> 0 /\ p :e X /\
    (forall i:set, i :e n -> apply_fun Sfam i c= X /\
      exists h:set, continuous_map S1 S1_topology (apply_fun Sfam i)
        (subspace_topology X Tx (apply_fun Sfam i)) h /\
        bijection S1 (apply_fun Sfam i) h) /\
    X = Union (Repl n (fun i:set => apply_fun Sfam i)) /\
    (forall i j:set, i :e n -> j :e n -> i <> j ->
      apply_fun Sfam i :/\: apply_fun Sfam j = Sing p) /\
    ~Hausdorff_space X Tx.
admit.
Qed.

(** from S71 Exercise 2 (line 3601 in algtop.tex) **)
(** LATEX VERSION: If X is the wedge of closed subspaces X1,...,Xn with p a deformation **)
(** retract of open W_i in X_i, then pi1(X,p) is the free product of pi1(X_i,p). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex71_2_wedge_general :
  forall X Tx n Xfam p:set,
  Hausdorff_space X Tx ->
  n :e omega -> n <> 0 -> p :e X ->
  (forall i:set, i :e n -> apply_fun Xfam i c= X /\
    X :\: (apply_fun Xfam i) :e Tx) ->
  X = Union (Repl n (fun i:set => apply_fun Xfam i)) ->
  (forall i j:set, i :e n -> j :e n -> i <> j ->
    apply_fun Xfam i :/\: apply_fun Xfam j = Sing p) ->
  (forall i:set, i :e n ->
    exists Wi:set, Wi c= apply_fun Xfam i /\
      Wi :e subspace_topology X Tx (apply_fun Xfam i) /\
      deformation_retract (apply_fun Xfam i) (subspace_topology X Tx (apply_fun Xfam i))
        (Sing p)) ->
  exists FP multFP eFP invFP ifam:set,
    external_free_product FP multFP eFP invFP n
      (graph n (fun i:set =>
        fundamental_group (apply_fun Xfam i)
          (subspace_topology X Tx (apply_fun Xfam i)) p))
      (graph n (fun i:set =>
        fundamental_group_mult (apply_fun Xfam i)
          (subspace_topology X Tx (apply_fun Xfam i)) p))
      ifam /\
    exists phi:set,
      group_isomorphism FP multFP
        (fundamental_group X Tx p) (fundamental_group_mult X Tx p) phi.
admit.
Qed.

(** from S71 Exercise 3 (line 3602 in algtop.tex) **)
(** LATEX VERSION: pi1(S^1 wedge S^2, p) is isomorphic to Z (the integers). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex71_3_S1_wedge_S2 :
  forall X Tx p:set,
  Hausdorff_space X Tx -> p :e X ->
  (exists A B:set,
    A c= X /\ B c= X /\
    (exists h:set, homeomorphism A (subspace_topology X Tx A) S1 S1_topology h) /\
    (exists h:set, homeomorphism B (subspace_topology X Tx B) (Sn 2) (Sn_topology 2) h) /\
    A :/\: B = Sing p /\ X = A :\/: B) ->
  exists phi:set,
    group_isomorphism
      (fundamental_group X Tx p) (fundamental_group_mult X Tx p)
      (fundamental_group S1 S1_topology S1_basepoint)
      (fundamental_group_mult S1 S1_topology S1_basepoint) phi.
admit.
Qed.

(** from S71 Exercise 4 (line 3604 in algtop.tex) **)
(** LATEX VERSION: If X is an infinite wedge of circles, then X does not **)
(** satisfy the first countability axiom. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex71_4_infinite_wedge_not_first_countable :
  forall X Tx J Sfam p:set,
  wedge_of_circles X Tx J Sfam p ->
  ~finite J ->
  ~first_countable_space X Tx.
admit.
Qed.

(** from S71 Exercise 5(a) (line 3605 in algtop.tex) **)
(** LATEX VERSION: Let Sn be the circle of radius n in R^2 centered at (n,0). **)
(** Let Y = union of Sn, p = common point. Y is not homeomorphic to a **)
(** countably infinite wedge X of circles. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex71_5a_tangent_circles_not_wedge :
  forall Y Ty p:set,
  Y c= EuclidPlane ->
  topology_on Y Ty ->
  p :e Y ->
  (forall n:set, n :e omega -> n <> 0 ->
    exists Cn:set, Cn c= Y /\
      (exists h:set, homeomorphism S1 S1_topology Cn (subspace_topology Y Ty Cn) h) /\
      p :e Cn) ->
  Y = Union (Repl (omega :\: Sing 0) (fun n:set =>
    {z :e EuclidPlane | distance_R2 z (n, 0) = n})) ->
  forall X Tx J Sfam q:set,
  wedge_of_circles X Tx J Sfam q ->
  equip J omega ->
  ~(exists h:set, homeomorphism Y Ty X Tx h).
admit.
Qed.

(** from S71 Exercise 5(b) (line 3607 in algtop.tex) **)
(** LATEX VERSION: Despite not being a wedge, pi1(Y,p) is a free group **)
(** with {[fn]} as a system of free generators, where fn is a loop **)
(** representing a generator of pi1(Sn,p). **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex71_5b_tangent_circles_free_pi1 :
  forall Y Ty p:set,
  Y c= EuclidPlane ->
  topology_on Y Ty ->
  p = (0, 0) -> p :e Y ->
  Y = Union (Repl (omega :\: Sing 0) (fun n:set =>
    {z :e EuclidPlane | distance_R2 z (n, 0) = n})) ->
  exists gens:set,
    free_group_with_generators
      (fundamental_group Y Ty p) (fundamental_group_mult Y Ty p)
      (fundamental_group_id Y Ty p) (fundamental_group_inv Y Ty p)
      (omega :\: Sing 0) gens.
admit.
Qed.

(** ============================================================ **)
(** S72 Adjoining a Two-cell                                     **)
(** (lines 3609-3697 in algtop.tex)                              **)
(** ============================================================ **)

(** from S72 Theorem 72.1 (line 3616 in algtop.tex): adjoining a 2-cell **)
(** LATEX VERSION: Let X be Hausdorff, A closed path-connected subspace. **)
(** Suppose h: B^2 -> X maps Int B^2 bijectively onto X-A and S^1 into A. **)
(** from S72 Theorem 72.1 (line 3616 in algtop.tex): adjoining a two-cell **)
(** Let p in S^1, a = h(p), k = h|S^1. Then i_star: pi1(A,a) -> pi1(X,a) is **)
(** surjective with kernel = least normal subgroup containing image of k_star. **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 500 **)
Theorem thm72_1_adjoining_two_cell :
  forall X Tx A h p:set,
  Hausdorff_space X Tx ->
  closed_in X Tx A ->
  path_connected_space A (subspace_topology X Tx A) ->
  continuous_map B2 B2_topology X Tx h ->
  (forall x:set, x :e B2 -> ~(x :e S1) -> ~(apply_fun h x :e A)) ->
  (forall x y:set, x :e B2 -> y :e B2 -> ~(x :e S1) -> ~(y :e S1) ->
    apply_fun h x = apply_fun h y -> x = y) ->
  (forall y:set, y :e X -> ~(y :e A) ->
    exists x:set, x :e B2 /\ ~(x :e S1) /\ apply_fun h x = y) ->
  (forall x:set, x :e S1 -> apply_fun h x :e A) ->
  p :e S1 ->
  let a := apply_fun h p in
  let k := graph S1 (fun x:set => apply_fun h x) in
  homomorphism_image
    (fundamental_group A (subspace_topology X Tx A) a)
    (induced_homomorphism
      A (subspace_topology X Tx A) a X Tx a
      (graph A (fun x:set => x))) =
    fundamental_group X Tx a /\
  kernel_of
    (fundamental_group A (subspace_topology X Tx A) a)
    (fundamental_group_id X Tx a)
    (induced_homomorphism
      A (subspace_topology X Tx A) a X Tx a
      (graph A (fun x:set => x))) =
    least_normal_subgroup
      (fundamental_group A (subspace_topology X Tx A) a)
      (fundamental_group_mult A (subspace_topology X Tx A) a)
      (fundamental_group_id A (subspace_topology X Tx A) a)
      (fundamental_group_inv A (subspace_topology X Tx A) a)
      (homomorphism_image
        (fundamental_group S1 S1_topology p)
        (induced_homomorphism S1 S1_topology p
          A (subspace_topology X Tx A) a k)).
admit.
Qed.

(** from S72 Exercises Exercise 2 / Theorem (line 3797 in algtop.tex): finitely presented groups **)
(** LATEX VERSION: If G is a finitely presented group, then there is a compact **)
(** Hausdorff space X whose fundamental group is isomorphic to G. **)
(** EFFORT: 15 lines textbook, difficulty 7/10, USD 300 **)
Theorem ex72_2_finitely_presented_realized :
  forall G multG eG invG:set,
  finitely_presented G multG eG invG ->
  exists X Tx x0:set,
    compact_space X Tx /\ Hausdorff_space X Tx /\ x0 :e X /\
    exists phi:set,
      group_isomorphism
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
        G multG phi.
admit.
Qed.

(** from S72 Exercise 1 (line 3694 in algtop.tex) **)
(** LATEX VERSION: Let h: B^n -> X map S^{n-1} into A and Int B^n bijectively **)
(** onto X-A. If n > 2, what about i-star: pi1(A,a) -> pi1(X,a)? **)
(** Answer: it is an isomorphism (adding an n-cell with n>2 does not change pi1). **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex72_1_high_dimensional_cell :
  forall X Tx A h n:set,
  Hausdorff_space X Tx ->
  closed_in X Tx A ->
  path_connected_space A (subspace_topology X Tx A) ->
  n :e omega -> 2 :e n ->
  continuous_map (Bn_closed n) (Bn_closed_topology n) X Tx h ->
  (forall x:set, x :e Sn (nat_primrec 0 (fun i _ => i) n) -> apply_fun h x :e A) ->
  (forall x y:set, x :e Bn_closed n -> y :e Bn_closed n ->
    ~(x :e Sn (nat_primrec 0 (fun i _ => i) n)) -> ~(y :e Sn (nat_primrec 0 (fun i _ => i) n)) ->
    apply_fun h x = apply_fun h y -> x = y) ->
  forall a:set, a :e A ->
    exists phi:set,
      group_isomorphism
        (fundamental_group A (subspace_topology X Tx A) a)
        (fundamental_group_mult A (subspace_topology X Tx A) a)
        (fundamental_group X Tx a)
        (fundamental_group_mult X Tx a) phi.
admit.
Qed.

(** from S72 Exercise 3 (line 3696 in algtop.tex) **)
(** LATEX VERSION: If G has a normal, path-connected space with pi1 isomorphic to G, **)
(** and x is in G, then G/N (where N is least normal subgroup containing x) **)
(** also has such a space. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex72_3_quotient_by_element :
  forall G multG eG invG:set,
  group_structure G multG eG invG ->
  (exists X Tx x0:set, normal_space X Tx /\ path_connected_space X Tx /\ x0 :e X /\
    exists phi:set, group_isomorphism
      (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
      G multG phi) ->
  forall x:set, x :e G ->
    let N := least_normal_subgroup G multG eG invG (Sing x) in
    exists Y Ty y0:set, normal_space Y Ty /\ path_connected_space Y Ty /\ y0 :e Y /\
      exists psi:set, group_isomorphism
        (fundamental_group Y Ty y0) (fundamental_group_mult Y Ty y0)
        (quotient_group_set G multG N) (quotient_group_mult G multG N) psi.
admit.
Qed.

(** ============================================================ **)
(** S73 The Fundamental Groups of the Torus and the Dunce Cap    **)
(** (lines 3699-3806 in algtop.tex)                              **)
(** ============================================================ **)

(** from S73 Theorem 73.1 (line 3702 in algtop.tex): torus presentation **)
(** LATEX VERSION: The fundamental group of the torus has a presentation **)
(** with two generators alpha, beta and a single relation alpha beta alpha^{-1} beta^{-1}. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm73_1_torus_presentation :
  forall x0:set,
  x0 :e torus ->
  exists F multF eF invF alpha beta:set,
    free_group_with_generators F multF eF invF (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then alpha else beta)) /\
    let rel := commutator multF invF alpha beta in
    let N := least_normal_subgroup F multF eF invF (Sing rel) in
    exists phi:set,
      group_isomorphism
        (quotient_group_set F multF N)
        (quotient_group_mult F multF N)
        (fundamental_group torus torus_topology x0)
        (fundamental_group_mult torus torus_topology x0)
        phi.
admit.
Qed.

(** from S73 Corollary 73.2 (line 3724 in algtop.tex): torus pi1 is Z x Z **)
(** LATEX VERSION: The fundamental group of the torus is a free abelian group of rank 2. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem cor73_2_torus_free_abelian_rank_2 :
  forall x0:set,
  x0 :e torus ->
  exists basis:set,
    free_abelian_group_with_basis
      (fundamental_group torus torus_topology x0)
      (fundamental_group_mult torus torus_topology x0)
      (fundamental_group_id torus torus_topology x0)
      (fundamental_group_inv torus torus_topology x0)
      (UPair 0 1)
      basis.
admit.
Qed.

(** Infrastructure: real number division a/b for b nonzero **)
Definition real_div : set -> set -> set :=
  fun a b => Eps_i (fun r:set => r :e R /\ mul_SNo b r = a).

(** from S73 Definition (line 3730 in algtop.tex): n-fold dunce cap **)
(** LATEX VERSION: Form quotient space from B^2 by identifying each x in S^1 with **)
(** r(x), r^2(x),...,r^{n-1}(x) where r is rotation by 2pi/n. **)
Definition dunce_cap : set -> set :=
  fun n =>
    Eps_i (fun X:set => exists Tx pi:set,
      topology_on X Tx /\
      Hausdorff_space X Tx /\
      compact_space X Tx /\
      continuous_map B2 B2_topology X Tx pi /\
      (forall x y:set, x :e B2 -> y :e B2 ->
        apply_fun pi x = apply_fun pi y <->
        (x = y \/
         (x :e S1 /\ y :e S1 /\
          exists k:set, k :e omega /\ k :e n /\
            y = (add_SNo (mul_SNo (x 0) (apply_fun cos_real (mul_SNo (real_div two_pi n) k)))
                         (minus_SNo (mul_SNo (x 1) (apply_fun sin_real (mul_SNo (real_div two_pi n) k)))),
                 add_SNo (mul_SNo (x 0) (apply_fun sin_real (mul_SNo (real_div two_pi n) k)))
                         (mul_SNo (x 1) (apply_fun cos_real (mul_SNo (real_div two_pi n) k)))))))).

Definition dunce_cap_topology : set -> set :=
  fun n =>
    Eps_i (fun Tx:set =>
      topology_on (dunce_cap n) Tx /\
      Hausdorff_space (dunce_cap n) Tx /\
      compact_space (dunce_cap n) Tx).

(** from S73 Lemma 73.3 (line 3736 in algtop.tex): closed quotient map preserves normality **)
(** LATEX VERSION: If pi: E -> X is a closed quotient map and E is normal, then X is normal. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma73_3_closed_quotient_normal :
  forall E Te X Tx pi:set,
  topology_on E Te -> topology_on X Tx ->
  normal_space E Te ->
  continuous_map E Te X Tx pi ->
  (forall C:set, closed_in E Te C -> closed_in X Tx (image_of pi C)) ->
  (forall V:set, V :e Tx -> {x :e E | apply_fun pi x :e V} :e Te) ->
  normal_space X Tx.
admit.
Qed.

(** from S73 Theorem 73.4 (line 3761 in algtop.tex): pi1 of n-fold dunce cap **)
(** LATEX VERSION: The fundamental group of the n-fold dunce cap is a cyclic group **)
(** of order n. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm73_4_dunce_cap_pi1 :
  forall n:set,
  n :e omega -> n <> 0 -> ordsucc 0 :e n ->
  forall x0:set,
    x0 :e dunce_cap n ->
    cyclic_group
      (fundamental_group (dunce_cap n) (dunce_cap_topology n) x0)
      (fundamental_group_mult (dunce_cap n) (dunce_cap_topology n) x0)
      (fundamental_group_id (dunce_cap n) (dunce_cap_topology n) x0)
      (fundamental_group_inv (dunce_cap n) (dunce_cap_topology n) x0) /\
    equip (fundamental_group (dunce_cap n) (dunce_cap_topology n) x0) n.
admit.
Qed.

(** from S73 Exercise 1(a) (line 3789 in algtop.tex) **)
(** LATEX VERSION: Find a space with pi1 isomorphic to Z/n x Z/m. **)
(** (Product of two dunce caps of orders n and m.) **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex73_1a_cyclic_product_space :
  forall n m:set, n :e omega -> n <> 0 -> m :e omega -> m <> 0 ->
  exists X Tx x0:set,
    compact_space X Tx /\ Hausdorff_space X Tx /\ x0 :e X /\
    abelian_group
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (fundamental_group_inv X Tx x0) /\
    cyclic_group
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (fundamental_group_inv X Tx x0) /\
    equip (fundamental_group X Tx x0) (mul_nat n m).
admit.
Qed.

(** from S73 Exercise 1(c) (line 3792 in algtop.tex) **)
(** LATEX VERSION: Find a space with pi1 isomorphic to Z/n free-product Z/m. **)
(** (Wedge of two dunce caps of orders n and m.) **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex73_1c_cyclic_free_product_space :
  forall n m:set, n :e omega -> n <> 0 -> m :e omega -> m <> 0 ->
  exists X Tx x0:set,
    compact_space X Tx /\ Hausdorff_space X Tx /\ x0 :e X /\
    exists G1 mult1 e1 inv1 G2 mult2 e2 inv2:set,
      cyclic_group G1 mult1 e1 inv1 /\ equip G1 n /\
      cyclic_group G2 mult2 e2 inv2 /\ equip G2 m /\
      exists FP multFP eFP invFP ifam:set,
        external_free_product FP multFP eFP invFP (UPair 0 1)
          (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
          (graph (UPair 0 1) (fun i:set => if i = 0 then mult1 else mult2))
          ifam /\
        exists phi:set,
          group_isomorphism
            (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
            FP multFP phi.
admit.
Qed.

(** from S73 Exercise 4 (line 3805 in algtop.tex) **)
(** LATEX VERSION: The space constructed in Exercise 2 is metrizable. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex73_4_two_complex_metrizable :
  forall G multG eG invG:set,
  finitely_presented G multG eG invG ->
  exists X Tx x0 d:set,
    metric_on X d /\ Tx = metric_topology X d /\
    compact_space X Tx /\ x0 :e X /\
    exists phi:set,
      group_isomorphism
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
        G multG phi.
admit.
Qed.

(** ============================================================ **)
(** CHAPTER 12: CLASSIFICATION OF SURFACES                       **)
(** ============================================================ **)

(** ============================================================ **)
(** S74 Fundamental Groups of Surfaces                           **)
(** (lines 3811-4035 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: point on S^1 at real parameter s **)
(** S1_param s = (cos(2 pi s), sin(2 pi s)) **)
Definition S1_param : set -> set :=
  fun s => apply_fun covering_map_R_S1 s.

(** from S74 Definition (line 3814 in algtop.tex): polygonal region **)
(** LATEX VERSION: A polygonal region P is the intersection of **)
(** half-planes determined by n >= 3 points on a circle, forming a **)
(** compact convex polygon with n vertices and n edges. **)
Definition polygonal_region : set -> set -> set -> prop :=
  fun P n vertices =>
    n :e omega /\ ordsucc (ordsucc (ordsucc 0)) c= n /\
    P c= setprod R R /\
    compact_space P (subspace_topology (setprod R R) R2_topology P) /\
    connected_space P (subspace_topology (setprod R R) R2_topology P) /\
    function_on vertices (ordsucc n) (setprod R R) /\
    apply_fun vertices n = apply_fun vertices 0 /\
    (forall i:set, i :e n -> apply_fun vertices i :e P) /\
    (forall i j:set, i :e n -> j :e n ->
      apply_fun vertices i = apply_fun vertices j -> i = j) /\
    (** P is homeomorphic to the closed unit disk B^2 **)
    (exists h:set,
      homeomorphism P (subspace_topology (setprod R R) R2_topology P)
        B2 B2_topology h) /\
    (** P is convex **)
    (forall x y:set, x :e P -> y :e P ->
      forall t:set, t :e unit_interval ->
        (add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (x 0)) (mul_SNo t (y 0)),
         add_SNo (mul_SNo (add_SNo 1 (minus_SNo t)) (x 1)) (mul_SNo t (y 1))) :e P).

(** from S74 Definition (line 3860 in algtop.tex): labelling scheme **)
(** LATEX VERSION: A labelling scheme for an n-sided polygon is a **)
(** sequence w = a_{i1}^{e1} ... a_{in}^{en} of labels with exponents +/-1. **)
(** Encoded as a function w : n -> (label, sign) where sign in {0, 1}. **)
(** sign = 0 means exponent +1, sign = 1 means exponent -1. **)
Definition labelling_scheme : set -> set -> prop :=
  fun n w =>
    n :e omega /\ ordsucc (ordsucc (ordsucc 0)) c= n /\
    (forall i:set, i :e n ->
      (apply_fun w i) :e setprod omega (ordsucc (ordsucc 0)) /\
      (apply_fun w i) 0 :e omega /\
      ((apply_fun w i) 1 = 0 \/ (apply_fun w i) 1 = ordsucc 0)).

(** Infrastructure: oriented point on S^1 for arc k of n arcs, at parameter t **)
(** With sign = 0 (positive): point at angle 2 pi (k+t)/n **)
(** With sign = 1 (negative): point at angle 2 pi (k+1-t)/n **)
Definition S1_oriented_arc_point : set -> set -> set -> set -> set :=
  fun n k sign t =>
    S1_param (real_div
      (add_SNo k (Eps_i (fun s:set =>
        (sign = 0 /\ s = t) \/ (sign = ordsucc 0 /\ s = add_SNo 1 (minus_SNo t)))))
      n).

(** Infrastructure: pasting equivalence relation on B^2 from labelling scheme **)
(** Interior points are equivalent only to themselves. **)
(** Boundary points on arcs with the same label are identified **)
(** via the positive linear map respecting orientations. **)
Definition polygon_pasting_equiv : set -> set -> set -> set -> prop :=
  fun n w x y =>
    x :e B2 /\ y :e B2 /\
    (x = y \/
     (x :e S1 /\ y :e S1 /\
      exists i j:set, i :e n /\ j :e n /\ i <> j /\
        (apply_fun w i) 0 = (apply_fun w j) 0 /\
        exists t:set, t :e unit_interval /\
          x = S1_oriented_arc_point n i ((apply_fun w i) 1) t /\
          y = S1_oriented_arc_point n j ((apply_fun w j) 1) t)).

(** Infrastructure: the quotient space obtained by pasting edges of B^2 **)
(** according to labelling scheme w with n edges **)
Definition polygon_pasting_space : set -> set -> set :=
  fun n w =>
    {cls :e Power B2 |
      exists x:set, x :e B2 /\
        cls = {y :e B2 | polygon_pasting_equiv n w x y}}.

(** Infrastructure: the quotient map for polygon pasting **)
Definition polygon_pasting_map : set -> set -> set :=
  fun n w =>
    graph B2 (fun x:set => {y :e B2 | polygon_pasting_equiv n w x y}).

(** Infrastructure: the quotient topology for polygon pasting **)
Definition polygon_pasting_topology : set -> set -> set :=
  fun n w =>
    quotient_topology B2 B2_topology (polygon_pasting_space n w) (polygon_pasting_map n w).

(** from S74 Theorem 74.1 (line 3916 in algtop.tex): compact Hausdorff **)
(** LATEX VERSION: Let X be the space obtained from a finite collection **)
(** of polygonal regions by pasting edges according to some labelling **)
(** scheme. Then X is a compact Hausdorff space. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm74_1_polygon_pasting_compact_hausdorff :
  forall n w:set,
  labelling_scheme n w ->
  compact_space (polygon_pasting_space n w) (polygon_pasting_topology n w) /\
  Hausdorff_space (polygon_pasting_space n w) (polygon_pasting_topology n w).
admit.
Qed.

(** from S74 Theorem 74.2 (line 3927 in algtop.tex): fundamental group from scheme **)
(** LATEX VERSION: If pi maps all vertices of P to a single point x0 of X, **)
(** and a1,...,ak are the distinct labels, then pi1(X,x0) is isomorphic to **)
(** from S74 Theorem 74.2 (line 3927 in algtop.tex): pi1 from labelling scheme **)
(** the quotient of the free group on k generators alpha1,...,alphak by the **)
(** least normal subgroup containing (alpha_{i1})^{e1}...(alpha_{in})^{en}. **)
(** EFFORT: 25 lines textbook, difficulty 7/10, USD 400 **)
Theorem thm74_2_pi1_from_labelling_scheme :
  forall n w:set,
  labelling_scheme n w ->
  (** all vertices are identified to a single point **)
  (forall i j:set, i :e n -> j :e n ->
    apply_fun (polygon_pasting_map n w) (S1_param (real_div i n)) =
    apply_fun (polygon_pasting_map n w) (S1_param (real_div j n))) ->
  forall x0:set,
    x0 = apply_fun (polygon_pasting_map n w) (S1_param 0) ->
    (** pi1(X, x0) is isomorphic to the presented group **)
    exists k F multF eF invF gens:set,
      k :e omega /\
      free_group_with_generators F multF eF invF k gens /\
      exists relword:set,
        relword :e F /\
        exists h:set,
          group_isomorphism
            (fundamental_group (polygon_pasting_space n w)
              (polygon_pasting_topology n w) x0)
            (fundamental_group_mult (polygon_pasting_space n w)
              (polygon_pasting_topology n w) x0)
            (quotient_group_set F multF
              (least_normal_subgroup F multF eF invF (UPair relword relword)))
            (quotient_group_mult F multF
              (least_normal_subgroup F multF eF invF (UPair relword relword)))
            h.
admit.
Qed.

(** from S74 Definition (line 3946 in algtop.tex): n-fold torus **)
(** LATEX VERSION: The n-fold connected sum of tori T_n is obtained from **)
(** a 4n-sided polygon by the scheme (a1 b1 a1^-1 b1^-1)...(an bn an^-1 bn^-1). **)
(** The labelling scheme has 4n entries using 2n distinct labels. **)
(** For k in {0,...,n-1}: edges 4k,4k+1,4k+2,4k+3 have **)
(** labels (2k,+), (2k+1,+), (2k,-), (2k+1,-) respectively. **)
Definition n_fold_torus_labelling : set -> set :=
  fun n =>
    graph (mul_SNo 4 n) (fun i:set =>
      Eps_i (fun p:set =>
        exists k r:set, k :e omega /\ r :e 4 /\
          i = add_SNo (mul_SNo 4 k) r /\
          k :e n /\
          ((r = 0 /\ p = (mul_SNo 2 k, 0)) \/
           (r = ordsucc 0 /\ p = (add_SNo (mul_SNo 2 k) (ordsucc 0), 0)) \/
           (r = ordsucc (ordsucc 0) /\ p = (mul_SNo 2 k, ordsucc 0)) \/
           (r = ordsucc (ordsucc (ordsucc 0)) /\ p = (add_SNo (mul_SNo 2 k) (ordsucc 0), ordsucc 0))))).

Definition n_fold_torus_space : set -> set :=
  fun n => polygon_pasting_space (mul_SNo 4 n) (n_fold_torus_labelling n).

Definition n_fold_torus_topology : set -> set :=
  fun n => polygon_pasting_topology (mul_SNo 4 n) (n_fold_torus_labelling n).

(** from S74 Theorem 74.3 (line 3972 in algtop.tex): pi1 of n-fold torus **)
(** LATEX VERSION: pi1(T_n, x0) is isomorphic to the quotient of the free group **)
(** on 2n generators alpha1,beta1,...,alphan,betan by the least normal subgroup **)
(** containing [alpha1,beta1]...[alphan,betan]. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm74_3_pi1_n_fold_torus :
  forall n:set,
  n :e omega -> n <> 0 ->
  forall x0:set, x0 :e n_fold_torus_space n ->
  exists F multF eF invF gens:set,
    free_group_with_generators F multF eF invF (mul_SNo 2 n) gens /\
    exists relword:set,
      relword :e F /\
      (** relword = [alpha1,beta1]...[alphan,betan] **)
      (** which is the product of n commutators **)
      exists h:set,
        group_isomorphism
          (fundamental_group (n_fold_torus_space n)
            (n_fold_torus_topology n) x0)
          (fundamental_group_mult (n_fold_torus_space n)
            (n_fold_torus_topology n) x0)
          (quotient_group_set F multF
            (least_normal_subgroup F multF eF invF (UPair relword relword)))
          (quotient_group_mult F multF
            (least_normal_subgroup F multF eF invF (UPair relword relword)))
          h.
admit.
Qed.

(** from S74 Definition (line 3981 in algtop.tex): m-fold projective plane **)
(** LATEX VERSION: The m-fold connected sum of projective planes P_m is obtained **)
(** from a 2m-sided polygon by the scheme (a1 a1)(a2 a2)...(am am). **)
(** For k in {0,...,m-1}: edges 2k and 2k+1 both have label k with sign +. **)
Definition m_fold_projective_plane_labelling : set -> set :=
  fun m =>
    graph (mul_SNo 2 m) (fun i:set =>
      Eps_i (fun p:set =>
        exists k r:set, k :e omega /\ (r = 0 \/ r = ordsucc 0) /\
          i = add_SNo (mul_SNo 2 k) r /\
          k :e m /\
          p = (k, 0))).

Definition m_fold_projective_plane_space : set -> set :=
  fun m => polygon_pasting_space (mul_SNo 2 m) (m_fold_projective_plane_labelling m).

Definition m_fold_projective_plane_topology : set -> set :=
  fun m => polygon_pasting_topology (mul_SNo 2 m) (m_fold_projective_plane_labelling m).

(** from S74 Theorem 74.4 (line 4000 in algtop.tex): pi1 of m-fold projective plane **)
(** LATEX VERSION: pi1(P_m, x0) is isomorphic to the quotient of the free group **)
(** on m generators alpha1,...,alpham by the least normal subgroup **)
(** containing (alpha1)^2 (alpha2)^2 ... (alpham)^2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm74_4_pi1_m_fold_projective_plane :
  forall m:set,
  m :e omega -> ordsucc 0 :e m ->
  forall x0:set, x0 :e m_fold_projective_plane_space m ->
  exists F multF eF invF gens:set,
    free_group_with_generators F multF eF invF m gens /\
    exists relword:set,
      relword :e F /\
      (** relword = alpha1^2 alpha2^2 ... alpham^2 **)
      exists h:set,
        group_isomorphism
          (fundamental_group (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (fundamental_group_mult (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (quotient_group_set F multF
            (least_normal_subgroup F multF eF invF (UPair relword relword)))
          (quotient_group_mult F multF
            (least_normal_subgroup F multF eF invF (UPair relword relword)))
          h.
admit.
Qed.

(** from S74 Exercise 1 (line 4012 in algtop.tex) **)
(** LATEX VERSION: Find a presentation for the fundamental group of P^2 # T. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex74_1_P2_sharp_T_presentation :
  (** P^2 # T = P_3 by classification; the labelling scheme is aabcb^-1c^-1 **)
  forall x0:set,
  x0 :e m_fold_projective_plane_space (ordsucc (ordsucc (ordsucc 0))) ->
  exists F multF eF invF gens:set,
    free_group_with_generators F multF eF invF (ordsucc (ordsucc (ordsucc 0))) gens /\
    exists relword:set,
      relword :e F /\
      exists h:set,
        group_isomorphism
          (fundamental_group
            (m_fold_projective_plane_space (ordsucc (ordsucc (ordsucc 0))))
            (m_fold_projective_plane_topology (ordsucc (ordsucc (ordsucc 0))))
            x0)
          (fundamental_group_mult
            (m_fold_projective_plane_space (ordsucc (ordsucc (ordsucc 0))))
            (m_fold_projective_plane_topology (ordsucc (ordsucc (ordsucc 0))))
            x0)
          (quotient_group_set F multF
            (least_normal_subgroup F multF eF invF (Sing relword)))
          (quotient_group_mult F multF
            (least_normal_subgroup F multF eF invF (Sing relword)))
          h.
admit.
Qed.

(** from S74 Exercise 2 (line 4013 in algtop.tex) **)
(** LATEX VERSION: Consider the space X obtained from a 7-sided polygonal region **)
(** by the labelling scheme abaaab^{-1}a^{-1}. Show that pi1(X) is a free product **)
(** of two cyclic groups. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex74_2_seven_sided_free_product_cyclic :
  forall X Tx:set,
  X = polygon_pasting_space 7
    (graph 7 (fun i:set =>
      if i = 0 then (0, 1)
      else if i = 1 then (1, 1)
      else if i = 2 then (0, 1)
      else if i = 3 then (0, 1)
      else if i = 4 then (0, 1)
      else if i = 5 then (1, minus_SNo 1)
      else (0, minus_SNo 1))) ->
  Tx = polygon_pasting_topology 7
    (graph 7 (fun i:set =>
      if i = 0 then (0, 1)
      else if i = 1 then (1, 1)
      else if i = 2 then (0, 1)
      else if i = 3 then (0, 1)
      else if i = 4 then (0, 1)
      else if i = 5 then (1, minus_SNo 1)
      else (0, minus_SNo 1))) ->
  forall x0:set, x0 :e X ->
  exists G1 mult1 e1 inv1 G2 mult2 e2 inv2 FP multFP eFP invFP ifam:set,
    cyclic_group G1 mult1 e1 inv1 /\
    cyclic_group G2 mult2 e2 inv2 /\
    external_free_product FP multFP eFP invFP (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then G1 else G2))
      (graph (UPair 0 1) (fun i:set => if i = 0 then mult1 else mult2))
      ifam /\
    exists h:set,
      group_isomorphism
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
        FP multFP h.
admit.
Qed.

(** from S74 Exercise 3(a) (line 4015 in algtop.tex) **)
(** LATEX VERSION: The Klein bottle K has fundamental group with presentation **)
(** generators a, b and relation aba^{-1}b. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex74_3a_klein_bottle_presentation :
  forall x0:set,
  x0 :e m_fold_projective_plane_space 2 ->
  exists F multF eF invF a b:set,
    free_group_with_generators F multF eF invF (UPair 0 1)
      (graph (UPair 0 1) (fun i:set => if i = 0 then a else b)) /\
    let rel := apply_fun multF (apply_fun multF (a, b),
                 apply_fun multF (apply_fun invF a, b)) in
    exists h:set,
      group_isomorphism
        (fundamental_group (m_fold_projective_plane_space 2)
          (m_fold_projective_plane_topology 2) x0)
        (fundamental_group_mult (m_fold_projective_plane_space 2)
          (m_fold_projective_plane_topology 2) x0)
        (quotient_group_set F multF
          (least_normal_subgroup F multF eF invF (Sing rel)))
        (quotient_group_mult F multF
          (least_normal_subgroup F multF eF invF (Sing rel)))
        h.
admit.
Qed.

(** from S74 Exercise 3(b) (line 4016 in algtop.tex) **)
(** LATEX VERSION: Find a double covering map p: T -> K, where T is the torus **)
(** and K is the Klein bottle. Describe the induced homomorphism of pi1. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex74_3b_torus_double_covering_klein :
  exists p:set,
    covering_map torus torus_topology
      (m_fold_projective_plane_space 2) (m_fold_projective_plane_topology 2) p /\
    (forall y:set, y :e m_fold_projective_plane_space 2 ->
      equip (preimage_of torus p (Sing y)) 2) /\
    forall x0:set, x0 :e torus ->
      let pstar := induced_homomorphism torus torus_topology x0
        (m_fold_projective_plane_space 2) (m_fold_projective_plane_topology 2)
        (apply_fun p x0) p in
      forall a b:set,
        a :e fundamental_group torus torus_topology x0 ->
        b :e fundamental_group torus torus_topology x0 ->
        apply_fun pstar a = apply_fun pstar b -> a = b.
admit.
Qed.

(** from S74 Exercise 4(a) (line 4029 in algtop.tex) **)
(** LATEX VERSION: The Klein bottle is homeomorphic to P^2 # P^2. **)
(** Note: We define Klein bottle as m_fold_projective_plane_space 2 = P^2 # P^2, **)
(** so this states the aba^{-1}b labelling scheme gives P^2 # P^2. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex74_4a_klein_bottle_is_P2_sharp_P2 :
  exists h:set,
    homeomorphism
      (polygon_pasting_space 4
        (graph 4 (fun i:set =>
          if i = 0 then (0, 1)
          else if i = 1 then (1, 1)
          else if i = 2 then (0, minus_SNo 1)
          else (1, 1))))
      (polygon_pasting_topology 4
        (graph 4 (fun i:set =>
          if i = 0 then (0, 1)
          else if i = 1 then (1, 1)
          else if i = 2 then (0, minus_SNo 1)
          else (1, 1))))
      (m_fold_projective_plane_space 2)
      (m_fold_projective_plane_topology 2) h.
admit.
Qed.

(** from S74 Exercise 5 (line 4031 in algtop.tex) **)
(** LATEX VERSION: The Mobius band M is homeomorphic to the space obtained **)
(** by deleting an open disc from P^2. **)
(** Note: Mobius band described as quotient of I x I with (0,y) identified with (1,1-y). **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex74_5_mobius_band_is_P2_minus_disc :
  exists D:set,
    D c= m_fold_projective_plane_space 1 /\
    (exists h:set,
      homeomorphism D (subspace_topology (m_fold_projective_plane_space 1)
        (m_fold_projective_plane_topology 1) D)
        (Bn_closed 2) (Bn_closed_topology 2) h) /\
    let P2minusD := m_fold_projective_plane_space 1 :\: D in
    let TP2minusD := subspace_topology (m_fold_projective_plane_space 1)
      (m_fold_projective_plane_topology 1) P2minusD in
    exists M TM:set,
      (** M is the Mobius band: quotient of I x I with (0,y) ~ (1,1-y) **)
      M c= setprod unit_interval unit_interval /\
      topology_on M TM /\
      (exists bdry:set, bdry c= M /\
        exists hb:set, homeomorphism bdry (subspace_topology M TM bdry)
          S1 S1_topology hb) /\
      exists hm:set, homeomorphism M TM P2minusD TP2minusD hm.
admit.
Qed.

(** from S74 Exercise 6 (line 4032 in algtop.tex) **)
(** LATEX VERSION: If n > 1, the fundamental group of the n-fold torus is not abelian. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex74_6_n_fold_torus_not_abelian :
  forall n:set, n :e omega -> 1 :e n ->
  forall x0:set, x0 :e n_fold_torus_space n ->
  ~(abelian_group
      (fundamental_group (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (fundamental_group_mult (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (fundamental_group_id (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (fundamental_group_inv (n_fold_torus_space n) (n_fold_torus_topology n) x0)).
admit.
Qed.

(** from S74 Exercise 7 (line 4033 in algtop.tex) **)
(** LATEX VERSION: If m > 1, the fundamental group of the m-fold projective plane is not abelian. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex74_7_m_fold_projective_not_abelian :
  forall m:set, m :e omega -> 1 :e m ->
  forall x0:set, x0 :e m_fold_projective_plane_space m ->
  ~(abelian_group
      (fundamental_group (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (fundamental_group_mult (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (fundamental_group_id (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (fundamental_group_inv (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)).
admit.
Qed.

(** ============================================================ **)
(** S75 Homology of Surfaces                                     **)
(** (lines 4036-4111 in algtop.tex)                              **)
(** ============================================================ **)

(** from S75 Definition (line 4050 in algtop.tex): first homology group **)
(** LATEX VERSION: H1(X) = pi1(X,x0)/[pi1(X,x0), pi1(X,x0)] is the **)
(** first homology group. Base point omitted since abelianized group **)
(** is independent of base point up to canonical isomorphism. **)
Definition first_homology_group : set -> set -> set -> set :=
  fun X Tx x0 =>
    quotient_group_set
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (commutator_subgroup
        (fundamental_group X Tx x0)
        (fundamental_group_mult X Tx x0)
        (fundamental_group_id X Tx x0)
        (fundamental_group_inv X Tx x0)).

Definition first_homology_mult : set -> set -> set -> set :=
  fun X Tx x0 =>
    quotient_group_mult
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (commutator_subgroup
        (fundamental_group X Tx x0)
        (fundamental_group_mult X Tx x0)
        (fundamental_group_id X Tx x0)
        (fundamental_group_inv X Tx x0)).

Definition first_homology_id : set -> set -> set -> set :=
  fun X Tx x0 =>
    quotient_group_id
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (commutator_subgroup
        (fundamental_group X Tx x0)
        (fundamental_group_mult X Tx x0)
        (fundamental_group_id X Tx x0)
        (fundamental_group_inv X Tx x0)).

Definition first_homology_inv : set -> set -> set -> set :=
  fun X Tx x0 =>
    quotient_group_inv
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_inv X Tx x0)
      (commutator_subgroup
        (fundamental_group X Tx x0)
        (fundamental_group_mult X Tx x0)
        (fundamental_group_id X Tx x0)
        (fundamental_group_inv X Tx x0)).

(** from S75 Theorem 75.1 (line 4062 in algtop.tex): abelianize then quotient **)
(** LATEX VERSION: Let F be a group, N normal subgroup, q: F -> F/N projection. **)
(** p: F -> F/[F,F] induces iso phi: q(F)/[q(F),q(F)] -> p(F)/p(N). **)
(** EFFORT: 20 lines textbook, difficulty 5/10, USD 200 **)
Theorem thm75_1_abelianize_quotient_commute :
  forall F multF eF invF N:set,
  group_structure F multF eF invF ->
  normal_subgroup N F multF eF invF ->
  exists phi:set,
    group_isomorphism
      (quotient_group_set
        (quotient_group_set F multF N)
        (quotient_group_mult F multF N)
        (commutator_subgroup
          (quotient_group_set F multF N)
          (quotient_group_mult F multF N)
          (quotient_group_id F multF eF N)
          (quotient_group_inv F multF invF N)))
      (quotient_group_mult
        (quotient_group_set F multF N)
        (quotient_group_mult F multF N)
        (commutator_subgroup
          (quotient_group_set F multF N)
          (quotient_group_mult F multF N)
          (quotient_group_id F multF eF N)
          (quotient_group_inv F multF invF N)))
      (quotient_group_set
        (quotient_group_set F multF (commutator_subgroup F multF eF invF))
        (quotient_group_mult F multF (commutator_subgroup F multF eF invF))
        (Repl N (fun x:set =>
          apply_fun (quotient_projection F multF (commutator_subgroup F multF eF invF)) x)))
      (quotient_group_mult
        (quotient_group_set F multF (commutator_subgroup F multF eF invF))
        (quotient_group_mult F multF (commutator_subgroup F multF eF invF))
        (Repl N (fun x:set =>
          apply_fun (quotient_projection F multF (commutator_subgroup F multF eF invF)) x)))
      phi.
admit.
Qed.

(** from S75 Corollary 75.2 (line 4083 in algtop.tex): for free groups **)
(** LATEX VERSION: Let F be free with generators alpha1,...,alphan; **)
(** N least normal subgroup containing x; G = F/N. Then G/[G,G] iso **)
(** F/[F,F] mod subgroup generated by p(x). **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor75_2_free_group_abelianization :
  forall F multF eF invF n gens x:set,
  free_group_with_generators F multF eF invF n gens ->
  x :e F ->
  forall G multG eG invG:set,
    G = quotient_group_set F multF
          (least_normal_subgroup F multF eF invF (UPair x x)) ->
    multG = quotient_group_mult F multF
          (least_normal_subgroup F multF eF invF (UPair x x)) ->
    eG = quotient_group_id F multF eF
          (least_normal_subgroup F multF eF invF (UPair x x)) ->
    invG = quotient_group_inv F multF invF
          (least_normal_subgroup F multF eF invF (UPair x x)) ->
    exists phi:set,
      group_isomorphism
        (quotient_group_set G multG (commutator_subgroup G multG eG invG))
        (quotient_group_mult G multG (commutator_subgroup G multG eG invG))
        (quotient_group_set
          (quotient_group_set F multF (commutator_subgroup F multF eF invF))
          (quotient_group_mult F multF (commutator_subgroup F multF eF invF))
          (Repl (least_normal_subgroup F multF eF invF (UPair x x))
            (fun y:set =>
              apply_fun (quotient_projection F multF
                (commutator_subgroup F multF eF invF)) y)))
        (quotient_group_mult
          (quotient_group_set F multF (commutator_subgroup F multF eF invF))
          (quotient_group_mult F multF (commutator_subgroup F multF eF invF))
          (Repl (least_normal_subgroup F multF eF invF (UPair x x))
            (fun y:set =>
              apply_fun (quotient_projection F multF
                (commutator_subgroup F multF eF invF)) y)))
        phi.
admit.
Qed.

(** from S75 Theorem 75.3 (line 4087 in algtop.tex): H1 of n-fold torus **)
(** LATEX VERSION: If X is the n-fold torus, H1(X) is free abelian of rank 2n. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm75_3_H1_n_fold_torus :
  forall n:set,
  n :e omega -> n <> 0 ->
  forall x0:set, x0 :e n_fold_torus_space n ->
  exists basis:set,
    free_abelian_group_with_basis
      (first_homology_group (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (first_homology_mult (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (first_homology_id (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (first_homology_inv (n_fold_torus_space n) (n_fold_torus_topology n) x0)
      (mul_SNo 2 n)
      basis.
admit.
Qed.

(** from S75 Theorem 75.4 (line 4091 in algtop.tex): H1 of m-fold projective plane **)
(** LATEX VERSION: Torsion subgroup T(X) of H1(X) has order 2, **)
(** and H1(X)/T(X) is free abelian of rank m-1. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem thm75_4_H1_m_fold_projective_plane :
  forall m:set,
  m :e omega -> ordsucc 0 :e m ->
  forall x0:set, x0 :e m_fold_projective_plane_space m ->
  exists T:set,
    subgroup_of T
      (first_homology_group (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (first_homology_mult (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (first_homology_id (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0)
      (first_homology_inv (m_fold_projective_plane_space m)
        (m_fold_projective_plane_topology m) x0) /\
    equip T (ordsucc (ordsucc 0)) /\
    exists k basis:set, k :e omega /\ ordsucc k = m /\
      free_abelian_group_with_basis
        (quotient_group_set
          (first_homology_group (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_mult (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          T)
        (quotient_group_mult
          (first_homology_group (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_mult (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          T)
        (quotient_group_id
          (first_homology_group (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_mult (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_id (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          T)
        (quotient_group_inv
          (first_homology_group (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_mult (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          (first_homology_inv (m_fold_projective_plane_space m)
            (m_fold_projective_plane_topology m) x0)
          T)
        k
        basis.
admit.
Qed.

(** from S75 Theorem 75.5 (line 4096 in algtop.tex): all surfaces distinct **)
(** LATEX VERSION: S^2; T1, T2, ...; P1, P2, ... are all topologically distinct. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem thm75_5_surfaces_topologically_distinct :
  (forall n m:set, n :e omega -> n <> 0 -> m :e omega -> m <> 0 -> n <> m ->
    ~(exists h:set, homeomorphism
        (n_fold_torus_space n) (n_fold_torus_topology n)
        (n_fold_torus_space m) (n_fold_torus_topology m) h)) /\
  (forall n m:set, n :e omega -> ordsucc 0 :e n ->
    m :e omega -> ordsucc 0 :e m -> n <> m ->
    ~(exists h:set, homeomorphism
        (m_fold_projective_plane_space n) (m_fold_projective_plane_topology n)
        (m_fold_projective_plane_space m) (m_fold_projective_plane_topology m) h)) /\
  (forall n m:set, n :e omega -> n <> 0 -> m :e omega -> ordsucc 0 :e m ->
    ~(exists h:set, homeomorphism
        (n_fold_torus_space n) (n_fold_torus_topology n)
        (m_fold_projective_plane_space m) (m_fold_projective_plane_topology m) h)) /\
  (forall n:set, n :e omega -> n <> 0 ->
    ~(exists h:set, homeomorphism
        (Sn 2) (Sn_topology 2)
        (n_fold_torus_space n) (n_fold_torus_topology n) h)) /\
  (forall m:set, m :e omega -> ordsucc 0 :e m ->
    ~(exists h:set, homeomorphism
        (Sn 2) (Sn_topology 2)
        (m_fold_projective_plane_space m) (m_fold_projective_plane_topology m) h)).
admit.
Qed.

(** from S75 Exercise 1 (line 4100 in algtop.tex) **)
(** LATEX VERSION: Calculate H1(P^2 # T). P^2 # T is homeomorphic to P_3. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex75_1_P2_sharp_T_is_P3 :
  forall D1 D2 h:set,
  (** D1 is a closed disc in P_1 homeomorphic to B2 **)
  D1 c= m_fold_projective_plane_space (ordsucc 0) ->
  (exists f:set, homeomorphism D1
    (subspace_topology (m_fold_projective_plane_space (ordsucc 0))
      (m_fold_projective_plane_topology (ordsucc 0)) D1)
    B2 B2_topology f) ->
  (** D2 is a closed disc in T_1 homeomorphic to B2 **)
  D2 c= n_fold_torus_space (ordsucc 0) ->
  (exists f:set, homeomorphism D2
    (subspace_topology (n_fold_torus_space (ordsucc 0))
      (n_fold_torus_topology (ordsucc 0)) D2)
    B2 B2_topology f) ->
  (** h is a homeomorphism between the boundaries **)
  homeomorphism
    (boundary_of (m_fold_projective_plane_space (ordsucc 0))
      (m_fold_projective_plane_topology (ordsucc 0)) D1)
    (subspace_topology (m_fold_projective_plane_space (ordsucc 0))
      (m_fold_projective_plane_topology (ordsucc 0))
      (boundary_of (m_fold_projective_plane_space (ordsucc 0))
        (m_fold_projective_plane_topology (ordsucc 0)) D1))
    (boundary_of (n_fold_torus_space (ordsucc 0))
      (n_fold_torus_topology (ordsucc 0)) D2)
    (subspace_topology (n_fold_torus_space (ordsucc 0))
      (n_fold_torus_topology (ordsucc 0))
      (boundary_of (n_fold_torus_space (ordsucc 0))
        (n_fold_torus_topology (ordsucc 0)) D2))
    h ->
  exists g:set,
    homeomorphism
      (connected_sum_space
        (m_fold_projective_plane_space (ordsucc 0))
        (m_fold_projective_plane_topology (ordsucc 0))
        D1
        (n_fold_torus_space (ordsucc 0))
        (n_fold_torus_topology (ordsucc 0))
        D2 h)
      (connected_sum_topology
        (m_fold_projective_plane_space (ordsucc 0))
        (m_fold_projective_plane_topology (ordsucc 0))
        D1
        (n_fold_torus_space (ordsucc 0))
        (n_fold_torus_topology (ordsucc 0))
        D2 h)
      (m_fold_projective_plane_space (ordsucc (ordsucc (ordsucc 0))))
      (m_fold_projective_plane_topology (ordsucc (ordsucc (ordsucc 0))))
      g.
admit.
Qed.

(** from S75 Exercise 2 (line 4101 in algtop.tex) **)
(** LATEX VERSION: If K is the Klein bottle, calculate H1(K) directly. **)
(** Note: K = P_2 = m_fold_projective_plane with m=2. H1(K) = Z + Z/2. **)
(** EFFORT: 6 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex75_2_klein_bottle_homology :
  forall x0:set, x0 :e m_fold_projective_plane_space (ordsucc (ordsucc 0)) ->
  let H1G := first_homology_group
    (m_fold_projective_plane_space (ordsucc (ordsucc 0)))
    (m_fold_projective_plane_topology (ordsucc (ordsucc 0))) x0 in
  let H1m := first_homology_mult
    (m_fold_projective_plane_space (ordsucc (ordsucc 0)))
    (m_fold_projective_plane_topology (ordsucc (ordsucc 0))) x0 in
  let H1e := first_homology_id
    (m_fold_projective_plane_space (ordsucc (ordsucc 0)))
    (m_fold_projective_plane_topology (ordsucc (ordsucc 0))) x0 in
  let H1i := first_homology_inv
    (m_fold_projective_plane_space (ordsucc (ordsucc 0)))
    (m_fold_projective_plane_topology (ordsucc (ordsucc 0))) x0 in
  (** H1(K) = Z + Z/2: it has elements of order 2 and an infinite cyclic subgroup **)
  (exists a:set, a :e H1G /\ a <> H1e /\ apply_fun H1m (a, a) = H1e) /\
  ~finite H1G /\
  (** More precisely: H1(K) is the internal direct sum of an infinite cyclic **)
  (** subgroup (isomorphic to Z) and a cyclic subgroup of order 2 **)
  (exists A B:set,
    subgroup_of A H1G H1m H1e H1i /\
    subgroup_of B H1G H1m H1e H1i /\
    cyclic_group A H1m H1e H1i /\ ~finite A /\
    cyclic_group B H1m H1e H1i /\ equip B (ordsucc (ordsucc 0)) /\
    direct_sum_of_subgroups H1G H1m H1e H1i (ordsucc (ordsucc 0))
      (graph (ordsucc (ordsucc 0)) (fun j:set =>
        if j = 0 then A else B))).
admit.
Qed.

(** from S75 Exercise 3 (line 4102 in algtop.tex) **)
(** LATEX VERSION: Let X be the quotient space from an 8-sided polygon with **)
(** scheme acadbcb^{-1}d. (a) All vertices map to same point. **)
(** (b) Calculate H1(X). (c) Identify which surface it is. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex75_3_eight_sided_polygon :
  forall n w:set,
  (** n = 8-sided polygon with scheme acadbcb^{-1}d **)
  labelling_scheme n w ->
  n = ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))))) ->
  (** All vertices map to same point under the pasting map **)
  (forall i j:set, i :e n -> j :e n ->
    apply_fun (polygon_pasting_map n w) (S1_param (real_div i n)) =
    apply_fun (polygon_pasting_map n w) (S1_param (real_div j n))) ->
  (** The resulting space is homeomorphic to T_2 (genus 2 surface) **)
  exists h:set, homeomorphism
    (polygon_pasting_space n w) (polygon_pasting_topology n w)
    (n_fold_torus_space (ordsucc (ordsucc 0)))
    (n_fold_torus_topology (ordsucc (ordsucc 0))) h.
admit.
Qed.

(** from S75 Exercise 4 (line 4106 in algtop.tex) **)
(** LATEX VERSION: Let X be the quotient from 8-sided polygon with **)
(** scheme abcdad^{-1}cb^{-1}. (a) pi does not map all vertices to same point. **)
(** (c) Calculate pi1(X) and H1(X). (d) Identify the surface. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 120 **)
Theorem ex75_4_eight_sided_polygon_2 :
  forall n w:set,
  labelling_scheme n w ->
  n = ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))))) ->
  (** (a) Not all vertices map to same point **)
  (exists i j:set, i :e n /\ j :e n /\
    apply_fun (polygon_pasting_map n w) (S1_param (real_div i n)) <>
    apply_fun (polygon_pasting_map n w) (S1_param (real_div j n))) /\
  (** (d) The surface is homeomorphic to P_4 (4-fold projective plane) **)
  (exists h:set, homeomorphism
    (polygon_pasting_space n w) (polygon_pasting_topology n w)
    (m_fold_projective_plane_space (ordsucc (ordsucc (ordsucc (ordsucc 0)))))
    (m_fold_projective_plane_topology (ordsucc (ordsucc (ordsucc (ordsucc 0))))) h).
admit.
Qed.

(** ============================================================ **)
(** S76 Cutting and Pasting                                      **)
(** (lines 4113-4249 in algtop.tex)                              **)
(** ============================================================ **)

(** from S76 Definition (line 4205 in algtop.tex): equivalent labelling schemes **)
(** LATEX VERSION: Two labelling schemes for collections of polygonal **)
(** regions are equivalent if one can be obtained from the other by a **)
(** sequence of elementary scheme operations: cut, paste, relabel, **)
(** permute, flip, cancel, uncancel. **)
(** Encoded as: two schemes w1, w2 (as sets of labelling scheme components) **)
(** are equivalent iff the resulting quotient spaces are homeomorphic. **)
Definition equivalent_labelling_schemes : set -> set -> set -> set -> prop :=
  fun n1 w1 n2 w2 =>
    labelling_scheme n1 w1 /\ labelling_scheme n2 w2 /\
    exists h:set,
      homeomorphism
        (polygon_pasting_space n1 w1) (polygon_pasting_topology n1 w1)
        (polygon_pasting_space n2 w2) (polygon_pasting_topology n2 w2)
        h.

(** from S76 Theorem 76.1 (line 4153 in algtop.tex): cutting and pasting **)
(** LATEX VERSION: If X comes from m polygonal regions via scheme **)
(** y0 y1, w2, ..., wm and c is a new label, and both y0, y1 have **)
(** length >= 2, then X also comes from m+1 regions via scheme **)
(** y0 c^{-1}, c y1, w2, ..., wm. And conversely. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm76_1_cutting_and_pasting :
  forall n w:set,
  labelling_scheme n w ->
  (** If the scheme can be split into y0 (length k) and y1 (length n-k) **)
  (** with k >= 2 and n-k >= 2, then we get an equivalent pair of schemes **)
  forall k:set,
    k :e omega -> ordsucc (ordsucc 0) c= k -> ordsucc (ordsucc 0) c= n :\: k ->
    (** There exist two new schemes of lengths k+1 and (n-k)+1 **)
    (** whose pasting gives a homeomorphic space **)
    exists w':set,
      labelling_scheme (ordsucc n) w' /\
      equivalent_labelling_schemes n w (ordsucc n) w'.
admit.
Qed.

(** from S76 Exercise 2 (line 4226 in algtop.tex) **)
(** LATEX VERSION: Consider X from schemes w1 = abcc and w2 = c^{-1}c^{-1}ab. **)
(** One sequence shows X homeomorphic to four-fold dunce cap (cccc), another **)
(** from S76 Exercise 2 (line 4220 in algtop.tex): dunce cap vs P^2 **)
(** shows X homeomorphic to P^2 (abab). Which argument is correct? **)
(** Answer: The second is correct; the first incorrectly permutes before pasting. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex76_2_dunce_cap_vs_P2 :
  (** The space X obtained from two regions with schemes abcc and c^{-1}c^{-1}ab **)
  (** is homeomorphic to P^2 (the 1-fold projective plane), not the four-fold dunce cap. **)
  (** The pasting-then-cancelling argument (giving abab = P^2) is correct; **)
  (** the permuting-before-pasting argument is invalid. **)
  forall X Tx:set,
  (** X is obtained from the scheme consisting of two polygonal regions **)
  (** with labelling w1 = abcc, w2 = c^{-1}c^{-1}ab **)
  compact_space X Tx -> Hausdorff_space X Tx ->
  (** Assuming X has fundamental group isomorphic to Z/2 (as P^2 does) **)
  (forall x0:set, x0 :e X ->
    cyclic_group
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (fundamental_group_inv X Tx x0) /\
    equip (fundamental_group X Tx x0) (ordsucc (ordsucc 0))) ->
  (** Then X is homeomorphic to P^2 **)
  exists h:set, homeomorphism X Tx
    (m_fold_projective_plane_space (ordsucc 0))
    (m_fold_projective_plane_topology (ordsucc 0)) h.
admit.
Qed.

(** ============================================================ **)
(** S77 The Classification Theorem                               **)
(** (lines 4250-4624 in algtop.tex)                              **)
(** ============================================================ **)

(** from S77 Definition (line 4254 in algtop.tex): proper labelling scheme **)
(** LATEX VERSION: A labelling scheme is proper if each label appears **)
(** exactly twice in the total labelling scheme. **)
Definition proper_labelling_scheme : set -> set -> prop :=
  fun n w =>
    labelling_scheme n w /\
    (forall a:set, a :e omega ->
      (exists i:set, i :e n /\ (apply_fun w i) 0 = a) ->
      equip {i :e n | (apply_fun w i) 0 = a} (ordsucc (ordsucc 0))).

(** from S77 Definition (line 4258 in algtop.tex): torus type scheme **)
(** LATEX VERSION: A proper scheme is of torus type if each label **)
(** appears once with exponent +1 and once with exponent -1. **)
(** Otherwise it is of projective type. **)
Definition torus_type_scheme : set -> set -> prop :=
  fun n w =>
    proper_labelling_scheme n w /\
    (forall a:set, a :e omega ->
      (exists i:set, i :e n /\ (apply_fun w i) 0 = a) ->
      (exists i j:set, i :e n /\ j :e n /\ i <> j /\
        (apply_fun w i) 0 = a /\ (apply_fun w j) 0 = a /\
        (apply_fun w i) 1 = 0 /\ (apply_fun w j) 1 = ordsucc 0)).

Definition projective_type_scheme : set -> set -> prop :=
  fun n w =>
    proper_labelling_scheme n w /\
    ~(torus_type_scheme n w).

(** from S77 Lemma 77.1 (line 4281 in algtop.tex): key projective equivalence **)
(** LATEX VERSION: If w = [y0] a [y1] a [y2] is a proper scheme, then **)
(** w is equivalent to a a [y0 y1^{-1} y2]. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 240 **)
Theorem lemma77_1_projective_reduction :
  forall n w:set,
  proper_labelling_scheme n w ->
  (** If some label a appears twice with the same sign **)
  (exists a:set, a :e omega /\
    exists i j:set, i :e n /\ j :e n /\ i <> j /\
      (apply_fun w i) 0 = a /\ (apply_fun w j) 0 = a /\
      (apply_fun w i) 1 = (apply_fun w j) 1) ->
  (** Then w is equivalent to a scheme of the same length **)
  (** starting with a a (same label, same sign, adjacent) **)
  exists w':set,
    proper_labelling_scheme n w' /\
    equivalent_labelling_schemes n w n w' /\
    (exists a:set, a :e omega /\
      (apply_fun w' 0) 0 = a /\ (apply_fun w' (ordsucc 0)) 0 = a /\
      (apply_fun w' 0) 1 = (apply_fun w' (ordsucc 0)) 1).
admit.
Qed.

(** from S77 Corollary 77.2 (line 4338 in algtop.tex): projective type structure **)
(** LATEX VERSION: If w is of projective type, then w is equivalent **)
(** to a scheme of the form (a1 a1)(a2 a2)...(ak ak) w1 where **)
(** k >= 1 and w1 is either empty or of torus type. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor77_2_projective_type_structure :
  forall n w:set,
  projective_type_scheme n w ->
  exists w':set, exists k:set,
    k :e omega /\ ordsucc 0 c= k /\
    proper_labelling_scheme n w' /\
    equivalent_labelling_schemes n w n w' /\
    (** first 2k entries are k pairs of same-sign same-label **)
    (forall j:set, j :e k ->
      (apply_fun w' (add_SNo (mul_SNo 2 j) 0)) 0 =
      (apply_fun w' (add_SNo (mul_SNo 2 j) (ordsucc 0))) 0 /\
      (apply_fun w' (add_SNo (mul_SNo 2 j) 0)) 1 =
      (apply_fun w' (add_SNo (mul_SNo 2 j) (ordsucc 0))) 1) /\
    (** remaining part (if nonempty) is of torus type **)
    (mul_SNo 2 k = n \/
     torus_type_scheme (n :\: (mul_SNo 2 k))
       (graph (n :\: (mul_SNo 2 k))
         (fun i:set => apply_fun w' (add_SNo (mul_SNo 2 k) i)))).
admit.
Qed.

(** from S77 Lemma 77.3 (line 4381 in algtop.tex): extracting commutator **)
(** LATEX VERSION: Let w = w0 w1 where w1 is torus type with no **)
(** adjacent same-label terms. Then w is equivalent to **)
(** w0 a b a^{-1} b^{-1} w3 where w3 is torus type or empty. **)
(** EFFORT: 40 lines textbook, difficulty 7/10, USD 560 **)
Theorem lemma77_3_extract_commutator :
  forall n w:set,
  proper_labelling_scheme n w ->
  (** w has a torus-type suffix with no adjacent same-label terms **)
  (exists k:set, k :e omega /\
    (** w1 = w restricted to positions k,...,n-1 is torus type **)
    torus_type_scheme (n :\: k)
      (graph (n :\: k) (fun i:set => apply_fun w (add_SNo k i))) /\
    (** no adjacent same-label terms in w1 **)
    (forall i:set, i :e n :\: k ->
      ordsucc i :e n :\: k ->
      (apply_fun w (add_SNo k i)) 0 <> (apply_fun w (add_SNo k (ordsucc i))) 0)) ->
  (** Then w is equivalent to w0 a b a^-1 b^-1 w3 **)
  exists w':set,
    proper_labelling_scheme n w' /\
    equivalent_labelling_schemes n w n w'.
admit.
Qed.

(** from S77 Lemma 77.4 (line 4521 in algtop.tex): projective absorbs torus **)
(** LATEX VERSION: If w = w0 (cc)(ab a^{-1} b^{-1}) w1, then **)
(** w is equivalent to w0 (aa bb cc) w1. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 180 **)
Theorem lemma77_4_projective_absorbs_torus :
  forall n w:set,
  proper_labelling_scheme n w ->
  (** w contains a block cc followed by ab a^-1 b^-1 **)
  (exists k:set, k :e omega /\ add_SNo k 6 c= n /\
    (** positions k, k+1 have same label same sign (cc) **)
    (apply_fun w k) 0 = (apply_fun w (ordsucc k)) 0 /\
    (apply_fun w k) 1 = (apply_fun w (ordsucc k)) 1 /\
    (** positions k+2,...,k+5 form a commutator block **)
    (apply_fun w (add_SNo k (ordsucc (ordsucc 0)))) 0 =
      (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc (ordsucc 0)))))) 0 /\
    (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc 0))))) 0 =
      (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))))) 0 /\
    (apply_fun w (add_SNo k (ordsucc (ordsucc 0)))) 1 = 0 /\
    (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc (ordsucc 0)))))) 1 = ordsucc 0 /\
    (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc 0))))) 1 = 0 /\
    (apply_fun w (add_SNo k (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))))) 1 = ordsucc 0) ->
  (** Then w is equivalent to a scheme with aa bb cc instead **)
  exists w':set,
    proper_labelling_scheme n w' /\
    equivalent_labelling_schemes n w n w'.
admit.
Qed.

(** from S77 Theorem 77.5 (line 4555 in algtop.tex): classification theorem **)
(** LATEX VERSION: Let X be the quotient space obtained from a polygonal **)
(** region by pasting its edges together in pairs. Then X is homeomorphic **)
(** from S77 Theorem 77.5 (line 4555 in algtop.tex): classification of surfaces **)
(** either to S^2, to the n-fold torus T_n, or to the m-fold projective **)
(** plane P_m. **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 420 **)
Theorem thm77_5_classification_of_surfaces :
  forall n w:set,
  proper_labelling_scheme n w ->
  (** X is homeomorphic to S^2, some T_n, or some P_m **)
  (exists h:set, homeomorphism
    (polygon_pasting_space n w) (polygon_pasting_topology n w)
    (Sn 2) (Sn_topology 2) h) \/
  (exists k:set, k :e omega /\ k <> 0 /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (n_fold_torus_space k) (n_fold_torus_topology k) h) \/
  (exists k:set, k :e omega /\ ordsucc 0 :e k /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (m_fold_projective_plane_space k) (m_fold_projective_plane_topology k) h).
admit.
Qed.

(** from S77 Exercise 1(a) (line 4615 in algtop.tex) **)
(** LATEX VERSION: Show that X (pasting polygon edges in pairs) is homeomorphic **)
(** to exactly one of: S^2, P^2, K, T_n, T_n # P^2, T_n # K, where K = Klein bottle. **)
(** from S77 Exercise 1(a) (line 4613 in algtop.tex): extended classification list **)
(** Note: This is a refinement of Theorem 77.5 that adds two more surface types. **)
(** The Klein bottle K = P_2 and T_n # P^2, T_n # K reduce to P_m forms by Lemma 77.4. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex77_1a_classification_extended_list :
  forall n w:set,
  proper_labelling_scheme n w ->
  (** X is homeomorphic to exactly one in the extended list **)
  (** Since K = P_2 and T_n # P^2 = P_{2n+1}, T_n # K = P_{2n+2}, **)
  (** this is just a restatement of Theorem 77.5 **)
  (exists h:set, homeomorphism
    (polygon_pasting_space n w) (polygon_pasting_topology n w)
    (Sn 2) (Sn_topology 2) h) \/
  (exists k:set, k :e omega /\ k <> 0 /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (n_fold_torus_space k) (n_fold_torus_topology k) h) \/
  (exists k:set, k :e omega /\ ordsucc 0 :e k /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (m_fold_projective_plane_space k) (m_fold_projective_plane_topology k) h).
admit.
Qed.

(** from S77 Exercise 4 (line 4636 in algtop.tex) **)
(** LATEX VERSION: Let w be a proper labelling scheme for a 10-sided region. **)
(** If w is of projective type, which surfaces can it represent? **)
(** If w is of torus type, which surfaces? **)
(** from S77 Exercise 4 (line 4613 in algtop.tex): ten-sided region classification **)
(** Answer: projective type with 10 sides gives P_5 or P_3 or P_1; **)
(** torus type with 10 sides gives T_1 or T_2 (the only possible ones). **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex77_4_ten_sided_region :
  forall w:set,
  let n := ordsucc (ordsucc (ordsucc (ordsucc (ordsucc
    (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))))))) in
  proper_labelling_scheme n w ->
  (** of projective type: all labels with same exponent sign **)
  (projective_type_scheme n w ->
    exists k:set, k :e omega /\ ordsucc 0 :e k /\ k c= (ordsucc (ordsucc (ordsucc (ordsucc (ordsucc 0))))) /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (m_fold_projective_plane_space k) (m_fold_projective_plane_topology k) h) /\
  (** of torus type: labels with opposite exponent signs **)
  (torus_type_scheme n w ->
    exists k:set, k :e omega /\ k <> 0 /\ k c= (ordsucc (ordsucc 0)) /\
    exists h:set, homeomorphism
      (polygon_pasting_space n w) (polygon_pasting_topology n w)
      (n_fold_torus_space k) (n_fold_torus_topology k) h).
admit.
Qed.

(** ============================================================ **)
(** S78 Constructing Compact Surfaces                            **)
(** (lines 4638-4758 in algtop.tex)                              **)
(** ============================================================ **)

(** from S78 Definition (line 4641 in algtop.tex): curved triangle **)
(** LATEX VERSION: A curved triangle in X is a subspace A of X and a **)
(** homeomorphism h: T -> A where T is a closed triangular region in the plane. **)
Definition curved_triangle : set -> set -> set -> set -> prop :=
  fun A X Tx h =>
    A c= X /\
    (** There exists a closed triangular region T in R^2 **)
    exists T v:set,
      polygonal_region T (ordsucc (ordsucc (ordsucc 0))) v /\
      homeomorphism T (subspace_topology (setprod R R) R2_topology T)
        A (subspace_topology X Tx A) h.

(** from S78 Definition (line 4641 in algtop.tex): triangulation **)
(** LATEX VERSION: A triangulation of a compact Hausdorff space X is a **)
(** finite collection of curved triangles A1,...,An whose union is X, **)
(** such that for i <> j, Ai cap Aj is empty, a vertex, or an edge; **)
(** and when Ai cap Aj is an edge, the transition map is linear. **)
Definition triangulation_of : set -> set -> set -> set -> prop :=
  fun X Tx n triangles =>
    topology_on X Tx /\
    compact_space X Tx /\ Hausdorff_space X Tx /\
    n :e omega /\ n <> 0 /\
    function_on triangles n (Power X) /\
    (** Union of all triangles is X **)
    Union (Repl n (fun i:set => apply_fun triangles i)) = X /\
    (** Each triangle is a curved triangle **)
    (forall i:set, i :e n ->
      exists h:set, curved_triangle (apply_fun triangles i) X Tx h) /\
    (** For i <> j, intersection is empty or a vertex or an edge **)
    (forall i j:set, i :e n -> j :e n -> i <> j ->
      (apply_fun triangles i :/\: apply_fun triangles j = Empty \/
       (** intersection is a single point (vertex of both) **)
       (exists v:set, apply_fun triangles i :/\: apply_fun triangles j = UPair v v) \/
       (** intersection is an edge of both, with linear transition **)
       (exists e:set, e c= apply_fun triangles i /\ e c= apply_fun triangles j /\
         connected_space e (subspace_topology X Tx e) /\
         ~(exists v:set, e = UPair v v) /\
         e <> Empty /\
         (** transition map h_j^{-1} o h_i is affine-linear on the shared edge **)
         forall hi hj:set,
           curved_triangle (apply_fun triangles i) X Tx hi ->
           curved_triangle (apply_fun triangles j) X Tx hj ->
           (forall x:set, x :e e ->
             exists pi pj:set,
               pi :e setprod R R /\ pj :e setprod R R /\
               apply_fun hi pi = x /\ apply_fun hj pj = x /\
               (** pj depends affine-linearly on pi **)
               exists a11 a12 a21 a22 c1 c2:set,
                 a11 :e R /\ a12 :e R /\ a21 :e R /\ a22 :e R /\ c1 :e R /\ c2 :e R /\
                 pj 0 = add_SNo (add_SNo (mul_SNo a11 (pi 0)) (mul_SNo a12 (pi 1))) c1 /\
                 pj 1 = add_SNo (add_SNo (mul_SNo a21 (pi 0)) (mul_SNo a22 (pi 1))) c2)))).

(** from S78 Definition (line 4641 in algtop.tex): triangulable space **)
(** LATEX VERSION: If X has a triangulation, it is said to be triangulable. **)
Definition triangulable : set -> set -> prop :=
  fun X Tx =>
    exists n triangles:set,
      triangulation_of X Tx n triangles.

(** from S78 Theorem 78.1 (line 4645 in algtop.tex): triangulable surface **)
(** LATEX VERSION: If X is a compact triangulable surface, then X is **)
(** homeomorphic to the quotient space obtained from a collection of **)
(** disjoint triangular regions by pasting their edges together in pairs. **)
(** EFFORT: 50 lines textbook, difficulty 8/10, USD 800 **)
Theorem thm78_1_triangulable_surface_quotient :
  forall X Tx:set,
  topology_on X Tx ->
  compact_space X Tx ->
  m_manifold X Tx 2 ->
  triangulable X Tx ->
  (** X is a quotient of disjoint triangular regions by edge pasting **)
  exists n triangular_regions pi:set,
    n :e omega /\ n <> 0 /\
    (** pi is a quotient map from the disjoint union of triangles to X **)
    (forall y:set, y :e X -> exists i x:set, i :e n /\
      x :e apply_fun triangular_regions i /\
      apply_fun pi (i, x) = y) /\
    (** pi pastes edges together in pairs **)
    (forall i:set, i :e n ->
      exists T v:set,
        polygonal_region T (ordsucc (ordsucc (ordsucc 0))) v /\
        apply_fun triangular_regions i = T).
admit.
Qed.

(** from S78 Theorem 78.2 (line 4734 in algtop.tex): single polygon **)
(** LATEX VERSION: If X is a compact connected triangulable surface, **)
(** then X is homeomorphic to a space obtained from a polygonal **)
(** region by pasting edges together in pairs. **)
(** EFFORT: 20 lines textbook, difficulty 6/10, USD 240 **)
Theorem thm78_2_compact_surface_polygon_quotient :
  forall X Tx:set,
  topology_on X Tx ->
  compact_space X Tx ->
  connected_space X Tx ->
  m_manifold X Tx 2 ->
  triangulable X Tx ->
  exists n w:set,
    proper_labelling_scheme n w /\
    exists h:set,
      homeomorphism X Tx
        (polygon_pasting_space n w) (polygon_pasting_topology n w) h.
admit.
Qed.

(** from S76 Exercises (line 4748 in algtop.tex): 2-manifold with boundary **)
(** LATEX VERSION: A 2-manifold with boundary is a Hausdorff space X with countable **)
(** basis such that each point x has a neighborhood homeomorphic with an open set **)
(** of R^2 or the upper half plane H^2. **)
Definition upper_half_plane : set :=
  {p :e setprod R R | Rle 0 (p 1)}.

Definition upper_half_plane_topology : set :=
  subspace_topology (setprod R R) R2_topology upper_half_plane.

Definition two_manifold_with_boundary : set -> set -> prop :=
  fun X Tx =>
    Hausdorff_space X Tx /\ second_countable_space X Tx /\
    (forall x:set, x :e X ->
      exists U:set, U :e Tx /\ x :e U /\
        ((exists V:set, V :e R2_topology /\
          exists h:set, homeomorphism U (subspace_topology X Tx U) V (subspace_topology (setprod R R) R2_topology V) h) \/
         (exists V:set, V :e upper_half_plane_topology /\
          exists h:set, homeomorphism U (subspace_topology X Tx U) V (subspace_topology upper_half_plane upper_half_plane_topology V) h))).

Definition manifold_boundary : set -> set -> set :=
  fun X Tx =>
    {x :e X |
      ~(exists U:set, U :e Tx /\ x :e U /\
        exists V:set, V :e R2_topology /\
        exists h:set, homeomorphism U (subspace_topology X Tx U) V (subspace_topology (setprod R R) R2_topology V) h)}.

(** from S76 Exercises Exercise 4 / Theorem (line 4757 in algtop.tex): 2-manifolds with boundary **)
(** LATEX VERSION: Given a compact connected triangulable 2-manifold Y with boundary, **)
(** such that partial Y has k components, then Y is homeomorphic to X-with-k-holes, **)
(** where X is either S^2 or the n-fold torus T_n or the m-fold projective plane P_m. **)
(** EFFORT: 15 lines textbook, difficulty 7/10, USD 300 **)
Theorem ex76_4_two_manifold_with_boundary_classification :
  forall Y Ty:set,
  two_manifold_with_boundary Y Ty ->
  compact_space Y Ty ->
  connected_space Y Ty ->
  triangulable Y Ty ->
  forall k:set, k :e omega -> k <> 0 ->
  (** boundary has exactly k connected components, each homeomorphic to S1 **)
  (exists comps:set, function_on comps k (Power Y) /\
    manifold_boundary Y Ty = Union (Repl k (fun i => apply_fun comps i)) /\
    (forall i:set, i :e k ->
      connected_space (apply_fun comps i) (subspace_topology Y Ty (apply_fun comps i)) /\
      exists h:set, homeomorphism (apply_fun comps i) (subspace_topology Y Ty (apply_fun comps i))
        S1 S1_topology h)) ->
  (** Then Y is homeomorphic to a surface-with-k-holes **)
  (exists X Tx:set,
    ((exists h:set, homeomorphism X Tx (Sn 2) (Sn_topology 2) h) \/
     (exists n:set, n :e omega /\ n <> 0 /\
       exists h:set, homeomorphism X Tx
         (n_fold_torus_space n) (n_fold_torus_topology n) h) \/
     (exists m:set, m :e omega /\ m <> 0 /\
       exists h:set, homeomorphism X Tx
         (m_fold_projective_plane_space m) (m_fold_projective_plane_topology m) h)) /\
    exists discs:set, function_on discs k (Power X) /\
      (forall i:set, i :e k -> apply_fun discs i :e Tx) /\
      (forall i j:set, i :e k -> j :e k -> i <> j ->
        apply_fun discs i :/\: apply_fun discs j = Empty) /\
      exists h:set, homeomorphism Y Ty
        (X :\: Union (Repl k (fun i => apply_fun discs i)))
        (subspace_topology X Tx (X :\: Union (Repl k (fun i => apply_fun discs i)))) h).
admit.
Qed.

(** from S78 Exercise 1(a) (line 4745 in algtop.tex) **)
(** LATEX VERSION: What space is indicated by labelling scheme abc, dae, bef, cdf **)
(** for four triangular regions? **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex78_1a_four_triangles_sphere :
  (** The space from four triangular regions with scheme abc, dae, bef, cdf **)
  (** is homeomorphic to S^2 (the tetrahedron is a triangulation of S^2) **)
  forall X Tx:set,
    triangulable X Tx ->
    compact_space X Tx -> Hausdorff_space X Tx ->
    (** X has 4 triangles, 6 edges (each appearing exactly twice), 4 vertices **)
    (forall x0:set, x0 :e X -> simply_connected X Tx) ->
    exists h:set, homeomorphism X Tx (Sn 2) (Sn_topology 2) h.
admit.
Qed.

(** from S78 Exercise 1(b) (line 4747 in algtop.tex) **)
(** LATEX VERSION: What space is indicated by labelling scheme abc, cba, def, dfe^{-1} **)
(** for four triangular regions? **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex78_1b_four_triangles_torus :
  (** The space from four triangular regions with scheme abc, cba, def, dfe^{-1} **)
  (** is a surface; specifically homeomorphic to the torus T **)
  forall X Tx:set,
    triangulable X Tx ->
    compact_space X Tx -> Hausdorff_space X Tx ->
    (forall x0:set, x0 :e X ->
      exists phi:set, group_isomorphism
        (fundamental_group X Tx x0) (fundamental_group_mult X Tx x0)
        (setprod int int) (product_group_mult int integers_group_mult int integers_group_mult) phi) ->
    exists h:set, homeomorphism X Tx torus torus_topology h.
admit.
Qed.

(** from S78 Exercise 3 (line 4752 in algtop.tex) **)
(** LATEX VERSION: Show that the closed unit ball in R^2 is a 2-manifold with boundary. **)
(** EFFORT: 4 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex78_3_closed_ball_two_manifold_with_boundary :
  two_manifold_with_boundary (Bn_closed 2) (Bn_closed_topology 2) /\
  manifold_boundary (Bn_closed 2) (Bn_closed_topology 2) = Sn (ordsucc 0).
admit.
Qed.

(** from S78 Exercise 4 (line 4753 in algtop.tex) **)
(** LATEX VERSION: Let X be a 2-manifold; let U1,...,Uk be disjoint open sets **)
(** each homeomorphic to B^2 via h_i. Then Y = X - union of h_i(B_epsilon) **)
(** is a 2-manifold with boundary, and partial Y has k components. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex78_4_manifold_with_holes :
  forall X Tx:set,
  Hausdorff_space X Tx -> second_countable_space X Tx ->
  (forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      exists V:set, V :e R2_topology /\
      exists h:set, homeomorphism U (subspace_topology X Tx U)
        V (subspace_topology (setprod R R) R2_topology V) h) ->
  forall k:set, k :e omega -> k <> 0 ->
  forall discs:set,
    function_on discs k (Power X) ->
    (forall i:set, i :e k -> apply_fun discs i :e Tx) ->
    (forall i:set, i :e k ->
      exists h:set, homeomorphism
        B2 B2_topology
        (apply_fun discs i) (subspace_topology X Tx (apply_fun discs i)) h) ->
    (forall i j:set, i :e k -> j :e k -> i <> j ->
      apply_fun discs i :/\: apply_fun discs j = Empty) ->
    let Y := X :\: Union (Repl k (fun i => apply_fun discs i)) in
    two_manifold_with_boundary Y (subspace_topology X Tx Y) /\
    (exists comps:set, function_on comps k (Power Y) /\
      manifold_boundary Y (subspace_topology X Tx Y) =
        Union (Repl k (fun i => apply_fun comps i)) /\
      (forall i:set, i :e k ->
        connected_space (apply_fun comps i)
          (subspace_topology Y (subspace_topology X Tx Y) (apply_fun comps i))) /\
      (forall i j:set, i :e k -> j :e k -> i <> j ->
        apply_fun comps i :/\: apply_fun comps j = Empty)).
admit.
Qed.

(** ============================================================ **)
(** CHAPTER 13: Classification of Covering Spaces                **)
(** ============================================================ **)

(** ============================================================ **)
(** S79 Equivalence of Covering Spaces                           **)
(** (lines 4784-4948 in algtop.tex)                              **)
(** ============================================================ **)

(** from S79 Definition (line 4787 in algtop.tex): equivalence of covering maps **)
(** LATEX VERSION: Let p: E -> B and p': E' -> B be covering maps. They are said **)
(** to be equivalent if there exists a homeomorphism h: E -> E' such that p = p' o h. **)
Definition equivalent_covering_maps : set -> set -> set -> set -> set -> set -> set -> set -> prop :=
  fun E Te E' Te' B Tb p p' =>
    covering_map E Te B Tb p /\
    covering_map E' Te' B Tb p' /\
    exists h:set,
      homeomorphism E Te E' Te' h /\
      (forall x:set, x :e E -> apply_fun p x = apply_fun p' (apply_fun h x)).

(** from S79 Lemma 79.1 (line 4792 in algtop.tex): the general lifting lemma **)
(** LATEX VERSION: Let p: E -> B be covering, p(e0)=b0. Let f: Y -> B continuous **)
(** with f(y0)=b0. If Y is path connected and locally path connected, then f lifts **)
(** from S79 Lemma 79.1 (line 4792 in algtop.tex): general lifting lemma **)
(** to f_tilde: Y -> E with f_tilde(y0)=e0 iff f_star(pi1(Y,y0)) subset p_star(pi1(E,e0)). **)
(** Furthermore, if such a lifting exists, it is unique. **)
(** EFFORT: 40 lines textbook, difficulty 7/10, USD 560 **)
Theorem lemma79_1_general_lifting :
  forall E Te B Tb p e0 Y Ty y0 f:set,
  covering_map E Te B Tb p ->
  e0 :e E -> apply_fun p e0 = apply_fun f y0 ->
  path_connected_space Y Ty -> locally_path_connected Y Ty ->
  continuous_map Y Ty B Tb f -> y0 :e Y ->
  (** f lifts iff f_star(pi1(Y,y0)) subset p_star(pi1(E,e0)) **)
  ((exists ft:set,
      continuous_map Y Ty E Te ft /\
      apply_fun ft y0 = e0 /\
      (forall y:set, y :e Y -> apply_fun p (apply_fun ft y) = apply_fun f y))
   <->
   (forall cls:set,
     cls :e homomorphism_image
       (fundamental_group Y Ty y0)
       (induced_homomorphism Y Ty y0 B Tb (apply_fun f y0) f) ->
     cls :e homomorphism_image
       (fundamental_group E Te e0)
       (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))) /\
  (** uniqueness **)
  (forall ft1 ft2:set,
    continuous_map Y Ty E Te ft1 -> continuous_map Y Ty E Te ft2 ->
    apply_fun ft1 y0 = e0 -> apply_fun ft2 y0 = e0 ->
    (forall y:set, y :e Y -> apply_fun p (apply_fun ft1 y) = apply_fun f y) ->
    (forall y:set, y :e Y -> apply_fun p (apply_fun ft2 y) = apply_fun f y) ->
    forall y:set, y :e Y -> apply_fun ft1 y = apply_fun ft2 y).
admit.
Qed.

(** from S79 Theorem 79.2 (line 4836 in algtop.tex): equivalence iff same subgroup **)
(** LATEX VERSION: Let p: E -> B and p': E' -> B be covering maps with **)
(** p(e0) = p'(e0') = b0. There is an equivalence h: E -> E' with h(e0)=e0' **)
(** iff H0 = H0', where H0 = p_star(pi1(E,e0)), H0' = p'_star(pi1(E',e0')). **)
(** If h exists, it is unique. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm79_2_equivalence_iff_same_subgroup :
  forall E Te E' Te' B Tb p p' e0 e0':set,
  covering_map E Te B Tb p ->
  covering_map E' Te' B Tb p' ->
  e0 :e E -> e0' :e E' ->
  apply_fun p e0 = apply_fun p' e0' ->
  path_connected_space E Te -> locally_path_connected E Te ->
  path_connected_space E' Te' -> locally_path_connected E' Te' ->
  ((exists h:set,
      homeomorphism E Te E' Te' h /\
      apply_fun h e0 = e0' /\
      (forall x:set, x :e E -> apply_fun p x = apply_fun p' (apply_fun h x)))
   <->
   homomorphism_image
     (fundamental_group E Te e0)
     (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p) =
   homomorphism_image
     (fundamental_group E' Te' e0')
     (induced_homomorphism E' Te' e0' B Tb (apply_fun p' e0') p')).
admit.
Qed.

(** Infrastructure: conjugate subgroups **)
(** H1 and H2 are conjugate subgroups of G if H2 = alpha H1 alpha^{-1} for some alpha in G **)
Definition conjugate_subgroups : set -> set -> set -> set -> set -> set -> prop :=
  fun H1 H2 G mult e inv =>
    subgroup_of H1 G mult e inv /\
    subgroup_of H2 G mult e inv /\
    exists alpha:set, alpha :e G /\
      H2 = {apply_fun mult (apply_fun mult (alpha, h), apply_fun inv alpha) | h :e H1}.

(** from S79 Lemma 79.3 (line 4862 in algtop.tex): conjugacy of subgroups **)
(** LATEX VERSION: Let p: E -> B be covering. Let e0, e1 in p^{-1}(b0), **)
(** Hi = p_star(pi1(E,ei)). **)
(** (a) If gamma is a path in E from e0 to e1, and alpha = p o gamma, **)
(** from S79 Lemma 79.3(a) (line 4862 in algtop.tex): conjugacy of subgroups **)
(** then [alpha] H1 [alpha]^{-1} = H0, so H0 and H1 are conjugate. **)
(** (b) Given e0 and H conjugate to H0, exists e1 in p^{-1}(b0) with H1 = H. **)
(** EFFORT: 20 lines textbook, difficulty 5/10, USD 200 **)
Theorem lemma79_3a_conjugacy_of_subgroups :
  forall E Te B Tb p e0 e1:set,
  covering_map E Te B Tb p ->
  e0 :e E -> e1 :e E ->
  apply_fun p e0 = apply_fun p e1 ->
  path_connected_space E Te ->
  conjugate_subgroups
    (homomorphism_image
      (fundamental_group E Te e1)
      (induced_homomorphism E Te e1 B Tb (apply_fun p e1) p))
    (homomorphism_image
      (fundamental_group E Te e0)
      (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
    (fundamental_group B Tb (apply_fun p e0))
    (fundamental_group_mult B Tb (apply_fun p e0))
    (fundamental_group_id B Tb (apply_fun p e0))
    (fundamental_group_inv B Tb (apply_fun p e0)).
admit.
Qed.

(** from S79 Lemma 79.3(b) (line 4862 in algtop.tex): conjugacy converse **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma79_3b_conjugacy_converse :
  forall E Te B Tb p e0:set,
  covering_map E Te B Tb p ->
  e0 :e E ->
  path_connected_space E Te ->
  forall H:set,
    conjugate_subgroups
      H
      (homomorphism_image
        (fundamental_group E Te e0)
        (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
      (fundamental_group B Tb (apply_fun p e0))
      (fundamental_group_mult B Tb (apply_fun p e0))
      (fundamental_group_id B Tb (apply_fun p e0))
      (fundamental_group_inv B Tb (apply_fun p e0)) ->
    exists e1:set, e1 :e E /\ apply_fun p e1 = apply_fun p e0 /\
      homomorphism_image
        (fundamental_group E Te e1)
        (induced_homomorphism E Te e1 B Tb (apply_fun p e1) p) = H.
admit.
Qed.

(** from S79 Theorem 79.4 (line 4890 in algtop.tex): equivalence iff conjugate subgroups **)
(** LATEX VERSION: The covering maps p and p' are equivalent iff the subgroups **)
(** H0 = p_star(pi1(E,e0)) and H0' = p'_star(pi1(E',e0')) are conjugate in pi1(B,b0). **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 100 **)
Theorem thm79_4_equivalence_iff_conjugate :
  forall E Te E' Te' B Tb p p' e0 e0':set,
  covering_map E Te B Tb p ->
  covering_map E' Te' B Tb p' ->
  e0 :e E -> e0' :e E' ->
  apply_fun p e0 = apply_fun p' e0' ->
  path_connected_space E Te -> locally_path_connected E Te ->
  path_connected_space E' Te' -> locally_path_connected E' Te' ->
  (equivalent_covering_maps E Te E' Te' B Tb p p'
   <->
   conjugate_subgroups
     (homomorphism_image
       (fundamental_group E Te e0)
       (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
     (homomorphism_image
       (fundamental_group E' Te' e0')
       (induced_homomorphism E' Te' e0' B Tb (apply_fun p' e0') p'))
     (fundamental_group B Tb (apply_fun p e0))
     (fundamental_group_mult B Tb (apply_fun p e0))
     (fundamental_group_id B Tb (apply_fun p e0))
     (fundamental_group_inv B Tb (apply_fun p e0))).
admit.
Qed.

(** from S79 Exercises Exercise 5b / Theorem (line 4925 in algtop.tex): torus covering spaces **)
(** LATEX VERSION: If E is a covering space of the torus T, then E is homeomorphic **)
(** either to R^2, or to S^1 x R, or to T. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 150 **)
Theorem ex79_5b_torus_covering_classification :
  forall E Te p:set,
  covering_map E Te torus torus_topology p ->
  path_connected_space E Te -> locally_path_connected E Te ->
  (exists h:set, homeomorphism E Te (setprod R R) R2_topology h) \/
  (exists h:set, homeomorphism E Te
    (setprod S1 R) (product_topology S1 S1_topology R R_standard_topology) h) \/
  (exists h:set, homeomorphism E Te torus torus_topology h).
admit.
Qed.

(** from S79 Exercise 1 (line 4911 in algtop.tex) **)
(** LATEX VERSION: If n > 1, every continuous map f: S^n -> S^1 is nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex79_1_Sn_to_S1_nulhomotopic : forall n:set,
  n :e omega -> 1 :e n ->
  forall f:set,
    continuous_map (Sn n) (Sn_topology n) S1 S1_topology f ->
    nulhomotopic (Sn n) (Sn_topology n) S1 S1_topology f.
admit.
Qed.

(** from S79 Exercise 2(a) (line 4912 in algtop.tex) **)
(** LATEX VERSION: Every continuous map f: P^2 -> S^1 is nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex79_2a_P2_to_S1_nulhomotopic :
  forall f:set,
    continuous_map (m_fold_projective_plane_space 1)
      (m_fold_projective_plane_topology 1) S1 S1_topology f ->
    nulhomotopic (m_fold_projective_plane_space 1)
      (m_fold_projective_plane_topology 1) S1 S1_topology f.
admit.
Qed.

(** from S79 Exercise 2(b) (line 4913 in algtop.tex) **)
(** LATEX VERSION: There exists a continuous map of the torus into S^1 that is not nulhomotopic. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex79_2b_torus_to_S1_not_nulhomotopic :
  exists f:set,
    continuous_map torus torus_topology S1 S1_topology f /\
    ~(nulhomotopic torus torus_topology S1 S1_topology f).
admit.
Qed.

(** from S79 Exercise 3 (line 4914 in algtop.tex) **)
(** LATEX VERSION: p-star(pi1(E,e0)) is normal in pi1(B,b0) iff for every **)
(** pair e1,e2 in p^{-1}(b0), there is an equivalence h: E -> E with h(e1) = e2. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex79_3_normal_subgroup_criterion : forall E Te B Tb p e0:set,
  covering_map E Te B Tb p ->
  path_connected_space E Te -> locally_path_connected E Te ->
  path_connected_space B Tb -> locally_path_connected B Tb ->
  apply_fun p e0 :e B -> e0 :e E ->
  (normal_subgroup
    (homomorphism_image
      (fundamental_group E Te e0)
      (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
    (fundamental_group B Tb (apply_fun p e0))
    (fundamental_group_mult B Tb (apply_fun p e0))
    (fundamental_group_id B Tb (apply_fun p e0))
    (fundamental_group_inv B Tb (apply_fun p e0))
  <->
  (forall e1 e2:set, e1 :e E -> e2 :e E ->
    apply_fun p e1 = apply_fun p e0 -> apply_fun p e2 = apply_fun p e0 ->
    exists h:set, homeomorphism E Te E Te h /\
      apply_fun h e1 = e2 /\
      (forall x:set, x :e E -> apply_fun p (apply_fun h x) = apply_fun p x))).
admit.
Qed.

(** from S79 Exercise 7 (line 4947 in algtop.tex) **)
(** LATEX VERSION: Let p: G-tilde -> G be a homomorphism of topological groups **)
(** that is a covering map. If G is abelian, so is G-tilde. **)
(** EFFORT: 3 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex79_7_abelian_covering_group : forall G Tg Gtilde Tgt p multG multGt:set,
  topological_group G Tg ->
  topological_group Gtilde Tgt ->
  covering_map Gtilde Tgt G Tg p ->
  function_on multG (setprod G G) G ->
  function_on multGt (setprod Gtilde Gtilde) Gtilde ->
  (forall x y:set, x :e Gtilde -> y :e Gtilde ->
    apply_fun p (apply_fun multGt (x, y)) = apply_fun multG (apply_fun p x, apply_fun p y)) ->
  (forall x y:set, x :e G -> y :e G ->
    apply_fun multG (x, y) = apply_fun multG (y, x)) ->
  forall x y:set, x :e Gtilde -> y :e Gtilde ->
    apply_fun multGt (x, y) = apply_fun multGt (y, x).
admit.
Qed.

(** from S79 Exercise 4(a) (line 4915 in algtop.tex) **)
(** LATEX VERSION: Find a covering space of T = S^1 x S^1 corresponding to **)
(** the subgroup of Z x Z generated by m x 0, where m is a positive integer. **)
(** Answer: S^1 x R covers T via the map (z, t) -> (z^m, exp(2pi i t)). **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex79_4a_torus_covering_cyclic : forall m:set,
  m :e omega -> m <> 0 ->
  exists E Te p e0:set,
    covering_map E Te torus torus_topology p /\
    e0 :e E /\ apply_fun p e0 = (S1_basepoint, S1_basepoint) /\
    (** The covering corresponds to the subgroup mZ x 0 of Z x Z **)
    (** The fiber over (b0,b0) has exactly m points **)
    equip (preimage_of E p (Sing (S1_basepoint, S1_basepoint))) m.
admit.
Qed.

(** from S79 Exercise 4(b) (line 4916 in algtop.tex) **)
(** LATEX VERSION: Find a covering space of T corresponding to the trivial subgroup. **)
(** Answer: R x R = R^2 is the universal covering of T. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex79_4b_torus_universal_covering :
  exists E Te p:set,
    covering_map E Te torus torus_topology p /\
    simply_connected E Te.
admit.
Qed.

(** from S79 Exercise 4(c) (line 4917 in algtop.tex) **)
(** LATEX VERSION: Find a covering space of T corresponding to the subgroup **)
(** generated by m x 0 and 0 x n, where m, n are positive integers. **)
(** Answer: T itself via the map (z, w) -> (z^m, w^n). Fiber has mn points. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex79_4c_torus_covering_finite : forall m n:set,
  m :e omega -> m <> 0 -> n :e omega -> n <> 0 ->
  exists E Te p e0:set,
    covering_map E Te torus torus_topology p /\
    e0 :e E /\ apply_fun p e0 = (S1_basepoint, S1_basepoint) /\
    (** The fiber over (b0,b0) has exactly mn points **)
    equip (preimage_of E p (Sing (S1_basepoint, S1_basepoint))) (mul_SNo m n).
admit.
Qed.

(** from S79 Exercise 5(a) / Theorem (line 4920 in algtop.tex) **)
(** LATEX VERSION: Every isomorphism of pi1(T, x0) with itself is induced **)
(** by a homeomorphism of T with itself that maps x0 to x0. **)
(** EFFORT: 12 lines textbook, difficulty 6/10, USD 200 **)
Theorem ex79_5a_torus_automorphism :
  let x0 := (S1_basepoint, S1_basepoint) in
  forall phi:set,
    group_isomorphism
      (fundamental_group torus torus_topology x0)
      (fundamental_group_mult torus torus_topology x0)
      (fundamental_group torus torus_topology x0)
      (fundamental_group_mult torus torus_topology x0)
      phi ->
    exists h:set,
      homeomorphism torus torus_topology torus torus_topology h /\
      apply_fun h x0 = x0 /\
      (forall cls:set, cls :e fundamental_group torus torus_topology x0 ->
        apply_fun (induced_homomorphism torus torus_topology x0 torus torus_topology x0
          (graph torus (fun y:set => apply_fun h y))) cls =
        apply_fun phi cls).
admit.
Qed.

(** ============================================================ **)
(** S80 The Universal Covering Space                             **)
(** (lines 4949-5017 in algtop.tex)                              **)
(** ============================================================ **)

(** from S80 Definition (line 4950 in algtop.tex): universal covering space **)
(** LATEX VERSION: If E is simply connected and p: E -> B is covering, then E **)
(** is called a universal covering space of B. **)
(** Note: this is implicitly defined in the text, not a separate formal definition **)

(** from S80 Lemma 80.1 (line 4954 in algtop.tex): path component restriction **)
(** LATEX VERSION: Let B be path connected and locally path connected. Let p: E -> B **)
(** be a covering map (E not required path connected). If E0 is a path component of E, **)
(** then the restriction p0: E0 -> B is a covering map. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma80_1_path_component_covering :
  forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  path_connected_space B Tb -> locally_path_connected B Tb ->
  forall E0:set,
    E0 c= E -> E0 <> Empty ->
    path_connected_space E0 (subspace_topology E Te E0) ->
    (forall x:set, x :e E ->
      (exists y:set, y :e E0 /\ exists gamma:set,
        continuous_map unit_interval unit_interval_topology E Te gamma /\
        apply_fun gamma 0 = x /\ apply_fun gamma 1 = y) ->
      x :e E0) ->
    covering_map E0 (subspace_topology E Te E0) B Tb
      (graph E0 (fun x:set => apply_fun p x)).
admit.
Qed.

(** from S80 Lemma 80.2a (line 4962 in algtop.tex): if p and r covering, so is q **)
(** LATEX VERSION: Let p = r o q with p: X -> Z, q: X -> Y, r: Y -> Z. **)
(** (a) If p and r are covering maps, so is q. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem lemma80_2a_covering_composition :
  forall X Tx Y Ty Z Tz q r:set,
  path_connected_space X Tx -> locally_path_connected X Tx ->
  path_connected_space Y Ty -> locally_path_connected Y Ty ->
  path_connected_space Z Tz -> locally_path_connected Z Tz ->
  covering_map X Tx Z Tz (compose_fun X q r) ->
  covering_map Y Ty Z Tz r ->
  continuous_map X Tx Y Ty q ->
  covering_map X Tx Y Ty q.
admit.
Qed.

(** from S80 Lemma 80.2b (line 4965 in algtop.tex): if p and q covering, so is r **)
(** LATEX VERSION: (b) If p and q are covering maps, so is r. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 280 **)
Theorem lemma80_2b_covering_composition :
  forall X Tx Y Ty Z Tz q r:set,
  path_connected_space X Tx -> locally_path_connected X Tx ->
  path_connected_space Y Ty -> locally_path_connected Y Ty ->
  path_connected_space Z Tz -> locally_path_connected Z Tz ->
  covering_map X Tx Z Tz (compose_fun X q r) ->
  covering_map X Tx Y Ty q ->
  continuous_map Y Ty Z Tz r ->
  surjective_map Y Z r ->
  covering_map Y Ty Z Tz r.
admit.
Qed.

(** from S80 Theorem 80.3 (line 4983 in algtop.tex): universal covering covers everything **)
(** LATEX VERSION: Let p: E -> B be covering with E simply connected. Given any **)
(** covering map r: Y -> B, there is a covering map q: E -> Y such that r o q = p. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm80_3_universal_covers_everything :
  forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  simply_connected E Te ->
  locally_path_connected E Te ->
  forall Y Ty r:set,
    covering_map Y Ty B Tb r ->
    locally_path_connected Y Ty ->
    exists q:set,
      covering_map E Te Y Ty q /\
      (forall x:set, x :e E ->
        apply_fun r (apply_fun q x) = apply_fun p x).
admit.
Qed.

(** from S80 Lemma 80.4 (line 4997 in algtop.tex): necessary condition for universal cover **)
(** LATEX VERSION: Let p: E -> B covering with E simply connected. Then b0 has a **)
(** neighborhood U such that inclusion i: U -> B induces the trivial homomorphism **)
(** i_star: pi1(U,b0) -> pi1(B,b0). **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma80_4_universal_cover_semilocal :
  forall E Te B Tb p:set,
  covering_map E Te B Tb p ->
  simply_connected E Te ->
  forall b0:set, b0 :e B ->
    exists U:set, U :e Tb /\ b0 :e U /\
      (forall cls:set,
        cls :e fundamental_group U (subspace_topology B Tb U) b0 ->
        apply_fun
          (induced_homomorphism U (subspace_topology B Tb U) b0 B Tb b0
            (graph U (fun x:set => x)))
          cls =
        fundamental_group_id B Tb b0).
admit.
Qed.

(** from S79 Exercises Exercise 6 / Theorem (line 4929 in algtop.tex): topological group lifting **)
(** LATEX VERSION: Let G be a topological group with multiplication m and identity e. **)
(** If p: Gtilde -> G is a covering map with p(etilde) = e, there is a unique **)
(** from S79 Exercise 6 (line 4909 in algtop.tex): topological group covering lift **)
(** multiplication on Gtilde making it a topological group with identity etilde **)
(** such that p is a homomorphism. **)
(** EFFORT: 20 lines textbook, difficulty 7/10, USD 400 **)
Theorem ex79_6_topological_group_covering_lift :
  forall G Tg multG eG invG:set,
  topological_group G Tg ->
  function_on multG (setprod G G) G ->
  function_on invG G G ->
  eG :e G ->
  (forall x y z:set, x :e G -> y :e G -> z :e G ->
    apply_fun multG (apply_fun multG (x,y), z) = apply_fun multG (x, apply_fun multG (y,z))) ->
  (forall x:set, x :e G -> apply_fun multG (eG,x) = x /\ apply_fun multG (x,eG) = x) ->
  (forall x:set, x :e G -> apply_fun multG (x, apply_fun invG x) = eG /\
    apply_fun multG (apply_fun invG x, x) = eG) ->
  continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg multG ->
  continuous_map G Tg G Tg invG ->
  forall Gt Tgt p etilde:set,
  covering_map Gt Tgt G Tg p ->
  path_connected_space Gt Tgt -> locally_path_connected Gt Tgt ->
  etilde :e Gt -> apply_fun p etilde = eG ->
  (** There exists a unique group structure on Gtilde making p a homomorphism **)
  exists multGt invGt:set,
    topological_group Gt Tgt /\
    function_on multGt (setprod Gt Gt) Gt /\
    function_on invGt Gt Gt /\
    (forall x y:set, x :e Gt -> y :e Gt ->
      apply_fun p (apply_fun multGt (x,y)) = apply_fun multG (apply_fun p x, apply_fun p y)) /\
    (forall x:set, x :e Gt -> apply_fun p (apply_fun invGt x) = apply_fun invG (apply_fun p x)) /\
    (forall x:set, x :e Gt ->
      apply_fun multGt (etilde, x) = x /\ apply_fun multGt (x, etilde) = x) /\
    (forall x:set, x :e Gt ->
      apply_fun multGt (x, apply_fun invGt x) = etilde /\
      apply_fun multGt (apply_fun invGt x, x) = etilde) /\
    continuous_map (setprod Gt Gt) (product_topology Gt Tgt Gt Tgt) Gt Tgt multGt /\
    continuous_map Gt Tgt Gt Tgt invGt.
admit.
Qed.

(** from S80 Exercise 1(a) (line 5012 in algtop.tex) **)
(** LATEX VERSION: Let q: X -> Y and r: Y -> Z be covering maps. Show that **)
(** if Z has a universal covering space, then p = r o q is a covering map. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem ex80_1a_composition_of_coverings :
  forall X Tx Y Ty Z Tz q r:set,
  covering_map X Tx Y Ty q ->
  covering_map Y Ty Z Tz r ->
  (** Z has a universal covering space **)
  (exists U Tu p:set, covering_map U Tu Z Tz p /\ simply_connected U Tu) ->
  covering_map X Tx Z Tz
    (graph X (fun x:set => apply_fun r (apply_fun q x))).
admit.
Qed.

(** from S80 Exercise 1(b) (line 5013 in algtop.tex) **)
(** LATEX VERSION: Give an example where q and r are covering maps but p = r o q is not. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex80_1b_composition_not_covering :
  exists X Tx Y Ty Z Tz q r:set,
    covering_map X Tx Y Ty q /\
    covering_map Y Ty Z Tz r /\
    ~(covering_map X Tx Z Tz
      (graph X (fun x:set => apply_fun r (apply_fun q x)))).
admit.
Qed.

(** ============================================================ **)
(** S81 Covering Transformations                                 **)
(** (lines 5019-5221 in algtop.tex)                              **)
(** ============================================================ **)

(** from S81 text (line 5020 in algtop.tex): covering transformation **)
(** LATEX VERSION: An equivalence of a covering space with itself is called a **)
(** covering transformation. The set of all covering transformations forms a group **)
(** called C(E,p,B). **)
Definition covering_transformation : set -> set -> set -> set -> set -> set -> prop :=
  fun E Te B Tb p h =>
    homeomorphism E Te E Te h /\
    (forall x:set, x :e E -> apply_fun p (apply_fun h x) = apply_fun p x).

Definition covering_transformation_group : set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p =>
    {h :e function_space E E | covering_transformation E Te B Tb p h}.

(** Infrastructure: multiplication on C(E,p,B) = composition **)
Definition covering_transformation_mult : set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p =>
    graph (setprod (covering_transformation_group E Te B Tb p)
                   (covering_transformation_group E Te B Tb p))
      (fun pr:set => compose_fun E (pr 0) (pr 1)).

(** Infrastructure: identity covering transformation **)
Definition covering_transformation_id : set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p => graph E (fun x:set => x).

(** Infrastructure: inverse covering transformation **)
Definition covering_transformation_inv : set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p =>
    graph (covering_transformation_group E Te B Tb p)
      (fun h:set => Eps_i (fun k:set =>
        k :e covering_transformation_group E Te B Tb p /\
        (forall x:set, x :e E -> apply_fun k (apply_fun h x) = x))).

(** from S81 Definition (line 5025 in algtop.tex): normalizer **)
(** LATEX VERSION: If H is a subgroup of the group G, then the normalizer of H in G **)
(** is N(H) = {g in G | gHg^{-1} = H}. **)
Definition normalizer : set -> set -> set -> set -> set -> set :=
  fun H G mult e inv =>
    {g :e G |
      (forall h:set, h :e H ->
        apply_fun mult (apply_fun mult (g, h), apply_fun inv g) :e H) /\
      (forall h:set, h :e H ->
        apply_fun mult (apply_fun mult (apply_fun inv g, h), g) :e H)}.

(** from S81 Definition (line 5035 in algtop.tex): the map Psi: C(E,p,B) -> F **)
(** LATEX VERSION: Define Psi(h) = h(e0) for each covering transformation h. **)
(** Psi is injective since h is determined by h(e0). **)
Definition covering_trans_evaluation : set -> set -> set -> set -> set -> set -> set :=
  fun E Te B Tb p e0 =>
    graph (covering_transformation_group E Te B Tb p)
      (fun h:set => apply_fun h e0).

(** from S81 Lemma 81.1 (line 5049 in algtop.tex) **)
(** LATEX VERSION: The image of Psi equals the image under Phi of the **)
(** subgroup N(H0)/H0 of pi1(B,b0)/H0. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem lemma81_1_image_of_psi :
  forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  path_connected_space E Te -> locally_path_connected E Te ->
  forall e1:set, e1 :e E -> apply_fun p e1 = apply_fun p e0 ->
  (** there is a covering transformation h with h(e0) = e1 **)
  (exists h:set, covering_transformation E Te B Tb p h /\ apply_fun h e0 = e1)
  <->
  (** iff the corresponding element of pi1 is in N(H0) **)
  (forall alpha:set,
    loop_at B Tb (apply_fun p e0) alpha ->
    apply_fun (path_lift E Te B Tb p e0 alpha) 1 = e1 ->
    path_homotopy_class_loop B Tb (apply_fun p e0) alpha :e
      normalizer
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
        (fundamental_group B Tb (apply_fun p e0))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (fundamental_group_id B Tb (apply_fun p e0))
        (fundamental_group_inv B Tb (apply_fun p e0))).
admit.
Qed.

(** from S81 Theorem 81.2 (line 5055 in algtop.tex) **)
(** LATEX VERSION: The bijection Phi^{-1} o Psi : C(E,p,B) -> N(H0)/H0 **)
(** is an isomorphism of groups. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem thm81_2_covering_trans_isomorphism :
  forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  path_connected_space E Te -> locally_path_connected E Te ->
  exists phi:set,
    group_isomorphism
      (covering_transformation_group E Te B Tb p)
      (covering_transformation_mult E Te B Tb p)
      (quotient_group_set
        (normalizer
          (homomorphism_image
            (fundamental_group E Te e0)
            (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
          (fundamental_group B Tb (apply_fun p e0))
          (fundamental_group_mult B Tb (apply_fun p e0))
          (fundamental_group_id B Tb (apply_fun p e0))
          (fundamental_group_inv B Tb (apply_fun p e0)))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)))
      (quotient_group_mult
        (normalizer
          (homomorphism_image
            (fundamental_group E Te e0)
            (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
          (fundamental_group B Tb (apply_fun p e0))
          (fundamental_group_mult B Tb (apply_fun p e0))
          (fundamental_group_id B Tb (apply_fun p e0))
          (fundamental_group_inv B Tb (apply_fun p e0)))
        (fundamental_group_mult B Tb (apply_fun p e0))
        (homomorphism_image
          (fundamental_group E Te e0)
          (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p)))
      phi.
admit.
Qed.

(** from S81 Definition (line 5103 in algtop.tex): regular covering map **)
(** LATEX VERSION: If H0 is a normal subgroup of pi1(B,b0), then p: E -> B **)
(** is called a regular covering map. **)
Definition regular_covering_map : set -> set -> set -> set -> set -> set -> prop :=
  fun E Te B Tb p e0 =>
    covering_map E Te B Tb p /\ e0 :e E /\
    normal_subgroup
      (homomorphism_image
        (fundamental_group E Te e0)
        (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p))
      (fundamental_group B Tb (apply_fun p e0))
      (fundamental_group_mult B Tb (apply_fun p e0))
      (fundamental_group_id B Tb (apply_fun p e0))
      (fundamental_group_inv B Tb (apply_fun p e0)).

(** from S81 Corollary 81.3 (line 5091 in algtop.tex) **)
(** LATEX VERSION: H0 is normal in pi1(B,b0) iff for every pair e1,e2 in p^{-1}(b0) **)
(** there is a covering transformation h with h(e1)=e2. In this case, **)
(** C(E,p,B) is isomorphic to pi1(B,b0)/H0. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor81_3_normal_iff_transitive :
  forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  path_connected_space E Te -> locally_path_connected E Te ->
  (regular_covering_map E Te B Tb p e0
   <->
   (forall e1 e2:set, e1 :e E -> e2 :e E ->
     apply_fun p e1 = apply_fun p e0 ->
     apply_fun p e2 = apply_fun p e0 ->
     exists h:set, covering_transformation E Te B Tb p h /\ apply_fun h e1 = e2)).
admit.
Qed.

(** from S81 Corollary 81.4 (line 5097 in algtop.tex) **)
(** LATEX VERSION: If E is simply connected, then C(E,p,B) is isomorphic to pi1(B,b0). **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem cor81_4_simply_connected_covering_trans :
  forall E Te B Tb p e0:set,
  covering_map E Te B Tb p -> e0 :e E ->
  simply_connected E Te ->
  locally_path_connected E Te ->
  exists phi:set,
    group_isomorphism
      (covering_transformation_group E Te B Tb p)
      (covering_transformation_mult E Te B Tb p)
      (fundamental_group B Tb (apply_fun p e0))
      (fundamental_group_mult B Tb (apply_fun p e0))
      phi.
admit.
Qed.

(** from S81 Definition (line 5121 in algtop.tex): orbit space **)
(** LATEX VERSION: Let G be a subgroup of homeomorphisms of X. The orbit space X/G **)
(** is the quotient space by the relation x ~ g(x) for all g in G. **)
Definition orbit_equiv : set -> set -> set -> set -> prop :=
  fun X G x y =>
    x :e X /\ y :e X /\
    exists g:set, g :e G /\ apply_fun g x = y.

Definition orbit_space : set -> set -> set :=
  fun X G =>
    {cls :e Power X | exists x:set, x :e X /\ cls = {y :e X | orbit_equiv X G x y}}.

Definition orbit_map : set -> set -> set :=
  fun X G =>
    graph X (fun x:set => {y :e X | orbit_equiv X G x y}).

Definition orbit_topology : set -> set -> set -> set :=
  fun X Tx G =>
    quotient_topology X Tx (orbit_space X G) (orbit_map X G).

(** from S81 Definition (line 5123 in algtop.tex): properly discontinuous action **)
(** LATEX VERSION: The action of G on X is properly discontinuous if for every x in X **)
(** there is a neighborhood U of x such that g(U) is disjoint from U whenever g /= e. **)
Definition properly_discontinuous : set -> set -> set -> set -> prop :=
  fun X Tx G idG =>
    (forall x:set, x :e X ->
      exists U:set, U :e Tx /\ x :e U /\
        (forall g:set, g :e G -> g <> idG ->
          apply_fun g x :e X /\
          (forall y:set, y :e U -> apply_fun g y /:e U))).

(** from S81 Theorem 81.5 (line 5125 in algtop.tex) **)
(** LATEX VERSION: Let X be path connected and locally path connected; let G be a **)
(** group of homeomorphisms of X. The quotient map pi: X -> X/G is a covering map **)
(** from S81 Theorem 81.5 (line 5125 in algtop.tex): properly discontinuous covering **)
(** iff the action of G is properly discontinuous. In this case, pi is regular **)
(** and G is its group of covering transformations. **)
(** EFFORT: 25 lines textbook, difficulty 7/10, USD 350 **)
Theorem thm81_5_properly_discontinuous_covering :
  forall X Tx G idG:set,
  path_connected_space X Tx -> locally_path_connected X Tx ->
  (forall g:set, g :e G -> homeomorphism X Tx X Tx g) ->
  idG :e G -> (forall x:set, x :e X -> apply_fun idG x = x) ->
  (covering_map X Tx (orbit_space X G) (orbit_topology X Tx G) (orbit_map X G)
   <->
   properly_discontinuous X Tx G idG).
admit.
Qed.

(** from S81 Theorem 81.6 (line 5137 in algtop.tex) **)
(** LATEX VERSION: If p: X -> B is regular with covering transformation group G, **)
(** then there is a homeomorphism k: X/G -> B such that p = k o pi. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm81_6_regular_orbit_homeomorphism :
  forall X Tx B Tb p e0:set,
  regular_covering_map X Tx B Tb p e0 ->
  path_connected_space X Tx -> locally_path_connected X Tx ->
  exists k:set,
    homeomorphism
      (orbit_space X (covering_transformation_group X Tx B Tb p))
      (orbit_topology X Tx (covering_transformation_group X Tx B Tb p))
      B Tb k /\
    (forall x:set, x :e X ->
      apply_fun k (apply_fun (orbit_map X (covering_transformation_group X Tx B Tb p)) x) =
      apply_fun p x).
admit.
Qed.

(** Infrastructure: fixed-point free group action **)
(** An action of G on X is fixed-point free if no non-identity element has a fixed point. **)
Definition fixed_point_free_action : set -> set -> set -> prop :=
  fun X G idG =>
    (forall g:set, g :e G -> g <> idG ->
      forall x:set, x :e X -> apply_fun g x <> x).

(** from S81 Exercises Exercise 6 / Theorem (line 5214 in algtop.tex): properly discontinuous actions **)
(** LATEX VERSION: Let X be locally compact Hausdorff, G a group of homeomorphisms **)
(** with fixed-point free action. If for each compact C, only finitely many g in G **)
(** have C cap g(C) nonempty, then the action is properly discontinuous and X/G **)
(** is locally compact Hausdorff. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem ex81_6_properly_discontinuous_criterion :
  forall X Tx G idG:set,
  locally_compact X Tx -> Hausdorff_space X Tx ->
  (forall g:set, g :e G -> homeomorphism X Tx X Tx g) ->
  idG :e G -> (forall x:set, x :e X -> apply_fun idG x = x) ->
  fixed_point_free_action X G idG ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) ->
    finite {g :e G | image_of g C :/\: C <> Empty}) ->
  properly_discontinuous X Tx G idG /\
  locally_compact (orbit_space X G) (orbit_topology X Tx G) /\
  Hausdorff_space (orbit_space X G) (orbit_topology X Tx G).
admit.
Qed.

(** from S81 Exercise 1(a) (line 5155 in algtop.tex) **)
(** LATEX VERSION: Find a group G of homeomorphisms of the torus T having order 2 **)
(** such that T/G is homeomorphic to the torus. **)
(** (Answer: G = {id, h} where h(z,w) = (-z, -w) on S^1 x S^1.) **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex81_1a_torus_quotient_torus :
  exists G idG:set,
    (forall g:set, g :e G -> homeomorphism torus torus_topology torus torus_topology g) /\
    idG :e G /\ (forall x:set, x :e torus -> apply_fun idG x = x) /\
    equip G (ordsucc (ordsucc 0)) /\
    properly_discontinuous torus torus_topology G idG /\
    exists h:set, homeomorphism
      (orbit_space torus G) (orbit_topology torus torus_topology G)
      torus torus_topology h.
admit.
Qed.

(** from S81 Exercise 1(b) (line 5156 in algtop.tex) **)
(** LATEX VERSION: Find a group G of homeomorphisms of T having order 2 such that **)
(** T/G is homeomorphic to the Klein bottle. **)
(** (Answer: G = {id, h} where h(z,w) = (-z, conj(w)) on S^1 x S^1.) **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex81_1b_torus_quotient_klein_bottle :
  exists G idG:set,
    (forall g:set, g :e G -> homeomorphism torus torus_topology torus torus_topology g) /\
    idG :e G /\ (forall x:set, x :e torus -> apply_fun idG x = x) /\
    equip G (ordsucc (ordsucc 0)) /\
    properly_discontinuous torus torus_topology G idG /\
    (** T/G is homeomorphic to Klein bottle = P_2 **)
    exists h:set, homeomorphism
      (orbit_space torus G) (orbit_topology torus torus_topology G)
      (m_fold_projective_plane_space (ordsucc (ordsucc 0)))
      (m_fold_projective_plane_topology (ordsucc (ordsucc 0))) h.
admit.
Qed.

(** from S81 Exercise 3(a) (line 5199 in algtop.tex) **)
(** LATEX VERSION: Let p: X -> B be a covering map (not necessarily regular); **)
(** let G be its group of covering transformations. Show the action of G on X **)
(** is properly discontinuous. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex81_3a_covering_trans_properly_discontinuous :
  forall X Tx B Tb p:set,
  covering_map X Tx B Tb p ->
  let G := covering_transformation_group X Tx B Tb p in
  let idG := graph X (fun x:set => x) in
  properly_discontinuous X Tx G idG.
admit.
Qed.

(** from S81 Exercise 3(b) (line 5200 in algtop.tex) **)
(** LATEX VERSION: Show there exists a covering map k: X/G -> B with k o pi = p. **)
(** EFFORT: 5 lines textbook, difficulty 4/10, USD 60 **)
Theorem ex81_3b_quotient_covering :
  forall X Tx B Tb p:set,
  covering_map X Tx B Tb p ->
  path_connected_space X Tx -> locally_path_connected X Tx ->
  let G := covering_transformation_group X Tx B Tb p in
  exists k:set,
    covering_map
      (orbit_space X G) (orbit_topology X Tx G)
      B Tb k /\
    (forall x:set, x :e X ->
      apply_fun k (apply_fun (orbit_map X G) x) = apply_fun p x).
admit.
Qed.

(** from S81 Exercise 4 (line 5203 in algtop.tex) **)
(** LATEX VERSION: If X is Hausdorff and G is a finite group of homeomorphisms **)
(** whose action is fixed-point free, then the action is properly discontinuous. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex81_4_finite_fixed_point_free :
  forall X Tx G idG:set,
  Hausdorff_space X Tx ->
  (forall g:set, g :e G -> homeomorphism X Tx X Tx g) ->
  idG :e G -> (forall x:set, x :e X -> apply_fun idG x = x) ->
  finite G ->
  fixed_point_free_action X G idG ->
  properly_discontinuous X Tx G idG.
admit.
Qed.

(** from S81 Exercise 5 (line 5204 in algtop.tex) **)
(** LATEX VERSION: Consider S^3 as pairs (z1,z2) in C^2 with |z1|^2+|z2|^2=1. **)
(** Given coprime n,k, define h(z1,z2) = (z1 e^{2pi i/n}, z2 e^{2pi ik/n}). **)
(** (a) h generates a cyclic group of order n, only identity has fixed point. **)
(** The orbit space S^3/G is called the lens space L(n,k). **)
(** (b) If L(n,k) homeomorphic to L(n',k') then n = n'. **)
(** (c) L(n,k) is a compact 3-manifold. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem ex81_5_lens_space :
  forall n k:set,
  n :e omega -> k :e omega -> n <> 0 -> k <> 0 ->
  (** n and k are coprime **)
  (forall d:set, d :e omega -> d <> 0 ->
    (exists a:set, a :e omega /\ n = mul_SNo d a) ->
    (exists b:set, b :e omega /\ k = mul_SNo d b) ->
    d = ordsucc 0) ->
  (** (a) h generates cyclic group of order n with only identity having fixed point **)
  exists G idG:set,
    (forall g:set, g :e G -> homeomorphism (Sn 3) (Sn_topology 3) (Sn 3) (Sn_topology 3) g) /\
    idG :e G /\ (forall x:set, x :e Sn 3 -> apply_fun idG x = x) /\
    equip G n /\
    fixed_point_free_action (Sn 3) G idG /\
    (** (b) L(n,k) determines n: homeomorphic lens spaces have same n **)
    (forall n' k':set, n' :e omega -> k' :e omega -> n' <> 0 -> k' <> 0 ->
      (forall d:set, d :e omega -> d <> 0 ->
        (exists a:set, a :e omega /\ n' = mul_SNo d a) ->
        (exists b:set, b :e omega /\ k' = mul_SNo d b) ->
        d = ordsucc 0) ->
      forall G' idG':set,
        (forall g:set, g :e G' -> homeomorphism (Sn 3) (Sn_topology 3) (Sn 3) (Sn_topology 3) g) ->
        idG' :e G' -> (forall x:set, x :e Sn 3 -> apply_fun idG' x = x) ->
        equip G' n' ->
        fixed_point_free_action (Sn 3) G' idG' ->
        (exists h:set, homeomorphism
          (orbit_space (Sn 3) G) (orbit_topology (Sn 3) (Sn_topology 3) G)
          (orbit_space (Sn 3) G') (orbit_topology (Sn 3) (Sn_topology 3) G') h) ->
        n = n') /\
    (** (c) L(n,k) is a compact 3-manifold **)
    compact_space (orbit_space (Sn 3) G) (orbit_topology (Sn 3) (Sn_topology 3) G).
admit.
Qed.

(** ============================================================ **)
(** S82 Existence of Covering Spaces                            **)
(** (lines 5223-5381 in algtop.tex)                              **)
(** ============================================================ **)

(** from S82 Definition (line 5228 in algtop.tex): semilocally simply connected **)
(** LATEX VERSION: A space B is semilocally simply connected if for each b in B, **)
(** there is a neighborhood U of b such that the homomorphism **)
(** i_star: pi1(U,b) -> pi1(B,b) induced by inclusion is trivial. **)
Definition semilocally_simply_connected : set -> set -> prop :=
  fun B Tb =>
    topology_on B Tb /\
    (forall b:set, b :e B ->
      exists U:set, U :e Tb /\ b :e U /\
        (forall cls:set,
          cls :e fundamental_group U (subspace_topology B Tb U) b ->
          apply_fun
            (induced_homomorphism U (subspace_topology B Tb U) b B Tb b
              (graph U (fun x:set => x)))
            cls =
          fundamental_group_id B Tb b)).

(** from S82 Theorem 82.1 (line 5240 in algtop.tex): existence of covering spaces **)
(** LATEX VERSION: Let B be path connected, locally path connected, and semilocally **)
(** simply connected. Given a subgroup H of pi1(B,b0), there exists a covering map **)
(** p: E -> B and a point e0 in p^{-1}(b0) such that p_star(pi1(E,e0)) = H. **)
(** EFFORT: 60 lines textbook, difficulty 9/10, USD 1200 **)
Theorem thm82_1_existence_of_covering :
  forall B Tb b0:set,
  path_connected_space B Tb -> locally_path_connected B Tb ->
  semilocally_simply_connected B Tb -> b0 :e B ->
  forall H:set,
    subgroup_of H
      (fundamental_group B Tb b0)
      (fundamental_group_mult B Tb b0)
      (fundamental_group_id B Tb b0)
      (fundamental_group_inv B Tb b0) ->
    exists E Te p e0:set,
      covering_map E Te B Tb p /\ e0 :e E /\
      apply_fun p e0 = b0 /\
      path_connected_space E Te /\ locally_path_connected E Te /\
      homomorphism_image
        (fundamental_group E Te e0)
        (induced_homomorphism E Te e0 B Tb (apply_fun p e0) p) = H.
admit.
Qed.

(** from S82 Corollary 82.2 (line 5380 in algtop.tex): universal covering existence **)
(** LATEX VERSION: The space B has a universal covering space iff B is path connected, **)
(** locally path connected, and semilocally simply connected. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem cor82_2_universal_covering_existence :
  forall B Tb:set,
  (exists E Te p:set,
    covering_map E Te B Tb p /\ simply_connected E Te)
  <->
  (path_connected_space B Tb /\ locally_path_connected B Tb /\
   semilocally_simply_connected B Tb).
admit.
Qed.

(** from S82 Exercises Exercise 1 (line 5384 in algtop.tex): simply connected implies semilocally simply connected **)
(** LATEX VERSION: Show that a simply connected space is semilocally simply connected. **)
(** EFFORT: 3 lines textbook, difficulty 2/10, USD 30 **)
Theorem ex82_1_simply_connected_semilocally :
  forall X Tx:set,
  simply_connected X Tx ->
  semilocally_simply_connected X Tx.
admit.
Qed.

(** Infrastructure: infinite earring in R^2 **)
(** from S80 Example 1 (line 5005 in algtop.tex): C_n is circle of radius 1/n centered at (1/n, 0) **)
(** The infinite earring X is the union of all C_n, as a subspace of R^2. **)
(** earring_circle n = circle of radius 1/n centered at (1/n, 0) in R^2 **)
Definition earring_circle : set -> set :=
  fun n =>
    {p :e setprod R R |
      add_SNo (mul_SNo (add_SNo (p 0) (minus_SNo (div_SNo 1 n))) (add_SNo (p 0) (minus_SNo (div_SNo 1 n))))
              (mul_SNo (p 1) (p 1)) = mul_SNo (div_SNo 1 n) (div_SNo 1 n)}.

Definition infinite_earring_space : set :=
  Union {earring_circle n | n :e omega :\: Sing Empty}.

Definition infinite_earring_topology : set :=
  subspace_topology (setprod R R) R2_topology infinite_earring_space.

(** Infrastructure: cone on a subspace of R^2 embedded in R^3 **)
(** from S82 Exercises Exercise 2 (line 5385 in algtop.tex) **)
(** C(X) is the subspace of R^3 that is the union of all line segments **)
(** joining points of X x {0} to the point p = ((0,0),1). **)
(** R^3 is encoded as (R^2) x R, so a point is ((x,y), z). **)
(** A point ((x,y),z) is in C(X) iff there exists t in [0,1] and q in X **)
(** such that ((x,y),z) = (1-t)((q0,q1),0) + t((0,0),1). **)
Definition cone_on_R2_in_R3 : set -> set :=
  fun X =>
    {p :e setprod (setprod R R) R |
      exists t:set, t :e R /\ Rle 0 t /\ Rle t 1 /\
        ((t = 1 /\ (p 0) 0 = 0 /\ (p 0) 1 = 0 /\ p 1 = 1) \/
         (exists q:set, q :e X /\
           (p 0) 0 = mul_SNo (add_SNo 1 (minus_SNo t)) (q 0) /\
           (p 0) 1 = mul_SNo (add_SNo 1 (minus_SNo t)) (q 1) /\
           p 1 = t))}.

(** R^3 topology as (R^2) x R **)
Definition R3_topology : set :=
  product_topology (setprod R R) R2_topology R R_standard_topology.

(** from S82 Exercises Exercise 2 (line 5385 in algtop.tex): cone on infinite earring **)
(** LATEX VERSION: Let C(X) be the cone on the infinite earring X. **)
(** Show that C(X) is simply connected, but is not locally simply connected at the origin. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex82_2_cone_earring_simply_connected :
  let CX := cone_on_R2_in_R3 infinite_earring_space in
  let TCX := subspace_topology (setprod (setprod R R) R) R3_topology CX in
  simply_connected CX TCX /\
  ~(forall U:set, U :e TCX -> ((0, 0), 0) :e U ->
    exists V:set, V :e TCX /\ ((0, 0), 0) :e V /\ V c= U /\
    simply_connected V (subspace_topology CX TCX V)).
admit.
Qed.

(** ============================================================ **)
(** Supplementary Exercises: Topological Properties and pi_1     **)
(** (lines 5388-5449 in algtop.tex)                              **)
(** ============================================================ **)

(** Infrastructure: star-refinement property for open covers **)
(** A covering B refines A with the star property: for any two elements **)
(** B, B' of B with nonempty intersection, B union B' lies in some element of A. **)
Definition star_refinement_cover : set -> set -> set -> set -> prop :=
  fun X Tx B A =>
    open_cover_of X Tx B /\
    open_cover_of X Tx A /\
    refines_cover B A /\
    (forall U V:set, U :e B -> V :e B -> U :/\: V <> Empty ->
      exists W:set, W :e A /\ U :\/: V c= W).

(** from Supplementary Exercises Exercise 1a (line 5393 in algtop.tex): metrizable star refinement **)
(** LATEX VERSION: If X is metrizable, then for any open covering A, there exists an **)
(** open covering B refining A such that for each pair B, B' in B with nonempty **)
(** intersection, B union B' lies in an element of A. **)
(** EFFORT: 6 lines textbook, difficulty 4/10, USD 80 **)
Theorem supp_ex_1a_metrizable_star_refinement :
  forall X Tx:set,
  metrizable X Tx ->
  forall A:set, open_cover_of X Tx A ->
  exists B:set, star_refinement_cover X Tx B A.
admit.
Qed.

(** from Supplementary Exercises Exercise 1b (line 5394 in algtop.tex): compact Hausdorff star refinement **)
(** LATEX VERSION: If X is compact Hausdorff, then for any open covering A, there exists **)
(** a finite open covering B refining A with the star property. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem supp_ex_1b_compact_Hausdorff_star_refinement :
  forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx ->
  forall A:set, open_cover_of X Tx A ->
  exists B:set, star_refinement_cover X Tx B A /\ finite B.
admit.
Qed.

(** from Supplementary Exercises Exercise 2 / Theorem (line 5406 in algtop.tex): pi_1 countable **)
(** LATEX VERSION: Let X be a space that is path connected, locally path connected, **)
(** and semilocally simply connected. If X is regular with a countable basis, **)
(** then pi_1(X, x_0) is countable. **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 200 **)
Theorem supp_ex_2_pi1_countable_regular_second_countable :
  forall X Tx x0:set,
  path_connected_space X Tx ->
  locally_path_connected X Tx ->
  semilocally_simply_connected X Tx ->
  regular_space X Tx ->
  second_countable_space X Tx ->
  x0 :e X ->
  countable (fundamental_group X Tx x0).
admit.
Qed.

(** from Supplementary Exercises Exercise 3 (line 5424 in algtop.tex): covering space regular + countable basis **)
(** LATEX VERSION: Let p: E -> X be a covering map such that pi_1(X, x_0) is countable. **)
(** If X is regular with a countable basis, so is E. **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem supp_ex_3_covering_inherits_regular_second_countable :
  forall E Te X Tx p x0:set,
  covering_map E Te X Tx p ->
  x0 :e X ->
  countable (fundamental_group X Tx x0) ->
  regular_space X Tx ->
  second_countable_space X Tx ->
  regular_space E Te /\ second_countable_space E Te.
admit.
Qed.

(** Infrastructure: finitely generated group **)
(** A group G is finitely generated if there exists a finite subset S of G **)
(** such that every element of G can be written as a product of elements **)
(** of S and their inverses. **)
Definition finitely_generated_group : set -> set -> set -> set -> prop :=
  fun G mult e inv =>
    group_structure G mult e inv /\
    exists S:set, S c= G /\ finite S /\
      (forall g:set, g :e G ->
        exists n xs:set, n :e omega /\ function_on xs n G /\
          (forall i:set, i :e n ->
            apply_fun xs i :e S \/
            (exists s:set, s :e S /\ apply_fun xs i = apply_fun inv s)) /\
          g = nat_primrec e (fun i r => apply_fun mult (r, apply_fun xs i)) n).

(** from Supplementary Exercises Exercise 4 / Theorem (line 5427 in algtop.tex): pi_1 finitely generated **)
(** LATEX VERSION: Let X be a space that is path connected, locally path connected, **)
(** and semilocally simply connected. If X is compact Hausdorff, then **)
(** pi_1(X, x_0) is finitely generated, and hence countable. **)
(** EFFORT: 12 lines textbook, difficulty 6/10, USD 200 **)
Theorem supp_ex_4_pi1_finitely_generated_compact_Hausdorff :
  forall X Tx x0:set,
  path_connected_space X Tx ->
  locally_path_connected X Tx ->
  semilocally_simply_connected X Tx ->
  compact_space X Tx -> Hausdorff_space X Tx ->
  x0 :e X ->
  finitely_generated_group
    (fundamental_group X Tx x0)
    (fundamental_group_mult X Tx x0)
    (fundamental_group_id X Tx x0)
    (fundamental_group_inv X Tx x0) /\
  countable (fundamental_group X Tx x0).
admit.
Qed.

(** from Supplementary Exercises Exercise 5 (line 5448 in algtop.tex): infinite earring uncountable pi_1 **)
(** LATEX VERSION: Let X be the infinite earring. Show that X is a compact Hausdorff **)
(** space with a countable basis whose fundamental group is uncountable. **)
(** EFFORT: 10 lines textbook, difficulty 6/10, USD 150 **)
Theorem supp_ex_5_infinite_earring_uncountable_pi1 :
  let X := infinite_earring_space in
  let Tx := infinite_earring_topology in
  let x0 := (0, 0) in
  compact_space X Tx /\
  Hausdorff_space X Tx /\
  second_countable_space X Tx /\
  x0 :e X /\
  ~countable (fundamental_group X Tx x0).
admit.
Qed.

(** ============================================================ **)
(** CHAPTER 14: Applications to Group Theory                     **)
(** ============================================================ **)

(** ============================================================ **)
(** S83 Covering Spaces of a Graph                               **)
(** (lines 5455-5543 in algtop.tex)                              **)
(** ============================================================ **)

(** from S83 Definition (line 5460 in algtop.tex): general linear graph **)
(** LATEX VERSION: A linear graph is a space X written as the union of arcs A_alpha, **)
(** where (1) any two arcs intersect in at most a common endpoint, and **)
(** (2) the topology of X is coherent with the subspaces A_alpha. **)
(** Note: this generalizes the finite linear_graph definition from S50 **)
Definition general_linear_graph : set -> set -> set -> prop :=
  fun X Tx Arcs =>
    topology_on X Tx /\
    (forall A:set, A :e Arcs -> A c= X /\ arc A (subspace_topology X Tx A)) /\
    X = Union Arcs /\
    (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
      A :/\: B = Empty \/
      (exists p:set, A :/\: B = Sing p /\
        (exists q:set, end_points_of_arc A (subspace_topology X Tx A) p q \/
                       end_points_of_arc A (subspace_topology X Tx A) q p) /\
        (exists r:set, end_points_of_arc B (subspace_topology X Tx B) p r \/
                       end_points_of_arc B (subspace_topology X Tx B) r p))) /\
    (** coherence: C is closed in X iff C cap A is closed in A for each A **)
    (forall C:set, C c= X ->
      (closed_in X Tx C <->
       (forall A:set, A :e Arcs ->
         closed_in A (subspace_topology X Tx A) (C :/\: A)))).

(** from S83 Definition (line 5499 in algtop.tex): subgraph **)
(** LATEX VERSION: A subgraph of X is a subspace Y that is a union of edges of X. **)
Definition subgraph_of : set -> set -> set -> set -> prop :=
  fun Y X Tx Arcs =>
    general_linear_graph X Tx Arcs /\
    Y c= X /\ Y = Union {A :e Arcs | A c= Y}.

(** Infrastructure: vertices of a linear graph **)
Definition graph_vertices : set -> set -> set -> set :=
  fun X Tx Arcs =>
    {x :e X | exists A:set, A :e Arcs /\
      exists p q:set, end_points_of_arc A (subspace_topology X Tx A) p q /\
        (x = p \/ x = q)}.

(** from S83 Lemma 83.1 (line 5470 in algtop.tex): linear graphs are normal **)
(** LATEX VERSION: Every linear graph X is Hausdorff; in fact, it is normal. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma83_1_linear_graph_normal :
  forall X Tx Arcs:set,
  general_linear_graph X Tx Arcs ->
  normal_space X Tx.
admit.
Qed.

(** from S83 Lemma 83.2 (line 5503 in algtop.tex): compact subspace in finite subgraph **)
(** LATEX VERSION: If C is a compact subspace of a linear graph X, there is a finite **)
(** subgraph Y containing C. If C is connected, Y can be chosen connected. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 120 **)
Theorem lemma83_2_compact_finite_subgraph :
  forall X Tx Arcs C:set,
  general_linear_graph X Tx Arcs ->
  C c= X -> compact_space C (subspace_topology X Tx C) ->
  exists Arcs':set,
    Arcs' c= Arcs /\ finite Arcs' /\ C c= Union Arcs'.
admit.
Qed.

(** from S83 Lemma 83.3 (line 5510 in algtop.tex): graph is loc path connected **)
(** LATEX VERSION: If X is a linear graph, then X is locally path connected **)
(** and semilocally simply connected. **)
(** EFFORT: 15 lines textbook, difficulty 5/10, USD 150 **)
Theorem lemma83_3_graph_locally_path_connected :
  forall X Tx Arcs:set,
  general_linear_graph X Tx Arcs ->
  locally_path_connected X Tx /\ semilocally_simply_connected X Tx.
admit.
Qed.

(** from S83 Theorem 83.4 (line 5530 in algtop.tex): covering of graph is graph **)
(** LATEX VERSION: Let p: E -> X be a covering map where X is a linear graph. **)
(** If A_alpha is an edge of X and B is a path component of p^{-1}(A_alpha), **)
(** then p maps B homeomorphically onto A_alpha. Furthermore, E is a linear graph **)
(** with path components of p^{-1}(A_alpha) as its edges. **)
(** EFFORT: 30 lines textbook, difficulty 7/10, USD 420 **)
Theorem thm83_4_covering_of_graph_is_graph :
  forall X Tx Arcs E Te p:set,
  general_linear_graph X Tx Arcs ->
  covering_map E Te X Tx p ->
  exists ArcsE:set,
    general_linear_graph E Te ArcsE /\
    (forall B:set, B :e ArcsE ->
      exists A:set, A :e Arcs /\
        B c= preimage_of E p A /\
        path_connected_space B (subspace_topology E Te B) /\
        homeomorphism B (subspace_topology E Te B) A (subspace_topology X Tx A)
            (graph B (fun x:set => apply_fun p x))).
admit.
Qed.

(** from S83 Exercise 2 (line 5547 in algtop.tex) **)
(** LATEX VERSION: The Euler number = vertices - edges. What is Euler number **)
(** of: (a) arc, (b) circle, (c) wedge of n circles, (d) complete graph on n vertices? **)
(** If E is an n-fold covering of X, how are Euler numbers of E and X related? **)
(** EFFORT: 6 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex83_2_euler_number_examples :
  (** (a) An arc has 2 vertices, 1 edge, so chi = 1 **)
  (forall X Tx Arcs:set,
    general_linear_graph X Tx Arcs ->
    finite Arcs -> equip Arcs (ordsucc 0) ->
    equip (graph_vertices X Tx Arcs) (ordsucc (ordsucc 0))) /\
  (** (b) A circle has n vertices, n edges for some n >= 1, so chi = 0 **)
  (forall X Tx Arcs:set,
    general_linear_graph X Tx Arcs ->
    finite Arcs ->
    (exists h:set, homeomorphism X Tx S1 S1_topology h) ->
    equip Arcs (graph_vertices X Tx Arcs)) /\
  (** (c) A wedge of n circles: 1 vertex, n edges, chi = 1 - n **)
  (forall n:set, n :e omega -> n <> 0 ->
    forall X Tx Arcs:set,
    general_linear_graph X Tx Arcs ->
    finite Arcs ->
    equip (graph_vertices X Tx Arcs) (ordsucc 0) ->
    (exists J gens:set, free_group_with_generators
      (fundamental_group X Tx (Eps_i (fun v:set => v :e graph_vertices X Tx Arcs)))
      (fundamental_group_mult X Tx (Eps_i (fun v:set => v :e graph_vertices X Tx Arcs)))
      (fundamental_group_id X Tx (Eps_i (fun v:set => v :e graph_vertices X Tx Arcs)))
      (fundamental_group_inv X Tx (Eps_i (fun v:set => v :e graph_vertices X Tx Arcs)))
      J gens /\ equip J n) ->
    equip Arcs n) /\
  (** Covering relation: n-fold covering multiplies vertices and edges by n **)
  (forall X Tx ArcsX E Te ArcsE p n:set,
    general_linear_graph X Tx ArcsX -> finite ArcsX ->
    general_linear_graph E Te ArcsE -> finite ArcsE ->
    covering_map E Te X Tx p ->
    n :e omega -> n <> 0 ->
    (forall x:set, x :e X ->
      equip (preimage_of E p (Sing x)) n) ->
    (forall nv:set, nv :e omega -> equip (graph_vertices X Tx ArcsX) nv ->
      equip (graph_vertices E Te ArcsE) (mul_SNo n nv)) /\
    (forall ne:set, ne :e omega -> equip ArcsX ne ->
      equip ArcsE (mul_SNo n ne))).
admit.
Qed.

(** ============================================================ **)
(** S84 The Fundamental Group of a Graph                         **)
(** (lines 5550-5738 in algtop.tex)                              **)
(** ============================================================ **)

(** from S84 Definition (line 5553 in algtop.tex): oriented edge, edge path **)
(** LATEX VERSION: An oriented edge e is an edge with an ordering of its vertices **)
(** (initial and final). An edge path is a sequence e1,...,en of oriented edges **)
(** where final vertex of e_i = initial vertex of e_{i+1}. **)
Definition oriented_edge : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx Arcs A initial final =>
    A :e Arcs /\ end_points_of_arc A (subspace_topology X Tx A) initial final.

(** Infrastructure: an edge path is a finite function from n to oriented edges **)
(** encoded as a sequence of (A, initial, final) triples **)
Definition edge_path : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx Arcs n path_seq x0 =>
    n :e omega /\
    function_on path_seq n (setprod (setprod X X) (Power X)) /\
    (forall i:set, i :e n ->
      exists A ini fin:set,
        apply_fun path_seq i = ((ini, fin), A) /\
        oriented_edge X Tx Arcs A ini fin) /\
    (** initial vertex of first edge is x0 **)
    (n <> 0 -> (apply_fun path_seq 0) 0 0 = x0) /\
    (** consecutive edges share vertices **)
    (forall i:set, i :e n -> ordsucc i :e n ->
      (apply_fun path_seq i) 0 1 = (apply_fun path_seq (ordsucc i)) 0 0).

(** from S84 Definition (line 5569 in algtop.tex): reduced edge path **)
(** LATEX VERSION: An edge path is reduced if no two consecutive edges are the **)
(** same edge with opposite orientations. **)
Definition reduced_edge_path : set -> set -> set -> set -> set -> set -> prop :=
  fun X Tx Arcs n path_seq x0 =>
    edge_path X Tx Arcs n path_seq x0 /\
    (forall i:set, i :e n -> ordsucc i :e n ->
      ~((apply_fun path_seq i) 1 = (apply_fun path_seq (ordsucc i)) 1 /\
        (apply_fun path_seq i) 0 0 = (apply_fun path_seq (ordsucc i)) 0 1 /\
        (apply_fun path_seq i) 0 1 = (apply_fun path_seq (ordsucc i)) 0 0)).

(** from S84 Definition (line 5581 in algtop.tex): tree **)
(** LATEX VERSION: A subgraph T of X is a tree if T is connected and **)
(** T contains no closed reduced edge paths. **)
Definition tree_in_graph : set -> set -> set -> set -> set -> prop :=
  fun T ArcsT X Tx Arcs =>
    subgraph_of T X Tx Arcs /\
    general_linear_graph T (subspace_topology X Tx T) ArcsT /\
    connected_space T (subspace_topology X Tx T) /\
    ~(exists n path_seq x0:set,
        n :e omega /\ n <> 0 /\
        reduced_edge_path T (subspace_topology X Tx T) ArcsT n path_seq x0 /\
        (exists j:set, j :e n /\ ordsucc j /:e n /\
          (apply_fun path_seq j) 0 1 = x0)).

(** from S84 Definition (line 5623 in algtop.tex): maximal tree **)
(** LATEX VERSION: A tree T in X is maximal if no tree in X properly contains T. **)
Definition maximal_tree : set -> set -> set -> set -> set -> prop :=
  fun T ArcsT X Tx Arcs =>
    tree_in_graph T ArcsT X Tx Arcs /\
    (forall T' ArcsT':set,
      tree_in_graph T' ArcsT' X Tx Arcs ->
      T c= T' -> T' = T).

(** from S84 Lemma 84.1 (line 5563 in algtop.tex): connected iff edge paths **)
(** LATEX VERSION: A graph X is connected iff every pair of vertices can be **)
(** joined by an edge path. **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma84_1_connected_iff_edge_paths :
  forall X Tx Arcs:set,
  general_linear_graph X Tx Arcs ->
  (connected_space X Tx <->
   (forall x y:set, x :e graph_vertices X Tx Arcs -> y :e graph_vertices X Tx Arcs ->
     exists n path_seq:set, edge_path X Tx Arcs n path_seq x /\
       n <> 0 /\
       (exists j:set, j :e n /\ ordsucc j /:e n /\
         (apply_fun path_seq j) 0 1 = y))).
admit.
Qed.

(** from S84 Lemma 84.2 (line 5601 in algtop.tex): tree extension **)
(** LATEX VERSION: If T is a tree and A is an edge intersecting T in a single vertex, **)
(** then T union A is a tree. Conversely, if T is a finite tree with more than one **)
(** edge, then T = T0 union A where T0 is a tree and A intersects T0 in one vertex. **)
(** EFFORT: 20 lines textbook, difficulty 5/10, USD 200 **)
Theorem lemma84_2_tree_extension :
  forall T ArcsT X Tx Arcs A:set,
  tree_in_graph T ArcsT X Tx Arcs ->
  A :e Arcs -> ~(A c= T) ->
  (exists v:set, v :e graph_vertices X Tx Arcs /\ T :/\: A = Sing v) ->
  tree_in_graph (T :\/: A) ({A} :\/: ArcsT) X Tx Arcs.
admit.
Qed.

(** from S84 Lemma 84.2 converse (line 5601 in algtop.tex): finite tree decomposition **)
(** LATEX VERSION: If T is a finite tree with more than one edge, then T = T0 union A **)
(** where T0 is a tree and A intersects T0 in a single vertex. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma84_2_tree_decomposition :
  forall T ArcsT X Tx Arcs:set,
  tree_in_graph T ArcsT X Tx Arcs ->
  finite ArcsT ->
  (exists A1 A2:set, A1 :e ArcsT /\ A2 :e ArcsT /\ A1 <> A2) ->
  exists A:set, exists B:set, A :e ArcsT /\ B = ArcsT :\: Sing A /\
    let T0 := Union B in
    (exists v:set, v :e graph_vertices X Tx Arcs /\ T0 :/\: A = Sing v) /\
    tree_in_graph T0 B X Tx Arcs.
admit.
Qed.

(** from S84 Theorem 84.3 (line 5617 in algtop.tex): tree is simply connected **)
(** LATEX VERSION: Any tree T is simply connected. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm84_3_tree_simply_connected :
  forall T ArcsT X Tx Arcs:set,
  tree_in_graph T ArcsT X Tx Arcs ->
  simply_connected T (subspace_topology X Tx T).
admit.
Qed.

(** from S84 Theorem 84.4 (line 5625 in algtop.tex): maximal tree contains all vertices **)
(** LATEX VERSION: Let X be a connected graph. A tree T in X is maximal iff it **)
(** contains all the vertices of X. **)
(** EFFORT: 12 lines textbook, difficulty 5/10, USD 120 **)
Theorem thm84_4_maximal_tree_all_vertices :
  forall T ArcsT X Tx Arcs:set,
  general_linear_graph X Tx Arcs ->
  connected_space X Tx ->
  (maximal_tree T ArcsT X Tx Arcs <->
   (tree_in_graph T ArcsT X Tx Arcs /\
    graph_vertices X Tx Arcs c= T)).
admit.
Qed.

(** from S84 Theorem 84.5 (line 5631 in algtop.tex): every tree in maximal tree **)
(** LATEX VERSION: If X is a linear graph, every tree T0 in X is contained **)
(** in a maximal tree in X. **)
(** EFFORT: 8 lines textbook, difficulty 4/10, USD 80 **)
Theorem thm84_5_tree_in_maximal :
  forall T0 ArcsT0 X Tx Arcs:set,
  general_linear_graph X Tx Arcs ->
  tree_in_graph T0 ArcsT0 X Tx Arcs ->
  exists T ArcsT:set,
    maximal_tree T ArcsT X Tx Arcs /\ T0 c= T.
admit.
Qed.

(** from S84 Lemma 84.6 (line 5643 in algtop.tex): generator from edge **)
(** LATEX VERSION: Suppose X = U union V, U, V open, simply connected. **)
(** U cap V = A union B disjoint open path-connected. alpha path in U from a to b, **)
(** beta path in V from b to a. Then [alpha . beta] generates pi1(X,a). **)
(** EFFORT: 15 lines textbook, difficulty 6/10, USD 180 **)
Theorem lemma84_6_generator_from_edge :
  forall X Tx U V A B a b alpha beta:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> X = U :\/: V ->
  simply_connected U (subspace_topology X Tx U) ->
  simply_connected V (subspace_topology X Tx V) ->
  A c= U :/\: V -> B c= U :/\: V -> A :/\: B = Empty ->
  (U :/\: V) = A :\/: B ->
  A :e subspace_topology X Tx (U :/\: V) ->
  B :e subspace_topology X Tx (U :/\: V) ->
  path_connected_space A (subspace_topology X Tx A) ->
  path_connected_space B (subspace_topology X Tx B) ->
  a :e A -> b :e B ->
  continuous_map unit_interval unit_interval_topology U (subspace_topology X Tx U) alpha ->
  apply_fun alpha 0 = a -> apply_fun alpha 1 = b ->
  continuous_map unit_interval unit_interval_topology V (subspace_topology X Tx V) beta ->
  apply_fun beta 0 = b -> apply_fun beta 1 = a ->
  forall cls:set, cls :e fundamental_group X Tx a ->
    exists n:set, n :e omega /\
      (cls = group_power_nat
        (fundamental_group_mult X Tx a)
        (fundamental_group_id X Tx a)
        (path_homotopy_class_loop X Tx a (path_concat alpha beta)) n \/
       cls = group_power_nat
        (fundamental_group_mult X Tx a)
        (fundamental_group_id X Tx a)
        (apply_fun (fundamental_group_inv X Tx a)
          (path_homotopy_class_loop X Tx a (path_concat alpha beta))) n).
admit.
Qed.

(** from S84 Theorem 84.7 (line 5663 in algtop.tex): pi1 of graph is free **)
(** LATEX VERSION: Let X be a connected graph that is not a tree. Then pi1(X) is **)
(** a nontrivial free group. If T is a maximal tree in X, the fundamental group **)
(** has free generators in bijection with edges of X not in T. **)
(** EFFORT: 35 lines textbook, difficulty 8/10, USD 560 **)
Theorem thm84_7_pi1_graph_is_free :
  forall X Tx Arcs T ArcsT x0:set,
  general_linear_graph X Tx Arcs ->
  connected_space X Tx ->
  maximal_tree T ArcsT X Tx Arcs ->
  x0 :e graph_vertices X Tx Arcs ->
  exists J gens:set,
    equip J {A :e Arcs | ~(A c= T)} /\
    free_group_with_generators
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (fundamental_group_inv X Tx x0)
      J gens.
admit.
Qed.

(** from S84 Exercise 1 (line 5742 in algtop.tex) **)
(** LATEX VERSION: Give an example to show that the second part of Lemma 84.2 **)
(** need not hold if T is infinite. (Lemma 84.2 says that for a finite **)
(** subgraph T, alpha reduces to an edge path in T.) **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex84_1_infinite_tree_counterexample :
  (** There exists an infinite graph X with a maximal tree T of X **)
  (** such that the conclusion of Lemma 84.2 (every closed edge path **)
  (** reduces to one lying in T) fails for infinite T. **)
  (** Specifically: there is a loop not homotopic to a loop in any **)
  (** finite subgraph containing all its edge-crossings outside T. **)
  exists X Tx Arcs T ArcsT x0:set,
    general_linear_graph X Tx Arcs /\
    ~finite Arcs /\
    connected_space X Tx /\
    maximal_tree T ArcsT X Tx Arcs /\
    ~finite ArcsT /\
    x0 :e graph_vertices X Tx Arcs /\
    (** pi1(X) is nontrivial despite infinite tree **)
    exists cls:set,
      cls :e fundamental_group X Tx x0 /\
      cls <> fundamental_group_id X Tx x0.
admit.
Qed.

(** from S84 Exercise 2 (line 5743 in algtop.tex) **)
(** LATEX VERSION: What is the cardinality of a system of free generators for **)
(** the fundamental group of the complete graph on n vertices? **)
(** from S84 Exercise 2 (line 5740 in algtop.tex): complete graph generators **)
(** Answer: By Euler number formula, it is 1 - chi = 1 - (n - n(n-1)/2) **)
(** = 1 - n + n(n-1)/2 = (n-1)(n-2)/2 for n >= 2. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex84_2_complete_graph_generators :
  forall n:set, n :e omega -> ordsucc (ordsucc 0) c= n ->
  forall V G Tg ArcsG x0:set,
    complete_graph_on V G Tg ->
    equip V n ->
    general_linear_graph G Tg ArcsG ->
    x0 :e graph_vertices G Tg ArcsG ->
    exists J gens:set,
      free_group_with_generators
        (fundamental_group G Tg x0)
        (fundamental_group_mult G Tg x0)
        (fundamental_group_id G Tg x0)
        (fundamental_group_inv G Tg x0)
        J gens /\
      (** Number of free generators = 1 + edges - vertices = 1 + n(n-1)/2 - n **)
      equip J (add_SNo 1 (add_SNo
        (real_div (mul_SNo n (add_SNo n (minus_SNo 1))) (ordsucc (ordsucc 0)))
        (minus_SNo n))).
admit.
Qed.

(** ============================================================ **)
(** S85 Subgroups of Free Groups                                 **)
(** (lines 5749-5795 in algtop.tex)                              **)
(** ============================================================ **)

(** from S85 Theorem 85.1 (line 5752 in algtop.tex): subgroup of free group is free **)
(** LATEX VERSION: If H is a subgroup of a free group F, then H is free. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm85_1_subgroup_of_free_is_free :
  forall F multF eF invF J gens:set,
  free_group_with_generators F multF eF invF J gens ->
  forall H:set,
    subgroup_of H F multF eF invF ->
    exists JH gensH:set,
      free_group_with_generators H multF eF invF JH gensH.
admit.
Qed.

(** from S85 Definition (line 5764 in algtop.tex): Euler number of finite graph **)
(** LATEX VERSION: The Euler number of a finite linear graph X is the number of **)
(** vertices minus the number of edges, denoted chi(X). **)
Definition euler_number : set -> set -> set -> set :=
  fun X Tx Arcs =>
    add_SNo
      (Eps_i (fun n:set => n :e omega /\ equip (graph_vertices X Tx Arcs) n))
      (minus_SNo (Eps_i (fun n:set => n :e omega /\ equip Arcs n))).

(** from S85 Lemma 85.2 (line 5766 in algtop.tex): free generators = 1 - chi **)
(** LATEX VERSION: If X is a finite, connected linear graph, then the cardinality **)
(** of a system of free generators for pi1(X) is 1 - chi(X). **)
(** EFFORT: 10 lines textbook, difficulty 4/10, USD 80 **)
Theorem lemma85_2_free_gen_euler :
  forall X Tx Arcs x0:set,
  general_linear_graph X Tx Arcs ->
  finite Arcs ->
  connected_space X Tx ->
  x0 :e graph_vertices X Tx Arcs ->
  exists J gens:set,
    free_group_with_generators
      (fundamental_group X Tx x0)
      (fundamental_group_mult X Tx x0)
      (fundamental_group_id X Tx x0)
      (fundamental_group_inv X Tx x0)
      J gens /\
    equip J (add_SNo 1 (minus_SNo (euler_number X Tx Arcs))).
admit.
Qed.

(** from S85 Definition (line 5778 in algtop.tex): index of a subgroup **)
(** LATEX VERSION: If the collection G/H of right cosets of H in G is finite, **)
(** its cardinality is called the index of H in G. **)
Definition subgroup_index : set -> set -> set -> set -> set -> set :=
  fun H G mult e inv =>
    Eps_i (fun k:set => k :e omega /\
      equip (right_coset_set G mult H) k).

(** from S85 Theorem 85.3 (line 5780 in algtop.tex): free generators formula **)
(** LATEX VERSION: Let F be a free group with n+1 free generators; let H be a **)
(** subgroup of F. If H has index k in F, then H has kn+1 free generators. **)
(** EFFORT: 10 lines textbook, difficulty 5/10, USD 100 **)
Theorem thm85_3_free_gen_index_formula :
  forall F multF eF invF J gens:set,
  free_group_with_generators F multF eF invF J gens ->
  forall n:set, n :e omega /\ equip J (ordsucc n) ->
  forall H:set,
    subgroup_of H F multF eF invF ->
    forall k:set, k :e omega /\ k <> 0 /\
      equip (right_coset_set F multF H) k ->
      exists JH gensH:set,
        free_group_with_generators H multF eF invF JH gensH /\
        equip JH (ordsucc (mul_SNo k n)).
admit.
Qed.

(** from S85 Exercise 1 (line 5799 in algtop.tex) **)
(** LATEX VERSION: Show that the Euler number of a finite linear graph X **)
(** is a topological invariant of X. **)
(** EFFORT: 5 lines textbook, difficulty 3/10, USD 50 **)
Theorem ex85_1_euler_number_topological_invariant :
  forall X Tx ArcsX Y Ty ArcsY:set,
  general_linear_graph X Tx ArcsX -> finite ArcsX ->
  general_linear_graph Y Ty ArcsY -> finite ArcsY ->
  (exists h:set, homeomorphism X Tx Y Ty h) ->
  euler_number X Tx ArcsX = euler_number Y Ty ArcsY.
admit.
Qed.

(** from S85 Exercise 2 (line 5800 in algtop.tex) **)
(** LATEX VERSION: Let F be a free group on two free generators alpha and beta. **)
(** Let H be the subgroup generated by alpha. Show H has infinite index in F. **)
(** EFFORT: 4 lines textbook, difficulty 3/10, USD 40 **)
Theorem ex85_2_infinite_index_subgroup :
  forall F multF eF invF J gens:set,
  free_group_with_generators F multF eF invF J gens ->
  equip J (ordsucc (ordsucc 0)) ->
  forall alpha:set, alpha :e J ->
  let H := {g :e F | exists n:set, n :e int /\
    ((n :e omega /\ g = group_power_nat multF eF (apply_fun gens alpha) n) \/
     (exists m:set, m :e omega /\ n = minus_SNo (ordsucc m) /\
      g = group_power_nat multF eF (apply_fun invF (apply_fun gens alpha)) (ordsucc m)))} in
  subgroup_of H F multF eF invF /\
  ~finite (right_coset_set F multF H).
admit.
Qed.

(** from S85 Exercise 3 (line 5801 in algtop.tex) **)
(** LATEX VERSION: Let p: R -> S^1 be the standard covering. Consider **)
(** p x p: R x R -> S^1 x S^1. Let X = (b0 x S^1) union (S^1 x b0), **)
(** from S85 Exercise 3 (line 5797 in algtop.tex): covering of wedge in torus **)
(** E = (p x p)^{-1}(X), q = restriction. Find free generators for **)
(** q-push(pi1(E, e0)). **)
(** EFFORT: 8 lines textbook, difficulty 5/10, USD 100 **)
Theorem ex85_3_covering_of_wedge_in_torus :
  let b0 := S1_basepoint in
  let X := ({b0} :*: S1) :\/: (S1 :*: {b0}) in
  (** X is a subspace of the torus S^1 x S^1, homotopy equivalent to wedge of 2 circles **)
  (** pi1(X) is free on 2 generators alpha, beta **)
  forall x0:set, x0 = (b0, b0) -> x0 :e X ->
  exists J gens:set,
    free_group_with_generators
      (fundamental_group X (subspace_topology torus torus_topology X) x0)
      (fundamental_group_mult X (subspace_topology torus torus_topology X) x0)
      (fundamental_group_id X (subspace_topology torus torus_topology X) x0)
      (fundamental_group_inv X (subspace_topology torus torus_topology X) x0)
      J gens /\
    equip J (ordsucc (ordsucc 0)) /\
    (** The covering E -> X has infinite-sheeted fibers **)
    (** The subgroup q-push(pi1(E,e0)) is free on countably many generators **)
    forall E Te q e0:set,
      E c= setprod R R ->
      (forall z:set, z :e E <-> (exists r s:set, z = (r, s) /\
        ((apply_fun covering_map_R_S1 r = b0 /\ apply_fun covering_map_R_S1 s :e S1) \/
         (apply_fun covering_map_R_S1 r :e S1 /\ apply_fun covering_map_R_S1 s = b0)))) ->
      covering_map E Te X (subspace_topology torus torus_topology X) q ->
      e0 = (0, 0) -> e0 :e E ->
      exists JE gensE:set,
        free_group_with_generators
          (homomorphism_image
            (fundamental_group E Te e0)
            (induced_homomorphism E Te e0 X (subspace_topology torus torus_topology X) x0 q))
          (fundamental_group_mult X (subspace_topology torus torus_topology X) x0)
          (fundamental_group_id X (subspace_topology torus torus_topology X) x0)
          (fundamental_group_inv X (subspace_topology torus torus_topology X) x0)
          JE gensE /\
        ~finite JE.

